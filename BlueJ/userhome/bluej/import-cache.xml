<?xml version="1.0" encoding="UTF-8"?>
<packages javaHome="H:\Infomatik\Schule\BlueJ\BlueJ\jdk" version="5.0.2">
    <package name="java">
        <package name="io">
            <acts name="InterruptedIOException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that an I/O operation has been interrupted. An
                     &lt;code&gt;InterruptedIOException&lt;/code&gt; is thrown to indicate that an
                     input or output transfer has been terminated because the thread
                     performing it was interrupted. The field {@link #bytesTransferred}
                     indicates how many bytes were successfully transferred before
                     the interruption occurred.
                    
                     @author  unascribed
                     @see     java.io.InputStream
                     @see     java.io.OutputStream
                     @see     java.lang.Thread#interrupt()
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ObjectStreamConstants" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.io">
                <superTypes/>
                <javadoc xml:space="preserve">
                     Constants written into the Object Serialization Stream.
                    
                     @author  unascribed
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="FilterWriter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Writer"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Abstract class for writing filtered character streams.
                     The abstract class &lt;code&gt;FilterWriter&lt;/code&gt; itself
                     provides default methods that pass all requests to the
                     contained stream. Subclasses of &lt;code&gt;FilterWriter&lt;/code&gt;
                     should override some of these methods and may also
                     provide additional methods and fields.
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="Serializable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.io">
                <superTypes/>
                <javadoc xml:space="preserve">
                     Serializability of a class is enabled by the class implementing the
                     java.io.Serializable interface.
                    
                     &lt;p&gt;&lt;strong&gt;Warning: Deserialization of untrusted data is inherently dangerous
                     and should be avoided. Untrusted data should be carefully validated according to the
                     "Serialization and Deserialization" section of the
                     {@extLink secure_coding_guidelines_javase Secure Coding Guidelines for Java SE}.
                     {@extLink serialization_filter_guide Serialization Filtering} describes best
                     practices for defensive use of serial filters.
                     &lt;/strong&gt;&lt;/p&gt;
                    
                     Classes that do not implement this
                     interface will not have any of their state serialized or
                     deserialized.  All subtypes of a serializable class are themselves
                     serializable.  The serialization interface has no methods or fields
                     and serves only to identify the semantics of being serializable. &lt;p&gt;
                    
                     To allow subtypes of non-serializable classes to be serialized, the
                     subtype may assume responsibility for saving and restoring the
                     state of the supertype's public, protected, and (if accessible)
                     package fields.  The subtype may assume this responsibility only if
                     the class it extends has an accessible no-arg constructor to
                     initialize the class's state.  It is an error to declare a class
                     Serializable if this is not the case.  The error will be detected at
                     runtime. &lt;p&gt;
                    
                     During deserialization, the fields of non-serializable classes will
                     be initialized using the public or protected no-arg constructor of
                     the class.  A no-arg constructor must be accessible to the subclass
                     that is serializable.  The fields of serializable subclasses will
                     be restored from the stream. &lt;p&gt;
                    
                     When traversing a graph, an object may be encountered that does not
                     support the Serializable interface. In this case the
                     NotSerializableException will be thrown and will identify the class
                     of the non-serializable object. &lt;p&gt;
                    
                     Classes that require special handling during the serialization and
                     deserialization process must implement special methods with these exact
                     signatures:
                    
                     &lt;PRE&gt;
                     private void writeObject(java.io.ObjectOutputStream out)
                         throws IOException
                     private void readObject(java.io.ObjectInputStream in)
                         throws IOException, ClassNotFoundException;
                     private void readObjectNoData()
                         throws ObjectStreamException;
                     &lt;/PRE&gt;
                    
                     &lt;p&gt;The writeObject method is responsible for writing the state of the
                     object for its particular class so that the corresponding
                     readObject method can restore it.  The default mechanism for saving
                     the Object's fields can be invoked by calling
                     out.defaultWriteObject. The method does not need to concern
                     itself with the state belonging to its superclasses or subclasses.
                     State is saved by writing the individual fields to the
                     ObjectOutputStream using the writeObject method or by using the
                     methods for primitive data types supported by DataOutput.
                    
                     &lt;p&gt;The readObject method is responsible for reading from the stream and
                     restoring the classes fields. It may call in.defaultReadObject to invoke
                     the default mechanism for restoring the object's non-static and
                     non-transient fields.  The defaultReadObject method uses information in
                     the stream to assign the fields of the object saved in the stream with the
                     correspondingly named fields in the current object.  This handles the case
                     when the class has evolved to add new fields. The method does not need to
                     concern itself with the state belonging to its superclasses or subclasses.
                     State is restored by reading data from the ObjectInputStream for
                     the individual fields and making assignments to the appropriate fields
                     of the object. Reading primitive data types is supported by DataInput.
                    
                     &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
                     the object for its particular class in the event that the serialization
                     stream does not list the given class as a superclass of the object being
                     deserialized.  This may occur in cases where the receiving party uses a
                     different version of the deserialized instance's class than the sending
                     party, and the receiver's version extends classes that are not extended by
                     the sender's version.  This may also occur if the serialization stream has
                     been tampered; hence, readObjectNoData is useful for initializing
                     deserialized objects properly despite a "hostile" or incomplete source
                     stream.
                    
                     &lt;p&gt;Serializable classes that need to designate an alternative object to be
                     used when writing an object to the stream should implement this
                     special method with the exact signature:
                    
                     &lt;PRE&gt;
                     ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;
                     &lt;/PRE&gt;&lt;p&gt;
                    
                     This writeReplace method is invoked by serialization if the method
                     exists and it would be accessible from a method defined within the
                     class of the object being serialized. Thus, the method can have private,
                     protected and package-private access. Subclass access to this method
                     follows java accessibility rules. &lt;p&gt;
                    
                     Classes that need to designate a replacement when an instance of it
                     is read from the stream should implement this special method with the
                     exact signature.
                    
                     &lt;PRE&gt;
                     ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;
                     &lt;/PRE&gt;&lt;p&gt;
                    
                     This readResolve method follows the same invocation rules and
                     accessibility rules as writeReplace.&lt;p&gt;
                    
                     The serialization runtime associates with each serializable class a version
                     number, called a serialVersionUID, which is used during deserialization to
                     verify that the sender and receiver of a serialized object have loaded
                     classes for that object that are compatible with respect to serialization.
                     If the receiver has loaded a class for the object that has a different
                     serialVersionUID than that of the corresponding sender's class, then
                     deserialization will result in an {@link InvalidClassException}.  A
                     serializable class can declare its own serialVersionUID explicitly by
                     declaring a field named &lt;code&gt;"serialVersionUID"&lt;/code&gt; that must be static,
                     final, and of type &lt;code&gt;long&lt;/code&gt;:
                    
                     &lt;PRE&gt;
                     ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;
                     &lt;/PRE&gt;
                    
                     If a serializable class does not explicitly declare a serialVersionUID, then
                     the serialization runtime will calculate a default serialVersionUID value
                     for that class based on various aspects of the class, as described in the
                     Java(TM) Object Serialization Specification.  However, it is &lt;em&gt;strongly
                     recommended&lt;/em&gt; that all serializable classes explicitly declare
                     serialVersionUID values, since the default serialVersionUID computation is
                     highly sensitive to class details that may vary depending on compiler
                     implementations, and can thus result in unexpected
                     &lt;code&gt;InvalidClassException&lt;/code&gt;s during deserialization.  Therefore, to
                     guarantee a consistent serialVersionUID value across different java compiler
                     implementations, a serializable class must declare an explicit
                     serialVersionUID value.  It is also strongly advised that explicit
                     serialVersionUID declarations use the &lt;code&gt;private&lt;/code&gt; modifier where
                     possible, since such declarations apply only to the immediately declaring
                     class--serialVersionUID fields are not useful as inherited members. Array
                     classes cannot declare an explicit serialVersionUID, so they always have
                     the default computed value, but the requirement for matching
                     serialVersionUID values is waived for array classes.
                    
                     @author  unascribed
                     @see java.io.ObjectOutputStream
                     @see java.io.ObjectInputStream
                     @see java.io.ObjectOutput
                     @see java.io.ObjectInput
                     @see java.io.Externalizable
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="Closeable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.io">
                <superTypes>
                    <superType superType="java.lang.AutoCloseable"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@code Closeable} is a source or destination of data that can be closed.
                     The close method is invoked to release resources that the object is
                     holding (such as open files).
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="OutputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Closeable"/>
                    <superType superType="java.io.Flushable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This abstract class is the superclass of all classes representing
                     an output stream of bytes. An output stream accepts output bytes
                     and sends them to some sink.
                     &lt;p&gt;
                     Applications that need to define a subclass of
                     &lt;code&gt;OutputStream&lt;/code&gt; must always provide at least a method
                     that writes one byte of output.
                    
                     @author  Arthur van Hoff
                     @see     java.io.BufferedOutputStream
                     @see     java.io.ByteArrayOutputStream
                     @see     java.io.DataOutputStream
                     @see     java.io.FilterOutputStream
                     @see     java.io.InputStream
                     @see     java.io.OutputStream#write(int)
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="FileNotFoundException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that an attempt to open the file denoted by a specified pathname
                     has failed.
                    
                     &lt;p&gt; This exception will be thrown by the {@link FileInputStream}, {@link
                     FileOutputStream}, and {@link RandomAccessFile} constructors when a file
                     with the specified pathname does not exist.  It will also be thrown by these
                     constructors if the file does exist but for some reason is inaccessible, for
                     example when an attempt is made to open a read-only file for writing.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="UncheckedIOException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Wraps an {@link IOException} with an unchecked exception.
                    
                     @since   1.8
                    </javadoc>
            </acts>
            <acts name="FilePermission" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.security.Permission"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class represents access to a file or directory.  A FilePermission consists
                     of a pathname and a set of actions valid for that pathname.
                     &lt;P&gt;
                     Pathname is the pathname of the file or directory granted the specified
                     actions. A pathname that ends in "/*" (where "/" is
                     the file separator character, &lt;code&gt;File.separatorChar&lt;/code&gt;) indicates
                     all the files and directories contained in that directory. A pathname
                     that ends with "/-" indicates (recursively) all files
                     and subdirectories contained in that directory. Such a pathname is called
                     a wildcard pathname. Otherwise, it's a simple pathname.
                     &lt;P&gt;
                     A pathname consisting of the special token {@literal "&lt;&lt;ALL FILES&gt;&gt;"}
                     matches &lt;b&gt;any&lt;/b&gt; file.
                     &lt;P&gt;
                     Note: A pathname consisting of a single "*" indicates all the files
                     in the current directory, while a pathname consisting of a single "-"
                     indicates all the files in the current directory and
                     (recursively) all files and subdirectories contained in the current
                     directory.
                     &lt;P&gt;
                     The actions to be granted are passed to the constructor in a string containing
                     a list of one or more comma-separated keywords. The possible keywords are
                     "read", "write", "execute", "delete", and "readlink". Their meaning is
                     defined as follows:
                    
                     &lt;DL&gt;
                        &lt;DT&gt; read &lt;DD&gt; read permission
                        &lt;DT&gt; write &lt;DD&gt; write permission
                        &lt;DT&gt; execute
                        &lt;DD&gt; execute permission. Allows &lt;code&gt;Runtime.exec&lt;/code&gt; to
                             be called. Corresponds to &lt;code&gt;SecurityManager.checkExec&lt;/code&gt;.
                        &lt;DT&gt; delete
                        &lt;DD&gt; delete permission. Allows &lt;code&gt;File.delete&lt;/code&gt; to
                             be called. Corresponds to &lt;code&gt;SecurityManager.checkDelete&lt;/code&gt;.
                        &lt;DT&gt; readlink
                        &lt;DD&gt; read link permission. Allows the target of a
                             &lt;a href="../nio/file/package-summary.html#links"&gt;symbolic link&lt;/a&gt;
                             to be read by invoking the {@link java.nio.file.Files#readSymbolicLink
                             readSymbolicLink } method.
                     &lt;/DL&gt;
                     &lt;P&gt;
                     The actions string is converted to lowercase before processing.
                     &lt;P&gt;
                     Be careful when granting FilePermissions. Think about the implications
                     of granting read and especially write access to various files and
                     directories. The {@literal "&lt;&lt;ALL FILES&gt;&gt;"} permission with write action is
                     especially dangerous. This grants permission to write to the entire
                     file system. One thing this effectively allows is replacement of the
                     system binary, including the JVM runtime environment.
                     &lt;P&gt;
                     Please note: Code can always read a file from the same
                     directory it's in (or a subdirectory of that directory); it does not
                     need explicit permission to do so.
                    
                     @see java.security.Permission
                     @see java.security.Permissions
                     @see java.security.PermissionCollection
                    
                    
                     @author Marianne Mueller
                     @author Roland Schemers
                     @since 1.2
                    
                     @serial exclude
                    </javadoc>
            </acts>
            <acts name="StringBufferInputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.InputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class allows an application to create an input stream in
                     which the bytes read are supplied by the contents of a string.
                     Applications can also read bytes from a byte array by using a
                     &lt;code&gt;ByteArrayInputStream&lt;/code&gt;.
                     &lt;p&gt;
                     Only the low eight bits of each character in the string are used by
                     this class.
                    
                     @author     Arthur van Hoff
                     @see        java.io.ByteArrayInputStream
                     @see        java.io.StringReader
                     @since      1.0
                     @deprecated This class does not properly convert characters into bytes.  As
                                 of JDK&amp;nbsp;1.1, the preferred way to create a stream from a
                                 string is via the &lt;code&gt;StringReader&lt;/code&gt; class.
                    </javadoc>
            </acts>
            <acts name="BufferedInputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.FilterInputStream"/>
                    <superType superType="java.io.InputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A &lt;code&gt;BufferedInputStream&lt;/code&gt; adds
                     functionality to another input stream-namely,
                     the ability to buffer the input and to
                     support the &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt;
                     methods. When  the &lt;code&gt;BufferedInputStream&lt;/code&gt;
                     is created, an internal buffer array is
                     created. As bytes  from the stream are read
                     or skipped, the internal buffer is refilled
                     as necessary  from the contained input stream,
                     many bytes at a time. The &lt;code&gt;mark&lt;/code&gt;
                     operation  remembers a point in the input
                     stream and the &lt;code&gt;reset&lt;/code&gt; operation
                     causes all the  bytes read since the most
                     recent &lt;code&gt;mark&lt;/code&gt; operation to be
                     reread before new bytes are  taken from
                     the contained input stream.
                    
                     @author  Arthur van Hoff
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="PushbackInputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.FilterInputStream"/>
                    <superType superType="java.io.InputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A &lt;code&gt;PushbackInputStream&lt;/code&gt; adds
                     functionality to another input stream, namely
                     the  ability to "push back" or "unread" bytes,
                     by storing pushed-back bytes in an internal buffer.
                     This is useful in situations where
                     it is convenient for a fragment of code
                     to read an indefinite number of data bytes
                     that  are delimited by a particular byte
                     value; after reading the terminating byte,
                     the  code fragment can "unread" it, so that
                     the next read operation on the input stream
                     will reread the byte that was pushed back.
                     For example, bytes representing the  characters
                     constituting an identifier might be terminated
                     by a byte representing an  operator character;
                     a method whose job is to read just an identifier
                     can read until it  sees the operator and
                     then push the operator back to be re-read.
                    
                     @author  David Connelly
                     @author  Jonathan Payne
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="EOFException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that an end of file or end of stream has been reached
                     unexpectedly during input.
                     &lt;p&gt;
                     This exception is mainly used by data input streams to signal end of
                     stream. Note that many other input operations return a special value on
                     end of stream rather than throwing an exception.
                    
                     @author  Frank Yellin
                     @see     java.io.DataInputStream
                     @see     java.io.IOException
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="StreamCorruptedException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.ObjectStreamException"/>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when control information that was read from an object stream
                     violates internal consistency checks.
                    
                     @author  unascribed
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="ObjectStreamException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Superclass of all exceptions specific to Object Stream classes.
                    
                     @author  unascribed
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="SerializablePermission" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.security.BasicPermission"/>
                    <superType superType="java.security.Permission"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">code was borrowed originally from java.lang.RuntimePermission.</javadoc>
            </acts>
            <acts name="FilterReader" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Reader"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Abstract class for reading filtered character streams.
                     The abstract class &lt;code&gt;FilterReader&lt;/code&gt; itself
                     provides default methods that pass all requests to
                     the contained stream. Subclasses of &lt;code&gt;FilterReader&lt;/code&gt;
                     should override some of these methods and may also provide
                     additional methods and fields.
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="ObjectInputFilter" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.io">
                <superTypes/>
                <javadoc xml:space="preserve">
                     Filter classes, array lengths, and graph metrics during deserialization.
                    
                     &lt;p&gt;&lt;strong&gt;Warning: Deserialization of untrusted data is inherently dangerous
                     and should be avoided. Untrusted data should be carefully validated according to the
                     "Serialization and Deserialization" section of the
                     {@extLink secure_coding_guidelines_javase Secure Coding Guidelines for Java SE}.
                     {@extLink serialization_filter_guide Serialization Filtering} describes best
                     practices for defensive use of serial filters.
                     &lt;/strong&gt;&lt;/p&gt;
                    
                     If set on an {@link ObjectInputStream}, the {@link #checkInput checkInput(FilterInfo)}
                     method is called to validate classes, the length of each array,
                     the number of objects being read from the stream, the depth of the graph,
                     and the total number of bytes read from the stream.
                     &lt;p&gt;
                     A filter can be set via {@link ObjectInputStream#setObjectInputFilter setObjectInputFilter}
                     for an individual ObjectInputStream.
                     A filter can be set via {@link Config#setSerialFilter(ObjectInputFilter) Config.setSerialFilter}
                     to affect every {@code ObjectInputStream} that does not otherwise set a filter.
                     &lt;p&gt;
                     A filter determines whether the arguments are {@link Status#ALLOWED ALLOWED}
                     or {@link Status#REJECTED REJECTED} and should return the appropriate status.
                     If the filter cannot determine the status it should return
                     {@link Status#UNDECIDED UNDECIDED}.
                     Filters should be designed for the specific use case and expected types.
                     A filter designed for a particular use may be passed a class that is outside
                     of the scope of the filter. If the purpose of the filter is to black-list classes
                     then it can reject a candidate class that matches and report UNDECIDED for others.
                     A filter may be called with class equals {@code null}, {@code arrayLength} equal -1,
                     the depth, number of references, and stream size and return a status
                     that reflects only one or only some of the values.
                     This allows a filter to specific about the choice it is reporting and
                     to use other filters without forcing either allowed or rejected status.
                    
                     &lt;p&gt;
                     Typically, a custom filter should check if a process-wide filter
                     is configured and defer to it if so. For example,
                     &lt;pre&gt;{@code
                     ObjectInputFilter.Status checkInput(FilterInfo info) {
                         ObjectInputFilter serialFilter = ObjectInputFilter.Config.getSerialFilter();
                         if (serialFilter != null) {
                             ObjectInputFilter.Status status = serialFilter.checkInput(info);
                             if (status != ObjectInputFilter.Status.UNDECIDED) {
                                 // The process-wide filter overrides this filter
                                 return status;
                             }
                         }
                         if (info.serialClass() != null &amp;&amp;
                             Remote.class.isAssignableFrom(info.serialClass())) {
                             return Status.REJECTED;      // Do not allow Remote objects
                         }
                         return Status.UNDECIDED;
                     }
                    }&lt;/pre&gt;
                     &lt;p&gt;
                     Unless otherwise noted, passing a {@code null} argument to a
                     method in this interface and its nested classes will cause a
                     {@link NullPointerException} to be thrown.
                    
                     @see ObjectInputStream#setObjectInputFilter(ObjectInputFilter)
                     @since 9
                    </javadoc>
            </acts>
            <acts name="Status" access="PUBLIC" declaringClass="ObjectInputFilter" kind="TYPE" typeKind="ENUM" packageName="java.io">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="InvalidClassException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.ObjectStreamException"/>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when the Serialization runtime detects one of the following
                     problems with a Class.
                     &lt;UL&gt;
                     &lt;LI&gt; The serial version of the class does not match that of the class
                          descriptor read from the stream
                     &lt;LI&gt; The class contains unknown datatypes
                     &lt;LI&gt; The class does not have an accessible no-arg constructor
                     &lt;/UL&gt;
                    
                     @author  unascribed
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="UnsupportedEncodingException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The Character Encoding is not supported.
                    
                     @author  Asmus Freytag
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="SyncFailedException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that a sync operation has failed.
                    
                     @author  Ken Arnold
                     @see     java.io.FileDescriptor#sync
                     @see     java.io.IOException
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="Flushable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.io">
                <superTypes/>
                <javadoc xml:space="preserve">
                     A {@code Flushable} is a destination of data that can be flushed.  The
                     flush method is invoked to write any buffered output to the underlying
                     stream.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="FileInputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.InputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A &lt;code&gt;FileInputStream&lt;/code&gt; obtains input bytes
                     from a file in a file system. What files
                     are  available depends on the host environment.
                    
                     &lt;p&gt;&lt;code&gt;FileInputStream&lt;/code&gt; is meant for reading streams of raw bytes
                     such as image data. For reading streams of characters, consider using
                     &lt;code&gt;FileReader&lt;/code&gt;.
                    
                     @apiNote
                     To release resources used by this stream {@link #close} should be called
                     directly or by try-with-resources. Subclasses are responsible for the cleanup
                     of resources acquired by the subclass.
                     Subclasses that override {@link #finalize} in order to perform cleanup
                     should be modified to use alternative cleanup mechanisms such as
                     {@link java.lang.ref.Cleaner} and remove the overriding {@code finalize} method.
                    
                     @implSpec
                     If this FileInputStream has been subclassed and the {@link #close}
                     method has been overridden, the {@link #close} method will be
                     called when the FileInputStream is unreachable.
                     Otherwise, it is implementation specific how the resource cleanup described in
                     {@link #close} is performed.
                    
                    
                     @author  Arthur van Hoff
                     @see     java.io.File
                     @see     java.io.FileDescriptor
                     @see     java.io.FileOutputStream
                     @see     java.nio.file.Files#newInputStream
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="PushbackReader" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.FilterReader"/>
                    <superType superType="java.io.Reader"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A character-stream reader that allows characters to be pushed back into the
                     stream.
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="DataInput" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.io">
                <superTypes/>
                <javadoc xml:space="preserve">
                     The {@code DataInput} interface provides
                     for reading bytes from a binary stream and
                     reconstructing from them data in any of
                     the Java primitive types. There is also
                     a
                     facility for reconstructing a {@code String}
                     from data in
                     &lt;a href="#modified-utf-8"&gt;modified UTF-8&lt;/a&gt;
                     format.
                     &lt;p&gt;
                     It is generally true of all the reading
                     routines in this interface that if end of
                     file is reached before the desired number
                     of bytes has been read, an {@code EOFException}
                     (which is a kind of {@code IOException})
                     is thrown. If any byte cannot be read for
                     any reason other than end of file, an {@code IOException}
                     other than {@code EOFException} is
                     thrown. In particular, an {@code IOException}
                     may be thrown if the input stream has been
                     closed.
                    
                     &lt;h3&gt;&lt;a id="modified-utf-8"&gt;Modified UTF-8&lt;/a&gt;&lt;/h3&gt;
                     &lt;p&gt;
                     Implementations of the DataInput and DataOutput interfaces represent
                     Unicode strings in a format that is a slight modification of UTF-8.
                     (For information regarding the standard UTF-8 format, see section
                     &lt;i&gt;3.9 Unicode Encoding Forms&lt;/i&gt; of &lt;i&gt;The Unicode Standard, Version
                     4.0&lt;/i&gt;)
                    
                     &lt;ul&gt;
                     &lt;li&gt;Characters in the range {@code '\u0001'} to
                             {@code '\u007F'} are represented by a single byte.
                     &lt;li&gt;The null character {@code '\u0000'} and characters
                             in the range {@code '\u0080'} to {@code '\u07FF'} are
                             represented by a pair of bytes.
                     &lt;li&gt;Characters in the range {@code '\u0800'}
                             to {@code '\uFFFF'} are represented by three bytes.
                     &lt;/ul&gt;
                    
                       &lt;table class="plain" style="margin-left:2em;"&gt;
                         &lt;caption&gt;Encoding of UTF-8 values&lt;/caption&gt;
                         &lt;thead&gt;
                         &lt;tr&gt;
                           &lt;th scope="col" rowspan="2"&gt;Value&lt;/th&gt;
                           &lt;th scope="col" rowspan="2"&gt;Byte&lt;/th&gt;
                           &lt;th scope="col" colspan="8" id="bit_a"&gt;Bit Values&lt;/th&gt;
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;!-- Value --&gt;
                           &lt;!-- Byte --&gt;
                           &lt;th scope="col" style="width:3em"&gt; 7 &lt;/th&gt;
                           &lt;th scope="col" style="width:3em"&gt; 6 &lt;/th&gt;
                           &lt;th scope="col" style="width:3em"&gt; 5 &lt;/th&gt;
                           &lt;th scope="col" style="width:3em"&gt; 4 &lt;/th&gt;
                           &lt;th scope="col" style="width:3em"&gt; 3 &lt;/th&gt;
                           &lt;th scope="col" style="width:3em"&gt; 2 &lt;/th&gt;
                           &lt;th scope="col" style="width:3em"&gt; 1 &lt;/th&gt;
                           &lt;th scope="col" style="width:3em"&gt; 0 &lt;/th&gt;
                         &lt;/thead&gt;
                         &lt;tbody&gt;
                         &lt;tr&gt;
                           &lt;th scope="row" style="text-align:left; font-weight:normal"&gt;
                             {@code \u0001} to {@code \u007F} &lt;/th&gt;
                           &lt;th scope="row" style="font-weight:normal; text-align:center"&gt; 1 &lt;/th&gt;
                           &lt;td style="text-align:center"&gt;0
                           &lt;td colspan="7" style="text-align:right; padding-right:6em"&gt;bits 6-0
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;th scope="row" rowspan="2" style="text-align:left; font-weight:normal"&gt;
                               {@code \u0000},&lt;br&gt;
                               {@code \u0080} to {@code \u07FF} &lt;/th&gt;
                           &lt;th scope="row" style="font-weight:normal; text-align:center"&gt; 1 &lt;/th&gt;
                           &lt;td style="text-align:center"&gt;1
                           &lt;td style="text-align:center"&gt;1
                           &lt;td style="text-align:center"&gt;0
                           &lt;td colspan="5" style="text-align:right; padding-right:6em"&gt;bits 10-6
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;!-- (value) --&gt;
                           &lt;th scope="row" style="font-weight:normal; text-align:center"&gt; 2 &lt;/th&gt;
                           &lt;td style="text-align:center"&gt;1
                           &lt;td style="text-align:center"&gt;0
                           &lt;td colspan="6" style="text-align:right; padding-right:6em"&gt;bits 5-0
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;th scope="row" rowspan="3" style="text-align:left; font-weight:normal"&gt;
                             {@code \u0800} to {@code \uFFFF} &lt;/th&gt;
                           &lt;th scope="row" style="font-weight:normal; text-align:center"&gt; 1 &lt;/th&gt;
                           &lt;td style="text-align:center"&gt;1
                           &lt;td style="text-align:center"&gt;1
                           &lt;td style="text-align:center"&gt;1
                           &lt;td style="text-align:center"&gt;0
                           &lt;td colspan="4" style="text-align:right; padding-right:6em"&gt;bits 15-12
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;!-- (value) --&gt;
                           &lt;th scope="row" style="font-weight:normal; text-align:center"&gt; 2 &lt;/th&gt;
                           &lt;td style="text-align:center"&gt;1
                           &lt;td style="text-align:center"&gt;0
                           &lt;td colspan="6" style="text-align:right; padding-right:6em"&gt;bits 11-6
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;!-- (value) --&gt;
                           &lt;th scope="row" style="font-weight:normal; text-align:center"&gt; 3 &lt;/th&gt;
                           &lt;td style="text-align:center"&gt;1
                           &lt;td style="text-align:center"&gt;0
                           &lt;td colspan="6" style="text-align:right; padding-right:6em"&gt;bits 5-0
                         &lt;/tr&gt;
                         &lt;/tbody&gt;
                       &lt;/table&gt;
                    
                     &lt;p&gt;
                     The differences between this format and the
                     standard UTF-8 format are the following:
                     &lt;ul&gt;
                     &lt;li&gt;The null byte {@code '\u0000'} is encoded in 2-byte format
                         rather than 1-byte, so that the encoded strings never have
                         embedded nulls.
                     &lt;li&gt;Only the 1-byte, 2-byte, and 3-byte formats are used.
                     &lt;li&gt;&lt;a href="../lang/Character.html#unicode"&gt;Supplementary characters&lt;/a&gt;
                         are represented in the form of surrogate pairs.
                     &lt;/ul&gt;
                     @author  Frank Yellin
                     @see     java.io.DataInputStream
                     @see     java.io.DataOutput
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="NotSerializableException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.ObjectStreamException"/>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when an instance is required to have a Serializable interface.
                     The serialization runtime or the class of the instance can throw
                     this exception. The argument should be the name of the class.
                    
                     @author  unascribed
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="RandomAccessFile" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.DataOutput"/>
                    <superType superType="java.io.DataInput"/>
                    <superType superType="java.io.Closeable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Instances of this class support both reading and writing to a
                     random access file. A random access file behaves like a large
                     array of bytes stored in the file system. There is a kind of cursor,
                     or index into the implied array, called the &lt;em&gt;file pointer&lt;/em&gt;;
                     input operations read bytes starting at the file pointer and advance
                     the file pointer past the bytes read. If the random access file is
                     created in read/write mode, then output operations are also available;
                     output operations write bytes starting at the file pointer and advance
                     the file pointer past the bytes written. Output operations that write
                     past the current end of the implied array cause the array to be
                     extended. The file pointer can be read by the
                     {@code getFilePointer} method and set by the {@code seek}
                     method.
                     &lt;p&gt;
                     It is generally true of all the reading routines in this class that
                     if end-of-file is reached before the desired number of bytes has been
                     read, an {@code EOFException} (which is a kind of
                     {@code IOException}) is thrown. If any byte cannot be read for
                     any reason other than end-of-file, an {@code IOException} other
                     than {@code EOFException} is thrown. In particular, an
                     {@code IOException} may be thrown if the stream has been closed.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ByteArrayInputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.InputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@code ByteArrayInputStream} contains
                     an internal buffer that contains bytes that
                     may be read from the stream. An internal
                     counter keeps track of the next byte to
                     be supplied by the {@code read} method.
                     &lt;p&gt;
                     Closing a {@code ByteArrayInputStream} has no effect. The methods in
                     this class can be called after the stream has been closed without
                     generating an {@code IOException}.
                    
                     @author  Arthur van Hoff
                     @see     java.io.StringBufferInputStream
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="PutField" access="PUBLIC" declaringClass="ObjectOutputStream" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="ObjectStreamField" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A description of a Serializable field from a Serializable class.  An array
                     of ObjectStreamFields is used to declare the Serializable fields of a class.
                    
                     @author      Mike Warres
                     @author      Roger Riggs
                     @see ObjectStreamClass
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="FileOutputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.OutputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A file output stream is an output stream for writing data to a
                     &lt;code&gt;File&lt;/code&gt; or to a &lt;code&gt;FileDescriptor&lt;/code&gt;. Whether or not
                     a file is available or may be created depends upon the underlying
                     platform.  Some platforms, in particular, allow a file to be opened
                     for writing by only one {@code FileOutputStream} (or other
                     file-writing object) at a time.  In such situations the constructors in
                     this class will fail if the file involved is already open.
                    
                     &lt;p&gt;&lt;code&gt;FileOutputStream&lt;/code&gt; is meant for writing streams of raw bytes
                     such as image data. For writing streams of characters, consider using
                     &lt;code&gt;FileWriter&lt;/code&gt;.
                    
                     @apiNote
                     To release resources used by this stream {@link #close} should be called
                     directly or by try-with-resources. Subclasses are responsible for the cleanup
                     of resources acquired by the subclass.
                     Subclasses that override {@link #finalize} in order to perform cleanup
                     should be modified to use alternative cleanup mechanisms such as
                     {@link java.lang.ref.Cleaner} and remove the overriding {@code finalize} method.
                    
                     @implSpec
                     If this FileOutputStream has been subclassed and the {@link #close}
                     method has been overridden, the {@link #close} method will be
                     called when the FileInputStream is unreachable.
                     Otherwise, it is implementation specific how the resource cleanup described in
                     {@link #close} is performed.
                    
                     @author  Arthur van Hoff
                     @see     java.io.File
                     @see     java.io.FileDescriptor
                     @see     java.io.FileInputStream
                     @see     java.nio.file.Files#newOutputStream
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="NotActiveException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.ObjectStreamException"/>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when serialization or deserialization is not active.
                    
                     @author  unascribed
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="Externalizable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Only the identity of the class of an Externalizable instance is
                     written in the serialization stream and it is the responsibility
                     of the class to save and restore the contents of its instances.
                    
                     The writeExternal and readExternal methods of the Externalizable
                     interface are implemented by a class to give the class complete
                     control over the format and contents of the stream for an object
                     and its supertypes. These methods must explicitly
                     coordinate with the supertype to save its state. These methods supersede
                     customized implementations of writeObject and readObject methods.&lt;br&gt;
                    
                     Object Serialization uses the Serializable and Externalizable
                     interfaces.  Object persistence mechanisms can use them as well.  Each
                     object to be stored is tested for the Externalizable interface. If
                     the object supports Externalizable, the writeExternal method is called. If the
                     object does not support Externalizable and does implement
                     Serializable, the object is saved using
                     ObjectOutputStream. &lt;br&gt; When an Externalizable object is
                     reconstructed, an instance is created using the public no-arg
                     constructor, then the readExternal method called.  Serializable
                     objects are restored by reading them from an ObjectInputStream.&lt;br&gt;
                    
                     An Externalizable instance can designate a substitution object via
                     the writeReplace and readResolve methods documented in the Serializable
                     interface.&lt;br&gt;
                    
                     @author  unascribed
                     @see java.io.ObjectOutputStream
                     @see java.io.ObjectInputStream
                     @see java.io.ObjectOutput
                     @see java.io.ObjectInput
                     @see java.io.Serializable
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="ObjectInput" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.DataInput"/>
                    <superType superType="java.lang.AutoCloseable"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     ObjectInput extends the DataInput interface to include the reading of
                     objects. DataInput includes methods for the input of primitive types,
                     ObjectInput extends that interface to include objects, arrays, and Strings.
                    
                     @author  unascribed
                     @see java.io.InputStream
                     @see java.io.ObjectOutputStream
                     @see java.io.ObjectInputStream
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="File" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An abstract representation of file and directory pathnames.
                    
                     &lt;p&gt; User interfaces and operating systems use system-dependent &lt;em&gt;pathname
                     strings&lt;/em&gt; to name files and directories.  This class presents an
                     abstract, system-independent view of hierarchical pathnames.  An
                     &lt;em&gt;abstract pathname&lt;/em&gt; has two components:
                    
                     &lt;ol&gt;
                     &lt;li&gt; An optional system-dependent &lt;em&gt;prefix&lt;/em&gt; string,
                          such as a disk-drive specifier, &lt;code&gt;"/"&lt;/code&gt;&amp;nbsp;for the UNIX root
                          directory, or &lt;code&gt;"\\\\"&lt;/code&gt;&amp;nbsp;for a Microsoft Windows UNC pathname, and
                     &lt;li&gt; A sequence of zero or more string &lt;em&gt;names&lt;/em&gt;.
                     &lt;/ol&gt;
                    
                     The first name in an abstract pathname may be a directory name or, in the
                     case of Microsoft Windows UNC pathnames, a hostname.  Each subsequent name
                     in an abstract pathname denotes a directory; the last name may denote
                     either a directory or a file.  The &lt;em&gt;empty&lt;/em&gt; abstract pathname has no
                     prefix and an empty name sequence.
                    
                     &lt;p&gt; The conversion of a pathname string to or from an abstract pathname is
                     inherently system-dependent.  When an abstract pathname is converted into a
                     pathname string, each name is separated from the next by a single copy of
                     the default &lt;em&gt;separator character&lt;/em&gt;.  The default name-separator
                     character is defined by the system property &lt;code&gt;file.separator&lt;/code&gt;, and
                     is made available in the public static fields {@link
                     #separator} and {@link #separatorChar} of this class.
                     When a pathname string is converted into an abstract pathname, the names
                     within it may be separated by the default name-separator character or by any
                     other name-separator character that is supported by the underlying system.
                    
                     &lt;p&gt; A pathname, whether abstract or in string form, may be either
                     &lt;em&gt;absolute&lt;/em&gt; or &lt;em&gt;relative&lt;/em&gt;.  An absolute pathname is complete in
                     that no other information is required in order to locate the file that it
                     denotes.  A relative pathname, in contrast, must be interpreted in terms of
                     information taken from some other pathname.  By default the classes in the
                     &lt;code&gt;java.io&lt;/code&gt; package always resolve relative pathnames against the
                     current user directory.  This directory is named by the system property
                     &lt;code&gt;user.dir&lt;/code&gt;, and is typically the directory in which the Java
                     virtual machine was invoked.
                    
                     &lt;p&gt; The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname may be obtained by invoking
                     the {@link #getParent} method of this class and consists of the pathname's
                     prefix and each name in the pathname's name sequence except for the last.
                     Each directory's absolute pathname is an ancestor of any {@code File}
                     object with an absolute abstract pathname which begins with the directory's
                     absolute pathname.  For example, the directory denoted by the abstract
                     pathname {@code "/usr"} is an ancestor of the directory denoted by the
                     pathname {@code "/usr/local/bin"}.
                    
                     &lt;p&gt; The prefix concept is used to handle root directories on UNIX platforms,
                     and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms,
                     as follows:
                    
                     &lt;ul&gt;
                    
                     &lt;li&gt; For UNIX platforms, the prefix of an absolute pathname is always
                     &lt;code&gt;"/"&lt;/code&gt;.  Relative pathnames have no prefix.  The abstract pathname
                     denoting the root directory has the prefix &lt;code&gt;"/"&lt;/code&gt; and an empty
                     name sequence.
                    
                     &lt;li&gt; For Microsoft Windows platforms, the prefix of a pathname that contains a drive
                     specifier consists of the drive letter followed by &lt;code&gt;":"&lt;/code&gt; and
                     possibly followed by &lt;code&gt;"\\"&lt;/code&gt; if the pathname is absolute.  The
                     prefix of a UNC pathname is &lt;code&gt;"\\\\"&lt;/code&gt;; the hostname and the share
                     name are the first two names in the name sequence.  A relative pathname that
                     does not specify a drive has no prefix.
                    
                     &lt;/ul&gt;
                    
                     &lt;p&gt; Instances of this class may or may not denote an actual file-system
                     object such as a file or a directory.  If it does denote such an object
                     then that object resides in a &lt;i&gt;partition&lt;/i&gt;.  A partition is an
                     operating system-specific portion of storage for a file system.  A single
                     storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may
                     contain multiple partitions.  The object, if any, will reside on the
                     partition &lt;a id="partName"&gt;named&lt;/a&gt; by some ancestor of the absolute
                     form of this pathname.
                    
                     &lt;p&gt; A file system may implement restrictions to certain operations on the
                     actual file-system object, such as reading, writing, and executing.  These
                     restrictions are collectively known as &lt;i&gt;access permissions&lt;/i&gt;.  The file
                     system may have multiple sets of access permissions on a single object.
                     For example, one set may apply to the object's &lt;i&gt;owner&lt;/i&gt;, and another
                     may apply to all other users.  The access permissions on an object may
                     cause some methods in this class to fail.
                    
                     &lt;p&gt; Instances of the &lt;code&gt;File&lt;/code&gt; class are immutable; that is, once
                     created, the abstract pathname represented by a &lt;code&gt;File&lt;/code&gt; object
                     will never change.
                    
                     &lt;h3&gt;Interoperability with {@code java.nio.file} package&lt;/h3&gt;
                    
                     &lt;p&gt; The &lt;a href="../../java/nio/file/package-summary.html"&gt;{@code java.nio.file}&lt;/a&gt;
                     package defines interfaces and classes for the Java virtual machine to access
                     files, file attributes, and file systems. This API may be used to overcome
                     many of the limitations of the {@code java.io.File} class.
                     The {@link #toPath toPath} method may be used to obtain a {@link
                     Path} that uses the abstract path represented by a {@code File} object to
                     locate a file. The resulting {@code Path} may be used with the {@link
                     java.nio.file.Files} class to provide more efficient and extensive access to
                     additional file operations, file attributes, and I/O exceptions to help
                     diagnose errors when an operation on a file fails.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="StreamTokenizer" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code StreamTokenizer} class takes an input stream and
                     parses it into "tokens", allowing the tokens to be
                     read one at a time. The parsing process is controlled by a table
                     and a number of flags that can be set to various states. The
                     stream tokenizer can recognize identifiers, numbers, quoted
                     strings, and various comment styles.
                     &lt;p&gt;
                     Each byte read from the input stream is regarded as a character
                     in the range {@code '\u0000'} through {@code '\u00FF'}.
                     The character value is used to look up five possible attributes of
                     the character: &lt;i&gt;white space&lt;/i&gt;, &lt;i&gt;alphabetic&lt;/i&gt;,
                     &lt;i&gt;numeric&lt;/i&gt;, &lt;i&gt;string quote&lt;/i&gt;, and &lt;i&gt;comment character&lt;/i&gt;.
                     Each character can have zero or more of these attributes.
                     &lt;p&gt;
                     In addition, an instance has four flags. These flags indicate:
                     &lt;ul&gt;
                     &lt;li&gt;Whether line terminators are to be returned as tokens or treated
                         as white space that merely separates tokens.
                     &lt;li&gt;Whether C-style comments are to be recognized and skipped.
                     &lt;li&gt;Whether C++-style comments are to be recognized and skipped.
                     &lt;li&gt;Whether the characters of identifiers are converted to lowercase.
                     &lt;/ul&gt;
                     &lt;p&gt;
                     A typical application first constructs an instance of this class,
                     sets up the syntax tables, and then repeatedly loops calling the
                     {@code nextToken} method in each iteration of the loop until
                     it returns the value {@code TT_EOF}.
                    
                     @author  James Gosling
                     @see     java.io.StreamTokenizer#nextToken()
                     @see     java.io.StreamTokenizer#TT_EOF
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="DataOutput" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.io">
                <superTypes/>
                <javadoc xml:space="preserve">
                     The &lt;code&gt;DataOutput&lt;/code&gt; interface provides
                     for converting data from any of the Java
                     primitive types to a series of bytes and
                     writing these bytes to a binary stream.
                     There is  also a facility for converting
                     a &lt;code&gt;String&lt;/code&gt; into
                     &lt;a href="DataInput.html#modified-utf-8"&gt;modified UTF-8&lt;/a&gt;
                     format and writing the resulting series
                     of bytes.
                     &lt;p&gt;
                     For all the methods in this interface that
                     write bytes, it is generally true that if
                     a byte cannot be written for any reason,
                     an &lt;code&gt;IOException&lt;/code&gt; is thrown.
                    
                     @author  Frank Yellin
                     @see     java.io.DataInput
                     @see     java.io.DataOutputStream
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ObjectInputValidation" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.io">
                <superTypes/>
                <javadoc xml:space="preserve">
                     Callback interface to allow validation of objects within a graph.
                     Allows an object to be called when a complete graph of objects has
                     been deserialized.
                    
                     @author  unascribed
                     @see     ObjectInputStream
                     @see     ObjectInputStream#registerValidation(java.io.ObjectInputValidation, int)
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="Config" access="PUBLIC" declaringClass="ObjectInputFilter" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="DataOutputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.DataOutput"/>
                    <superType superType="java.io.FilterOutputStream"/>
                    <superType superType="java.io.OutputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A data output stream lets an application write primitive Java data
                     types to an output stream in a portable way. An application can
                     then use a data input stream to read the data back in.
                    
                     @author  unascribed
                     @see     java.io.DataInputStream
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="FileWriter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.OutputStreamWriter"/>
                    <superType superType="java.io.Writer"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Writes text to character files using a default buffer size. Encoding from characters
                     to bytes uses either a specified {@linkplain java.nio.charset.Charset charset}
                     or the platform's
                     {@linkplain java.nio.charset.Charset#defaultCharset() default charset}.
                    
                     &lt;p&gt;
                     Whether or not a file is available or may be created depends upon the
                     underlying platform.  Some platforms, in particular, allow a file to be
                     opened for writing by only one {@code FileWriter} (or other file-writing
                     object) at a time.  In such situations the constructors in this class
                     will fail if the file involved is already open.
                    
                     &lt;p&gt;
                     The {@code FileWriter} is meant for writing streams of characters. For writing
                     streams of raw bytes, consider using a {@code FileOutputStream}.
                    
                     @see OutputStreamWriter
                     @see FileOutputStream
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="GetField" access="PUBLIC" declaringClass="ObjectInputStream" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Reader" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.lang.Readable"/>
                    <superType superType="java.io.Closeable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Abstract class for reading character streams.  The only methods that a
                     subclass must implement are read(char[], int, int) and close().  Most
                     subclasses, however, will override some of the methods defined here in order
                     to provide higher efficiency, additional functionality, or both.
                    
                    
                     @see BufferedReader
                     @see   LineNumberReader
                     @see CharArrayReader
                     @see InputStreamReader
                     @see   FileReader
                     @see FilterReader
                     @see   PushbackReader
                     @see PipedReader
                     @see StringReader
                     @see Writer
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="PipedOutputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.OutputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A piped output stream can be connected to a piped input stream
                     to create a communications pipe. The piped output stream is the
                     sending end of the pipe. Typically, data is written to a
                     &lt;code&gt;PipedOutputStream&lt;/code&gt; object by one thread and data is
                     read from the connected &lt;code&gt;PipedInputStream&lt;/code&gt; by some
                     other thread. Attempting to use both objects from a single thread
                     is not recommended as it may deadlock the thread.
                     The pipe is said to be &lt;a id=BROKEN&gt; &lt;i&gt;broken&lt;/i&gt; &lt;/a&gt; if a
                     thread that was reading data bytes from the connected piped input
                     stream is no longer alive.
                    
                     @author  James Gosling
                     @see     java.io.PipedInputStream
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ObjectOutputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.ObjectOutput"/>
                    <superType superType="java.io.ObjectStreamConstants"/>
                    <superType superType="java.io.OutputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An ObjectOutputStream writes primitive data types and graphs of Java objects
                     to an OutputStream.  The objects can be read (reconstituted) using an
                     ObjectInputStream.  Persistent storage of objects can be accomplished by
                     using a file for the stream.  If the stream is a network socket stream, the
                     objects can be reconstituted on another host or in another process.
                    
                     &lt;p&gt;Only objects that support the java.io.Serializable interface can be
                     written to streams.  The class of each serializable object is encoded
                     including the class name and signature of the class, the values of the
                     object's fields and arrays, and the closure of any other objects referenced
                     from the initial objects.
                    
                     &lt;p&gt;The method writeObject is used to write an object to the stream.  Any
                     object, including Strings and arrays, is written with writeObject. Multiple
                     objects or primitives can be written to the stream.  The objects must be
                     read back from the corresponding ObjectInputstream with the same types and
                     in the same order as they were written.
                    
                     &lt;p&gt;Primitive data types can also be written to the stream using the
                     appropriate methods from DataOutput. Strings can also be written using the
                     writeUTF method.
                    
                     &lt;p&gt;The default serialization mechanism for an object writes the class of the
                     object, the class signature, and the values of all non-transient and
                     non-static fields.  References to other objects (except in transient or
                     static fields) cause those objects to be written also. Multiple references
                     to a single object are encoded using a reference sharing mechanism so that
                     graphs of objects can be restored to the same shape as when the original was
                     written.
                    
                     &lt;p&gt;For example to write an object that can be read by the example in
                     ObjectInputStream:
                     &lt;br&gt;
                     &lt;pre&gt;
                          FileOutputStream fos = new FileOutputStream("t.tmp");
                          ObjectOutputStream oos = new ObjectOutputStream(fos);
                    
                          oos.writeInt(12345);
                          oos.writeObject("Today");
                          oos.writeObject(new Date());
                    
                          oos.close();
                     &lt;/pre&gt;
                    
                     &lt;p&gt;Classes that require special handling during the serialization and
                     deserialization process must implement special methods with these exact
                     signatures:
                     &lt;br&gt;
                     &lt;pre&gt;
                     private void readObject(java.io.ObjectInputStream stream)
                         throws IOException, ClassNotFoundException;
                     private void writeObject(java.io.ObjectOutputStream stream)
                         throws IOException
                     private void readObjectNoData()
                         throws ObjectStreamException;
                     &lt;/pre&gt;
                    
                     &lt;p&gt;The writeObject method is responsible for writing the state of the object
                     for its particular class so that the corresponding readObject method can
                     restore it.  The method does not need to concern itself with the state
                     belonging to the object's superclasses or subclasses.  State is saved by
                     writing the individual fields to the ObjectOutputStream using the
                     writeObject method or by using the methods for primitive data types
                     supported by DataOutput.
                    
                     &lt;p&gt;Serialization does not write out the fields of any object that does not
                     implement the java.io.Serializable interface.  Subclasses of Objects that
                     are not serializable can be serializable. In this case the non-serializable
                     class must have a no-arg constructor to allow its fields to be initialized.
                     In this case it is the responsibility of the subclass to save and restore
                     the state of the non-serializable class. It is frequently the case that the
                     fields of that class are accessible (public, package, or protected) or that
                     there are get and set methods that can be used to restore the state.
                    
                     &lt;p&gt;Serialization of an object can be prevented by implementing writeObject
                     and readObject methods that throw the NotSerializableException.  The
                     exception will be caught by the ObjectOutputStream and abort the
                     serialization process.
                    
                     &lt;p&gt;Implementing the Externalizable interface allows the object to assume
                     complete control over the contents and format of the object's serialized
                     form.  The methods of the Externalizable interface, writeExternal and
                     readExternal, are called to save and restore the objects state.  When
                     implemented by a class they can write and read their own state using all of
                     the methods of ObjectOutput and ObjectInput.  It is the responsibility of
                     the objects to handle any versioning that occurs.
                    
                     &lt;p&gt;Enum constants are serialized differently than ordinary serializable or
                     externalizable objects.  The serialized form of an enum constant consists
                     solely of its name; field values of the constant are not transmitted.  To
                     serialize an enum constant, ObjectOutputStream writes the string returned by
                     the constant's name method.  Like other serializable or externalizable
                     objects, enum constants can function as the targets of back references
                     appearing subsequently in the serialization stream.  The process by which
                     enum constants are serialized cannot be customized; any class-specific
                     writeObject and writeReplace methods defined by enum types are ignored
                     during serialization.  Similarly, any serialPersistentFields or
                     serialVersionUID field declarations are also ignored--all enum types have a
                     fixed serialVersionUID of 0L.
                    
                     &lt;p&gt;Primitive data, excluding serializable fields and externalizable data, is
                     written to the ObjectOutputStream in block-data records. A block data record
                     is composed of a header and data. The block data header consists of a marker
                     and the number of bytes to follow the header.  Consecutive primitive data
                     writes are merged into one block-data record.  The blocking factor used for
                     a block-data record will be 1024 bytes.  Each block-data record will be
                     filled up to 1024 bytes, or be written whenever there is a termination of
                     block-data mode.  Calls to the ObjectOutputStream methods writeObject,
                     defaultWriteObject and writeFields initially terminate any existing
                     block-data record.
                    
                     @author      Mike Warres
                     @author      Roger Riggs
                     @see java.io.DataOutput
                     @see java.io.ObjectInputStream
                     @see java.io.Serializable
                     @see java.io.Externalizable
                     @see &lt;a href="{@docRoot}/../specs/serialization/output.html"&gt;
                         Object Serialization Specification, Section 2, Object Output Classes&lt;/a&gt;
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="OptionalDataException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.ObjectStreamException"/>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Exception indicating the failure of an object read operation due to
                     unread primitive data, or the end of data belonging to a serialized
                     object in the stream.  This exception may be thrown in two cases:
                    
                     &lt;ul&gt;
                       &lt;li&gt;An attempt was made to read an object when the next element in the
                           stream is primitive data.  In this case, the OptionalDataException's
                           length field is set to the number of bytes of primitive data
                           immediately readable from the stream, and the eof field is set to
                           false.
                    
                       &lt;li&gt;An attempt was made to read past the end of data consumable by a
                           class-defined readObject or readExternal method.  In this case, the
                           OptionalDataException's eof field is set to true, and the length field
                           is set to 0.
                     &lt;/ul&gt;
                    
                     @author  unascribed
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="CharArrayWriter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Writer"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class implements a character buffer that can be used as an Writer.
                     The buffer automatically grows when data is written to the stream.  The data
                     can be retrieved using toCharArray() and toString().
                     &lt;P&gt;
                     Note: Invoking close() on this class has no effect, and methods
                     of this class can be called after the stream has closed
                     without generating an IOException.
                    
                     @author      Herb Jellinek
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="PipedReader" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Reader"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Piped character-input streams.
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="BufferedWriter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Writer"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Writes text to a character-output stream, buffering characters so as to
                     provide for the efficient writing of single characters, arrays, and strings.
                    
                     &lt;p&gt; The buffer size may be specified, or the default size may be accepted.
                     The default is large enough for most purposes.
                    
                     &lt;p&gt; A newLine() method is provided, which uses the platform's own notion of
                     line separator as defined by the system property {@code line.separator}.
                     Not all platforms use the newline character ('\n') to terminate lines.
                     Calling this method to terminate each output line is therefore preferred to
                     writing a newline character directly.
                    
                     &lt;p&gt; In general, a Writer sends its output immediately to the underlying
                     character or byte stream.  Unless prompt output is required, it is advisable
                     to wrap a BufferedWriter around any Writer whose write() operations may be
                     costly, such as FileWriters and OutputStreamWriters.  For example,
                    
                     &lt;pre&gt;
                     PrintWriter out
                       = new PrintWriter(new BufferedWriter(new FileWriter("foo.out")));
                     &lt;/pre&gt;
                    
                     will buffer the PrintWriter's output to the file.  Without buffering, each
                     invocation of a print() method would cause characters to be converted into
                     bytes that would then be written immediately to the file, which can be very
                     inefficient.
                    
                     @see PrintWriter
                     @see FileWriter
                     @see OutputStreamWriter
                     @see java.nio.file.Files#newBufferedWriter
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="LineNumberReader" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.BufferedReader"/>
                    <superType superType="java.io.Reader"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A buffered character-input stream that keeps track of line numbers.  This
                     class defines methods {@link #setLineNumber(int)} and {@link
                     #getLineNumber()} for setting and getting the current line number
                     respectively.
                    
                     &lt;p&gt; By default, line numbering begins at 0. This number increments at every
                     &lt;a href="#lt"&gt;line terminator&lt;/a&gt; as the data is read, and can be changed
                     with a call to {@code setLineNumber(int)}.  Note however, that
                     {@code setLineNumber(int)} does not actually change the current position in
                     the stream; it only changes the value that will be returned by
                     {@code getLineNumber()}.
                    
                     &lt;p&gt; A line is considered to be &lt;a id="lt"&gt;terminated&lt;/a&gt; by any one of a
                     line feed ('\n'), a carriage return ('\r'), or a carriage return followed
                     immediately by a linefeed.
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="FilenameFilter" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.io">
                <superTypes/>
                <javadoc xml:space="preserve">
                     Instances of classes that implement this interface are used to
                     filter filenames. These instances are used to filter directory
                     listings in the &lt;code&gt;list&lt;/code&gt; method of class
                     &lt;code&gt;File&lt;/code&gt;, and by the Abstract Window Toolkit's file
                     dialog component.
                    
                     @author  Arthur van Hoff
                     @author  Jonathan Payne
                     @see     java.awt.FileDialog#setFilenameFilter(java.io.FilenameFilter)
                     @see     java.io.File
                     @see     java.io.File#list(java.io.FilenameFilter)
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="PipedWriter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Writer"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Piped character-output streams.
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="StringWriter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Writer"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A character stream that collects its output in a string buffer, which can
                     then be used to construct a string.
                     &lt;p&gt;
                     Closing a {@code StringWriter} has no effect. The methods in this class
                     can be called after the stream has been closed without generating an
                     {@code IOException}.
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="Console" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Flushable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Methods to access the character-based console device, if any, associated
                     with the current Java virtual machine.
                    
                     &lt;p&gt; Whether a virtual machine has a console is dependent upon the
                     underlying platform and also upon the manner in which the virtual
                     machine is invoked.  If the virtual machine is started from an
                     interactive command line without redirecting the standard input and
                     output streams then its console will exist and will typically be
                     connected to the keyboard and display from which the virtual machine
                     was launched.  If the virtual machine is started automatically, for
                     example by a background job scheduler, then it will typically not
                     have a console.
                     &lt;p&gt;
                     If this virtual machine has a console then it is represented by a
                     unique instance of this class which can be obtained by invoking the
                     {@link java.lang.System#console()} method.  If no console device is
                     available then an invocation of that method will return {@code null}.
                     &lt;p&gt;
                     Read and write operations are synchronized to guarantee the atomic
                     completion of critical operations; therefore invoking methods
                     {@link #readLine()}, {@link #readPassword()}, {@link #format format()},
                     {@link #printf printf()} as well as the read, format and write operations
                     on the objects returned by {@link #reader()} and {@link #writer()} may
                     block in multithreaded scenarios.
                     &lt;p&gt;
                     Invoking {@code close()} on the objects returned by the {@link #reader()}
                     and the {@link #writer()} will not close the underlying stream of those
                     objects.
                     &lt;p&gt;
                     The console-read methods return {@code null} when the end of the
                     console input stream is reached, for example by typing control-D on
                     Unix or control-Z on Windows.  Subsequent read operations will succeed
                     if additional characters are later entered on the console's input
                     device.
                     &lt;p&gt;
                     Unless otherwise specified, passing a {@code null} argument to any method
                     in this class will cause a {@link NullPointerException} to be thrown.
                     &lt;p&gt;
                     &lt;b&gt;Security note:&lt;/b&gt;
                     If an application needs to read a password or other secure data, it should
                     use {@link #readPassword()} or {@link #readPassword(String, Object...)} and
                     manually zero the returned character array after processing to minimize the
                     lifetime of sensitive data in memory.
                    
                     &lt;blockquote&gt;&lt;pre&gt;{@code
                     Console cons;
                     char[] passwd;
                     if ((cons = System.console()) != null &amp;&amp;
                         (passwd = cons.readPassword("[%s]", "Password:")) != null) {
                         ...
                         java.util.Arrays.fill(passwd, ' ');
                     }
                     }&lt;/pre&gt;&lt;/blockquote&gt;
                    
                     @author  Xueming Shen
                     @since   1.6
                    </javadoc>
            </acts>
            <acts name="StringReader" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Reader"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A character stream whose source is a string.
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="FileReader" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.InputStreamReader"/>
                    <superType superType="java.io.Reader"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Reads text from character files using a default buffer size. Decoding from bytes
                     to characters uses either a specified {@linkplain java.nio.charset.Charset charset}
                     or the platform's
                     {@linkplain java.nio.charset.Charset#defaultCharset() default charset}.
                    
                     &lt;p&gt;
                     The {@code FileReader} is meant for reading streams of characters. For reading
                     streams of raw bytes, consider using a {@code FileInputStream}.
                    
                     @see InputStreamReader
                     @see FileInputStream
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="InvalidObjectException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.ObjectStreamException"/>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Indicates that one or more deserialized objects failed validation
                     tests.  The argument should provide the reason for the failure.
                    
                     @see ObjectInputValidation
                     @since 1.1
                    
                     @author  unascribed
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="WriteAbortedException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.ObjectStreamException"/>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that one of the ObjectStreamExceptions was thrown during a
                     write operation.  Thrown during a read operation when one of the
                     ObjectStreamExceptions was thrown during a write operation.  The
                     exception that terminated the write can be found in the detail
                     field. The stream is reset to it's initial state and all references
                     to objects already deserialized are discarded.
                    
                     &lt;p&gt;As of release 1.4, this exception has been retrofitted to conform to
                     the general purpose exception-chaining mechanism.  The "exception causing
                     the abort" that is provided at construction time and
                     accessed via the public {@link #detail} field is now known as the
                     &lt;i&gt;cause&lt;/i&gt;, and may be accessed via the {@link Throwable#getCause()}
                     method, as well as the aforementioned "legacy field."
                    
                     @author  unascribed
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="FileFilter" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.io">
                <superTypes/>
                <javadoc xml:space="preserve">
                     A filter for abstract pathnames.
                    
                     &lt;p&gt; Instances of this interface may be passed to the &lt;code&gt;{@link
                     File#listFiles(java.io.FileFilter) listFiles(FileFilter)}&lt;/code&gt; method
                     of the &lt;code&gt;{@link java.io.File}&lt;/code&gt; class.
                    
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="BufferedOutputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.FilterOutputStream"/>
                    <superType superType="java.io.OutputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The class implements a buffered output stream. By setting up such
                     an output stream, an application can write bytes to the underlying
                     output stream without necessarily causing a call to the underlying
                     system for each byte written.
                    
                     @author  Arthur van Hoff
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ObjectStreamClass" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Serialization's descriptor for classes.  It contains the name and
                     serialVersionUID of the class.  The ObjectStreamClass for a specific class
                     loaded in this Java VM can be found/created using the lookup method.
                    
                     &lt;p&gt;The algorithm to compute the SerialVersionUID is described in
                     &lt;a href="{@docRoot}/../specs/serialization/class.html#stream-unique-identifiers"&gt;
                         Object Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.
                    
                     @author      Mike Warres
                     @author      Roger Riggs
                     @see ObjectStreamField
                     @see &lt;a href="{@docRoot}/../specs/serialization/class.html"&gt;
                         Object Serialization Specification, Section 4, Class Descriptors&lt;/a&gt;
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="PrintWriter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Writer"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Prints formatted representations of objects to a text-output stream.  This
                     class implements all of the {@code print} methods found in {@link
                     PrintStream}.  It does not contain methods for writing raw bytes, for which
                     a program should use unencoded byte streams.
                    
                     &lt;p&gt; Unlike the {@link PrintStream} class, if automatic flushing is enabled
                     it will be done only when one of the {@code println}, {@code printf}, or
                     {@code format} methods is invoked, rather than whenever a newline character
                     happens to be output.  These methods use the platform's own notion of line
                     separator rather than the newline character.
                    
                     &lt;p&gt; Methods in this class never throw I/O exceptions, although some of its
                     constructors may.  The client may inquire as to whether any errors have
                     occurred by invoking {@link #checkError checkError()}.
                    
                     &lt;p&gt; This class always replaces malformed and unmappable character sequences with
                     the charset's default replacement string.
                     The {@linkplain java.nio.charset.CharsetEncoder} class should be used when more
                     control over the encoding process is required.
                    
                     @author      Frank Yellin
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="PrintStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.lang.Appendable"/>
                    <superType superType="java.io.Closeable"/>
                    <superType superType="java.io.FilterOutputStream"/>
                    <superType superType="java.io.OutputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@code PrintStream} adds functionality to another output stream,
                     namely the ability to print representations of various data values
                     conveniently.  Two other features are provided as well.  Unlike other output
                     streams, a {@code PrintStream} never throws an
                     {@code IOException}; instead, exceptional situations merely set an
                     internal flag that can be tested via the {@code checkError} method.
                     Optionally, a {@code PrintStream} can be created so as to flush
                     automatically; this means that the {@code flush} method is
                     automatically invoked after a byte array is written, one of the
                     {@code println} methods is invoked, or a newline character or byte
                     ({@code '\n'}) is written.
                    
                     &lt;p&gt; All characters printed by a {@code PrintStream} are converted into
                     bytes using the given encoding or charset, or platform's default character
                     encoding if not specified.
                     The {@link PrintWriter} class should be used in situations that require
                      writing characters rather than bytes.
                    
                     &lt;p&gt; This class always replaces malformed and unmappable character sequences with
                     the charset's default replacement string.
                     The {@linkplain java.nio.charset.CharsetEncoder} class should be used when more
                     control over the encoding process is required.
                    
                     @author     Frank Yellin
                     @author     Mark Reinhold
                     @since      1.0
                    </javadoc>
            </acts>
            <acts name="FilterInputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.InputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A &lt;code&gt;FilterInputStream&lt;/code&gt; contains
                     some other input stream, which it uses as
                     its  basic source of data, possibly transforming
                     the data along the way or providing  additional
                     functionality. The class &lt;code&gt;FilterInputStream&lt;/code&gt;
                     itself simply overrides all  methods of
                     &lt;code&gt;InputStream&lt;/code&gt; with versions that
                     pass all requests to the contained  input
                     stream. Subclasses of &lt;code&gt;FilterInputStream&lt;/code&gt;
                     may further override some of  these methods
                     and may also provide additional methods
                     and fields.
                    
                     @author  Jonathan Payne
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="InputStreamReader" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Reader"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An InputStreamReader is a bridge from byte streams to character streams: It
                     reads bytes and decodes them into characters using a specified {@link
                     java.nio.charset.Charset charset}.  The charset that it uses
                     may be specified by name or may be given explicitly, or the platform's
                     default charset may be accepted.
                    
                     &lt;p&gt; Each invocation of one of an InputStreamReader's read() methods may
                     cause one or more bytes to be read from the underlying byte-input stream.
                     To enable the efficient conversion of bytes to characters, more bytes may
                     be read ahead from the underlying stream than are necessary to satisfy the
                     current read operation.
                    
                     &lt;p&gt; For top efficiency, consider wrapping an InputStreamReader within a
                     BufferedReader.  For example:
                    
                     &lt;pre&gt;
                     BufferedReader in
                       = new BufferedReader(new InputStreamReader(System.in));
                     &lt;/pre&gt;
                    
                     @see BufferedReader
                     @see InputStream
                     @see java.nio.charset.Charset
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="ObjectOutput" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.DataOutput"/>
                    <superType superType="java.lang.AutoCloseable"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     ObjectOutput extends the DataOutput interface to include writing of objects.
                     DataOutput includes methods for output of primitive types, ObjectOutput
                     extends that interface to include objects, arrays, and Strings.
                    
                     @author  unascribed
                     @see java.io.InputStream
                     @see java.io.ObjectOutputStream
                     @see java.io.ObjectInputStream
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="InputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Closeable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This abstract class is the superclass of all classes representing
                     an input stream of bytes.
                    
                     &lt;p&gt; Applications that need to define a subclass of &lt;code&gt;InputStream&lt;/code&gt;
                     must always provide a method that returns the next byte of input.
                    
                     @author  Arthur van Hoff
                     @see     java.io.BufferedInputStream
                     @see     java.io.ByteArrayInputStream
                     @see     java.io.DataInputStream
                     @see     java.io.FilterInputStream
                     @see     java.io.InputStream#read()
                     @see     java.io.OutputStream
                     @see     java.io.PushbackInputStream
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="LineNumberInputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.FilterInputStream"/>
                    <superType superType="java.io.InputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class is an input stream filter that provides the added
                     functionality of keeping track of the current line number.
                     &lt;p&gt;
                     A line is a sequence of bytes ending with a carriage return
                     character ({@code '\r'}), a newline character
                     ({@code '\n'}), or a carriage return character followed
                     immediately by a linefeed character. In all three cases, the line
                     terminating character(s) are returned as a single newline character.
                     &lt;p&gt;
                     The line number begins at {@code 0}, and is incremented by
                     {@code 1} when a {@code read} returns a newline character.
                    
                     @author     Arthur van Hoff
                     @see        java.io.LineNumberReader
                     @since      1.0
                     @deprecated This class incorrectly assumes that bytes adequately represent
                                 characters.  As of JDK&amp;nbsp;1.1, the preferred way to operate on
                                 character streams is via the new character-stream classes, which
                                 include a class for counting line numbers.
                    </javadoc>
            </acts>
            <acts name="ByteArrayOutputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.OutputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class implements an output stream in which the data is
                     written into a byte array. The buffer automatically grows as data
                     is written to it.
                     The data can be retrieved using {@code toByteArray()} and
                     {@code toString()}.
                     &lt;p&gt;
                     Closing a {@code ByteArrayOutputStream} has no effect. The methods in
                     this class can be called after the stream has been closed without
                     generating an {@code IOException}.
                    
                     @author  Arthur van Hoff
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="IOException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that an I/O exception of some sort has occurred. This
                     class is the general class of exceptions produced by failed or
                     interrupted I/O operations.
                    
                     @author  unascribed
                     @see     java.io.InputStream
                     @see     java.io.OutputStream
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="PipedInputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.InputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A piped input stream should be connected
                     to a piped output stream; the piped  input
                     stream then provides whatever data bytes
                     are written to the piped output  stream.
                     Typically, data is read from a &lt;code&gt;PipedInputStream&lt;/code&gt;
                     object by one thread  and data is written
                     to the corresponding &lt;code&gt;PipedOutputStream&lt;/code&gt;
                     by some  other thread. Attempting to use
                     both objects from a single thread is not
                     recommended, as it may deadlock the thread.
                     The piped input stream contains a buffer,
                     decoupling read operations from write operations,
                     within limits.
                     A pipe is said to be &lt;a id="BROKEN"&gt; &lt;i&gt;broken&lt;/i&gt; &lt;/a&gt; if a
                     thread that was providing data bytes to the connected
                     piped output stream is no longer alive.
                    
                     @author  James Gosling
                     @see     java.io.PipedOutputStream
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="CharConversionException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Base class for character conversion exceptions.
                    
                     @author      Asmus Freytag
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="DataInputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.DataInput"/>
                    <superType superType="java.io.FilterInputStream"/>
                    <superType superType="java.io.InputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A data input stream lets an application read primitive Java data
                     types from an underlying input stream in a machine-independent
                     way. An application uses a data output stream to write data that
                     can later be read by a data input stream.
                     &lt;p&gt;
                     DataInputStream is not necessarily safe for multithreaded access.
                     Thread safety is optional and is the responsibility of users of
                     methods in this class.
                    
                     @author  Arthur van Hoff
                     @see     java.io.DataOutputStream
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="FileDescriptor" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Instances of the file descriptor class serve as an opaque handle
                     to the underlying machine-specific structure representing an open
                     file, an open socket, or another source or sink of bytes.
                     The main practical use for a file descriptor is to create a
                     {@link FileInputStream} or {@link FileOutputStream} to contain it.
                     &lt;p&gt;
                     Applications should not create their own file descriptors.
                    
                     @author  Pavani Diwanji
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="UTFDataFormatException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that a malformed string in
                     &lt;a href="DataInput.html#modified-utf-8"&gt;modified UTF-8&lt;/a&gt;
                     format has been read in a data
                     input stream or by any class that implements the data input
                     interface.
                     See the
                     &lt;a href="DataInput.html#modified-utf-8"&gt;&lt;code&gt;DataInput&lt;/code&gt;&lt;/a&gt;
                     class description for the format in
                     which modified UTF-8 strings are read and written.
                    
                     @author  Frank Yellin
                     @see     java.io.DataInput
                     @see     java.io.DataInputStream#readUTF(java.io.DataInput)
                     @see     java.io.IOException
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="CharArrayReader" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Reader"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class implements a character buffer that can be used as a
                     character-input stream.
                    
                     @author      Herb Jellinek
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="FilterInfo" access="PUBLIC" declaringClass="ObjectInputFilter" kind="TYPE" typeKind="INTERFACE" packageName="java.io">
                <superTypes/>
            </acts>
            <acts name="SequenceInputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.InputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A &lt;code&gt;SequenceInputStream&lt;/code&gt; represents
                     the logical concatenation of other input
                     streams. It starts out with an ordered
                     collection of input streams and reads from
                     the first one until end of file is reached,
                     whereupon it reads from the second one,
                     and so on, until end of file is reached
                     on the last of the contained input streams.
                    
                     @author  Author van Hoff
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="IOError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when a serious I/O error has occurred.
                    
                     @author  Xueming Shen
                     @since   1.6
                    </javadoc>
            </acts>
            <acts name="BufferedReader" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Reader"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Reads text from a character-input stream, buffering characters so as to
                     provide for the efficient reading of characters, arrays, and lines.
                    
                     &lt;p&gt; The buffer size may be specified, or the default size may be used.  The
                     default is large enough for most purposes.
                    
                     &lt;p&gt; In general, each read request made of a Reader causes a corresponding
                     read request to be made of the underlying character or byte stream.  It is
                     therefore advisable to wrap a BufferedReader around any Reader whose read()
                     operations may be costly, such as FileReaders and InputStreamReaders.  For
                     example,
                    
                     &lt;pre&gt;
                     BufferedReader in
                       = new BufferedReader(new FileReader("foo.in"));
                     &lt;/pre&gt;
                    
                     will buffer the input from the specified file.  Without buffering, each
                     invocation of read() or readLine() could cause bytes to be read from the
                     file, converted into characters, and then returned, which can be very
                     inefficient.
                    
                     &lt;p&gt; Programs that use DataInputStreams for textual input can be localized by
                     replacing each DataInputStream with an appropriate BufferedReader.
                    
                     @see FileReader
                     @see InputStreamReader
                     @see java.nio.file.Files#newBufferedReader
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="OutputStreamWriter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.Writer"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An OutputStreamWriter is a bridge from character streams to byte streams:
                     Characters written to it are encoded into bytes using a specified {@link
                     java.nio.charset.Charset charset}.  The charset that it uses
                     may be specified by name or may be given explicitly, or the platform's
                     default charset may be accepted.
                    
                     &lt;p&gt; Each invocation of a write() method causes the encoding converter to be
                     invoked on the given character(s).  The resulting bytes are accumulated in a
                     buffer before being written to the underlying output stream.  Note that the
                     characters passed to the write() methods are not buffered.
                    
                     &lt;p&gt; For top efficiency, consider wrapping an OutputStreamWriter within a
                     BufferedWriter so as to avoid frequent converter invocations.  For example:
                    
                     &lt;pre&gt;
                     Writer out
                       = new BufferedWriter(new OutputStreamWriter(System.out));
                     &lt;/pre&gt;
                    
                     &lt;p&gt; A &lt;i&gt;surrogate pair&lt;/i&gt; is a character represented by a sequence of two
                     {@code char} values: A &lt;i&gt;high&lt;/i&gt; surrogate in the range '&amp;#92;uD800' to
                     '&amp;#92;uDBFF' followed by a &lt;i&gt;low&lt;/i&gt; surrogate in the range '&amp;#92;uDC00' to
                     '&amp;#92;uDFFF'.
                    
                     &lt;p&gt; A &lt;i&gt;malformed surrogate element&lt;/i&gt; is a high surrogate that is not
                     followed by a low surrogate or a low surrogate that is not preceded by a
                     high surrogate.
                    
                     &lt;p&gt; This class always replaces malformed surrogate elements and unmappable
                     character sequences with the charset's default &lt;i&gt;substitution sequence&lt;/i&gt;.
                     The {@linkplain java.nio.charset.CharsetEncoder} class should be used when more
                     control over the encoding process is required.
                    
                     @see BufferedWriter
                     @see OutputStream
                     @see java.nio.charset.Charset
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="FilterOutputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.OutputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class is the superclass of all classes that filter output
                     streams. These streams sit on top of an already existing output
                     stream (the &lt;i&gt;underlying&lt;/i&gt; output stream) which it uses as its
                     basic sink of data, but possibly transforming the data along the
                     way or providing additional functionality.
                     &lt;p&gt;
                     The class &lt;code&gt;FilterOutputStream&lt;/code&gt; itself simply overrides
                     all methods of &lt;code&gt;OutputStream&lt;/code&gt; with versions that pass
                     all requests to the underlying output stream. Subclasses of
                     &lt;code&gt;FilterOutputStream&lt;/code&gt; may further override some of these
                     methods as well as provide additional methods and fields.
                    
                     @author  Jonathan Payne
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Writer" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.lang.Appendable"/>
                    <superType superType="java.io.Closeable"/>
                    <superType superType="java.io.Flushable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Abstract class for writing to character streams.  The only methods that a
                     subclass must implement are write(char[], int, int), flush(), and close().
                     Most subclasses, however, will override some of the methods defined here in
                     order to provide higher efficiency, additional functionality, or both.
                    
                     @see   BufferedWriter
                     @see   CharArrayWriter
                     @see   FilterWriter
                     @see   OutputStreamWriter
                     @see   FileWriter
                     @see   PipedWriter
                     @see   PrintWriter
                     @see   StringWriter
                     @see Reader
                    
                     @author      Mark Reinhold
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="ObjectInputStream" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.io">
                <superTypes>
                    <superType superType="java.io.ObjectInput"/>
                    <superType superType="java.io.ObjectStreamConstants"/>
                    <superType superType="java.io.InputStream"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An ObjectInputStream deserializes primitive data and objects previously
                     written using an ObjectOutputStream.
                    
                     &lt;p&gt;&lt;strong&gt;Warning: Deserialization of untrusted data is inherently dangerous
                     and should be avoided. Untrusted data should be carefully validated according to the
                     "Serialization and Deserialization" section of the
                     {@extLink secure_coding_guidelines_javase Secure Coding Guidelines for Java SE}.
                     {@extLink serialization_filter_guide Serialization Filtering} describes best
                     practices for defensive use of serial filters.
                     &lt;/strong&gt;&lt;/p&gt;
                    
                     &lt;p&gt;ObjectOutputStream and ObjectInputStream can provide an application with
                     persistent storage for graphs of objects when used with a FileOutputStream
                     and FileInputStream respectively.  ObjectInputStream is used to recover
                     those objects previously serialized. Other uses include passing objects
                     between hosts using a socket stream or for marshaling and unmarshaling
                     arguments and parameters in a remote communication system.
                    
                     &lt;p&gt;ObjectInputStream ensures that the types of all objects in the graph
                     created from the stream match the classes present in the Java Virtual
                     Machine.  Classes are loaded as required using the standard mechanisms.
                    
                     &lt;p&gt;Only objects that support the java.io.Serializable or
                     java.io.Externalizable interface can be read from streams.
                    
                     &lt;p&gt;The method &lt;code&gt;readObject&lt;/code&gt; is used to read an object from the
                     stream.  Java's safe casting should be used to get the desired type.  In
                     Java, strings and arrays are objects and are treated as objects during
                     serialization. When read they need to be cast to the expected type.
                    
                     &lt;p&gt;Primitive data types can be read from the stream using the appropriate
                     method on DataInput.
                    
                     &lt;p&gt;The default deserialization mechanism for objects restores the contents
                     of each field to the value and type it had when it was written.  Fields
                     declared as transient or static are ignored by the deserialization process.
                     References to other objects cause those objects to be read from the stream
                     as necessary.  Graphs of objects are restored correctly using a reference
                     sharing mechanism.  New objects are always allocated when deserializing,
                     which prevents existing objects from being overwritten.
                    
                     &lt;p&gt;Reading an object is analogous to running the constructors of a new
                     object.  Memory is allocated for the object and initialized to zero (NULL).
                     No-arg constructors are invoked for the non-serializable classes and then
                     the fields of the serializable classes are restored from the stream starting
                     with the serializable class closest to java.lang.object and finishing with
                     the object's most specific class.
                    
                     &lt;p&gt;For example to read from a stream as written by the example in
                     ObjectOutputStream:
                     &lt;br&gt;
                     &lt;pre&gt;
                          FileInputStream fis = new FileInputStream("t.tmp");
                          ObjectInputStream ois = new ObjectInputStream(fis);
                    
                          int i = ois.readInt();
                          String today = (String) ois.readObject();
                          Date date = (Date) ois.readObject();
                    
                          ois.close();
                     &lt;/pre&gt;
                    
                     &lt;p&gt;Classes control how they are serialized by implementing either the
                     java.io.Serializable or java.io.Externalizable interfaces.
                    
                     &lt;p&gt;Implementing the Serializable interface allows object serialization to
                     save and restore the entire state of the object and it allows classes to
                     evolve between the time the stream is written and the time it is read.  It
                     automatically traverses references between objects, saving and restoring
                     entire graphs.
                    
                     &lt;p&gt;Serializable classes that require special handling during the
                     serialization and deserialization process should implement the following
                     methods:
                    
                     &lt;pre&gt;
                     private void writeObject(java.io.ObjectOutputStream stream)
                         throws IOException;
                     private void readObject(java.io.ObjectInputStream stream)
                         throws IOException, ClassNotFoundException;
                     private void readObjectNoData()
                         throws ObjectStreamException;
                     &lt;/pre&gt;
                    
                     &lt;p&gt;The readObject method is responsible for reading and restoring the state
                     of the object for its particular class using data written to the stream by
                     the corresponding writeObject method.  The method does not need to concern
                     itself with the state belonging to its superclasses or subclasses.  State is
                     restored by reading data from the ObjectInputStream for the individual
                     fields and making assignments to the appropriate fields of the object.
                     Reading primitive data types is supported by DataInput.
                    
                     &lt;p&gt;Any attempt to read object data which exceeds the boundaries of the
                     custom data written by the corresponding writeObject method will cause an
                     OptionalDataException to be thrown with an eof field value of true.
                     Non-object reads which exceed the end of the allotted data will reflect the
                     end of data in the same way that they would indicate the end of the stream:
                     bytewise reads will return -1 as the byte read or number of bytes read, and
                     primitive reads will throw EOFExceptions.  If there is no corresponding
                     writeObject method, then the end of default serialized data marks the end of
                     the allotted data.
                    
                     &lt;p&gt;Primitive and object read calls issued from within a readExternal method
                     behave in the same manner--if the stream is already positioned at the end of
                     data written by the corresponding writeExternal method, object reads will
                     throw OptionalDataExceptions with eof set to true, bytewise reads will
                     return -1, and primitive reads will throw EOFExceptions.  Note that this
                     behavior does not hold for streams written with the old
                     &lt;code&gt;ObjectStreamConstants.PROTOCOL_VERSION_1&lt;/code&gt; protocol, in which the
                     end of data written by writeExternal methods is not demarcated, and hence
                     cannot be detected.
                    
                     &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
                     the object for its particular class in the event that the serialization
                     stream does not list the given class as a superclass of the object being
                     deserialized.  This may occur in cases where the receiving party uses a
                     different version of the deserialized instance's class than the sending
                     party, and the receiver's version extends classes that are not extended by
                     the sender's version.  This may also occur if the serialization stream has
                     been tampered; hence, readObjectNoData is useful for initializing
                     deserialized objects properly despite a "hostile" or incomplete source
                     stream.
                    
                     &lt;p&gt;Serialization does not read or assign values to the fields of any object
                     that does not implement the java.io.Serializable interface.  Subclasses of
                     Objects that are not serializable can be serializable. In this case the
                     non-serializable class must have a no-arg constructor to allow its fields to
                     be initialized.  In this case it is the responsibility of the subclass to
                     save and restore the state of the non-serializable class. It is frequently
                     the case that the fields of that class are accessible (public, package, or
                     protected) or that there are get and set methods that can be used to restore
                     the state.
                    
                     &lt;p&gt;The contents of the stream can be filtered during deserialization.
                     If a {@linkplain #setObjectInputFilter(ObjectInputFilter) filter is set}
                     on an ObjectInputStream, the {@link ObjectInputFilter} can check that
                     the classes, array lengths, number of references in the stream, depth, and
                     number of bytes consumed from the input stream are allowed and
                     if not, can terminate deserialization.
                     A {@linkplain ObjectInputFilter.Config#setSerialFilter(ObjectInputFilter) process-wide filter}
                     can be configured that is applied to each {@code ObjectInputStream} unless replaced
                     using {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}.
                    
                     &lt;p&gt;Any exception that occurs while deserializing an object will be caught by
                     the ObjectInputStream and abort the reading process.
                    
                     &lt;p&gt;Implementing the Externalizable interface allows the object to assume
                     complete control over the contents and format of the object's serialized
                     form.  The methods of the Externalizable interface, writeExternal and
                     readExternal, are called to save and restore the objects state.  When
                     implemented by a class they can write and read their own state using all of
                     the methods of ObjectOutput and ObjectInput.  It is the responsibility of
                     the objects to handle any versioning that occurs.
                    
                     &lt;p&gt;Enum constants are deserialized differently than ordinary serializable or
                     externalizable objects.  The serialized form of an enum constant consists
                     solely of its name; field values of the constant are not transmitted.  To
                     deserialize an enum constant, ObjectInputStream reads the constant name from
                     the stream; the deserialized constant is then obtained by calling the static
                     method &lt;code&gt;Enum.valueOf(Class, String)&lt;/code&gt; with the enum constant's
                     base type and the received constant name as arguments.  Like other
                     serializable or externalizable objects, enum constants can function as the
                     targets of back references appearing subsequently in the serialization
                     stream.  The process by which enum constants are deserialized cannot be
                     customized: any class-specific readObject, readObjectNoData, and readResolve
                     methods defined by enum types are ignored during deserialization.
                     Similarly, any serialPersistentFields or serialVersionUID field declarations
                     are also ignored--all enum types have a fixed serialVersionUID of 0L.
                    
                     @author      Mike Warres
                     @author      Roger Riggs
                     @see java.io.DataInput
                     @see java.io.ObjectOutputStream
                     @see java.io.Serializable
                     @see &lt;a href="{@docRoot}/../specs/serialization/input.html"&gt;
                         Object Serialization Specification, Section 3, Object Input Classes&lt;/a&gt;
                     @since   1.1
                    </javadoc>
            </acts>
        </package>
        <package name="rmi">
            <package name="dgc"/>
            <package name="registry"/>
            <package name="server"/>
            <package name="activation"/>
        </package>
        <package name="sql"/>
        <package name="security">
            <package name="interfaces"/>
            <package name="cert"/>
            <package name="acl"/>
            <package name="spec"/>
        </package>
        <package name="util">
            <acts name="UnknownFormatFlagsException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.IllegalFormatException"/>
                    <superType superType="java.lang.IllegalArgumentException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Unchecked exception thrown when an unknown flag is given.
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
                     method or constructor in this class will cause a {@link
                     NullPointerException} to be thrown.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="ConcurrentModificationException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This exception may be thrown by methods that have detected concurrent
                     modification of an object when such modification is not permissible.
                     &lt;p&gt;
                     For example, it is not generally permissible for one thread to modify a Collection
                     while another thread is iterating over it.  In general, the results of the
                     iteration are undefined under these circumstances.  Some Iterator
                     implementations (including those of all the general purpose collection implementations
                     provided by the JRE) may choose to throw this exception if this behavior is
                     detected.  Iterators that do this are known as &lt;i&gt;fail-fast&lt;/i&gt; iterators,
                     as they fail quickly and cleanly, rather that risking arbitrary,
                     non-deterministic behavior at an undetermined time in the future.
                     &lt;p&gt;
                     Note that this exception does not always indicate that an object has
                     been concurrently modified by a &lt;i&gt;different&lt;/i&gt; thread.  If a single
                     thread issues a sequence of method invocations that violates the
                     contract of an object, the object may throw this exception.  For
                     example, if a thread modifies a collection directly while it is
                     iterating over the collection with a fail-fast iterator, the iterator
                     will throw this exception.
                    
                     &lt;p&gt;Note that fail-fast behavior cannot be guaranteed as it is, generally
                     speaking, impossible to make any hard guarantees in the presence of
                     unsynchronized concurrent modification.  Fail-fast operations
                     throw {@code ConcurrentModificationException} on a best-effort basis.
                     Therefore, it would be wrong to write a program that depended on this
                     exception for its correctness: &lt;i&gt;{@code ConcurrentModificationException}
                     should be used only to detect bugs.&lt;/i&gt;
                    
                     @author  Josh Bloch
                     @see     Collection
                     @see     Iterator
                     @see     Spliterator
                     @see     ListIterator
                     @see     Vector
                     @see     LinkedList
                     @see     HashSet
                     @see     Hashtable
                     @see     TreeMap
                     @see     AbstractList
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="Builder" access="PUBLIC" declaringClass="Calendar" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="ArrayList" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.List"/>
                    <superType superType="java.util.RandomAccess"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.util.AbstractList"/>
                    <superType superType="java.util.AbstractCollection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Resizable-array implementation of the {@code List} interface.  Implements
                     all optional list operations, and permits all elements, including
                     {@code null}.  In addition to implementing the {@code List} interface,
                     this class provides methods to manipulate the size of the array that is
                     used internally to store the list.  (This class is roughly equivalent to
                     {@code Vector}, except that it is unsynchronized.)
                    
                     &lt;p&gt;The {@code size}, {@code isEmpty}, {@code get}, {@code set},
                     {@code iterator}, and {@code listIterator} operations run in constant
                     time.  The {@code add} operation runs in &lt;i&gt;amortized constant time&lt;/i&gt;,
                     that is, adding n elements requires O(n) time.  All of the other operations
                     run in linear time (roughly speaking).  The constant factor is low compared
                     to that for the {@code LinkedList} implementation.
                    
                     &lt;p&gt;Each {@code ArrayList} instance has a &lt;i&gt;capacity&lt;/i&gt;.  The capacity is
                     the size of the array used to store the elements in the list.  It is always
                     at least as large as the list size.  As elements are added to an ArrayList,
                     its capacity grows automatically.  The details of the growth policy are not
                     specified beyond the fact that adding an element has constant amortized
                     time cost.
                    
                     &lt;p&gt;An application can increase the capacity of an {@code ArrayList} instance
                     before adding a large number of elements using the {@code ensureCapacity}
                     operation.  This may reduce the amount of incremental reallocation.
                    
                     &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
                     If multiple threads access an {@code ArrayList} instance concurrently,
                     and at least one of the threads modifies the list structurally, it
                     &lt;i&gt;must&lt;/i&gt; be synchronized externally.  (A structural modification is
                     any operation that adds or deletes one or more elements, or explicitly
                     resizes the backing array; merely setting the value of an element is not
                     a structural modification.)  This is typically accomplished by
                     synchronizing on some object that naturally encapsulates the list.
                    
                     If no such object exists, the list should be "wrapped" using the
                     {@link Collections#synchronizedList Collections.synchronizedList}
                     method.  This is best done at creation time, to prevent accidental
                     unsynchronized access to the list:&lt;pre&gt;
                       List list = Collections.synchronizedList(new ArrayList(...));&lt;/pre&gt;
                    
                     &lt;p id="fail-fast"&gt;
                     The iterators returned by this class's {@link #iterator() iterator} and
                     {@link #listIterator(int) listIterator} methods are &lt;em&gt;fail-fast&lt;/em&gt;:
                     if the list is structurally modified at any time after the iterator is
                     created, in any way except through the iterator's own
                     {@link ListIterator#remove() remove} or
                     {@link ListIterator#add(Object) add} methods, the iterator will throw a
                     {@link ConcurrentModificationException}.  Thus, in the face of
                     concurrent modification, the iterator fails quickly and cleanly, rather
                     than risking arbitrary, non-deterministic behavior at an undetermined
                     time in the future.
                    
                     &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                     as it is, generally speaking, impossible to make any hard guarantees in the
                     presence of unsynchronized concurrent modification.  Fail-fast iterators
                     throw {@code ConcurrentModificationException} on a best-effort basis.
                     Therefore, it would be wrong to write a program that depended on this
                     exception for its correctness:  &lt;i&gt;the fail-fast behavior of iterators
                     should be used only to detect bugs.&lt;/i&gt;
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;E&gt; the type of elements in this list
                    
                     @author  Josh Bloch
                     @author  Neal Gafter
                     @see     Collection
                     @see     List
                     @see     LinkedList
                     @see     Vector
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="IllegalFormatConversionException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.IllegalFormatException"/>
                    <superType superType="java.lang.IllegalArgumentException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Unchecked exception thrown when the argument corresponding to the format
                     specifier is of an incompatible type.
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
                     method or constructor in this class will cause a {@link
                     NullPointerException} to be thrown.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="PropertyResourceBundle" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.ResourceBundle"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;code&gt;PropertyResourceBundle&lt;/code&gt; is a concrete subclass of
                     &lt;code&gt;ResourceBundle&lt;/code&gt; that manages resources for a locale
                     using a set of static strings from a property file. See
                     {@link ResourceBundle ResourceBundle} for more information about resource
                     bundles.
                    
                     &lt;p&gt;
                     Unlike other types of resource bundle, you don't subclass
                     &lt;code&gt;PropertyResourceBundle&lt;/code&gt;.  Instead, you supply properties
                     files containing the resource data.  &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;
                     will automatically look for the appropriate properties file and create a
                     &lt;code&gt;PropertyResourceBundle&lt;/code&gt; that refers to it. See
                     {@link ResourceBundle#getBundle(String, Locale, ClassLoader) ResourceBundle.getBundle}
                     for a complete description of the search and instantiation strategy.
                    
                     &lt;p&gt;
                     The following &lt;a id="sample"&gt;example&lt;/a&gt; shows a member of a resource
                     bundle family with the base name "MyResources".
                     The text defines the bundle "MyResources_de",
                     the German member of the bundle family.
                     This member is based on &lt;code&gt;PropertyResourceBundle&lt;/code&gt;, and the text
                     therefore is the content of the file "MyResources_de.properties"
                     (a related &lt;a href="ListResourceBundle.html#sample"&gt;example&lt;/a&gt; shows
                     how you can add bundles to this family that are implemented as subclasses
                     of &lt;code&gt;ListResourceBundle&lt;/code&gt;).
                     The keys in this example are of the form "s1" etc. The actual
                     keys are entirely up to your choice, so long as they are the same as
                     the keys you use in your program to retrieve the objects from the bundle.
                     Keys are case-sensitive.
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     # MessageFormat pattern
                     s1=Die Platte \"{1}\" enth&amp;auml;lt {0}.
                    
                     # location of {0} in pattern
                     s2=1
                    
                     # sample disk name
                     s3=Meine Platte
                    
                     # first ChoiceFormat choice
                     s4=keine Dateien
                    
                     # second ChoiceFormat choice
                     s5=eine Datei
                    
                     # third ChoiceFormat choice
                     s6={0,number} Dateien
                    
                     # sample date
                     s7=3. M&amp;auml;rz 1996
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     @apiNote
                     {@code PropertyResourceBundle} can be constructed either
                     from an {@code InputStream} or a {@code Reader}, which represents a property file.
                     Constructing a {@code PropertyResourceBundle} instance from an {@code InputStream}
                     requires that the input stream be encoded in {@code UTF-8}. By default, if a
                     {@link java.nio.charset.MalformedInputException} or an
                     {@link java.nio.charset.UnmappableCharacterException} occurs on reading the
                     input stream, then the {@code PropertyResourceBundle} instance resets to the state
                     before the exception, re-reads the input stream in {@code ISO-8859-1}, and
                     continues reading. If the system property
                     {@code java.util.PropertyResourceBundle.encoding} is set to either
                     "ISO-8859-1" or "UTF-8", the input stream is solely read in that encoding,
                     and throws the exception if it encounters an invalid sequence.
                     If "ISO-8859-1" is specified, characters that cannot be represented in
                     ISO-8859-1 encoding must be represented by Unicode Escapes as defined in section
                     3.3 of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;
                     whereas the other constructor which takes a {@code Reader} does not have that limitation.
                     Other encoding values are ignored for this system property.
                     The system property is read and evaluated when initializing this class.
                     Changing or removing the property has no effect after the initialization.
                    
                     @implSpec
                     The implementation of a {@code PropertyResourceBundle} subclass must be
                     thread-safe if it's simultaneously used by multiple threads. The default
                     implementations of the non-abstract methods in this class are thread-safe.
                    
                     @see ResourceBundle
                     @see ListResourceBundle
                     @see Properties
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="AbstractMap" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Map"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class provides a skeletal implementation of the {@code Map}
                     interface, to minimize the effort required to implement this interface.
                    
                     &lt;p&gt;To implement an unmodifiable map, the programmer needs only to extend this
                     class and provide an implementation for the {@code entrySet} method, which
                     returns a set-view of the map's mappings.  Typically, the returned set
                     will, in turn, be implemented atop {@code AbstractSet}.  This set should
                     not support the {@code add} or {@code remove} methods, and its iterator
                     should not support the {@code remove} method.
                    
                     &lt;p&gt;To implement a modifiable map, the programmer must additionally override
                     this class's {@code put} method (which otherwise throws an
                     {@code UnsupportedOperationException}), and the iterator returned by
                     {@code entrySet().iterator()} must additionally implement its
                     {@code remove} method.
                    
                     &lt;p&gt;The programmer should generally provide a void (no argument) and map
                     constructor, as per the recommendation in the {@code Map} interface
                     specification.
                    
                     &lt;p&gt;The documentation for each non-abstract method in this class describes its
                     implementation in detail.  Each of these methods may be overridden if the
                     map being implemented admits a more efficient implementation.
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;K&gt; the type of keys maintained by this map
                     @param &lt;V&gt; the type of mapped values
                    
                     @author  Josh Bloch
                     @author  Neal Gafter
                     @see Map
                     @see Collection
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="TreeSet" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.NavigableSet"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.util.AbstractSet"/>
                    <superType superType="java.util.AbstractCollection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@link NavigableSet} implementation based on a {@link TreeMap}.
                     The elements are ordered using their {@linkplain Comparable natural
                     ordering}, or by a {@link Comparator} provided at set creation
                     time, depending on which constructor is used.
                    
                     &lt;p&gt;This implementation provides guaranteed log(n) time cost for the basic
                     operations ({@code add}, {@code remove} and {@code contains}).
                    
                     &lt;p&gt;Note that the ordering maintained by a set (whether or not an explicit
                     comparator is provided) must be &lt;i&gt;consistent with equals&lt;/i&gt; if it is to
                     correctly implement the {@code Set} interface.  (See {@code Comparable}
                     or {@code Comparator} for a precise definition of &lt;i&gt;consistent with
                     equals&lt;/i&gt;.)  This is so because the {@code Set} interface is defined in
                     terms of the {@code equals} operation, but a {@code TreeSet} instance
                     performs all element comparisons using its {@code compareTo} (or
                     {@code compare}) method, so two elements that are deemed equal by this method
                     are, from the standpoint of the set, equal.  The behavior of a set
                     &lt;i&gt;is&lt;/i&gt; well-defined even if its ordering is inconsistent with equals; it
                     just fails to obey the general contract of the {@code Set} interface.
                    
                     &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
                     If multiple threads access a tree set concurrently, and at least one
                     of the threads modifies the set, it &lt;i&gt;must&lt;/i&gt; be synchronized
                     externally.  This is typically accomplished by synchronizing on some
                     object that naturally encapsulates the set.
                     If no such object exists, the set should be "wrapped" using the
                     {@link Collections#synchronizedSortedSet Collections.synchronizedSortedSet}
                     method.  This is best done at creation time, to prevent accidental
                     unsynchronized access to the set: &lt;pre&gt;
                       SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));&lt;/pre&gt;
                    
                     &lt;p&gt;The iterators returned by this class's {@code iterator} method are
                     &lt;i&gt;fail-fast&lt;/i&gt;: if the set is modified at any time after the iterator is
                     created, in any way except through the iterator's own {@code remove}
                     method, the iterator will throw a {@link ConcurrentModificationException}.
                     Thus, in the face of concurrent modification, the iterator fails quickly
                     and cleanly, rather than risking arbitrary, non-deterministic behavior at
                     an undetermined time in the future.
                    
                     &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                     as it is, generally speaking, impossible to make any hard guarantees in the
                     presence of unsynchronized concurrent modification.  Fail-fast iterators
                     throw {@code ConcurrentModificationException} on a best-effort basis.
                     Therefore, it would be wrong to write a program that depended on this
                     exception for its correctness:   &lt;i&gt;the fail-fast behavior of iterators
                     should be used only to detect bugs.&lt;/i&gt;
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;E&gt; the type of elements maintained by this set
                    
                     @author  Josh Bloch
                     @see     Collection
                     @see     Set
                     @see     HashSet
                     @see     Comparable
                     @see     Comparator
                     @see     TreeMap
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="Currency" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Represents a currency. Currencies are identified by their ISO 4217 currency
                     codes. Visit the &lt;a href="http://www.iso.org/iso/home/standards/currency_codes.htm"&gt;
                     ISO web site&lt;/a&gt; for more information.
                     &lt;p&gt;
                     The class is designed so that there's never more than one
                     &lt;code&gt;Currency&lt;/code&gt; instance for any given currency. Therefore, there's
                     no public constructor. You obtain a &lt;code&gt;Currency&lt;/code&gt; instance using
                     the &lt;code&gt;getInstance&lt;/code&gt; methods.
                     &lt;p&gt;
                     Users can supersede the Java runtime currency data by means of the system
                     property {@code java.util.currency.data}. If this system property is
                     defined then its value is the location of a properties file, the contents of
                     which are key/value pairs of the ISO 3166 country codes and the ISO 4217
                     currency data respectively.  The value part consists of three ISO 4217 values
                     of a currency, i.e., an alphabetic code, a numeric code, and a minor unit.
                     Those three ISO 4217 values are separated by commas.
                     The lines which start with '#'s are considered comment lines. An optional UTC
                     timestamp may be specified per currency entry if users need to specify a
                     cutover date indicating when the new data comes into effect. The timestamp is
                     appended to the end of the currency properties and uses a comma as a separator.
                     If a UTC datestamp is present and valid, the JRE will only use the new currency
                     properties if the current UTC date is later than the date specified at class
                     loading time. The format of the timestamp must be of ISO 8601 format :
                     {@code 'yyyy-MM-dd'T'HH:mm:ss'}. For example,
                     &lt;p&gt;
                     &lt;code&gt;
                     #Sample currency properties&lt;br&gt;
                     JP=JPZ,999,0
                     &lt;/code&gt;
                     &lt;p&gt;
                     will supersede the currency data for Japan. If JPZ is one of the existing
                     ISO 4217 currency code referred by other countries, the existing
                     JPZ currency data is updated with the given numeric code and minor
                     unit value.
                    
                     &lt;p&gt;
                     &lt;code&gt;
                     #Sample currency properties with cutover date&lt;br&gt;
                     JP=JPZ,999,0,2014-01-01T00:00:00
                     &lt;/code&gt;
                     &lt;p&gt;
                     will supersede the currency data for Japan if {@code Currency} class is loaded after
                     1st January 2014 00:00:00 GMT.
                     &lt;p&gt;
                     Where syntactically malformed entries are encountered, the entry is ignored
                     and the remainder of entries in file are processed. For instances where duplicate
                     country code entries exist, the behavior of the Currency information for that
                     {@code Currency} is undefined and the remainder of entries in file are processed.
                     &lt;p&gt;
                     If multiple property entries with same currency code but different numeric code
                     and/or minor unit are encountered, those entries are ignored and the remainder
                     of entries in file are processed.
                    
                     &lt;p&gt;
                     It is recommended to use {@link java.math.BigDecimal} class while dealing
                     with {@code Currency} or monetary values as it provides better handling of floating
                     point numbers and their operations.
                    
                     @see java.math.BigDecimal
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="MissingFormatArgumentException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.IllegalFormatException"/>
                    <superType superType="java.lang.IllegalArgumentException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Unchecked exception thrown when there is a format specifier which does not
                     have a corresponding argument or if an argument index refers to an argument
                     that does not exist.
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
                     method or constructor in this class will cause a {@link
                     NullPointerException} to be thrown.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="EnumMap" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.util.AbstractMap"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A specialized {@link Map} implementation for use with enum type keys.  All
                     of the keys in an enum map must come from a single enum type that is
                     specified, explicitly or implicitly, when the map is created.  Enum maps
                     are represented internally as arrays.  This representation is extremely
                     compact and efficient.
                    
                     &lt;p&gt;Enum maps are maintained in the &lt;i&gt;natural order&lt;/i&gt; of their keys
                     (the order in which the enum constants are declared).  This is reflected
                     in the iterators returned by the collections views ({@link #keySet()},
                     {@link #entrySet()}, and {@link #values()}).
                    
                     &lt;p&gt;Iterators returned by the collection views are &lt;i&gt;weakly consistent&lt;/i&gt;:
                     they will never throw {@link ConcurrentModificationException} and they may
                     or may not show the effects of any modifications to the map that occur while
                     the iteration is in progress.
                    
                     &lt;p&gt;Null keys are not permitted.  Attempts to insert a null key will
                     throw {@link NullPointerException}.  Attempts to test for the
                     presence of a null key or to remove one will, however, function properly.
                     Null values are permitted.
                    
                     &lt;P&gt;Like most collection implementations {@code EnumMap} is not
                     synchronized. If multiple threads access an enum map concurrently, and at
                     least one of the threads modifies the map, it should be synchronized
                     externally.  This is typically accomplished by synchronizing on some
                     object that naturally encapsulates the enum map.  If no such object exists,
                     the map should be "wrapped" using the {@link Collections#synchronizedMap}
                     method.  This is best done at creation time, to prevent accidental
                     unsynchronized access:
                    
                     &lt;pre&gt;
                         Map&amp;lt;EnumKey, V&amp;gt; m
                             = Collections.synchronizedMap(new EnumMap&amp;lt;EnumKey, V&amp;gt;(...));
                     &lt;/pre&gt;
                    
                     &lt;p&gt;Implementation note: All basic operations execute in constant time.
                     They are likely (though not guaranteed) to be faster than their
                     {@link HashMap} counterparts.
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @author Josh Bloch
                     @see EnumSet
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="Vector" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.List"/>
                    <superType superType="java.util.RandomAccess"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.util.AbstractList"/>
                    <superType superType="java.util.AbstractCollection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Vector} class implements a growable array of
                     objects. Like an array, it contains components that can be
                     accessed using an integer index. However, the size of a
                     {@code Vector} can grow or shrink as needed to accommodate
                     adding and removing items after the {@code Vector} has been created.
                    
                     &lt;p&gt;Each vector tries to optimize storage management by maintaining a
                     {@code capacity} and a {@code capacityIncrement}. The
                     {@code capacity} is always at least as large as the vector
                     size; it is usually larger because as components are added to the
                     vector, the vector's storage increases in chunks the size of
                     {@code capacityIncrement}. An application can increase the
                     capacity of a vector before inserting a large number of
                     components; this reduces the amount of incremental reallocation.
                    
                     &lt;p id="fail-fast"&gt;
                     The iterators returned by this class's {@link #iterator() iterator} and
                     {@link #listIterator(int) listIterator} methods are &lt;em&gt;fail-fast&lt;/em&gt;:
                     if the vector is structurally modified at any time after the iterator is
                     created, in any way except through the iterator's own
                     {@link ListIterator#remove() remove} or
                     {@link ListIterator#add(Object) add} methods, the iterator will throw a
                     {@link ConcurrentModificationException}.  Thus, in the face of
                     concurrent modification, the iterator fails quickly and cleanly, rather
                     than risking arbitrary, non-deterministic behavior at an undetermined
                     time in the future.  The {@link Enumeration Enumerations} returned by
                     the {@link #elements() elements} method are &lt;em&gt;not&lt;/em&gt; fail-fast; if the
                     Vector is structurally modified at any time after the enumeration is
                     created then the results of enumerating are undefined.
                    
                     &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                     as it is, generally speaking, impossible to make any hard guarantees in the
                     presence of unsynchronized concurrent modification.  Fail-fast iterators
                     throw {@code ConcurrentModificationException} on a best-effort basis.
                     Therefore, it would be wrong to write a program that depended on this
                     exception for its correctness:  &lt;i&gt;the fail-fast behavior of iterators
                     should be used only to detect bugs.&lt;/i&gt;
                    
                     &lt;p&gt;As of the Java 2 platform v1.2, this class was retrofitted to
                     implement the {@link List} interface, making it a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.  Unlike the new collection
                     implementations, {@code Vector} is synchronized.  If a thread-safe
                     implementation is not needed, it is recommended to use {@link
                     ArrayList} in place of {@code Vector}.
                    
                     @param &lt;E&gt; Type of component elements
                    
                     @author  Lee Boynton
                     @author  Jonathan Payne
                     @see Collection
                     @see LinkedList
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="AbstractIntSpliterator" access="PUBLIC" declaringClass="Spliterators" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Spliterator$OfInt"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="StringJoiner" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     {@code StringJoiner} is used to construct a sequence of characters separated
                     by a delimiter and optionally starting with a supplied prefix
                     and ending with a supplied suffix.
                     &lt;p&gt;
                     Prior to adding something to the {@code StringJoiner}, its
                     {@code sj.toString()} method will, by default, return {@code prefix + suffix}.
                     However, if the {@code setEmptyValue} method is called, the {@code emptyValue}
                     supplied will be returned instead. This can be used, for example, when
                     creating a string using set notation to indicate an empty set, i.e.
                     &lt;code&gt;"{}"&lt;/code&gt;, where the {@code prefix} is &lt;code&gt;"{"&lt;/code&gt;, the
                     {@code suffix} is &lt;code&gt;"}"&lt;/code&gt; and nothing has been added to the
                     {@code StringJoiner}.
                    
                     @apiNote
                     &lt;p&gt;The String {@code "[George:Sally:Fred]"} may be constructed as follows:
                    
                     &lt;pre&gt; {@code
                     StringJoiner sj = new StringJoiner(":", "[", "]");
                     sj.add("George").add("Sally").add("Fred");
                     String desiredString = sj.toString();
                     }&lt;/pre&gt;
                     &lt;p&gt;
                     A {@code StringJoiner} may be employed to create formatted output from a
                     {@link java.util.stream.Stream} using
                     {@link java.util.stream.Collectors#joining(CharSequence)}. For example:
                    
                     &lt;pre&gt; {@code
                     List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);
                     String commaSeparatedNumbers = numbers.stream()
                         .map(i -&gt; i.toString())
                         .collect(Collectors.joining(", "));
                     }&lt;/pre&gt;
                    
                     @see java.util.stream.Collectors#joining(CharSequence)
                     @see java.util.stream.Collectors#joining(CharSequence, CharSequence, CharSequence)
                     @since  1.8
                    </javadoc>
            </acts>
            <acts name="GregorianCalendar" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Calendar"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;code&gt;GregorianCalendar&lt;/code&gt; is a concrete subclass of
                     &lt;code&gt;Calendar&lt;/code&gt; and provides the standard calendar system
                     used by most of the world.
                    
                     &lt;p&gt; &lt;code&gt;GregorianCalendar&lt;/code&gt; is a hybrid calendar that
                     supports both the Julian and Gregorian calendar systems with the
                     support of a single discontinuity, which corresponds by default to
                     the Gregorian date when the Gregorian calendar was instituted
                     (October 15, 1582 in some countries, later in others).  The cutover
                     date may be changed by the caller by calling {@link
                     #setGregorianChange(Date) setGregorianChange()}.
                    
                     &lt;p&gt;
                     Historically, in those countries which adopted the Gregorian calendar first,
                     October 4, 1582 (Julian) was thus followed by October 15, 1582 (Gregorian). This calendar models
                     this correctly.  Before the Gregorian cutover, &lt;code&gt;GregorianCalendar&lt;/code&gt;
                     implements the Julian calendar.  The only difference between the Gregorian
                     and the Julian calendar is the leap year rule. The Julian calendar specifies
                     leap years every four years, whereas the Gregorian calendar omits century
                     years which are not divisible by 400.
                    
                     &lt;p&gt;
                     &lt;code&gt;GregorianCalendar&lt;/code&gt; implements &lt;em&gt;proleptic&lt;/em&gt; Gregorian and
                     Julian calendars. That is, dates are computed by extrapolating the current
                     rules indefinitely far backward and forward in time. As a result,
                     &lt;code&gt;GregorianCalendar&lt;/code&gt; may be used for all years to generate
                     meaningful and consistent results. However, dates obtained using
                     &lt;code&gt;GregorianCalendar&lt;/code&gt; are historically accurate only from March 1, 4
                     AD onward, when modern Julian calendar rules were adopted.  Before this date,
                     leap year rules were applied irregularly, and before 45 BC the Julian
                     calendar did not even exist.
                    
                     &lt;p&gt;
                     Prior to the institution of the Gregorian calendar, New Year's Day was
                     March 25. To avoid confusion, this calendar always uses January 1. A manual
                     adjustment may be made if desired for dates that are prior to the Gregorian
                     changeover and which fall between January 1 and March 24.
                    
                     &lt;h3&gt;&lt;a id="week_and_year"&gt;Week Of Year and Week Year&lt;/a&gt;&lt;/h3&gt;
                    
                     &lt;p&gt;Values calculated for the {@link Calendar#WEEK_OF_YEAR
                     WEEK_OF_YEAR} field range from 1 to 53. The first week of a
                     calendar year is the earliest seven day period starting on {@link
                     Calendar#getFirstDayOfWeek() getFirstDayOfWeek()} that contains at
                     least {@link Calendar#getMinimalDaysInFirstWeek()
                     getMinimalDaysInFirstWeek()} days from that year. It thus depends
                     on the values of {@code getMinimalDaysInFirstWeek()}, {@code
                     getFirstDayOfWeek()}, and the day of the week of January 1. Weeks
                     between week 1 of one year and week 1 of the following year
                     (exclusive) are numbered sequentially from 2 to 52 or 53 (except
                     for year(s) involved in the Julian-Gregorian transition).
                    
                     &lt;p&gt;The {@code getFirstDayOfWeek()} and {@code
                     getMinimalDaysInFirstWeek()} values are initialized using
                     locale-dependent resources when constructing a {@code
                     GregorianCalendar}. &lt;a id="iso8601_compatible_setting"&gt;The week
                     determination is compatible&lt;/a&gt; with the ISO 8601 standard when {@code
                     getFirstDayOfWeek()} is {@code MONDAY} and {@code
                     getMinimalDaysInFirstWeek()} is 4, which values are used in locales
                     where the standard is preferred. These values can explicitly be set by
                     calling {@link Calendar#setFirstDayOfWeek(int) setFirstDayOfWeek()} and
                     {@link Calendar#setMinimalDaysInFirstWeek(int)
                     setMinimalDaysInFirstWeek()}.
                    
                     &lt;p&gt;A &lt;a id="week_year"&gt;&lt;em&gt;week year&lt;/em&gt;&lt;/a&gt; is in sync with a
                     {@code WEEK_OF_YEAR} cycle. All weeks between the first and last
                     weeks (inclusive) have the same &lt;em&gt;week year&lt;/em&gt; value.
                     Therefore, the first and last days of a week year may have
                     different calendar year values.
                    
                     &lt;p&gt;For example, January 1, 1998 is a Thursday. If {@code
                     getFirstDayOfWeek()} is {@code MONDAY} and {@code
                     getMinimalDaysInFirstWeek()} is 4 (ISO 8601 standard compatible
                     setting), then week 1 of 1998 starts on December 29, 1997, and ends
                     on January 4, 1998. The week year is 1998 for the last three days
                     of calendar year 1997. If, however, {@code getFirstDayOfWeek()} is
                     {@code SUNDAY}, then week 1 of 1998 starts on January 4, 1998, and
                     ends on January 10, 1998; the first three days of 1998 then are
                     part of week 53 of 1997 and their week year is 1997.
                    
                     &lt;h4&gt;Week Of Month&lt;/h4&gt;
                    
                     &lt;p&gt;Values calculated for the &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; field range from 0
                     to 6.  Week 1 of a month (the days with &lt;code&gt;WEEK_OF_MONTH =
                     1&lt;/code&gt;) is the earliest set of at least
                     &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; contiguous days in that month,
                     ending on the day before &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;.  Unlike
                     week 1 of a year, week 1 of a month may be shorter than 7 days, need
                     not start on &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;, and will not include days of
                     the previous month.  Days of a month before week 1 have a
                     &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; of 0.
                    
                     &lt;p&gt;For example, if &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; is &lt;code&gt;SUNDAY&lt;/code&gt;
                     and &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; is 4, then the first week of
                     January 1998 is Sunday, January 4 through Saturday, January 10.  These days
                     have a &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; of 1.  Thursday, January 1 through
                     Saturday, January 3 have a &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; of 0.  If
                     &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; is changed to 3, then January 1
                     through January 3 have a &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; of 1.
                    
                     &lt;h4&gt;Default Fields Values&lt;/h4&gt;
                    
                     &lt;p&gt;The &lt;code&gt;clear&lt;/code&gt; method sets calendar field(s)
                     undefined. &lt;code&gt;GregorianCalendar&lt;/code&gt; uses the following
                     default value for each calendar field if its value is undefined.
                    
                     &lt;table class="striped" style="text-align: left; width: 66%;"&gt;
                     &lt;caption style="display:none"&gt;GregorianCalendar default field values&lt;/caption&gt;
                       &lt;thead&gt;
                         &lt;tr&gt;
                           &lt;th scope="col"&gt;
                              Field
                           &lt;/th&gt;
                           &lt;th scope="col"&gt;
                                Default Value
                           &lt;/th&gt;
                         &lt;/tr&gt;
                       &lt;/thead&gt;
                       &lt;tbody&gt;
                         &lt;tr&gt;
                           &lt;th scope="row"&gt;
                                  &lt;code&gt;ERA&lt;/code&gt;
                           &lt;/th&gt;
                           &lt;td&gt;
                                  &lt;code&gt;AD&lt;/code&gt;
                           &lt;/td&gt;
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;th scope="row"&gt;
                                  &lt;code&gt;YEAR&lt;/code&gt;
                           &lt;/th&gt;
                           &lt;td&gt;
                                  &lt;code&gt;1970&lt;/code&gt;
                           &lt;/td&gt;
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;th scope="row"&gt;
                                  &lt;code&gt;MONTH&lt;/code&gt;
                           &lt;/th&gt;
                           &lt;td&gt;
                                  &lt;code&gt;JANUARY&lt;/code&gt;
                           &lt;/td&gt;
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;th scope="row"&gt;
                                  &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;
                           &lt;/th&gt;
                           &lt;td&gt;
                                  &lt;code&gt;1&lt;/code&gt;
                           &lt;/td&gt;
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;th scope="row"&gt;
                                  &lt;code&gt;DAY_OF_WEEK&lt;/code&gt;
                           &lt;/th&gt;
                           &lt;td&gt;
                                  &lt;code&gt;the first day of week&lt;/code&gt;
                           &lt;/td&gt;
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;th scope="row"&gt;
                                  &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt;
                           &lt;/th&gt;
                           &lt;td&gt;
                                  &lt;code&gt;0&lt;/code&gt;
                           &lt;/td&gt;
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;th scope="row"&gt;
                                  &lt;code&gt;DAY_OF_WEEK_IN_MONTH&lt;/code&gt;
                           &lt;/th&gt;
                           &lt;td&gt;
                                  &lt;code&gt;1&lt;/code&gt;
                           &lt;/td&gt;
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;th scope="row"&gt;
                                  &lt;code&gt;AM_PM&lt;/code&gt;
                           &lt;/th&gt;
                           &lt;td&gt;
                                  &lt;code&gt;AM&lt;/code&gt;
                           &lt;/td&gt;
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;th scope="row"&gt;
                                  &lt;code&gt;HOUR, HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND&lt;/code&gt;
                           &lt;/th&gt;
                           &lt;td&gt;
                                  &lt;code&gt;0&lt;/code&gt;
                           &lt;/td&gt;
                         &lt;/tr&gt;
                       &lt;/tbody&gt;
                     &lt;/table&gt;
                     &lt;br&gt;Default values are not applicable for the fields not listed above.
                    
                     &lt;p&gt;
                     &lt;strong&gt;Example:&lt;/strong&gt;
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     // get the supported ids for GMT-08:00 (Pacific Standard Time)
                     String[] ids = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);
                     // if no ids were returned, something is wrong. get out.
                     if (ids.length == 0)
                         System.exit(0);
                    
                      // begin output
                     System.out.println("Current Time");
                    
                     // create a Pacific Standard Time time zone
                     SimpleTimeZone pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000, ids[0]);
                    
                     // set up rules for Daylight Saving Time
                     pdt.setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
                     pdt.setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
                    
                     // create a GregorianCalendar with the Pacific Daylight time zone
                     // and the current date and time
                     Calendar calendar = new GregorianCalendar(pdt);
                     Date trialTime = new Date();
                     calendar.setTime(trialTime);
                    
                     // print out a bunch of interesting things
                     System.out.println("ERA: " + calendar.get(Calendar.ERA));
                     System.out.println("YEAR: " + calendar.get(Calendar.YEAR));
                     System.out.println("MONTH: " + calendar.get(Calendar.MONTH));
                     System.out.println("WEEK_OF_YEAR: " + calendar.get(Calendar.WEEK_OF_YEAR));
                     System.out.println("WEEK_OF_MONTH: " + calendar.get(Calendar.WEEK_OF_MONTH));
                     System.out.println("DATE: " + calendar.get(Calendar.DATE));
                     System.out.println("DAY_OF_MONTH: " + calendar.get(Calendar.DAY_OF_MONTH));
                     System.out.println("DAY_OF_YEAR: " + calendar.get(Calendar.DAY_OF_YEAR));
                     System.out.println("DAY_OF_WEEK: " + calendar.get(Calendar.DAY_OF_WEEK));
                     System.out.println("DAY_OF_WEEK_IN_MONTH: "
                                        + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
                     System.out.println("AM_PM: " + calendar.get(Calendar.AM_PM));
                     System.out.println("HOUR: " + calendar.get(Calendar.HOUR));
                     System.out.println("HOUR_OF_DAY: " + calendar.get(Calendar.HOUR_OF_DAY));
                     System.out.println("MINUTE: " + calendar.get(Calendar.MINUTE));
                     System.out.println("SECOND: " + calendar.get(Calendar.SECOND));
                     System.out.println("MILLISECOND: " + calendar.get(Calendar.MILLISECOND));
                     System.out.println("ZONE_OFFSET: "
                                        + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000)));
                     System.out.println("DST_OFFSET: "
                                        + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000)));
                    
                     System.out.println("Current Time, with hour reset to 3");
                     calendar.clear(Calendar.HOUR_OF_DAY); // so doesn't override
                     calendar.set(Calendar.HOUR, 3);
                     System.out.println("ERA: " + calendar.get(Calendar.ERA));
                     System.out.println("YEAR: " + calendar.get(Calendar.YEAR));
                     System.out.println("MONTH: " + calendar.get(Calendar.MONTH));
                     System.out.println("WEEK_OF_YEAR: " + calendar.get(Calendar.WEEK_OF_YEAR));
                     System.out.println("WEEK_OF_MONTH: " + calendar.get(Calendar.WEEK_OF_MONTH));
                     System.out.println("DATE: " + calendar.get(Calendar.DATE));
                     System.out.println("DAY_OF_MONTH: " + calendar.get(Calendar.DAY_OF_MONTH));
                     System.out.println("DAY_OF_YEAR: " + calendar.get(Calendar.DAY_OF_YEAR));
                     System.out.println("DAY_OF_WEEK: " + calendar.get(Calendar.DAY_OF_WEEK));
                     System.out.println("DAY_OF_WEEK_IN_MONTH: "
                                        + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
                     System.out.println("AM_PM: " + calendar.get(Calendar.AM_PM));
                     System.out.println("HOUR: " + calendar.get(Calendar.HOUR));
                     System.out.println("HOUR_OF_DAY: " + calendar.get(Calendar.HOUR_OF_DAY));
                     System.out.println("MINUTE: " + calendar.get(Calendar.MINUTE));
                     System.out.println("SECOND: " + calendar.get(Calendar.SECOND));
                     System.out.println("MILLISECOND: " + calendar.get(Calendar.MILLISECOND));
                     System.out.println("ZONE_OFFSET: "
                            + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); // in hours
                     System.out.println("DST_OFFSET: "
                            + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); // in hours
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     @see          TimeZone
                     @author David Goldsmith, Mark Davis, Chen-Lieh Huang, Alan Liu
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="RandomAccess" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes/>
                <javadoc xml:space="preserve">
                     Marker interface used by {@code List} implementations to indicate that
                     they support fast (generally constant time) random access.  The primary
                     purpose of this interface is to allow generic algorithms to alter their
                     behavior to provide good performance when applied to either random or
                     sequential access lists.
                    
                     &lt;p&gt;The best algorithms for manipulating random access lists (such as
                     {@code ArrayList}) can produce quadratic behavior when applied to
                     sequential access lists (such as {@code LinkedList}).  Generic list
                     algorithms are encouraged to check whether the given list is an
                     {@code instanceof} this interface before applying an algorithm that would
                     provide poor performance if it were applied to a sequential access list,
                     and to alter their behavior if necessary to guarantee acceptable
                     performance.
                    
                     &lt;p&gt;It is recognized that the distinction between random and sequential
                     access is often fuzzy.  For example, some {@code List} implementations
                     provide asymptotically linear access times if they get huge, but constant
                     access times in practice.  Such a {@code List} implementation
                     should generally implement this interface.  As a rule of thumb, a
                     {@code List} implementation should implement this interface if,
                     for typical instances of the class, this loop:
                     &lt;pre&gt;
                         for (int i=0, n=list.size(); i &amp;lt; n; i++)
                             list.get(i);
                     &lt;/pre&gt;
                     runs faster than this loop:
                     &lt;pre&gt;
                         for (Iterator i=list.iterator(); i.hasNext(); )
                             i.next();
                     &lt;/pre&gt;
                    
                     &lt;p&gt;This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="IllformedLocaleException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown by methods in {@link Locale} and {@link Locale.Builder} to
                     indicate that an argument is not a well-formed BCP 47 tag.
                    
                     @see Locale
                     @since 1.7
                    </javadoc>
            </acts>
            <acts name="InputMismatchException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.NoSuchElementException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown by a {@code Scanner} to indicate that the token
                     retrieved does not match the pattern for the expected type, or
                     that the token is out of range for the expected type.
                    
                     @author  unascribed
                     @see     java.util.Scanner
                     @since   1.5
                    </javadoc>
            </acts>
            <acts name="IllegalFormatCodePointException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.IllegalFormatException"/>
                    <superType superType="java.lang.IllegalArgumentException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Unchecked exception thrown when a character with an invalid Unicode code
                     point as defined by {@link Character#isValidCodePoint} is passed to the
                     {@link Formatter}.
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
                     method or constructor in this class will cause a {@link
                     NullPointerException} to be thrown.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="LongSummaryStatistics" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.function.LongConsumer"/>
                    <superType superType="java.util.function.IntConsumer"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A state object for collecting statistics such as count, min, max, sum, and
                     average.
                    
                     &lt;p&gt;This class is designed to work with (though does not require)
                     {@linkplain java.util.stream streams}. For example, you can compute
                     summary statistics on a stream of longs with:
                     &lt;pre&gt; {@code
                     LongSummaryStatistics stats = longStream.collect(LongSummaryStatistics::new,
                                                                      LongSummaryStatistics::accept,
                                                                      LongSummaryStatistics::combine);
                     }&lt;/pre&gt;
                    
                     &lt;p&gt;{@code LongSummaryStatistics} can be used as a
                     {@linkplain java.util.stream.Stream#collect(Collector) reduction}
                     target for a {@linkplain java.util.stream.Stream stream}. For example:
                    
                     &lt;pre&gt; {@code
                     LongSummaryStatistics stats = people.stream()
                                                         .collect(Collectors.summarizingLong(Person::getAge));
                    }&lt;/pre&gt;
                    
                     This computes, in a single pass, the count of people, as well as the minimum,
                     maximum, sum, and average of their ages.
                    
                     @implNote This implementation is not thread safe. However, it is safe to use
                     {@link java.util.stream.Collectors#summarizingLong(java.util.function.ToLongFunction)
                     Collectors.summarizingLong()} on a parallel stream, because the parallel
                     implementation of {@link java.util.stream.Stream#collect Stream.collect()}
                     provides the necessary partitioning, isolation, and merging of results for
                     safe and efficient parallel execution.
                    
                     &lt;p&gt;This implementation does not check for overflow of the sum.
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="ServiceLoader" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Iterable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A facility to load implementations of a service.
                    
                     &lt;p&gt; A &lt;i&gt;service&lt;/i&gt; is a well-known interface or class for which zero, one,
                     or many service providers exist. A &lt;i&gt;service provider&lt;/i&gt; (or just
                     &lt;i&gt;provider&lt;/i&gt;) is a class that implements or subclasses the well-known
                     interface or class. A {@code ServiceLoader} is an object that locates and
                     loads service providers deployed in the run time environment at a time of an
                     application's choosing. Application code refers only to the service, not to
                     service providers, and is assumed to be capable of differentiating between
                     multiple service providers as well as handling the possibility that no service
                     providers are located.
                    
                     &lt;h3&gt; Obtaining a service loader &lt;/h3&gt;
                    
                     &lt;p&gt; An application obtains a service loader for a given service by invoking
                     one of the static {@code load} methods of ServiceLoader. If the application
                     is a module, then its module declaration must have a &lt;i&gt;uses&lt;/i&gt; directive
                     that specifies the service; this helps to locate providers and ensure they
                     will execute reliably. In addition, if the service is not in the application
                     module, then the module declaration must have a &lt;i&gt;requires&lt;/i&gt; directive
                     that specifies the module which exports the service.
                    
                     &lt;p&gt; A service loader can be used to locate and instantiate providers of the
                     service by means of the {@link #iterator() iterator} method. {@code ServiceLoader}
                     also defines the {@link #stream() stream} method to obtain a stream of providers
                     that can be inspected and filtered without instantiating them.
                    
                     &lt;p&gt; As an example, suppose the service is {@code com.example.CodecFactory}, an
                     interface that defines methods for producing encoders and decoders:
                    
                     &lt;pre&gt;{@code
                         package com.example;
                         public interface CodecFactory {
                             Encoder getEncoder(String encodingName);
                             Decoder getDecoder(String encodingName);
                         }
                     }&lt;/pre&gt;
                    
                     &lt;p&gt; The following code obtains a service loader for the {@code CodecFactory}
                     service, then uses its iterator (created automatically by the enhanced-for
                     loop) to yield instances of the service providers that are located:
                    
                     &lt;pre&gt;{@code
                         ServiceLoader&lt;CodecFactory&gt; loader = ServiceLoader.load(CodecFactory.class);
                         for (CodecFactory factory : loader) {
                             Encoder enc = factory.getEncoder("PNG");
                             if (enc != null)
                                 ... use enc to encode a PNG file
                                 break;
                             }
                     }&lt;/pre&gt;
                    
                     &lt;p&gt; If this code resides in a module, then in order to refer to the
                     {@code com.example.CodecFactory} interface, the module declaration would
                     require the module which exports the interface. The module declaration would
                     also specify use of {@code com.example.CodecFactory}:
                     &lt;pre&gt;{@code
                         requires com.example.codec.core;
                         uses com.example.CodecFactory;
                     }&lt;/pre&gt;
                    
                     &lt;p&gt; Sometimes an application may wish to inspect a service provider before
                     instantiating it, in order to determine if an instance of that service
                     provider would be useful. For example, a service provider for {@code
                     CodecFactory} that is capable of producing a "PNG" encoder may be annotated
                     with {@code @PNG}. The following code uses service loader's {@code stream}
                     method to yield instances of {@code Provider&lt;CodecFactory&gt;} in contrast to
                     how the iterator yields instances of {@code CodecFactory}:
                     &lt;pre&gt;{@code
                         ServiceLoader&lt;CodecFactory&gt; loader = ServiceLoader.load(CodecFactory.class);
                         Set&lt;CodecFactory&gt; pngFactories = loader
                                .stream()                                              // Note a below
                                .filter(p -&gt; p.type().isAnnotationPresent(PNG.class))  // Note b
                                .map(Provider::get)                                    // Note c
                                .collect(Collectors.toSet());
                     }&lt;/pre&gt;
                     &lt;ol type="a"&gt;
                       &lt;li&gt; A stream of {@code Provider&lt;CodecFactory&gt;} objects &lt;/li&gt;
                       &lt;li&gt; {@code p.type()} yields a {@code Class&lt;CodecFactory&gt;} &lt;/li&gt;
                       &lt;li&gt; {@code get()} yields an instance of {@code CodecFactory} &lt;/li&gt;
                     &lt;/ol&gt;
                    
                     &lt;h3&gt; Designing services &lt;/h3&gt;
                    
                     &lt;p&gt; A service is a single type, usually an interface or abstract class. A
                     concrete class can be used, but this is not recommended. The type may have
                     any accessibility. The methods of a service are highly domain-specific, so
                     this API specification cannot give concrete advice about their form or
                     function. However, there are two general guidelines:
                     &lt;ol&gt;
                       &lt;li&gt;&lt;p&gt; A service should declare as many methods as needed to allow service
                       providers to communicate their domain-specific properties and other
                       quality-of-implementation factors. An application which obtains a service
                       loader for the service may then invoke these methods on each instance of
                       a service provider, in order to choose the best provider for the
                       application. &lt;/p&gt;&lt;/li&gt;
                       &lt;li&gt;&lt;p&gt; A service should express whether its service providers are intended
                       to be direct implementations of the service or to be an indirection
                       mechanism such as a "proxy" or a "factory". Service providers tend to be
                       indirection mechanisms when domain-specific objects are relatively
                       expensive to instantiate; in this case, the service should be designed
                       so that service providers are abstractions which create the "real"
                       implementation on demand. For example, the {@code CodecFactory} service
                       expresses through its name that its service providers are factories
                       for codecs, rather than codecs themselves, because it may be expensive
                       or complicated to produce certain codecs. &lt;/p&gt;&lt;/li&gt;
                     &lt;/ol&gt;
                    
                     &lt;h3&gt; &lt;a id="developing-service-providers"&gt;Developing service providers&lt;/a&gt; &lt;/h3&gt;
                    
                     &lt;p&gt; A service provider is a single type, usually a concrete class. An
                     interface or abstract class is permitted because it may declare a static
                     provider method, discussed later. The type must be public and must not be
                     an inner class.
                    
                     &lt;p&gt; A service provider and its supporting code may be developed in a module,
                     which is then deployed on the application module path or in a modular
                     image. Alternatively, a service provider and its supporting code may be
                     packaged as a JAR file and deployed on the application class path. The
                     advantage of developing a service provider in a module is that the provider
                     can be fully encapsulated to hide all details of its implementation.
                    
                     &lt;p&gt; An application that obtains a service loader for a given service is
                     indifferent to whether providers of the service are deployed in modules or
                     packaged as JAR files. The application instantiates service providers via
                     the service loader's iterator, or via {@link Provider Provider} objects in
                     the service loader's stream, without knowledge of the service providers'
                     locations.
                    
                     &lt;h3&gt; Deploying service providers as modules &lt;/h3&gt;
                    
                     &lt;p&gt; A service provider that is developed in a module must be specified in a
                     &lt;i&gt;provides&lt;/i&gt; directive in the module declaration. The provides directive
                     specifies both the service and the service provider; this helps to locate the
                     provider when another module, with a &lt;i&gt;uses&lt;/i&gt; directive for the service,
                     obtains a service loader for the service. It is strongly recommended that the
                     module does not export the package containing the service provider. There is
                     no support for a module specifying, in a &lt;i&gt;provides&lt;/i&gt; directive, a service
                     provider in another module.
                    
                     &lt;p&gt; A service provider that is developed in a module has no control over when
                     it is instantiated, since that occurs at the behest of the application, but it
                     does have control over how it is instantiated:
                    
                     &lt;ul&gt;
                    
                       &lt;li&gt; If the service provider declares a provider method, then the service
                       loader invokes that method to obtain an instance of the service provider. A
                       provider method is a public static method named "provider" with no formal
                       parameters and a return type that is assignable to the service's interface
                       or class.
                       &lt;p&gt; In this case, the service provider itself need not be assignable to the
                       service's interface or class. &lt;/li&gt;
                    
                       &lt;li&gt; If the service provider does not declare a provider method, then the
                       service provider is instantiated directly, via its provider constructor. A
                       provider constructor is a public constructor with no formal parameters.
                       &lt;p&gt; In this case, the service provider must be assignable to the service's
                       interface or class &lt;/li&gt;
                    
                     &lt;/ul&gt;
                    
                     &lt;p&gt; A service provider that is deployed as an
                     {@linkplain java.lang.module.ModuleDescriptor#isAutomatic automatic module} on
                     the application module path must have a provider constructor. There is no
                     support for a provider method in this case.
                    
                     &lt;p&gt; As an example, suppose a module specifies the following directives:
                     &lt;pre&gt;{@code
                         provides com.example.CodecFactory with com.example.impl.StandardCodecs;
                         provides com.example.CodecFactory with com.example.impl.ExtendedCodecsFactory;
                     }&lt;/pre&gt;
                    
                     &lt;p&gt; where
                    
                     &lt;ul&gt;
                       &lt;li&gt; {@code com.example.CodecFactory} is the two-method service from
                       earlier. &lt;/li&gt;
                    
                       &lt;li&gt; {@code com.example.impl.StandardCodecs} is a public class that implements
                       {@code CodecFactory} and has a public no-args constructor. &lt;/li&gt;
                    
                       &lt;li&gt; {@code com.example.impl.ExtendedCodecsFactory} is a public class that
                       does not implement CodecFactory, but it declares a public static no-args
                       method named "provider" with a return type of {@code CodecFactory}. &lt;/li&gt;
                     &lt;/ul&gt;
                    
                     &lt;p&gt; A service loader will instantiate {@code StandardCodecs} via its
                     constructor, and will instantiate {@code ExtendedCodecsFactory} by invoking
                     its {@code provider} method. The requirement that the provider constructor or
                     provider method is public helps to document the intent that the class (that is,
                     the service provider) will be instantiated by an entity (that is, a service
                     loader) which is outside the class's package.
                    
                     &lt;h3&gt; Deploying service providers on the class path &lt;/h3&gt;
                    
                     A service provider that is packaged as a JAR file for the class path is
                     identified by placing a &lt;i&gt;provider-configuration file&lt;/i&gt; in the resource
                     directory {@code META-INF/services}. The name of the provider-configuration
                     file is the fully qualified binary name of the service. The provider-configuration
                     file contains a list of fully qualified binary names of service providers, one
                     per line.
                    
                     &lt;p&gt; For example, suppose the service provider
                     {@code com.example.impl.StandardCodecs} is packaged in a JAR file for the
                     class path. The JAR file will contain a provider-configuration file named:
                    
                     &lt;blockquote&gt;{@code
                         META-INF/services/com.example.CodecFactory
                     }&lt;/blockquote&gt;
                    
                     that contains the line:
                    
                     &lt;blockquote&gt;{@code
                         com.example.impl.StandardCodecs # Standard codecs
                     }&lt;/blockquote&gt;
                    
                     &lt;p&gt;&lt;a id="format"&gt;The provider-configuration file must be encoded in UTF-8. &lt;/a&gt;
                     Space and tab characters surrounding each service provider's name, as well as
                     blank lines, are ignored. The comment character is {@code '#'}
                     ({@code '&amp;#92;u0023'} &lt;span style="font-size:smaller;"&gt;NUMBER SIGN&lt;/span&gt;);
                     on each line all characters following the first comment character are ignored.
                     If a service provider class name is listed more than once in a
                     provider-configuration file then the duplicate is ignored. If a service
                     provider class is named in more than one configuration file then the duplicate
                     is ignored.
                    
                     &lt;p&gt; A service provider that is mentioned in a provider-configuration file may
                     be located in the same JAR file as the provider-configuration file or in a
                     different JAR file. The service provider must be visible from the class loader
                     that is initially queried to locate the provider-configuration file; this is
                     not necessarily the class loader which ultimately locates the
                     provider-configuration file.
                    
                     &lt;h3&gt; Timing of provider discovery &lt;/h3&gt;
                    
                     &lt;p&gt; Service providers are loaded and instantiated lazily, that is, on demand.
                     A service loader maintains a cache of the providers that have been loaded so
                     far. Each invocation of the {@code iterator} method returns an {@code Iterator}
                     that first yields all of the elements cached from previous iteration, in
                     instantiation order, and then lazily locates and instantiates any remaining
                     providers, adding each one to the cache in turn. Similarly, each invocation
                     of the stream method returns a {@code Stream} that first processes all
                     providers loaded by previous stream operations, in load order, and then lazily
                     locates any remaining providers. Caches are cleared via the {@link #reload
                     reload} method.
                    
                     &lt;h3&gt; &lt;a id="errors"&gt;Errors&lt;/a&gt; &lt;/h3&gt;
                    
                     &lt;p&gt; When using the service loader's {@code iterator}, the {@link
                     Iterator#hasNext() hasNext} and {@link Iterator#next() next} methods will
                     fail with {@link ServiceConfigurationError} if an error occurs locating,
                     loading or instantiating a service provider. When processing the service
                     loader's stream then {@code ServiceConfigurationError} may be thrown by any
                     method that causes a service provider to be located or loaded.
                    
                     &lt;p&gt; When loading or instantiating a service provider in a module, {@code
                     ServiceConfigurationError} can be thrown for the following reasons:
                    
                     &lt;ul&gt;
                    
                       &lt;li&gt; The service provider cannot be loaded. &lt;/li&gt;
                    
                       &lt;li&gt; The service provider does not declare a provider method, and either
                       it is not assignable to the service's interface/class or does not have a
                       provider constructor. &lt;/li&gt;
                    
                       &lt;li&gt; The service provider declares a public static no-args method named
                       "provider" with a return type that is not assignable to the service's
                       interface or class. &lt;/li&gt;
                    
                       &lt;li&gt; The service provider class file has more than one public static
                       no-args method named "{@code provider}". &lt;/li&gt;
                    
                       &lt;li&gt; The service provider declares a provider method and it fails by
                       returning {@code null} or throwing an exception. &lt;/li&gt;
                    
                       &lt;li&gt; The service provider does not declare a provider method, and its
                       provider constructor fails by throwing an exception. &lt;/li&gt;
                    
                     &lt;/ul&gt;
                    
                     &lt;p&gt; When reading a provider-configuration file, or loading or instantiating
                     a provider class named in a provider-configuration file, then {@code
                     ServiceConfigurationError} can be thrown for the following reasons:
                    
                     &lt;ul&gt;
                    
                       &lt;li&gt; The format of the provider-configuration file violates the &lt;a
                       href="ServiceLoader.html#format"&gt;format&lt;/a&gt; specified above; &lt;/li&gt;
                    
                       &lt;li&gt; An {@link IOException IOException} occurs while reading the
                       provider-configuration file; &lt;/li&gt;
                    
                       &lt;li&gt; A service provider cannot be loaded; &lt;/li&gt;
                    
                       &lt;li&gt; A service provider is not assignable to the service's interface or
                       class, or does not define a provider constructor, or cannot be
                       instantiated. &lt;/li&gt;
                    
                     &lt;/ul&gt;
                    
                     &lt;h3&gt; Security &lt;/h3&gt;
                    
                     &lt;p&gt; Service loaders always execute in the security context of the caller
                     of the iterator or stream methods and may also be restricted by the security
                     context of the caller that created the service loader.
                     Trusted system code should typically invoke the methods in this class, and
                     the methods of the iterators which they return, from within a privileged
                     security context.
                    
                     &lt;h3&gt; Concurrency &lt;/h3&gt;
                    
                     &lt;p&gt; Instances of this class are not safe for use by multiple concurrent
                     threads.
                    
                     &lt;h3&gt; Null handling &lt;/h3&gt;
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
                     method in this class will cause a {@link NullPointerException} to be thrown.
                    
                     @param  &lt;S&gt;
                             The type of the service to be loaded by this loader
                    
                     @author Mark Reinhold
                     @since 1.6
                     @revised 9
                     @spec JPMS
                    </javadoc>
            </acts>
            <acts name="Category" access="PUBLIC" declaringClass="Locale" kind="TYPE" typeKind="ENUM" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="TimeZone" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;code&gt;TimeZone&lt;/code&gt; represents a time zone offset, and also figures out daylight
                     savings.
                    
                     &lt;p&gt;
                     Typically, you get a &lt;code&gt;TimeZone&lt;/code&gt; using &lt;code&gt;getDefault&lt;/code&gt;
                     which creates a &lt;code&gt;TimeZone&lt;/code&gt; based on the time zone where the program
                     is running. For example, for a program running in Japan, &lt;code&gt;getDefault&lt;/code&gt;
                     creates a &lt;code&gt;TimeZone&lt;/code&gt; object based on Japanese Standard Time.
                    
                     &lt;p&gt;
                     You can also get a &lt;code&gt;TimeZone&lt;/code&gt; using &lt;code&gt;getTimeZone&lt;/code&gt;
                     along with a time zone ID. For instance, the time zone ID for the
                     U.S. Pacific Time zone is "America/Los_Angeles". So, you can get a
                     U.S. Pacific Time &lt;code&gt;TimeZone&lt;/code&gt; object with:
                     &lt;blockquote&gt;&lt;pre&gt;
                     TimeZone tz = TimeZone.getTimeZone("America/Los_Angeles");
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     You can use the &lt;code&gt;getAvailableIDs&lt;/code&gt; method to iterate through
                     all the supported time zone IDs. You can then choose a
                     supported ID to get a &lt;code&gt;TimeZone&lt;/code&gt;.
                     If the time zone you want is not represented by one of the
                     supported IDs, then a custom time zone ID can be specified to
                     produce a TimeZone. The syntax of a custom time zone ID is:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                     &lt;a id="CustomID"&gt;&lt;i&gt;CustomID:&lt;/i&gt;&lt;/a&gt;
                             &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt; &lt;code&gt;:&lt;/code&gt; &lt;i&gt;Minutes&lt;/i&gt;
                             &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt; &lt;i&gt;Minutes&lt;/i&gt;
                             &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt;
                     &lt;i&gt;Sign:&lt;/i&gt; one of
                             &lt;code&gt;+ -&lt;/code&gt;
                     &lt;i&gt;Hours:&lt;/i&gt;
                             &lt;i&gt;Digit&lt;/i&gt;
                             &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
                     &lt;i&gt;Minutes:&lt;/i&gt;
                             &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
                     &lt;i&gt;Digit:&lt;/i&gt; one of
                             &lt;code&gt;0 1 2 3 4 5 6 7 8 9&lt;/code&gt;
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;i&gt;Hours&lt;/i&gt; must be between 0 to 23 and &lt;i&gt;Minutes&lt;/i&gt; must be
                     between 00 to 59.  For example, "GMT+10" and "GMT+0010" mean ten
                     hours and ten minutes ahead of GMT, respectively.
                     &lt;p&gt;
                     The format is locale independent and digits must be taken from the
                     Basic Latin block of the Unicode standard. No daylight saving time
                     transition schedule can be specified with a custom time zone ID. If
                     the specified string doesn't match the syntax, &lt;code&gt;"GMT"&lt;/code&gt;
                     is used.
                     &lt;p&gt;
                     When creating a &lt;code&gt;TimeZone&lt;/code&gt;, the specified custom time
                     zone ID is normalized in the following syntax:
                     &lt;blockquote&gt;&lt;pre&gt;
                     &lt;a id="NormalizedCustomID"&gt;&lt;i&gt;NormalizedCustomID:&lt;/i&gt;&lt;/a&gt;
                             &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; &lt;code&gt;:&lt;/code&gt; &lt;i&gt;Minutes&lt;/i&gt;
                     &lt;i&gt;Sign:&lt;/i&gt; one of
                             &lt;code&gt;+ -&lt;/code&gt;
                     &lt;i&gt;TwoDigitHours:&lt;/i&gt;
                             &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
                     &lt;i&gt;Minutes:&lt;/i&gt;
                             &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
                     &lt;i&gt;Digit:&lt;/i&gt; one of
                             &lt;code&gt;0 1 2 3 4 5 6 7 8 9&lt;/code&gt;
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     For example, TimeZone.getTimeZone("GMT-8").getID() returns "GMT-08:00".
                    
                     &lt;h3&gt;Three-letter time zone IDs&lt;/h3&gt;
                    
                     For compatibility with JDK 1.1.x, some other three-letter time zone IDs
                     (such as "PST", "CTT", "AST") are also supported. However, &lt;strong&gt;their
                     use is deprecated&lt;/strong&gt; because the same abbreviation is often used
                     for multiple time zones (for example, "CST" could be U.S. "Central Standard
                     Time" and "China Standard Time"), and the Java platform can then only
                     recognize one of them.
                    
                    
                     @see          Calendar
                     @see          GregorianCalendar
                     @see          SimpleTimeZone
                     @author       Mark Davis, David Goldsmith, Chen-Lieh Huang, Alan Liu
                     @since        1.1
                    </javadoc>
            </acts>
            <acts name="SimpleImmutableEntry" access="PUBLIC" declaringClass="AbstractMap" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Map$Entry"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="SortedMap" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Map"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@link Map} that further provides a &lt;em&gt;total ordering&lt;/em&gt; on its keys.
                     The map is ordered according to the {@linkplain Comparable natural
                     ordering} of its keys, or by a {@link Comparator} typically
                     provided at sorted map creation time.  This order is reflected when
                     iterating over the sorted map's collection views (returned by the
                     {@code entrySet}, {@code keySet} and {@code values} methods).
                     Several additional operations are provided to take advantage of the
                     ordering.  (This interface is the map analogue of {@link SortedSet}.)
                    
                     &lt;p&gt;All keys inserted into a sorted map must implement the {@code Comparable}
                     interface (or be accepted by the specified comparator).  Furthermore, all
                     such keys must be &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} (or
                     {@code comparator.compare(k1, k2)}) must not throw a
                     {@code ClassCastException} for any keys {@code k1} and {@code k2} in
                     the sorted map.  Attempts to violate this restriction will cause the
                     offending method or constructor invocation to throw a
                     {@code ClassCastException}.
                    
                     &lt;p&gt;Note that the ordering maintained by a sorted map (whether or not an
                     explicit comparator is provided) must be &lt;em&gt;consistent with equals&lt;/em&gt; if
                     the sorted map is to correctly implement the {@code Map} interface.  (See
                     the {@code Comparable} interface or {@code Comparator} interface for a
                     precise definition of &lt;em&gt;consistent with equals&lt;/em&gt;.)  This is so because
                     the {@code Map} interface is defined in terms of the {@code equals}
                     operation, but a sorted map performs all key comparisons using its
                     {@code compareTo} (or {@code compare}) method, so two keys that are
                     deemed equal by this method are, from the standpoint of the sorted map,
                     equal.  The behavior of a tree map &lt;em&gt;is&lt;/em&gt; well-defined even if its
                     ordering is inconsistent with equals; it just fails to obey the general
                     contract of the {@code Map} interface.
                    
                     &lt;p&gt;All general-purpose sorted map implementation classes should provide four
                     "standard" constructors. It is not possible to enforce this recommendation
                     though as required constructors cannot be specified by interfaces. The
                     expected "standard" constructors for all sorted map implementations are:
                     &lt;ol&gt;
                       &lt;li&gt;A void (no arguments) constructor, which creates an empty sorted map
                       sorted according to the natural ordering of its keys.&lt;/li&gt;
                       &lt;li&gt;A constructor with a single argument of type {@code Comparator}, which
                       creates an empty sorted map sorted according to the specified comparator.&lt;/li&gt;
                       &lt;li&gt;A constructor with a single argument of type {@code Map}, which creates
                       a new map with the same key-value mappings as its argument, sorted
                       according to the keys' natural ordering.&lt;/li&gt;
                       &lt;li&gt;A constructor with a single argument of type {@code SortedMap}, which
                       creates a new sorted map with the same key-value mappings and the same
                       ordering as the input sorted map.&lt;/li&gt;
                     &lt;/ol&gt;
                    
                     &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: several methods return submaps with restricted key
                     ranges. Such ranges are &lt;em&gt;half-open&lt;/em&gt;, that is, they include their low
                     endpoint but not their high endpoint (where applicable).  If you need a
                     &lt;em&gt;closed range&lt;/em&gt; (which includes both endpoints), and the key type
                     allows for calculation of the successor of a given key, merely request
                     the subrange from {@code lowEndpoint} to
                     {@code successor(highEndpoint)}.  For example, suppose that {@code m}
                     is a map whose keys are strings.  The following idiom obtains a view
                     containing all of the key-value mappings in {@code m} whose keys are
                     between {@code low} and {@code high}, inclusive:&lt;pre&gt;
                       SortedMap&amp;lt;String, V&amp;gt; sub = m.subMap(low, high+"\0");&lt;/pre&gt;
                    
                     A similar technique can be used to generate an &lt;em&gt;open range&lt;/em&gt;
                     (which contains neither endpoint).  The following idiom obtains a
                     view containing all of the key-value mappings in {@code m} whose keys
                     are between {@code low} and {@code high}, exclusive:&lt;pre&gt;
                       SortedMap&amp;lt;String, V&amp;gt; sub = m.subMap(low+"\0", high);&lt;/pre&gt;
                    
                     &lt;p&gt;This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;K&gt; the type of keys maintained by this map
                     @param &lt;V&gt; the type of mapped values
                    
                     @author  Josh Bloch
                     @see Map
                     @see TreeMap
                     @see SortedSet
                     @see Comparator
                     @see Comparable
                     @see Collection
                     @see ClassCastException
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="IsoCountryCode" access="PUBLIC" declaringClass="Locale" kind="TYPE" typeKind="ENUM" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Arrays" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class contains various methods for manipulating arrays (such as
                     sorting and searching). This class also contains a static factory
                     that allows arrays to be viewed as lists.
                    
                     &lt;p&gt;The methods in this class all throw a {@code NullPointerException},
                     if the specified array reference is null, except where noted.
                    
                     &lt;p&gt;The documentation for the methods contained in this class includes
                     brief descriptions of the &lt;i&gt;implementations&lt;/i&gt;. Such descriptions should
                     be regarded as &lt;i&gt;implementation notes&lt;/i&gt;, rather than parts of the
                     &lt;i&gt;specification&lt;/i&gt;. Implementors should feel free to substitute other
                     algorithms, so long as the specification itself is adhered to. (For
                     example, the algorithm used by {@code sort(Object[])} does not have to be
                     a MergeSort, but it does have to be &lt;i&gt;stable&lt;/i&gt;.)
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @author Josh Bloch
                     @author Neal Gafter
                     @author John Rose
                     @since  1.2
                    </javadoc>
            </acts>
            <acts name="Map" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes/>
                <javadoc xml:space="preserve">
                     An object that maps keys to values.  A map cannot contain duplicate keys;
                     each key can map to at most one value.
                    
                     &lt;p&gt;This interface takes the place of the {@code Dictionary} class, which
                     was a totally abstract class rather than an interface.
                    
                     &lt;p&gt;The {@code Map} interface provides three &lt;i&gt;collection views&lt;/i&gt;, which
                     allow a map's contents to be viewed as a set of keys, collection of values,
                     or set of key-value mappings.  The &lt;i&gt;order&lt;/i&gt; of a map is defined as
                     the order in which the iterators on the map's collection views return their
                     elements.  Some map implementations, like the {@code TreeMap} class, make
                     specific guarantees as to their order; others, like the {@code HashMap}
                     class, do not.
                    
                     &lt;p&gt;Note: great care must be exercised if mutable objects are used as map
                     keys.  The behavior of a map is not specified if the value of an object is
                     changed in a manner that affects {@code equals} comparisons while the
                     object is a key in the map.  A special case of this prohibition is that it
                     is not permissible for a map to contain itself as a key.  While it is
                     permissible for a map to contain itself as a value, extreme caution is
                     advised: the {@code equals} and {@code hashCode} methods are no longer
                     well defined on such a map.
                    
                     &lt;p&gt;All general-purpose map implementation classes should provide two
                     "standard" constructors: a void (no arguments) constructor which creates an
                     empty map, and a constructor with a single argument of type {@code Map},
                     which creates a new map with the same key-value mappings as its argument.
                     In effect, the latter constructor allows the user to copy any map,
                     producing an equivalent map of the desired class.  There is no way to
                     enforce this recommendation (as interfaces cannot contain constructors) but
                     all of the general-purpose map implementations in the JDK comply.
                    
                     &lt;p&gt;The "destructive" methods contained in this interface, that is, the
                     methods that modify the map on which they operate, are specified to throw
                     {@code UnsupportedOperationException} if this map does not support the
                     operation.  If this is the case, these methods may, but are not required
                     to, throw an {@code UnsupportedOperationException} if the invocation would
                     have no effect on the map.  For example, invoking the {@link #putAll(Map)}
                     method on an unmodifiable map may, but is not required to, throw the
                     exception if the map whose mappings are to be "superimposed" is empty.
                    
                     &lt;p&gt;Some map implementations have restrictions on the keys and values they
                     may contain.  For example, some implementations prohibit null keys and
                     values, and some have restrictions on the types of their keys.  Attempting
                     to insert an ineligible key or value throws an unchecked exception,
                     typically {@code NullPointerException} or {@code ClassCastException}.
                     Attempting to query the presence of an ineligible key or value may throw an
                     exception, or it may simply return false; some implementations will exhibit
                     the former behavior and some will exhibit the latter.  More generally,
                     attempting an operation on an ineligible key or value whose completion
                     would not result in the insertion of an ineligible element into the map may
                     throw an exception or it may succeed, at the option of the implementation.
                     Such exceptions are marked as "optional" in the specification for this
                     interface.
                    
                     &lt;p&gt;Many methods in Collections Framework interfaces are defined
                     in terms of the {@link Object#equals(Object) equals} method.  For
                     example, the specification for the {@link #containsKey(Object)
                     containsKey(Object key)} method says: "returns {@code true} if and
                     only if this map contains a mapping for a key {@code k} such that
                     {@code (key==null ? k==null : key.equals(k))}." This specification should
                     &lt;i&gt;not&lt;/i&gt; be construed to imply that invoking {@code Map.containsKey}
                     with a non-null argument {@code key} will cause {@code key.equals(k)} to
                     be invoked for any key {@code k}.  Implementations are free to
                     implement optimizations whereby the {@code equals} invocation is avoided,
                     for example, by first comparing the hash codes of the two keys.  (The
                     {@link Object#hashCode()} specification guarantees that two objects with
                     unequal hash codes cannot be equal.)  More generally, implementations of
                     the various Collections Framework interfaces are free to take advantage of
                     the specified behavior of underlying {@link Object} methods wherever the
                     implementor deems it appropriate.
                    
                     &lt;p&gt;Some map operations which perform recursive traversal of the map may fail
                     with an exception for self-referential instances where the map directly or
                     indirectly contains itself. This includes the {@code clone()},
                     {@code equals()}, {@code hashCode()} and {@code toString()} methods.
                     Implementations may optionally handle the self-referential scenario, however
                     most current implementations do not do so.
                    
                     &lt;h2&gt;&lt;a id="unmodifiable"&gt;Unmodifiable Maps&lt;/a&gt;&lt;/h2&gt;
                     &lt;p&gt;The {@link Map#of() Map.of},
                     {@link Map#ofEntries(Map.Entry...) Map.ofEntries}, and
                     {@link Map#copyOf Map.copyOf}
                     static factory methods provide a convenient way to create unmodifiable maps.
                     The {@code Map}
                     instances created by these methods have the following characteristics:
                    
                     &lt;ul&gt;
                     &lt;li&gt;They are &lt;a href="Collection.html#unmodifiable"&gt;&lt;i&gt;unmodifiable&lt;/i&gt;&lt;/a&gt;. Keys and values
                     cannot be added, removed, or updated. Calling any mutator method on the Map
                     will always cause {@code UnsupportedOperationException} to be thrown.
                     However, if the contained keys or values are themselves mutable, this may cause the
                     Map to behave inconsistently or its contents to appear to change.
                     &lt;li&gt;They disallow {@code null} keys and values. Attempts to create them with
                     {@code null} keys or values result in {@code NullPointerException}.
                     &lt;li&gt;They are serializable if all keys and values are serializable.
                     &lt;li&gt;They reject duplicate keys at creation time. Duplicate keys
                     passed to a static factory method result in {@code IllegalArgumentException}.
                     &lt;li&gt;The iteration order of mappings is unspecified and is subject to change.
                     &lt;li&gt;They are &lt;a href="../lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;.
                     Callers should make no assumptions about the identity of the returned instances.
                     Factories are free to create new instances or reuse existing ones. Therefore,
                     identity-sensitive operations on these instances (reference equality ({@code ==}),
                     identity hash code, and synchronization) are unreliable and should be avoided.
                     &lt;li&gt;They are serialized as specified on the
                     &lt;a href="{@docRoot}/serialized-form.html#java.util.CollSer"&gt;Serialized Form&lt;/a&gt;
                     page.
                     &lt;/ul&gt;
                    
                     &lt;p&gt;This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;K&gt; the type of keys maintained by this map
                     @param &lt;V&gt; the type of mapped values
                    
                     @author  Josh Bloch
                     @see HashMap
                     @see TreeMap
                     @see Hashtable
                     @see SortedMap
                     @see Collection
                     @see Set
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="WeakHashMap" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Map"/>
                    <superType superType="java.util.AbstractMap"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Hash table based implementation of the {@code Map} interface, with
                     &lt;em&gt;weak keys&lt;/em&gt;.
                     An entry in a {@code WeakHashMap} will automatically be removed when
                     its key is no longer in ordinary use.  More precisely, the presence of a
                     mapping for a given key will not prevent the key from being discarded by the
                     garbage collector, that is, made finalizable, finalized, and then reclaimed.
                     When a key has been discarded its entry is effectively removed from the map,
                     so this class behaves somewhat differently from other {@code Map}
                     implementations.
                    
                     &lt;p&gt; Both null values and the null key are supported. This class has
                     performance characteristics similar to those of the {@code HashMap}
                     class, and has the same efficiency parameters of &lt;em&gt;initial capacity&lt;/em&gt;
                     and &lt;em&gt;load factor&lt;/em&gt;.
                    
                     &lt;p&gt; Like most collection classes, this class is not synchronized.
                     A synchronized {@code WeakHashMap} may be constructed using the
                     {@link Collections#synchronizedMap Collections.synchronizedMap}
                     method.
                    
                     &lt;p&gt; This class is intended primarily for use with key objects whose
                     {@code equals} methods test for object identity using the
                     {@code ==} operator.  Once such a key is discarded it can never be
                     recreated, so it is impossible to do a lookup of that key in a
                     {@code WeakHashMap} at some later time and be surprised that its entry
                     has been removed.  This class will work perfectly well with key objects
                     whose {@code equals} methods are not based upon object identity, such
                     as {@code String} instances.  With such recreatable key objects,
                     however, the automatic removal of {@code WeakHashMap} entries whose
                     keys have been discarded may prove to be confusing.
                    
                     &lt;p&gt; The behavior of the {@code WeakHashMap} class depends in part upon
                     the actions of the garbage collector, so several familiar (though not
                     required) {@code Map} invariants do not hold for this class.  Because
                     the garbage collector may discard keys at any time, a
                     {@code WeakHashMap} may behave as though an unknown thread is silently
                     removing entries.  In particular, even if you synchronize on a
                     {@code WeakHashMap} instance and invoke none of its mutator methods, it
                     is possible for the {@code size} method to return smaller values over
                     time, for the {@code isEmpty} method to return {@code false} and
                     then {@code true}, for the {@code containsKey} method to return
                     {@code true} and later {@code false} for a given key, for the
                     {@code get} method to return a value for a given key but later return
                     {@code null}, for the {@code put} method to return
                     {@code null} and the {@code remove} method to return
                     {@code false} for a key that previously appeared to be in the map, and
                     for successive examinations of the key set, the value collection, and
                     the entry set to yield successively smaller numbers of elements.
                    
                     &lt;p&gt; Each key object in a {@code WeakHashMap} is stored indirectly as
                     the referent of a weak reference.  Therefore a key will automatically be
                     removed only after the weak references to it, both inside and outside of the
                     map, have been cleared by the garbage collector.
                    
                     &lt;p&gt; &lt;strong&gt;Implementation note:&lt;/strong&gt; The value objects in a
                     {@code WeakHashMap} are held by ordinary strong references.  Thus care
                     should be taken to ensure that value objects do not strongly refer to their
                     own keys, either directly or indirectly, since that will prevent the keys
                     from being discarded.  Note that a value object may refer indirectly to its
                     key via the {@code WeakHashMap} itself; that is, a value object may
                     strongly refer to some other key object whose associated value object, in
                     turn, strongly refers to the key of the first value object.  If the values
                     in the map do not rely on the map holding strong references to them, one way
                     to deal with this is to wrap values themselves within
                     {@code WeakReferences} before
                     inserting, as in: {@code m.put(key, new WeakReference(value))},
                     and then unwrapping upon each {@code get}.
                    
                     &lt;p&gt;The iterators returned by the {@code iterator} method of the collections
                     returned by all of this class's "collection view methods" are
                     &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after the
                     iterator is created, in any way except through the iterator's own
                     {@code remove} method, the iterator will throw a {@link
                     ConcurrentModificationException}.  Thus, in the face of concurrent
                     modification, the iterator fails quickly and cleanly, rather than risking
                     arbitrary, non-deterministic behavior at an undetermined time in the future.
                    
                     &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                     as it is, generally speaking, impossible to make any hard guarantees in the
                     presence of unsynchronized concurrent modification.  Fail-fast iterators
                     throw {@code ConcurrentModificationException} on a best-effort basis.
                     Therefore, it would be wrong to write a program that depended on this
                     exception for its correctness:  &lt;i&gt;the fail-fast behavior of iterators
                     should be used only to detect bugs.&lt;/i&gt;
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;K&gt; the type of keys maintained by this map
                     @param &lt;V&gt; the type of mapped values
                    
                     @author      Doug Lea
                     @author      Josh Bloch
                     @author      Mark Reinhold
                     @since       1.2
                     @see         java.util.HashMap
                     @see         java.lang.ref.WeakReference
                    </javadoc>
            </acts>
            <acts name="Base64" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class consists exclusively of static methods for obtaining
                     encoders and decoders for the Base64 encoding scheme. The
                     implementation of this class supports the following types of Base64
                     as specified in
                     &lt;a href="http://www.ietf.org/rfc/rfc4648.txt"&gt;RFC 4648&lt;/a&gt; and
                     &lt;a href="http://www.ietf.org/rfc/rfc2045.txt"&gt;RFC 2045&lt;/a&gt;.
                    
                     &lt;ul&gt;
                     &lt;li&gt;&lt;a id="basic"&gt;&lt;b&gt;Basic&lt;/b&gt;&lt;/a&gt;
                     &lt;p&gt; Uses "The Base64 Alphabet" as specified in Table 1 of
                         RFC 4648 and RFC 2045 for encoding and decoding operation.
                         The encoder does not add any line feed (line separator)
                         character. The decoder rejects data that contains characters
                         outside the base64 alphabet.&lt;/p&gt;&lt;/li&gt;
                    
                     &lt;li&gt;&lt;a id="url"&gt;&lt;b&gt;URL and Filename safe&lt;/b&gt;&lt;/a&gt;
                     &lt;p&gt; Uses the "URL and Filename safe Base64 Alphabet" as specified
                         in Table 2 of RFC 4648 for encoding and decoding. The
                         encoder does not add any line feed (line separator) character.
                         The decoder rejects data that contains characters outside the
                         base64 alphabet.&lt;/p&gt;&lt;/li&gt;
                    
                     &lt;li&gt;&lt;a id="mime"&gt;&lt;b&gt;MIME&lt;/b&gt;&lt;/a&gt;
                     &lt;p&gt; Uses "The Base64 Alphabet" as specified in Table 1 of
                         RFC 2045 for encoding and decoding operation. The encoded output
                         must be represented in lines of no more than 76 characters each
                         and uses a carriage return {@code '\r'} followed immediately by
                         a linefeed {@code '\n'} as the line separator. No line separator
                         is added to the end of the encoded output. All line separators
                         or other characters not found in the base64 alphabet table are
                         ignored in decoding operation.&lt;/p&gt;&lt;/li&gt;
                     &lt;/ul&gt;
                    
                     &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a
                     method of this class will cause a {@link java.lang.NullPointerException
                     NullPointerException} to be thrown.
                    
                     @author  Xueming Shen
                     @since   1.8
                    </javadoc>
            </acts>
            <acts name="Set" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Collection"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A collection that contains no duplicate elements.  More formally, sets
                     contain no pair of elements {@code e1} and {@code e2} such that
                     {@code e1.equals(e2)}, and at most one null element.  As implied by
                     its name, this interface models the mathematical &lt;i&gt;set&lt;/i&gt; abstraction.
                    
                     &lt;p&gt;The {@code Set} interface places additional stipulations, beyond those
                     inherited from the {@code Collection} interface, on the contracts of all
                     constructors and on the contracts of the {@code add}, {@code equals} and
                     {@code hashCode} methods.  Declarations for other inherited methods are
                     also included here for convenience.  (The specifications accompanying these
                     declarations have been tailored to the {@code Set} interface, but they do
                     not contain any additional stipulations.)
                    
                     &lt;p&gt;The additional stipulation on constructors is, not surprisingly,
                     that all constructors must create a set that contains no duplicate elements
                     (as defined above).
                    
                     &lt;p&gt;Note: Great care must be exercised if mutable objects are used as set
                     elements.  The behavior of a set is not specified if the value of an object
                     is changed in a manner that affects {@code equals} comparisons while the
                     object is an element in the set.  A special case of this prohibition is
                     that it is not permissible for a set to contain itself as an element.
                    
                     &lt;p&gt;Some set implementations have restrictions on the elements that
                     they may contain.  For example, some implementations prohibit null elements,
                     and some have restrictions on the types of their elements.  Attempting to
                     add an ineligible element throws an unchecked exception, typically
                     {@code NullPointerException} or {@code ClassCastException}.  Attempting
                     to query the presence of an ineligible element may throw an exception,
                     or it may simply return false; some implementations will exhibit the former
                     behavior and some will exhibit the latter.  More generally, attempting an
                     operation on an ineligible element whose completion would not result in
                     the insertion of an ineligible element into the set may throw an
                     exception or it may succeed, at the option of the implementation.
                     Such exceptions are marked as "optional" in the specification for this
                     interface.
                    
                     &lt;h2&gt;&lt;a id="unmodifiable"&gt;Unmodifiable Sets&lt;/a&gt;&lt;/h2&gt;
                     &lt;p&gt;The {@link Set#of(Object...) Set.of} and
                     {@link Set#copyOf Set.copyOf} static factory methods
                     provide a convenient way to create unmodifiable sets. The {@code Set}
                     instances created by these methods have the following characteristics:
                    
                     &lt;ul&gt;
                     &lt;li&gt;They are &lt;a href="Collection.html#unmodifiable"&gt;&lt;i&gt;unmodifiable&lt;/i&gt;&lt;/a&gt;. Elements cannot
                     be added or removed. Calling any mutator method on the Set
                     will always cause {@code UnsupportedOperationException} to be thrown.
                     However, if the contained elements are themselves mutable, this may cause the
                     Set to behave inconsistently or its contents to appear to change.
                     &lt;li&gt;They disallow {@code null} elements. Attempts to create them with
                     {@code null} elements result in {@code NullPointerException}.
                     &lt;li&gt;They are serializable if all elements are serializable.
                     &lt;li&gt;They reject duplicate elements at creation time. Duplicate elements
                     passed to a static factory method result in {@code IllegalArgumentException}.
                     &lt;li&gt;The iteration order of set elements is unspecified and is subject to change.
                     &lt;li&gt;They are &lt;a href="../lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;.
                     Callers should make no assumptions about the identity of the returned instances.
                     Factories are free to create new instances or reuse existing ones. Therefore,
                     identity-sensitive operations on these instances (reference equality ({@code ==}),
                     identity hash code, and synchronization) are unreliable and should be avoided.
                     &lt;li&gt;They are serialized as specified on the
                     &lt;a href="{@docRoot}/serialized-form.html#java.util.CollSer"&gt;Serialized Form&lt;/a&gt;
                     page.
                     &lt;/ul&gt;
                    
                     &lt;p&gt;This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;E&gt; the type of elements maintained by this set
                    
                     @author  Josh Bloch
                     @author  Neal Gafter
                     @see Collection
                     @see List
                     @see SortedSet
                     @see HashSet
                     @see TreeSet
                     @see AbstractSet
                     @see Collections#singleton(java.lang.Object)
                     @see Collections#EMPTY_SET
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="PropertyPermission" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.security.BasicPermission"/>
                    <superType superType="java.security.Permission"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class is for property permissions.
                    
                     &lt;P&gt;
                     The name is the name of the property ("java.home",
                     "os.name", etc). The naming
                     convention follows the  hierarchical property naming convention.
                     Also, an asterisk
                     may appear at the end of the name, following a ".", or by itself, to
                     signify a wildcard match. For example: "java.*" and "*" signify a wildcard
                     match, while "*java" and "a*b" do not.
                     &lt;P&gt;
                     The actions to be granted are passed to the constructor in a string containing
                     a list of one or more comma-separated keywords. The possible keywords are
                     "read" and "write". Their meaning is defined as follows:
                    
                     &lt;DL&gt;
                        &lt;DT&gt; read
                        &lt;DD&gt; read permission. Allows &lt;code&gt;System.getProperty&lt;/code&gt; to
                             be called.
                        &lt;DT&gt; write
                        &lt;DD&gt; write permission. Allows &lt;code&gt;System.setProperty&lt;/code&gt; to
                             be called.
                     &lt;/DL&gt;
                     &lt;P&gt;
                     The actions string is converted to lowercase before processing.
                     &lt;P&gt;
                     Care should be taken before granting code permission to access
                     certain system properties.  For example, granting permission to
                     access the "java.home" system property gives potentially malevolent
                     code sensitive information about the system environment (the Java
                     installation directory).  Also, granting permission to access
                     the "user.name" and "user.home" system properties gives potentially
                     malevolent code sensitive information about the user environment
                     (the user's account name and home directory).
                    
                     @see java.security.BasicPermission
                     @see java.security.Permission
                     @see java.security.Permissions
                     @see java.security.PermissionCollection
                     @see java.lang.SecurityManager
                    
                    
                     @author Roland Schemers
                     @since 1.2
                    
                     @serial exclude
                    </javadoc>
            </acts>
            <acts name="FormatterClosedException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.IllegalStateException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Unchecked exception thrown when the formatter has been closed.
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
                     method or constructor in this class will cause a {@link
                     NullPointerException} to be thrown.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="AbstractCollection" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Collection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class provides a skeletal implementation of the {@code Collection}
                     interface, to minimize the effort required to implement this interface. &lt;p&gt;
                    
                     To implement an unmodifiable collection, the programmer needs only to
                     extend this class and provide implementations for the {@code iterator} and
                     {@code size} methods.  (The iterator returned by the {@code iterator}
                     method must implement {@code hasNext} and {@code next}.)&lt;p&gt;
                    
                     To implement a modifiable collection, the programmer must additionally
                     override this class's {@code add} method (which otherwise throws an
                     {@code UnsupportedOperationException}), and the iterator returned by the
                     {@code iterator} method must additionally implement its {@code remove}
                     method.&lt;p&gt;
                    
                     The programmer should generally provide a void (no argument) and
                     {@code Collection} constructor, as per the recommendation in the
                     {@code Collection} interface specification.&lt;p&gt;
                    
                     The documentation for each non-abstract method in this class describes its
                     implementation in detail.  Each of these methods may be overridden if
                     the collection being implemented admits a more efficient implementation.&lt;p&gt;
                    
                     This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @author  Josh Bloch
                     @author  Neal Gafter
                     @see Collection
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="IntSummaryStatistics" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.function.IntConsumer"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A state object for collecting statistics such as count, min, max, sum, and
                     average.
                    
                     &lt;p&gt;This class is designed to work with (though does not require)
                     {@linkplain java.util.stream streams}. For example, you can compute
                     summary statistics on a stream of ints with:
                     &lt;pre&gt; {@code
                     IntSummaryStatistics stats = intStream.collect(IntSummaryStatistics::new,
                                                                    IntSummaryStatistics::accept,
                                                                    IntSummaryStatistics::combine);
                     }&lt;/pre&gt;
                    
                     &lt;p&gt;{@code IntSummaryStatistics} can be used as a
                     {@linkplain java.util.stream.Stream#collect(Collector) reduction}
                     target for a {@linkplain java.util.stream.Stream stream}. For example:
                    
                     &lt;pre&gt; {@code
                     IntSummaryStatistics stats = people.stream()
                                                        .collect(Collectors.summarizingInt(Person::getDependents));
                    }&lt;/pre&gt;
                    
                     This computes, in a single pass, the count of people, as well as the minimum,
                     maximum, sum, and average of their number of dependents.
                    
                     @implNote This implementation is not thread safe. However, it is safe to use
                     {@link java.util.stream.Collectors#summarizingInt(java.util.function.ToIntFunction)
                     Collectors.summarizingInt()} on a parallel stream, because the parallel
                     implementation of {@link java.util.stream.Stream#collect Stream.collect()}
                     provides the necessary partitioning, isolation, and merging of results for
                     safe and efficient parallel execution.
                    
                     &lt;p&gt;This implementation does not check for overflow of the sum.
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="SortedSet" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Set"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@link Set} that further provides a &lt;i&gt;total ordering&lt;/i&gt; on its elements.
                     The elements are ordered using their {@linkplain Comparable natural
                     ordering}, or by a {@link Comparator} typically provided at sorted
                     set creation time.  The set's iterator will traverse the set in
                     ascending element order. Several additional operations are provided
                     to take advantage of the ordering.  (This interface is the set
                     analogue of {@link SortedMap}.)
                    
                     &lt;p&gt;All elements inserted into a sorted set must implement the {@code Comparable}
                     interface (or be accepted by the specified comparator).  Furthermore, all
                     such elements must be &lt;i&gt;mutually comparable&lt;/i&gt;: {@code e1.compareTo(e2)}
                     (or {@code comparator.compare(e1, e2)}) must not throw a
                     {@code ClassCastException} for any elements {@code e1} and {@code e2} in
                     the sorted set.  Attempts to violate this restriction will cause the
                     offending method or constructor invocation to throw a
                     {@code ClassCastException}.
                    
                     &lt;p&gt;Note that the ordering maintained by a sorted set (whether or not an
                     explicit comparator is provided) must be &lt;i&gt;consistent with equals&lt;/i&gt; if
                     the sorted set is to correctly implement the {@code Set} interface.  (See
                     the {@code Comparable} interface or {@code Comparator} interface for a
                     precise definition of &lt;i&gt;consistent with equals&lt;/i&gt;.)  This is so because
                     the {@code Set} interface is defined in terms of the {@code equals}
                     operation, but a sorted set performs all element comparisons using its
                     {@code compareTo} (or {@code compare}) method, so two elements that are
                     deemed equal by this method are, from the standpoint of the sorted set,
                     equal.  The behavior of a sorted set &lt;i&gt;is&lt;/i&gt; well-defined even if its
                     ordering is inconsistent with equals; it just fails to obey the general
                     contract of the {@code Set} interface.
                    
                     &lt;p&gt;All general-purpose sorted set implementation classes should
                     provide four "standard" constructors: 1) A void (no arguments)
                     constructor, which creates an empty sorted set sorted according to
                     the natural ordering of its elements.  2) A constructor with a
                     single argument of type {@code Comparator}, which creates an empty
                     sorted set sorted according to the specified comparator.  3) A
                     constructor with a single argument of type {@code Collection},
                     which creates a new sorted set with the same elements as its
                     argument, sorted according to the natural ordering of the elements.
                     4) A constructor with a single argument of type {@code SortedSet},
                     which creates a new sorted set with the same elements and the same
                     ordering as the input sorted set.  There is no way to enforce this
                     recommendation, as interfaces cannot contain constructors.
                    
                     &lt;p&gt;Note: several methods return subsets with restricted ranges.
                     Such ranges are &lt;i&gt;half-open&lt;/i&gt;, that is, they include their low
                     endpoint but not their high endpoint (where applicable).
                     If you need a &lt;i&gt;closed range&lt;/i&gt; (which includes both endpoints), and
                     the element type allows for calculation of the successor of a given
                     value, merely request the subrange from {@code lowEndpoint} to
                     {@code successor(highEndpoint)}.  For example, suppose that {@code s}
                     is a sorted set of strings.  The following idiom obtains a view
                     containing all of the strings in {@code s} from {@code low} to
                     {@code high}, inclusive:&lt;pre&gt;
                       SortedSet&amp;lt;String&amp;gt; sub = s.subSet(low, high+"\0");&lt;/pre&gt;
                    
                     A similar technique can be used to generate an &lt;i&gt;open range&lt;/i&gt; (which
                     contains neither endpoint).  The following idiom obtains a view
                     containing all of the Strings in {@code s} from {@code low} to
                     {@code high}, exclusive:&lt;pre&gt;
                       SortedSet&amp;lt;String&amp;gt; sub = s.subSet(low+"\0", high);&lt;/pre&gt;
                    
                     &lt;p&gt;This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;E&gt; the type of elements maintained by this set
                    
                     @author  Josh Bloch
                     @see Set
                     @see TreeSet
                     @see SortedMap
                     @see Collection
                     @see Comparable
                     @see Comparator
                     @see ClassCastException
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="TooManyListenersException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;p&gt;
                     The &lt;code&gt; TooManyListenersException &lt;/code&gt; Exception is used as part of
                     the Java Event model to annotate and implement a unicast special case of
                     a multicast Event Source.
                     &lt;/p&gt;
                     &lt;p&gt;
                     The presence of a "throws TooManyListenersException" clause on any given
                     concrete implementation of the normally multicast "void addXyzEventListener"
                     event listener registration pattern is used to annotate that interface as
                     implementing a unicast Listener special case, that is, that one and only
                     one Listener may be registered on the particular event listener source
                     concurrently.
                     &lt;/p&gt;
                    
                     @see java.util.EventObject
                     @see java.util.EventListener
                    
                     @author Laurence P. G. Cable
                     @since  1.1
                    </javadoc>
            </acts>
            <acts name="UnknownFormatConversionException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.IllegalFormatException"/>
                    <superType superType="java.lang.IllegalArgumentException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Unchecked exception thrown when an unknown conversion is given.
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to
                     any method or constructor in this class will cause a {@link
                     NullPointerException} to be thrown.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="AbstractQueue" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Queue"/>
                    <superType superType="java.util.AbstractCollection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class provides skeletal implementations of some {@link Queue}
                     operations. The implementations in this class are appropriate when
                     the base implementation does &lt;em&gt;not&lt;/em&gt; allow {@code null}
                     elements.  Methods {@link #add add}, {@link #remove remove}, and
                     {@link #element element} are based on {@link #offer offer}, {@link
                     #poll poll}, and {@link #peek peek}, respectively, but throw
                     exceptions instead of indicating failure via {@code false} or
                     {@code null} returns.
                    
                     &lt;p&gt;A {@code Queue} implementation that extends this class must
                     minimally define a method {@link Queue#offer} which does not permit
                     insertion of {@code null} elements, along with methods {@link
                     Queue#peek}, {@link Queue#poll}, {@link Collection#size}, and
                     {@link Collection#iterator}.  Typically, additional methods will be
                     overridden as well.  If these requirements cannot be met, consider
                     instead subclassing {@link AbstractCollection}.
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @since 1.5
                     @author Doug Lea
                     @param &lt;E&gt; the type of elements held in this queue
                    </javadoc>
            </acts>
            <acts name="SimpleTimeZone" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.TimeZone"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;code&gt;SimpleTimeZone&lt;/code&gt; is a concrete subclass of &lt;code&gt;TimeZone&lt;/code&gt;
                     that represents a time zone for use with a Gregorian calendar.
                     The class holds an offset from GMT, called &lt;em&gt;raw offset&lt;/em&gt;, and start
                     and end rules for a daylight saving time schedule.  Since it only holds
                     single values for each, it cannot handle historical changes in the offset
                     from GMT and the daylight saving schedule, except that the {@link
                     #setStartYear setStartYear} method can specify the year when the daylight
                     saving time schedule starts in effect.
                     &lt;p&gt;
                     To construct a &lt;code&gt;SimpleTimeZone&lt;/code&gt; with a daylight saving time
                     schedule, the schedule can be described with a set of rules,
                     &lt;em&gt;start-rule&lt;/em&gt; and &lt;em&gt;end-rule&lt;/em&gt;. A day when daylight saving time
                     starts or ends is specified by a combination of &lt;em&gt;month&lt;/em&gt;,
                     &lt;em&gt;day-of-month&lt;/em&gt;, and &lt;em&gt;day-of-week&lt;/em&gt; values. The &lt;em&gt;month&lt;/em&gt;
                     value is represented by a Calendar {@link Calendar#MONTH MONTH} field
                     value, such as {@link Calendar#MARCH}. The &lt;em&gt;day-of-week&lt;/em&gt; value is
                     represented by a Calendar {@link Calendar#DAY_OF_WEEK DAY_OF_WEEK} value,
                     such as {@link Calendar#SUNDAY SUNDAY}. The meanings of value combinations
                     are as follows.
                    
                     &lt;ul&gt;
                     &lt;li&gt;&lt;b&gt;Exact day of month&lt;/b&gt;&lt;br&gt;
                     To specify an exact day of month, set the &lt;em&gt;month&lt;/em&gt; and
                     &lt;em&gt;day-of-month&lt;/em&gt; to an exact value, and &lt;em&gt;day-of-week&lt;/em&gt; to zero. For
                     example, to specify March 1, set the &lt;em&gt;month&lt;/em&gt; to {@link Calendar#MARCH
                     MARCH}, &lt;em&gt;day-of-month&lt;/em&gt; to 1, and &lt;em&gt;day-of-week&lt;/em&gt; to 0.&lt;/li&gt;
                    
                     &lt;li&gt;&lt;b&gt;Day of week on or after day of month&lt;/b&gt;&lt;br&gt;
                     To specify a day of week on or after an exact day of month, set the
                     &lt;em&gt;month&lt;/em&gt; to an exact month value, &lt;em&gt;day-of-month&lt;/em&gt; to the day on
                     or after which the rule is applied, and &lt;em&gt;day-of-week&lt;/em&gt; to a negative {@link
                     Calendar#DAY_OF_WEEK DAY_OF_WEEK} field value. For example, to specify the
                     second Sunday of April, set &lt;em&gt;month&lt;/em&gt; to {@link Calendar#APRIL APRIL},
                     &lt;em&gt;day-of-month&lt;/em&gt; to 8, and &lt;em&gt;day-of-week&lt;/em&gt; to &lt;code&gt;-&lt;/code&gt;{@link
                     Calendar#SUNDAY SUNDAY}.&lt;/li&gt;
                    
                     &lt;li&gt;&lt;b&gt;Day of week on or before day of month&lt;/b&gt;&lt;br&gt;
                     To specify a day of the week on or before an exact day of the month, set
                     &lt;em&gt;day-of-month&lt;/em&gt; and &lt;em&gt;day-of-week&lt;/em&gt; to a negative value. For
                     example, to specify the last Wednesday on or before the 21st of March, set
                     &lt;em&gt;month&lt;/em&gt; to {@link Calendar#MARCH MARCH}, &lt;em&gt;day-of-month&lt;/em&gt; is -21
                     and &lt;em&gt;day-of-week&lt;/em&gt; is &lt;code&gt;-&lt;/code&gt;{@link Calendar#WEDNESDAY WEDNESDAY}. &lt;/li&gt;
                    
                     &lt;li&gt;&lt;b&gt;Last day-of-week of month&lt;/b&gt;&lt;br&gt;
                     To specify, the last day-of-week of the month, set &lt;em&gt;day-of-week&lt;/em&gt; to a
                     {@link Calendar#DAY_OF_WEEK DAY_OF_WEEK} value and &lt;em&gt;day-of-month&lt;/em&gt; to
                     -1. For example, to specify the last Sunday of October, set &lt;em&gt;month&lt;/em&gt;
                     to {@link Calendar#OCTOBER OCTOBER}, &lt;em&gt;day-of-week&lt;/em&gt; to {@link
                     Calendar#SUNDAY SUNDAY} and &lt;em&gt;day-of-month&lt;/em&gt; to -1.  &lt;/li&gt;
                    
                     &lt;/ul&gt;
                     The time of the day at which daylight saving time starts or ends is
                     specified by a millisecond value within the day. There are three kinds of
                     &lt;em&gt;mode&lt;/em&gt;s to specify the time: {@link #WALL_TIME}, {@link
                     #STANDARD_TIME} and {@link #UTC_TIME}. For example, if daylight
                     saving time ends
                     at 2:00 am in the wall clock time, it can be specified by 7200000
                     milliseconds in the {@link #WALL_TIME} mode. In this case, the wall clock time
                     for an &lt;em&gt;end-rule&lt;/em&gt; means the same thing as the daylight time.
                     &lt;p&gt;
                     The following are examples of parameters for constructing time zone objects.
                     &lt;pre&gt;&lt;code&gt;
                          // Base GMT offset: -8:00
                          // DST starts:      at 2:00am in standard time
                          //                  on the first Sunday in April
                          // DST ends:        at 2:00am in daylight time
                          //                  on the last Sunday in October
                          // Save:            1 hour
                          SimpleTimeZone(-28800000,
                                         "America/Los_Angeles",
                                         Calendar.APRIL, 1, -Calendar.SUNDAY,
                                         7200000,
                                         Calendar.OCTOBER, -1, Calendar.SUNDAY,
                                         7200000,
                                         3600000)
                    
                          // Base GMT offset: +1:00
                          // DST starts:      at 1:00am in UTC time
                          //                  on the last Sunday in March
                          // DST ends:        at 1:00am in UTC time
                          //                  on the last Sunday in October
                          // Save:            1 hour
                          SimpleTimeZone(3600000,
                                         "Europe/Paris",
                                         Calendar.MARCH, -1, Calendar.SUNDAY,
                                         3600000, SimpleTimeZone.UTC_TIME,
                                         Calendar.OCTOBER, -1, Calendar.SUNDAY,
                                         3600000, SimpleTimeZone.UTC_TIME,
                                         3600000)
                     &lt;/code&gt;&lt;/pre&gt;
                     These parameter rules are also applicable to the set rule methods, such as
                     &lt;code&gt;setStartRule&lt;/code&gt;.
                    
                     @since 1.1
                     @see      Calendar
                     @see      GregorianCalendar
                     @see      TimeZone
                     @author   David Goldsmith, Mark Davis, Chen-Lieh Huang, Alan Liu
                    </javadoc>
            </acts>
            <acts name="ListResourceBundle" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.ResourceBundle"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;code&gt;ListResourceBundle&lt;/code&gt; is an abstract subclass of
                     &lt;code&gt;ResourceBundle&lt;/code&gt; that manages resources for a locale
                     in a convenient and easy to use list. See &lt;code&gt;ResourceBundle&lt;/code&gt; for
                     more information about resource bundles in general.
                    
                     &lt;P&gt;
                     Subclasses must override &lt;code&gt;getContents&lt;/code&gt; and provide an array,
                     where each item in the array is a pair of objects.
                     The first element of each pair is the key, which must be a
                     &lt;code&gt;String&lt;/code&gt;, and the second element is the value associated with
                     that key.
                    
                     &lt;p&gt;
                     The following &lt;a id="sample"&gt;example&lt;/a&gt; shows two members of a resource
                     bundle family with the base name "MyResources".
                     "MyResources" is the default member of the bundle family, and
                     "MyResources_fr" is the French member.
                     These members are based on &lt;code&gt;ListResourceBundle&lt;/code&gt;
                     (a related &lt;a href="PropertyResourceBundle.html#sample"&gt;example&lt;/a&gt; shows
                     how you can add a bundle to this family that's based on a properties file).
                     The keys in this example are of the form "s1" etc. The actual
                     keys are entirely up to your choice, so long as they are the same as
                     the keys you use in your program to retrieve the objects from the bundle.
                     Keys are case-sensitive.
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                    
                     public class MyResources extends ListResourceBundle {
                         protected Object[][] getContents() {
                             return new Object[][] {
                             // LOCALIZE THIS
                                 {"s1", "The disk \"{1}\" contains {0}."},  // MessageFormat pattern
                                 {"s2", "1"},                               // location of {0} in pattern
                                 {"s3", "My Disk"},                         // sample disk name
                                 {"s4", "no files"},                        // first ChoiceFormat choice
                                 {"s5", "one file"},                        // second ChoiceFormat choice
                                 {"s6", "{0,number} files"},                // third ChoiceFormat choice
                                 {"s7", "3 Mar 96"},                        // sample date
                                 {"s8", new Dimension(1,5)}                 // real object, not just string
                             // END OF MATERIAL TO LOCALIZE
                             };
                         }
                     }
                    
                     public class MyResources_fr extends ListResourceBundle {
                         protected Object[][] getContents() {
                             return new Object[][] {
                             // LOCALIZE THIS
                                 {"s1", "Le disque \"{1}\" {0}."},          // MessageFormat pattern
                                 {"s2", "1"},                               // location of {0} in pattern
                                 {"s3", "Mon disque"},                      // sample disk name
                                 {"s4", "ne contient pas de fichiers"},     // first ChoiceFormat choice
                                 {"s5", "contient un fichier"},             // second ChoiceFormat choice
                                 {"s6", "contient {0,number} fichiers"},    // third ChoiceFormat choice
                                 {"s7", "3 mars 1996"},                     // sample date
                                 {"s8", new Dimension(1,3)}                 // real object, not just string
                             // END OF MATERIAL TO LOCALIZE
                             };
                         }
                     }
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt;
                     The implementation of a {@code ListResourceBundle} subclass must be thread-safe
                     if it's simultaneously used by multiple threads. The default implementations
                     of the methods in this class are thread-safe.
                    
                     @see ResourceBundle
                     @see PropertyResourceBundle
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="SimpleEntry" access="PUBLIC" declaringClass="AbstractMap" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Map$Entry"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Observer" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes/>
                <javadoc xml:space="preserve">
                     A class can implement the {@code Observer} interface when it
                     wants to be informed of changes in observable objects.
                    
                     @author  Chris Warth
                     @see     java.util.Observable
                     @since   1.0
                    
                     @deprecated
                     This interface has been deprecated. See the {@link Observable}
                     class for further information.
                    </javadoc>
            </acts>
            <acts name="EventListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes/>
                <javadoc xml:space="preserve">
                     A tagging interface that all event listener interfaces must extend.
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="Queue" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Collection"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A collection designed for holding elements prior to processing.
                     Besides basic {@link Collection} operations, queues provide
                     additional insertion, extraction, and inspection operations.
                     Each of these methods exists in two forms: one throws an exception
                     if the operation fails, the other returns a special value (either
                     {@code null} or {@code false}, depending on the operation).  The
                     latter form of the insert operation is designed specifically for
                     use with capacity-restricted {@code Queue} implementations; in most
                     implementations, insert operations cannot fail.
                    
                     &lt;table class="striped"&gt;
                     &lt;caption&gt;Summary of Queue methods&lt;/caption&gt;
                      &lt;thead&gt;
                      &lt;tr&gt;
                        &lt;td&gt;&lt;/td&gt;
                        &lt;th scope="col" style="font-weight:normal; font-style:italic"&gt;Throws exception&lt;/th&gt;
                        &lt;th scope="col" style="font-weight:normal; font-style:italic"&gt;Returns special value&lt;/th&gt;
                      &lt;/tr&gt;
                      &lt;/thead&gt;
                      &lt;tbody&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;Insert&lt;/th&gt;
                        &lt;td&gt;{@link #add(Object) add(e)}&lt;/td&gt;
                        &lt;td&gt;{@link #offer(Object) offer(e)}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;Remove&lt;/th&gt;
                        &lt;td&gt;{@link #remove() remove()}&lt;/td&gt;
                        &lt;td&gt;{@link #poll() poll()}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;Examine&lt;/th&gt;
                        &lt;td&gt;{@link #element() element()}&lt;/td&gt;
                        &lt;td&gt;{@link #peek() peek()}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt;Queues typically, but do not necessarily, order elements in a
                     FIFO (first-in-first-out) manner.  Among the exceptions are
                     priority queues, which order elements according to a supplied
                     comparator, or the elements' natural ordering, and LIFO queues (or
                     stacks) which order the elements LIFO (last-in-first-out).
                     Whatever the ordering used, the &lt;em&gt;head&lt;/em&gt; of the queue is that
                     element which would be removed by a call to {@link #remove()} or
                     {@link #poll()}.  In a FIFO queue, all new elements are inserted at
                     the &lt;em&gt;tail&lt;/em&gt; of the queue. Other kinds of queues may use
                     different placement rules.  Every {@code Queue} implementation
                     must specify its ordering properties.
                    
                     &lt;p&gt;The {@link #offer offer} method inserts an element if possible,
                     otherwise returning {@code false}.  This differs from the {@link
                     java.util.Collection#add Collection.add} method, which can fail to
                     add an element only by throwing an unchecked exception.  The
                     {@code offer} method is designed for use when failure is a normal,
                     rather than exceptional occurrence, for example, in fixed-capacity
                     (or &amp;quot;bounded&amp;quot;) queues.
                    
                     &lt;p&gt;The {@link #remove()} and {@link #poll()} methods remove and
                     return the head of the queue.
                     Exactly which element is removed from the queue is a
                     function of the queue's ordering policy, which differs from
                     implementation to implementation. The {@code remove()} and
                     {@code poll()} methods differ only in their behavior when the
                     queue is empty: the {@code remove()} method throws an exception,
                     while the {@code poll()} method returns {@code null}.
                    
                     &lt;p&gt;The {@link #element()} and {@link #peek()} methods return, but do
                     not remove, the head of the queue.
                    
                     &lt;p&gt;The {@code Queue} interface does not define the &lt;i&gt;blocking queue
                     methods&lt;/i&gt;, which are common in concurrent programming.  These methods,
                     which wait for elements to appear or for space to become available, are
                     defined in the {@link java.util.concurrent.BlockingQueue} interface, which
                     extends this interface.
                    
                     &lt;p&gt;{@code Queue} implementations generally do not allow insertion
                     of {@code null} elements, although some implementations, such as
                     {@link LinkedList}, do not prohibit insertion of {@code null}.
                     Even in the implementations that permit it, {@code null} should
                     not be inserted into a {@code Queue}, as {@code null} is also
                     used as a special return value by the {@code poll} method to
                     indicate that the queue contains no elements.
                    
                     &lt;p&gt;{@code Queue} implementations generally do not define
                     element-based versions of methods {@code equals} and
                     {@code hashCode} but instead inherit the identity based versions
                     from class {@code Object}, because element-based equality is not
                     always well-defined for queues with the same elements but different
                     ordering properties.
                    
                     &lt;p&gt;This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @since 1.5
                     @author Doug Lea
                     @param &lt;E&gt; the type of elements held in this queue
                    </javadoc>
            </acts>
            <acts name="Spliterator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes/>
                <javadoc xml:space="preserve">
                     An object for traversing and partitioning elements of a source.  The source
                     of elements covered by a Spliterator could be, for example, an array, a
                     {@link Collection}, an IO channel, or a generator function.
                    
                     &lt;p&gt;A Spliterator may traverse elements individually ({@link
                     #tryAdvance tryAdvance()}) or sequentially in bulk
                     ({@link #forEachRemaining forEachRemaining()}).
                    
                     &lt;p&gt;A Spliterator may also partition off some of its elements (using
                     {@link #trySplit}) as another Spliterator, to be used in
                     possibly-parallel operations.  Operations using a Spliterator that
                     cannot split, or does so in a highly imbalanced or inefficient
                     manner, are unlikely to benefit from parallelism.  Traversal
                     and splitting exhaust elements; each Spliterator is useful for only a single
                     bulk computation.
                    
                     &lt;p&gt;A Spliterator also reports a set of {@link #characteristics()} of its
                     structure, source, and elements from among {@link #ORDERED},
                     {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED}, {@link #NONNULL},
                     {@link #IMMUTABLE}, {@link #CONCURRENT}, and {@link #SUBSIZED}. These may
                     be employed by Spliterator clients to control, specialize or simplify
                     computation.  For example, a Spliterator for a {@link Collection} would
                     report {@code SIZED}, a Spliterator for a {@link Set} would report
                     {@code DISTINCT}, and a Spliterator for a {@link SortedSet} would also
                     report {@code SORTED}.  Characteristics are reported as a simple unioned bit
                     set.
                    
                     Some characteristics additionally constrain method behavior; for example if
                     {@code ORDERED}, traversal methods must conform to their documented ordering.
                     New characteristics may be defined in the future, so implementors should not
                     assign meanings to unlisted values.
                    
                     &lt;p&gt;&lt;a id="binding"&gt;A Spliterator that does not report {@code IMMUTABLE} or
                     {@code CONCURRENT} is expected to have a documented policy concerning:
                     when the spliterator &lt;em&gt;binds&lt;/em&gt; to the element source; and detection of
                     structural interference of the element source detected after binding.&lt;/a&gt;  A
                     &lt;em&gt;late-binding&lt;/em&gt; Spliterator binds to the source of elements at the
                     point of first traversal, first split, or first query for estimated size,
                     rather than at the time the Spliterator is created.  A Spliterator that is
                     not &lt;em&gt;late-binding&lt;/em&gt; binds to the source of elements at the point of
                     construction or first invocation of any method.  Modifications made to the
                     source prior to binding are reflected when the Spliterator is traversed.
                     After binding a Spliterator should, on a best-effort basis, throw
                     {@link ConcurrentModificationException} if structural interference is
                     detected.  Spliterators that do this are called &lt;em&gt;fail-fast&lt;/em&gt;.  The
                     bulk traversal method ({@link #forEachRemaining forEachRemaining()}) of a
                     Spliterator may optimize traversal and check for structural interference
                     after all elements have been traversed, rather than checking per-element and
                     failing immediately.
                    
                     &lt;p&gt;Spliterators can provide an estimate of the number of remaining elements
                     via the {@link #estimateSize} method.  Ideally, as reflected in characteristic
                     {@link #SIZED}, this value corresponds exactly to the number of elements
                     that would be encountered in a successful traversal.  However, even when not
                     exactly known, an estimated value may still be useful to operations
                     being performed on the source, such as helping to determine whether it is
                     preferable to split further or traverse the remaining elements sequentially.
                    
                     &lt;p&gt;Despite their obvious utility in parallel algorithms, spliterators are not
                     expected to be thread-safe; instead, implementations of parallel algorithms
                     using spliterators should ensure that the spliterator is only used by one
                     thread at a time.  This is generally easy to attain via &lt;em&gt;serial
                     thread-confinement&lt;/em&gt;, which often is a natural consequence of typical
                     parallel algorithms that work by recursive decomposition.  A thread calling
                     {@link #trySplit()} may hand over the returned Spliterator to another thread,
                     which in turn may traverse or further split that Spliterator.  The behaviour
                     of splitting and traversal is undefined if two or more threads operate
                     concurrently on the same spliterator.  If the original thread hands a
                     spliterator off to another thread for processing, it is best if that handoff
                     occurs before any elements are consumed with {@link #tryAdvance(Consumer)
                     tryAdvance()}, as certain guarantees (such as the accuracy of
                     {@link #estimateSize()} for {@code SIZED} spliterators) are only valid before
                     traversal has begun.
                    
                     &lt;p&gt;Primitive subtype specializations of {@code Spliterator} are provided for
                     {@link OfInt int}, {@link OfLong long}, and {@link OfDouble double} values.
                     The subtype default implementations of
                     {@link Spliterator#tryAdvance(java.util.function.Consumer)}
                     and {@link Spliterator#forEachRemaining(java.util.function.Consumer)} box
                     primitive values to instances of their corresponding wrapper class.  Such
                     boxing may undermine any performance advantages gained by using the primitive
                     specializations.  To avoid boxing, the corresponding primitive-based methods
                     should be used.  For example,
                     {@link Spliterator.OfInt#tryAdvance(java.util.function.IntConsumer)}
                     and {@link Spliterator.OfInt#forEachRemaining(java.util.function.IntConsumer)}
                     should be used in preference to
                     {@link Spliterator.OfInt#tryAdvance(java.util.function.Consumer)} and
                     {@link Spliterator.OfInt#forEachRemaining(java.util.function.Consumer)}.
                     Traversal of primitive values using boxing-based methods
                     {@link #tryAdvance tryAdvance()} and
                     {@link #forEachRemaining(java.util.function.Consumer) forEachRemaining()}
                     does not affect the order in which the values, transformed to boxed values,
                     are encountered.
                    
                     @apiNote
                     &lt;p&gt;Spliterators, like {@code Iterator}s, are for traversing the elements of
                     a source.  The {@code Spliterator} API was designed to support efficient
                     parallel traversal in addition to sequential traversal, by supporting
                     decomposition as well as single-element iteration.  In addition, the
                     protocol for accessing elements via a Spliterator is designed to impose
                     smaller per-element overhead than {@code Iterator}, and to avoid the inherent
                     race involved in having separate methods for {@code hasNext()} and
                     {@code next()}.
                    
                     &lt;p&gt;For mutable sources, arbitrary and non-deterministic behavior may occur if
                     the source is structurally interfered with (elements added, replaced, or
                     removed) between the time that the Spliterator binds to its data source and
                     the end of traversal.  For example, such interference will produce arbitrary,
                     non-deterministic results when using the {@code java.util.stream} framework.
                    
                     &lt;p&gt;Structural interference of a source can be managed in the following ways
                     (in approximate order of decreasing desirability):
                     &lt;ul&gt;
                     &lt;li&gt;The source cannot be structurally interfered with.
                     &lt;br&gt;For example, an instance of
                     {@link java.util.concurrent.CopyOnWriteArrayList} is an immutable source.
                     A Spliterator created from the source reports a characteristic of
                     {@code IMMUTABLE}.&lt;/li&gt;
                     &lt;li&gt;The source manages concurrent modifications.
                     &lt;br&gt;For example, a key set of a {@link java.util.concurrent.ConcurrentHashMap}
                     is a concurrent source.  A Spliterator created from the source reports a
                     characteristic of {@code CONCURRENT}.&lt;/li&gt;
                     &lt;li&gt;The mutable source provides a late-binding and fail-fast Spliterator.
                     &lt;br&gt;Late binding narrows the window during which interference can affect
                     the calculation; fail-fast detects, on a best-effort basis, that structural
                     interference has occurred after traversal has commenced and throws
                     {@link ConcurrentModificationException}.  For example, {@link ArrayList},
                     and many other non-concurrent {@code Collection} classes in the JDK, provide
                     a late-binding, fail-fast spliterator.&lt;/li&gt;
                     &lt;li&gt;The mutable source provides a non-late-binding but fail-fast Spliterator.
                     &lt;br&gt;The source increases the likelihood of throwing
                     {@code ConcurrentModificationException} since the window of potential
                     interference is larger.&lt;/li&gt;
                     &lt;li&gt;The mutable source provides a late-binding and non-fail-fast Spliterator.
                     &lt;br&gt;The source risks arbitrary, non-deterministic behavior after traversal
                     has commenced since interference is not detected.
                     &lt;/li&gt;
                     &lt;li&gt;The mutable source provides a non-late-binding and non-fail-fast
                     Spliterator.
                     &lt;br&gt;The source increases the risk of arbitrary, non-deterministic behavior
                     since non-detected interference may occur after construction.
                     &lt;/li&gt;
                     &lt;/ul&gt;
                    
                     &lt;p&gt;&lt;b&gt;Example.&lt;/b&gt; Here is a class (not a very useful one, except
                     for illustration) that maintains an array in which the actual data
                     are held in even locations, and unrelated tag data are held in odd
                     locations. Its Spliterator ignores the tags.
                    
                     &lt;pre&gt; {@code
                     class TaggedArray&lt;T&gt; {
                       private final Object[] elements; // immutable after construction
                       TaggedArray(T[] data, Object[] tags) {
                         int size = data.length;
                         if (tags.length != size) throw new IllegalArgumentException();
                         this.elements = new Object[2 * size];
                         for (int i = 0, j = 0; i &lt; size; ++i) {
                           elements[j++] = data[i];
                           elements[j++] = tags[i];
                         }
                       }
                    
                       public Spliterator&lt;T&gt; spliterator() {
                         return new TaggedArraySpliterator&lt;&gt;(elements, 0, elements.length);
                       }
                    
                       static class TaggedArraySpliterator&lt;T&gt; implements Spliterator&lt;T&gt; {
                         private final Object[] array;
                         private int origin; // current index, advanced on split or traversal
                         private final int fence; // one past the greatest index
                    
                         TaggedArraySpliterator(Object[] array, int origin, int fence) {
                           this.array = array; this.origin = origin; this.fence = fence;
                         }
                    
                         public void forEachRemaining(Consumer&lt;? super T&gt; action) {
                           for (; origin &lt; fence; origin += 2)
                             action.accept((T) array[origin]);
                         }
                    
                         public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
                           if (origin &lt; fence) {
                             action.accept((T) array[origin]);
                             origin += 2;
                             return true;
                           }
                           else // cannot advance
                             return false;
                         }
                    
                         public Spliterator&lt;T&gt; trySplit() {
                           int lo = origin; // divide range in half
                           int mid = ((lo + fence) &gt;&gt;&gt; 1) &amp; ~1; // force midpoint to be even
                           if (lo &lt; mid) { // split out left half
                             origin = mid; // reset this Spliterator's origin
                             return new TaggedArraySpliterator&lt;&gt;(array, lo, mid);
                           }
                           else       // too small to split
                             return null;
                         }
                    
                         public long estimateSize() {
                           return (long)((fence - origin) / 2);
                         }
                    
                         public int characteristics() {
                           return ORDERED | SIZED | IMMUTABLE | SUBSIZED;
                         }
                       }
                     }}&lt;/pre&gt;
                    
                     &lt;p&gt;As an example how a parallel computation framework, such as the
                     {@code java.util.stream} package, would use Spliterator in a parallel
                     computation, here is one way to implement an associated parallel forEach,
                     that illustrates the primary usage idiom of splitting off subtasks until
                     the estimated amount of work is small enough to perform
                     sequentially. Here we assume that the order of processing across
                     subtasks doesn't matter; different (forked) tasks may further split
                     and process elements concurrently in undetermined order.  This
                     example uses a {@link java.util.concurrent.CountedCompleter};
                     similar usages apply to other parallel task constructions.
                    
                     &lt;pre&gt;{@code
                     static &lt;T&gt; void parEach(TaggedArray&lt;T&gt; a, Consumer&lt;T&gt; action) {
                       Spliterator&lt;T&gt; s = a.spliterator();
                       long targetBatchSize = s.estimateSize() / (ForkJoinPool.getCommonPoolParallelism() * 8);
                       new ParEach(null, s, action, targetBatchSize).invoke();
                     }
                    
                     static class ParEach&lt;T&gt; extends CountedCompleter&lt;Void&gt; {
                       final Spliterator&lt;T&gt; spliterator;
                       final Consumer&lt;T&gt; action;
                       final long targetBatchSize;
                    
                       ParEach(ParEach&lt;T&gt; parent, Spliterator&lt;T&gt; spliterator,
                               Consumer&lt;T&gt; action, long targetBatchSize) {
                         super(parent);
                         this.spliterator = spliterator; this.action = action;
                         this.targetBatchSize = targetBatchSize;
                       }
                    
                       public void compute() {
                         Spliterator&lt;T&gt; sub;
                         while (spliterator.estimateSize() &gt; targetBatchSize &amp;&amp;
                                (sub = spliterator.trySplit()) != null) {
                           addToPendingCount(1);
                           new ParEach&lt;&gt;(this, sub, action, targetBatchSize).fork();
                         }
                         spliterator.forEachRemaining(action);
                         propagateCompletion();
                       }
                     }}&lt;/pre&gt;
                    
                     @implNote
                     If the boolean system property {@code org.openjdk.java.util.stream.tripwire}
                     is set to {@code true} then diagnostic warnings are reported if boxing of
                     primitive values occur when operating on primitive subtype specializations.
                    
                     @param &lt;T&gt; the type of elements returned by this Spliterator
                    
                     @see Collection
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="Enumeration" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes/>
                <javadoc xml:space="preserve">
                     An object that implements the Enumeration interface generates a
                     series of elements, one at a time. Successive calls to the
                     {@code nextElement} method return successive elements of the
                     series.
                     &lt;p&gt;
                     For example, to print all elements of a {@code Vector&lt;E&gt;} &lt;i&gt;v&lt;/i&gt;:
                     &lt;pre&gt;
                       for (Enumeration&amp;lt;E&amp;gt; e = v.elements(); e.hasMoreElements();)
                           System.out.println(e.nextElement());&lt;/pre&gt;
                     &lt;p&gt;
                     Methods are provided to enumerate through the elements of a
                     vector, the keys of a hashtable, and the values in a hashtable.
                     Enumerations are also used to specify the input streams to a
                     {@code SequenceInputStream}.
                    
                     @apiNote
                     The functionality of this interface is duplicated by the {@link Iterator}
                     interface.  In addition, {@code Iterator} adds an optional remove operation,
                     and has shorter method names.  New implementations should consider using
                     {@code Iterator} in preference to {@code Enumeration}. It is possible to
                     adapt an {@code Enumeration} to an {@code Iterator} by using the
                     {@link #asIterator} method.
                    
                     @see     java.util.Iterator
                     @see     java.io.SequenceInputStream
                     @see     java.util.Enumeration#nextElement()
                     @see     java.util.Hashtable
                     @see     java.util.Hashtable#elements()
                     @see     java.util.Hashtable#keys()
                     @see     java.util.Vector
                     @see     java.util.Vector#elements()
                    
                     @author  Lee Boynton
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Hashtable" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Map"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.util.Dictionary"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class implements a hash table, which maps keys to values. Any
                     non-{@code null} object can be used as a key or as a value. &lt;p&gt;
                    
                     To successfully store and retrieve objects from a hashtable, the
                     objects used as keys must implement the {@code hashCode}
                     method and the {@code equals} method. &lt;p&gt;
                    
                     An instance of {@code Hashtable} has two parameters that affect its
                     performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The
                     &lt;i&gt;capacity&lt;/i&gt; is the number of &lt;i&gt;buckets&lt;/i&gt; in the hash table, and the
                     &lt;i&gt;initial capacity&lt;/i&gt; is simply the capacity at the time the hash table
                     is created.  Note that the hash table is &lt;i&gt;open&lt;/i&gt;: in the case of a "hash
                     collision", a single bucket stores multiple entries, which must be searched
                     sequentially.  The &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash
                     table is allowed to get before its capacity is automatically increased.
                     The initial capacity and load factor parameters are merely hints to
                     the implementation.  The exact details as to when and whether the rehash
                     method is invoked are implementation-dependent.&lt;p&gt;
                    
                     Generally, the default load factor (.75) offers a good tradeoff between
                     time and space costs.  Higher values decrease the space overhead but
                     increase the time cost to look up an entry (which is reflected in most
                     {@code Hashtable} operations, including {@code get} and {@code put}).&lt;p&gt;
                    
                     The initial capacity controls a tradeoff between wasted space and the
                     need for {@code rehash} operations, which are time-consuming.
                     No {@code rehash} operations will &lt;i&gt;ever&lt;/i&gt; occur if the initial
                     capacity is greater than the maximum number of entries the
                     {@code Hashtable} will contain divided by its load factor.  However,
                     setting the initial capacity too high can waste space.&lt;p&gt;
                    
                     If many entries are to be made into a {@code Hashtable},
                     creating it with a sufficiently large capacity may allow the
                     entries to be inserted more efficiently than letting it perform
                     automatic rehashing as needed to grow the table. &lt;p&gt;
                    
                     This example creates a hashtable of numbers. It uses the names of
                     the numbers as keys:
                     &lt;pre&gt;   {@code
                       Hashtable&lt;String, Integer&gt; numbers
                         = new Hashtable&lt;String, Integer&gt;();
                       numbers.put("one", 1);
                       numbers.put("two", 2);
                       numbers.put("three", 3);}&lt;/pre&gt;
                    
                     &lt;p&gt;To retrieve a number, use the following code:
                     &lt;pre&gt;   {@code
                       Integer n = numbers.get("two");
                       if (n != null) {
                         System.out.println("two = " + n);
                       }}&lt;/pre&gt;
                    
                     &lt;p&gt;The iterators returned by the {@code iterator} method of the collections
                     returned by all of this class's "collection view methods" are
                     &lt;em&gt;fail-fast&lt;/em&gt;: if the Hashtable is structurally modified at any time
                     after the iterator is created, in any way except through the iterator's own
                     {@code remove} method, the iterator will throw a {@link
                     ConcurrentModificationException}.  Thus, in the face of concurrent
                     modification, the iterator fails quickly and cleanly, rather than risking
                     arbitrary, non-deterministic behavior at an undetermined time in the future.
                     The Enumerations returned by Hashtable's {@link #keys keys} and
                     {@link #elements elements} methods are &lt;em&gt;not&lt;/em&gt; fail-fast; if the
                     Hashtable is structurally modified at any time after the enumeration is
                     created then the results of enumerating are undefined.
                    
                     &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                     as it is, generally speaking, impossible to make any hard guarantees in the
                     presence of unsynchronized concurrent modification.  Fail-fast iterators
                     throw {@code ConcurrentModificationException} on a best-effort basis.
                     Therefore, it would be wrong to write a program that depended on this
                     exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators
                     should be used only to detect bugs.&lt;/i&gt;
                    
                     &lt;p&gt;As of the Java 2 platform v1.2, this class was retrofitted to
                     implement the {@link Map} interface, making it a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                    
                     Java Collections Framework&lt;/a&gt;.  Unlike the new collection
                     implementations, {@code Hashtable} is synchronized.  If a
                     thread-safe implementation is not needed, it is recommended to use
                     {@link HashMap} in place of {@code Hashtable}.  If a thread-safe
                     highly-concurrent implementation is desired, then it is recommended
                     to use {@link java.util.concurrent.ConcurrentHashMap} in place of
                     {@code Hashtable}.
                    
                     @param &lt;K&gt; the type of keys maintained by this map
                     @param &lt;V&gt; the type of mapped values
                    
                     @author  Arthur van Hoff
                     @author  Josh Bloch
                     @author  Neal Gafter
                     @see     Object#equals(java.lang.Object)
                     @see     Object#hashCode()
                     @see     Hashtable#rehash()
                     @see     Collection
                     @see     Map
                     @see     HashMap
                     @see     TreeMap
                     @since 1.0
                    </javadoc>
            </acts>
            <acts name="Calendar" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The &lt;code&gt;Calendar&lt;/code&gt; class is an abstract class that provides methods
                     for converting between a specific instant in time and a set of {@link
                     #fields calendar fields} such as &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH&lt;/code&gt;,
                     &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;, &lt;code&gt;HOUR&lt;/code&gt;, and so on, and for
                     manipulating the calendar fields, such as getting the date of the next
                     week. An instant in time can be represented by a millisecond value that is
                     an offset from the &lt;a id="Epoch"&gt;&lt;em&gt;Epoch&lt;/em&gt;&lt;/a&gt;, January 1, 1970
                     00:00:00.000 GMT (Gregorian).
                    
                     &lt;p&gt;The class also provides additional fields and methods for
                     implementing a concrete calendar system outside the package. Those
                     fields and methods are defined as &lt;code&gt;protected&lt;/code&gt;.
                    
                     &lt;p&gt;
                     Like other locale-sensitive classes, &lt;code&gt;Calendar&lt;/code&gt; provides a
                     class method, &lt;code&gt;getInstance&lt;/code&gt;, for getting a generally useful
                     object of this type. &lt;code&gt;Calendar&lt;/code&gt;'s &lt;code&gt;getInstance&lt;/code&gt; method
                     returns a &lt;code&gt;Calendar&lt;/code&gt; object whose
                     calendar fields have been initialized with the current date and time:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                         Calendar rightNow = Calendar.getInstance();
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt;A &lt;code&gt;Calendar&lt;/code&gt; object can produce all the calendar field values
                     needed to implement the date-time formatting for a particular language and
                     calendar style (for example, Japanese-Gregorian, Japanese-Traditional).
                     &lt;code&gt;Calendar&lt;/code&gt; defines the range of values returned by
                     certain calendar fields, as well as their meaning.  For example,
                     the first month of the calendar system has value &lt;code&gt;MONTH ==
                     JANUARY&lt;/code&gt; for all calendars.  Other values are defined by the
                     concrete subclass, such as &lt;code&gt;ERA&lt;/code&gt;.  See individual field
                     documentation and subclass documentation for details.
                    
                     &lt;h3&gt;Getting and Setting Calendar Field Values&lt;/h3&gt;
                    
                     &lt;p&gt;The calendar field values can be set by calling the &lt;code&gt;set&lt;/code&gt;
                     methods. Any field values set in a &lt;code&gt;Calendar&lt;/code&gt; will not be
                     interpreted until it needs to calculate its time value (milliseconds from
                     the Epoch) or values of the calendar fields. Calling the
                     &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;getTimeInMillis&lt;/code&gt;, &lt;code&gt;getTime&lt;/code&gt;,
                     &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;roll&lt;/code&gt; involves such calculation.
                    
                     &lt;h4&gt;Leniency&lt;/h4&gt;
                    
                     &lt;p&gt;&lt;code&gt;Calendar&lt;/code&gt; has two modes for interpreting the calendar
                     fields, &lt;em&gt;lenient&lt;/em&gt; and &lt;em&gt;non-lenient&lt;/em&gt;.  When a
                     &lt;code&gt;Calendar&lt;/code&gt; is in lenient mode, it accepts a wider range of
                     calendar field values than it produces.  When a &lt;code&gt;Calendar&lt;/code&gt;
                     recomputes calendar field values for return by &lt;code&gt;get()&lt;/code&gt;, all of
                     the calendar fields are normalized. For example, a lenient
                     &lt;code&gt;GregorianCalendar&lt;/code&gt; interprets &lt;code&gt;MONTH == JANUARY&lt;/code&gt;,
                     &lt;code&gt;DAY_OF_MONTH == 32&lt;/code&gt; as February 1.
                    
                     &lt;p&gt;When a &lt;code&gt;Calendar&lt;/code&gt; is in non-lenient mode, it throws an
                     exception if there is any inconsistency in its calendar fields. For
                     example, a &lt;code&gt;GregorianCalendar&lt;/code&gt; always produces
                     &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; values between 1 and the length of the month. A
                     non-lenient &lt;code&gt;GregorianCalendar&lt;/code&gt; throws an exception upon
                     calculating its time or calendar field values if any out-of-range field
                     value has been set.
                    
                     &lt;h4&gt;&lt;a id="first_week"&gt;First Week&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;code&gt;Calendar&lt;/code&gt; defines a locale-specific seven day week using two
                     parameters: the first day of the week and the minimal days in first week
                     (from 1 to 7).  These numbers are taken from the locale resource data or the
                     locale itself when a {@code Calendar} is constructed. If the designated
                     locale contains "fw" and/or "rg" &lt;a href="./Locale.html#def_locale_extension"&gt;
                     Unicode extensions&lt;/a&gt;, the first day of the week will be obtained according to
                     those extensions. If both "fw" and "rg" are specified, the value from the "fw"
                     extension supersedes the implicit one from the "rg" extension.
                     They may also be specified explicitly through the methods for setting their
                     values.
                    
                     &lt;p&gt;When setting or getting the &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; or
                     &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt; fields, &lt;code&gt;Calendar&lt;/code&gt; must determine the
                     first week of the month or year as a reference point.  The first week of a
                     month or year is defined as the earliest seven day period beginning on
                     &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; and containing at least
                     &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; days of that month or year.  Weeks
                     numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow
                     it.  Note that the normalized numbering returned by &lt;code&gt;get()&lt;/code&gt; may be
                     different.  For example, a specific &lt;code&gt;Calendar&lt;/code&gt; subclass may
                     designate the week before week 1 of a year as week &lt;code&gt;&lt;i&gt;n&lt;/i&gt;&lt;/code&gt; of
                     the previous year.
                    
                     &lt;h4&gt;Calendar Fields Resolution&lt;/h4&gt;
                    
                     When computing a date and time from the calendar fields, there
                     may be insufficient information for the computation (such as only
                     year and month with no day of month), or there may be inconsistent
                     information (such as Tuesday, July 15, 1996 (Gregorian) -- July 15,
                     1996 is actually a Monday). &lt;code&gt;Calendar&lt;/code&gt; will resolve
                     calendar field values to determine the date and time in the
                     following way.
                    
                     &lt;p&gt;&lt;a id="resolution"&gt;If there is any conflict in calendar field values,
                     &lt;code&gt;Calendar&lt;/code&gt; gives priorities to calendar fields that have been set
                     more recently.&lt;/a&gt; The following are the default combinations of the
                     calendar fields. The most recent combination, as determined by the
                     most recently set single field, will be used.
                    
                     &lt;p&gt;&lt;a id="date_resolution"&gt;For the date fields&lt;/a&gt;:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     YEAR + MONTH + DAY_OF_MONTH
                     YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK
                     YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK
                     YEAR + DAY_OF_YEAR
                     YEAR + DAY_OF_WEEK + WEEK_OF_YEAR
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;a id="time_resolution"&gt;For the time of day fields&lt;/a&gt;:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     HOUR_OF_DAY
                     AM_PM + HOUR
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt;If there are any calendar fields whose values haven't been set in the selected
                     field combination, &lt;code&gt;Calendar&lt;/code&gt; uses their default values. The default
                     value of each field may vary by concrete calendar systems. For example, in
                     &lt;code&gt;GregorianCalendar&lt;/code&gt;, the default of a field is the same as that
                     of the start of the Epoch: i.e., &lt;code&gt;YEAR = 1970&lt;/code&gt;, &lt;code&gt;MONTH =
                     JANUARY&lt;/code&gt;, &lt;code&gt;DAY_OF_MONTH = 1&lt;/code&gt;, etc.
                    
                     &lt;p&gt;
                     &lt;strong&gt;Note:&lt;/strong&gt; There are certain possible ambiguities in
                     interpretation of certain singular times, which are resolved in the
                     following ways:
                     &lt;ol&gt;
                         &lt;li&gt; 23:59 is the last minute of the day and 00:00 is the first
                              minute of the next day. Thus, 23:59 on Dec 31, 1999 &amp;lt; 00:00 on
                              Jan 1, 2000 &amp;lt; 00:01 on Jan 1, 2000.
                    
                         &lt;li&gt; Although historically not precise, midnight also belongs to "am",
                              and noon belongs to "pm", so on the same day,
                              12:00 am (midnight) &amp;lt; 12:01 am, and 12:00 pm (noon) &amp;lt; 12:01 pm
                     &lt;/ol&gt;
                    
                     &lt;p&gt;
                     The date or time format strings are not part of the definition of a
                     calendar, as those must be modifiable or overridable by the user at
                     runtime. Use {@link DateFormat}
                     to format dates.
                    
                     &lt;h4&gt;Field Manipulation&lt;/h4&gt;
                    
                     The calendar fields can be changed using three methods:
                     &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;add()&lt;/code&gt;, and &lt;code&gt;roll()&lt;/code&gt;.
                    
                     &lt;p&gt;&lt;strong&gt;&lt;code&gt;set(f, value)&lt;/code&gt;&lt;/strong&gt; changes calendar field
                     &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;.  In addition, it sets an
                     internal member variable to indicate that calendar field &lt;code&gt;f&lt;/code&gt; has
                     been changed. Although calendar field &lt;code&gt;f&lt;/code&gt; is changed immediately,
                     the calendar's time value in milliseconds is not recomputed until the next call to
                     &lt;code&gt;get()&lt;/code&gt;, &lt;code&gt;getTime()&lt;/code&gt;, &lt;code&gt;getTimeInMillis()&lt;/code&gt;,
                     &lt;code&gt;add()&lt;/code&gt;, or &lt;code&gt;roll()&lt;/code&gt; is made. Thus, multiple calls to
                     &lt;code&gt;set()&lt;/code&gt; do not trigger multiple, unnecessary
                     computations. As a result of changing a calendar field using
                     &lt;code&gt;set()&lt;/code&gt;, other calendar fields may also change, depending on the
                     calendar field, the calendar field value, and the calendar system. In addition,
                     &lt;code&gt;get(f)&lt;/code&gt; will not necessarily return &lt;code&gt;value&lt;/code&gt; set by
                     the call to the &lt;code&gt;set&lt;/code&gt; method
                     after the calendar fields have been recomputed. The specifics are determined by
                     the concrete calendar class.&lt;/p&gt;
                    
                     &lt;p&gt;&lt;em&gt;Example&lt;/em&gt;: Consider a &lt;code&gt;GregorianCalendar&lt;/code&gt;
                     originally set to August 31, 1999. Calling &lt;code&gt;set(Calendar.MONTH,
                     Calendar.SEPTEMBER)&lt;/code&gt; sets the date to September 31,
                     1999. This is a temporary internal representation that resolves to
                     October 1, 1999 if &lt;code&gt;getTime()&lt;/code&gt;is then called. However, a
                     call to &lt;code&gt;set(Calendar.DAY_OF_MONTH, 30)&lt;/code&gt; before the call to
                     &lt;code&gt;getTime()&lt;/code&gt; sets the date to September 30, 1999, since
                     no recomputation occurs after &lt;code&gt;set()&lt;/code&gt; itself.&lt;/p&gt;
                    
                     &lt;p&gt;&lt;strong&gt;&lt;code&gt;add(f, delta)&lt;/code&gt;&lt;/strong&gt; adds &lt;code&gt;delta&lt;/code&gt;
                     to field &lt;code&gt;f&lt;/code&gt;.  This is equivalent to calling &lt;code&gt;set(f,
                     get(f) + delta)&lt;/code&gt; with two adjustments:&lt;/p&gt;
                    
                     &lt;blockquote&gt;
                       &lt;p&gt;&lt;strong&gt;Add rule 1&lt;/strong&gt;. The value of field &lt;code&gt;f&lt;/code&gt;
                       after the call minus the value of field &lt;code&gt;f&lt;/code&gt; before the
                       call is &lt;code&gt;delta&lt;/code&gt;, modulo any overflow that has occurred in
                       field &lt;code&gt;f&lt;/code&gt;. Overflow occurs when a field value exceeds its
                       range and, as a result, the next larger field is incremented or
                       decremented and the field value is adjusted back into its range.&lt;/p&gt;
                    
                       &lt;p&gt;&lt;strong&gt;Add rule 2&lt;/strong&gt;. If a smaller field is expected to be
                       invariant, but it is impossible for it to be equal to its
                       prior value because of changes in its minimum or maximum after field
                       &lt;code&gt;f&lt;/code&gt; is changed or other constraints, such as time zone
                       offset changes, then its value is adjusted to be as close
                       as possible to its expected value. A smaller field represents a
                       smaller unit of time. &lt;code&gt;HOUR&lt;/code&gt; is a smaller field than
                       &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;. No adjustment is made to smaller fields
                       that are not expected to be invariant. The calendar system
                       determines what fields are expected to be invariant.&lt;/p&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt;In addition, unlike &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;add()&lt;/code&gt; forces
                     an immediate recomputation of the calendar's milliseconds and all
                     fields.&lt;/p&gt;
                    
                     &lt;p&gt;&lt;em&gt;Example&lt;/em&gt;: Consider a &lt;code&gt;GregorianCalendar&lt;/code&gt;
                     originally set to August 31, 1999. Calling &lt;code&gt;add(Calendar.MONTH,
                     13)&lt;/code&gt; sets the calendar to September 30, 2000. &lt;strong&gt;Add rule
                     1&lt;/strong&gt; sets the &lt;code&gt;MONTH&lt;/code&gt; field to September, since
                     adding 13 months to August gives September of the next year. Since
                     &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; cannot be 31 in September in a
                     &lt;code&gt;GregorianCalendar&lt;/code&gt;, &lt;strong&gt;add rule 2&lt;/strong&gt; sets the
                     &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; to 30, the closest possible value. Although
                     it is a smaller field, &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; is not adjusted by
                     rule 2, since it is expected to change when the month changes in a
                     &lt;code&gt;GregorianCalendar&lt;/code&gt;.&lt;/p&gt;
                    
                     &lt;p&gt;&lt;strong&gt;&lt;code&gt;roll(f, delta)&lt;/code&gt;&lt;/strong&gt; adds
                     &lt;code&gt;delta&lt;/code&gt; to field &lt;code&gt;f&lt;/code&gt; without changing larger
                     fields. This is equivalent to calling &lt;code&gt;add(f, delta)&lt;/code&gt; with
                     the following adjustment:&lt;/p&gt;
                    
                     &lt;blockquote&gt;
                       &lt;p&gt;&lt;strong&gt;Roll rule&lt;/strong&gt;. Larger fields are unchanged after the
                       call. A larger field represents a larger unit of
                       time. &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; is a larger field than
                       &lt;code&gt;HOUR&lt;/code&gt;.&lt;/p&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt;&lt;em&gt;Example&lt;/em&gt;: See {@link java.util.GregorianCalendar#roll(int, int)}.
                    
                     &lt;p&gt;&lt;strong&gt;Usage model&lt;/strong&gt;. To motivate the behavior of
                     &lt;code&gt;add()&lt;/code&gt; and &lt;code&gt;roll()&lt;/code&gt;, consider a user interface
                     component with increment and decrement buttons for the month, day, and
                     year, and an underlying &lt;code&gt;GregorianCalendar&lt;/code&gt;. If the
                     interface reads January 31, 1999 and the user presses the month
                     increment button, what should it read? If the underlying
                     implementation uses &lt;code&gt;set()&lt;/code&gt;, it might read March 3, 1999. A
                     better result would be February 28, 1999. Furthermore, if the user
                     presses the month increment button again, it should read March 31,
                     1999, not March 28, 1999. By saving the original date and using either
                     &lt;code&gt;add()&lt;/code&gt; or &lt;code&gt;roll()&lt;/code&gt;, depending on whether larger
                     fields should be affected, the user interface can behave as most users
                     will intuitively expect.&lt;/p&gt;
                    
                     @see          java.lang.System#currentTimeMillis()
                     @see          Date
                     @see          GregorianCalendar
                     @see          TimeZone
                     @see          java.text.DateFormat
                     @author Mark Davis, David Goldsmith, Chen-Lieh Huang, Alan Liu
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="AbstractSet" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Set"/>
                    <superType superType="java.util.AbstractCollection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class provides a skeletal implementation of the {@code Set}
                     interface to minimize the effort required to implement this
                     interface. &lt;p&gt;
                    
                     The process of implementing a set by extending this class is identical
                     to that of implementing a Collection by extending AbstractCollection,
                     except that all of the methods and constructors in subclasses of this
                     class must obey the additional constraints imposed by the {@code Set}
                     interface (for instance, the add method must not permit addition of
                     multiple instances of an object to a set).&lt;p&gt;
                    
                     Note that this class does not override any of the implementations from
                     the {@code AbstractCollection} class.  It merely adds implementations
                     for {@code equals} and {@code hashCode}.&lt;p&gt;
                    
                     This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;E&gt; the type of elements maintained by this set
                    
                     @author  Josh Bloch
                     @author  Neal Gafter
                     @see Collection
                     @see AbstractCollection
                     @see Set
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="OptionalInt" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A container object which may or may not contain an {@code int} value.
                     If a value is present, {@code isPresent()} returns {@code true}. If no
                     value is present, the object is considered &lt;i&gt;empty&lt;/i&gt; and
                     {@code isPresent()} returns {@code false}.
                    
                     &lt;p&gt;Additional methods that depend on the presence or absence of a contained
                     value are provided, such as {@link #orElse(int) orElse()}
                     (returns a default value if no value is present) and
                     {@link #ifPresent(IntConsumer) ifPresent()} (performs an
                     action if a value is present).
                    
                     &lt;p&gt;This is a &lt;a href="../lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code OptionalInt} may have unpredictable results and should be avoided.
                    
                     @apiNote
                     {@code OptionalInt} is primarily intended for use as a method return type where
                     there is a clear need to represent "no result." A variable whose type is
                     {@code OptionalInt} should never itself be {@code null}; it should always point
                     to an {@code OptionalInt} instance.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="Provider" access="PUBLIC" declaringClass="ServiceLoader" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.function.Supplier"/>
                </superTypes>
            </acts>
            <acts name="DoubleSummaryStatistics" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.function.DoubleConsumer"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A state object for collecting statistics such as count, min, max, sum, and
                     average.
                    
                     &lt;p&gt;This class is designed to work with (though does not require)
                     {@linkplain java.util.stream streams}. For example, you can compute
                     summary statistics on a stream of doubles with:
                     &lt;pre&gt; {@code
                     DoubleSummaryStatistics stats = doubleStream.collect(DoubleSummaryStatistics::new,
                                                                          DoubleSummaryStatistics::accept,
                                                                          DoubleSummaryStatistics::combine);
                     }&lt;/pre&gt;
                    
                     &lt;p&gt;{@code DoubleSummaryStatistics} can be used as a
                     {@linkplain java.util.stream.Stream#collect(Collector) reduction}
                     target for a {@linkplain java.util.stream.Stream stream}. For example:
                    
                     &lt;pre&gt; {@code
                     DoubleSummaryStatistics stats = people.stream()
                         .collect(Collectors.summarizingDouble(Person::getWeight));
                    }&lt;/pre&gt;
                    
                     This computes, in a single pass, the count of people, as well as the minimum,
                     maximum, sum, and average of their weights.
                    
                     @implNote This implementation is not thread safe. However, it is safe to use
                     {@link java.util.stream.Collectors#summarizingDouble(java.util.function.ToDoubleFunction)
                     Collectors.summarizingDouble()} on a parallel stream, because the parallel
                     implementation of {@link java.util.stream.Stream#collect Stream.collect()}
                     provides the necessary partitioning, isolation, and merging of results for
                     safe and efficient parallel execution.
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="TreeMap" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.NavigableMap"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.util.AbstractMap"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A Red-Black tree based {@link NavigableMap} implementation.
                     The map is sorted according to the {@linkplain Comparable natural
                     ordering} of its keys, or by a {@link Comparator} provided at map
                     creation time, depending on which constructor is used.
                    
                     &lt;p&gt;This implementation provides guaranteed log(n) time cost for the
                     {@code containsKey}, {@code get}, {@code put} and {@code remove}
                     operations.  Algorithms are adaptations of those in Cormen, Leiserson, and
                     Rivest's &lt;em&gt;Introduction to Algorithms&lt;/em&gt;.
                    
                     &lt;p&gt;Note that the ordering maintained by a tree map, like any sorted map, and
                     whether or not an explicit comparator is provided, must be &lt;em&gt;consistent
                     with {@code equals}&lt;/em&gt; if this sorted map is to correctly implement the
                     {@code Map} interface.  (See {@code Comparable} or {@code Comparator} for a
                     precise definition of &lt;em&gt;consistent with equals&lt;/em&gt;.)  This is so because
                     the {@code Map} interface is defined in terms of the {@code equals}
                     operation, but a sorted map performs all key comparisons using its {@code
                     compareTo} (or {@code compare}) method, so two keys that are deemed equal by
                     this method are, from the standpoint of the sorted map, equal.  The behavior
                     of a sorted map &lt;em&gt;is&lt;/em&gt; well-defined even if its ordering is
                     inconsistent with {@code equals}; it just fails to obey the general contract
                     of the {@code Map} interface.
                    
                     &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
                     If multiple threads access a map concurrently, and at least one of the
                     threads modifies the map structurally, it &lt;em&gt;must&lt;/em&gt; be synchronized
                     externally.  (A structural modification is any operation that adds or
                     deletes one or more mappings; merely changing the value associated
                     with an existing key is not a structural modification.)  This is
                     typically accomplished by synchronizing on some object that naturally
                     encapsulates the map.
                     If no such object exists, the map should be "wrapped" using the
                     {@link Collections#synchronizedSortedMap Collections.synchronizedSortedMap}
                     method.  This is best done at creation time, to prevent accidental
                     unsynchronized access to the map: &lt;pre&gt;
                       SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));&lt;/pre&gt;
                    
                     &lt;p&gt;The iterators returned by the {@code iterator} method of the collections
                     returned by all of this class's "collection view methods" are
                     &lt;em&gt;fail-fast&lt;/em&gt;: if the map is structurally modified at any time after
                     the iterator is created, in any way except through the iterator's own
                     {@code remove} method, the iterator will throw a {@link
                     ConcurrentModificationException}.  Thus, in the face of concurrent
                     modification, the iterator fails quickly and cleanly, rather than risking
                     arbitrary, non-deterministic behavior at an undetermined time in the future.
                    
                     &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                     as it is, generally speaking, impossible to make any hard guarantees in the
                     presence of unsynchronized concurrent modification.  Fail-fast iterators
                     throw {@code ConcurrentModificationException} on a best-effort basis.
                     Therefore, it would be wrong to write a program that depended on this
                     exception for its correctness:   &lt;em&gt;the fail-fast behavior of iterators
                     should be used only to detect bugs.&lt;/em&gt;
                    
                     &lt;p&gt;All {@code Map.Entry} pairs returned by methods in this class
                     and its views represent snapshots of mappings at the time they were
                     produced. They do &lt;strong&gt;not&lt;/strong&gt; support the {@code Entry.setValue}
                     method. (Note however that it is possible to change mappings in the
                     associated map using {@code put}.)
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;K&gt; the type of keys maintained by this map
                     @param &lt;V&gt; the type of mapped values
                    
                     @author  Josh Bloch and Doug Lea
                     @see Map
                     @see HashMap
                     @see Hashtable
                     @see Comparable
                     @see Comparator
                     @see Collection
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="Deque" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Queue"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A linear collection that supports element insertion and removal at
                     both ends.  The name &lt;i&gt;deque&lt;/i&gt; is short for "double ended queue"
                     and is usually pronounced "deck".  Most {@code Deque}
                     implementations place no fixed limits on the number of elements
                     they may contain, but this interface supports capacity-restricted
                     deques as well as those with no fixed size limit.
                    
                     &lt;p&gt;This interface defines methods to access the elements at both
                     ends of the deque.  Methods are provided to insert, remove, and
                     examine the element.  Each of these methods exists in two forms:
                     one throws an exception if the operation fails, the other returns a
                     special value (either {@code null} or {@code false}, depending on
                     the operation).  The latter form of the insert operation is
                     designed specifically for use with capacity-restricted
                     {@code Deque} implementations; in most implementations, insert
                     operations cannot fail.
                    
                     &lt;p&gt;The twelve methods described above are summarized in the
                     following table:
                    
                     &lt;table class="striped"&gt;
                     &lt;caption&gt;Summary of Deque methods&lt;/caption&gt;
                      &lt;thead&gt;
                      &lt;tr&gt;
                        &lt;td rowspan="2"&gt;&lt;/td&gt;
                        &lt;th scope="col" colspan="2"&gt; First Element (Head)&lt;/th&gt;
                        &lt;th scope="col" colspan="2"&gt; Last Element (Tail)&lt;/th&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                        &lt;th scope="col" style="font-weight:normal; font-style:italic"&gt;Throws exception&lt;/th&gt;
                        &lt;th scope="col" style="font-weight:normal; font-style:italic"&gt;Special value&lt;/th&gt;
                        &lt;th scope="col" style="font-weight:normal; font-style:italic"&gt;Throws exception&lt;/th&gt;
                        &lt;th scope="col" style="font-weight:normal; font-style:italic"&gt;Special value&lt;/th&gt;
                      &lt;/tr&gt;
                      &lt;/thead&gt;
                      &lt;tbody&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;Insert&lt;/th&gt;
                        &lt;td&gt;{@link #addFirst(Object) addFirst(e)}&lt;/td&gt;
                        &lt;td&gt;{@link #offerFirst(Object) offerFirst(e)}&lt;/td&gt;
                        &lt;td&gt;{@link #addLast(Object) addLast(e)}&lt;/td&gt;
                        &lt;td&gt;{@link #offerLast(Object) offerLast(e)}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;Remove&lt;/th&gt;
                        &lt;td&gt;{@link #removeFirst() removeFirst()}&lt;/td&gt;
                        &lt;td&gt;{@link #pollFirst() pollFirst()}&lt;/td&gt;
                        &lt;td&gt;{@link #removeLast() removeLast()}&lt;/td&gt;
                        &lt;td&gt;{@link #pollLast() pollLast()}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;Examine&lt;/th&gt;
                        &lt;td&gt;{@link #getFirst() getFirst()}&lt;/td&gt;
                        &lt;td&gt;{@link #peekFirst() peekFirst()}&lt;/td&gt;
                        &lt;td&gt;{@link #getLast() getLast()}&lt;/td&gt;
                        &lt;td&gt;{@link #peekLast() peekLast()}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt;This interface extends the {@link Queue} interface.  When a deque is
                     used as a queue, FIFO (First-In-First-Out) behavior results.  Elements are
                     added at the end of the deque and removed from the beginning.  The methods
                     inherited from the {@code Queue} interface are precisely equivalent to
                     {@code Deque} methods as indicated in the following table:
                    
                     &lt;table class="striped"&gt;
                     &lt;caption&gt;Comparison of Queue and Deque methods&lt;/caption&gt;
                      &lt;thead&gt;
                      &lt;tr&gt;
                        &lt;th scope="col"&gt; {@code Queue} Method&lt;/th&gt;
                        &lt;th scope="col"&gt; Equivalent {@code Deque} Method&lt;/th&gt;
                      &lt;/tr&gt;
                      &lt;/thead&gt;
                      &lt;tbody&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;{@link #add(Object) add(e)}&lt;/th&gt;
                        &lt;td&gt;{@link #addLast(Object) addLast(e)}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;{@link #offer(Object) offer(e)}&lt;/th&gt;
                        &lt;td&gt;{@link #offerLast(Object) offerLast(e)}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;{@link #remove() remove()}&lt;/th&gt;
                        &lt;td&gt;{@link #removeFirst() removeFirst()}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;{@link #poll() poll()}&lt;/th&gt;
                        &lt;td&gt;{@link #pollFirst() pollFirst()}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;{@link #element() element()}&lt;/th&gt;
                        &lt;td&gt;{@link #getFirst() getFirst()}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;{@link #peek() peek()}&lt;/th&gt;
                        &lt;td&gt;{@link #peekFirst() peekFirst()}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt;Deques can also be used as LIFO (Last-In-First-Out) stacks.  This
                     interface should be used in preference to the legacy {@link Stack} class.
                     When a deque is used as a stack, elements are pushed and popped from the
                     beginning of the deque.  Stack methods are equivalent to {@code Deque}
                     methods as indicated in the table below:
                    
                     &lt;table class="striped"&gt;
                     &lt;caption&gt;Comparison of Stack and Deque methods&lt;/caption&gt;
                      &lt;thead&gt;
                      &lt;tr&gt;
                        &lt;th scope="col"&gt; Stack Method&lt;/th&gt;
                        &lt;th scope="col"&gt; Equivalent {@code Deque} Method&lt;/th&gt;
                      &lt;/tr&gt;
                      &lt;/thead&gt;
                      &lt;tbody&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;{@link #push(Object) push(e)}&lt;/th&gt;
                        &lt;td&gt;{@link #addFirst(Object) addFirst(e)}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;{@link #pop() pop()}&lt;/th&gt;
                        &lt;td&gt;{@link #removeFirst() removeFirst()}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;tr&gt;
                        &lt;th scope="row"&gt;{@link #peek() peek()}&lt;/th&gt;
                        &lt;td&gt;{@link #getFirst() getFirst()}&lt;/td&gt;
                      &lt;/tr&gt;
                      &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt;Note that the {@link #peek peek} method works equally well when
                     a deque is used as a queue or a stack; in either case, elements are
                     drawn from the beginning of the deque.
                    
                     &lt;p&gt;This interface provides two methods to remove interior
                     elements, {@link #removeFirstOccurrence removeFirstOccurrence} and
                     {@link #removeLastOccurrence removeLastOccurrence}.
                    
                     &lt;p&gt;Unlike the {@link List} interface, this interface does not
                     provide support for indexed access to elements.
                    
                     &lt;p&gt;While {@code Deque} implementations are not strictly required
                     to prohibit the insertion of null elements, they are strongly
                     encouraged to do so.  Users of any {@code Deque} implementations
                     that do allow null elements are strongly encouraged &lt;i&gt;not&lt;/i&gt; to
                     take advantage of the ability to insert nulls.  This is so because
                     {@code null} is used as a special return value by various methods
                     to indicate that the deque is empty.
                    
                     &lt;p&gt;{@code Deque} implementations generally do not define
                     element-based versions of the {@code equals} and {@code hashCode}
                     methods, but instead inherit the identity-based versions from class
                     {@code Object}.
                    
                     &lt;p&gt;This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @author Doug Lea
                     @author Josh Bloch
                     @since  1.6
                     @param &lt;E&gt; the type of elements held in this deque
                    </javadoc>
            </acts>
            <acts name="Formattable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes/>
                <javadoc xml:space="preserve">
                     The {@code Formattable} interface must be implemented by any class that
                     needs to perform custom formatting using the {@code 's'} conversion
                     specifier of {@link java.util.Formatter}.  This interface allows basic
                     control for formatting arbitrary objects.
                    
                     For example, the following class prints out different representations of a
                     stock's name depending on the flags and length constraints:
                    
                     &lt;pre&gt; {@code
                       import java.nio.CharBuffer;
                       import java.util.Formatter;
                       import java.util.Formattable;
                       import java.util.Locale;
                       import static java.util.FormattableFlags.*;
                    
                       ...
                    
                       public class StockName implements Formattable {
                           private String symbol, companyName, frenchCompanyName;
                           public StockName(String symbol, String companyName,
                                            String frenchCompanyName) {
                               ...
                           }
                    
                           ...
                    
                           public void formatTo(Formatter fmt, int f, int width, int precision) {
                               StringBuilder sb = new StringBuilder();
                    
                               // decide form of name
                               String name = companyName;
                               if (fmt.locale().equals(Locale.FRANCE))
                                   name = frenchCompanyName;
                               boolean alternate = (f &amp; ALTERNATE) == ALTERNATE;
                               boolean usesymbol = alternate || (precision != -1 &amp;&amp; precision &lt; 10);
                               String out = (usesymbol ? symbol : name);
                    
                               // apply precision
                               if (precision == -1 || out.length() &lt; precision) {
                                   // write it all
                                   sb.append(out);
                               } else {
                                   sb.append(out.substring(0, precision - 1)).append('*');
                               }
                    
                               // apply width and justification
                               int len = sb.length();
                               if (len &lt; width)
                                   for (int i = 0; i &lt; width - len; i++)
                                       if ((f &amp; LEFT_JUSTIFY) == LEFT_JUSTIFY)
                                           sb.append(' ');
                                       else
                                           sb.insert(0, ' ');
                    
                               fmt.format(sb.toString());
                           }
                    
                           public String toString() {
                               return String.format("%s - %s", symbol, companyName);
                           }
                       }
                     }&lt;/pre&gt;
                    
                     &lt;p&gt; When used in conjunction with the {@link java.util.Formatter}, the above
                     class produces the following output for various format strings.
                    
                     &lt;pre&gt; {@code
                       Formatter fmt = new Formatter();
                       StockName sn = new StockName("HUGE", "Huge Fruit, Inc.",
                                                    "Fruit Titanesque, Inc.");
                       fmt.format("%s", sn);                   //   -&gt; "Huge Fruit, Inc."
                       fmt.format("%s", sn.toString());        //   -&gt; "HUGE - Huge Fruit, Inc."
                       fmt.format("%#s", sn);                  //   -&gt; "HUGE"
                       fmt.format("%-10.8s", sn);              //   -&gt; "HUGE      "
                       fmt.format("%.12s", sn);                //   -&gt; "Huge Fruit,*"
                       fmt.format(Locale.FRANCE, "%25s", sn);  //   -&gt; "   Fruit Titanesque, Inc."
                     }&lt;/pre&gt;
                    
                     &lt;p&gt; Formattables are not necessarily safe for multithreaded access.  Thread
                     safety is optional and may be enforced by classes that extend and implement
                     this interface.
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to
                     any method in this interface will cause a {@link
                     NullPointerException} to be thrown.
                    
                     @since  1.5
                    </javadoc>
            </acts>
            <acts name="Observable" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class represents an observable object, or "data"
                     in the model-view paradigm. It can be subclassed to represent an
                     object that the application wants to have observed.
                     &lt;p&gt;
                     An observable object can have one or more observers. An observer
                     may be any object that implements interface {@code Observer}. After an
                     observable instance changes, an application calling the
                     {@code Observable}'s {@code notifyObservers} method
                     causes all of its observers to be notified of the change by a call
                     to their {@code update} method.
                     &lt;p&gt;
                     The order in which notifications will be delivered is unspecified.
                     The default implementation provided in the Observable class will
                     notify Observers in the order in which they registered interest, but
                     subclasses may change this order, use no guaranteed order, deliver
                     notifications on separate threads, or may guarantee that their
                     subclass follows this order, as they choose.
                     &lt;p&gt;
                     Note that this notification mechanism has nothing to do with threads
                     and is completely separate from the {@code wait} and {@code notify}
                     mechanism of class {@code Object}.
                     &lt;p&gt;
                     When an observable object is newly created, its set of observers is
                     empty. Two observers are considered the same if and only if the
                     {@code equals} method returns true for them.
                    
                     @author  Chris Warth
                     @see     java.util.Observable#notifyObservers()
                     @see     java.util.Observable#notifyObservers(java.lang.Object)
                     @see     java.util.Observer
                     @see     java.util.Observer#update(java.util.Observable, java.lang.Object)
                     @since   1.0
                    
                     @deprecated
                     This class and the {@link Observer} interface have been deprecated.
                     The event model supported by {@code Observer} and {@code Observable}
                     is quite limited, the order of notifications delivered by
                     {@code Observable} is unspecified, and state changes are not in
                     one-for-one correspondence with notifications.
                     For a richer event model, consider using the
                     {@link java.beans} package.  For reliable and ordered
                     messaging among threads, consider using one of the concurrent data
                     structures in the {@link java.util.concurrent} package.
                     For reactive streams style programming, see the
                     {@link java.util.concurrent.Flow} API.
                    </javadoc>
            </acts>
            <acts name="OptionalDouble" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A container object which may or may not contain a {@code double} value.
                     If a value is present, {@code isPresent()} returns {@code true}. If no
                     value is present, the object is considered &lt;i&gt;empty&lt;/i&gt; and
                     {@code isPresent()} returns {@code false}.
                    
                     &lt;p&gt;Additional methods that depend on the presence or absence of a contained
                     value are provided, such as {@link #orElse(double) orElse()}
                     (returns a default value if no value is present) and
                     {@link #ifPresent(DoubleConsumer) ifPresent()} (performs
                     an action if a value is present).
                    
                     &lt;p&gt;This is a &lt;a href="../lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code OptionalDouble} may have unpredictable results and should be avoided.
                    
                     @apiNote
                     {@code OptionalDouble} is primarily intended for use as a method return type where
                     there is a clear need to represent "no result." A variable whose type is
                     {@code OptionalDouble} should never itself be {@code null}; it should always point
                     to an {@code OptionalDouble} instance.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="StringTokenizer" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Enumeration"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The string tokenizer class allows an application to break a
                     string into tokens. The tokenization method is much simpler than
                     the one used by the {@code StreamTokenizer} class. The
                     {@code StringTokenizer} methods do not distinguish among
                     identifiers, numbers, and quoted strings, nor do they recognize
                     and skip comments.
                     &lt;p&gt;
                     The set of delimiters (the characters that separate tokens) may
                     be specified either at creation time or on a per-token basis.
                     &lt;p&gt;
                     An instance of {@code StringTokenizer} behaves in one of two
                     ways, depending on whether it was created with the
                     {@code returnDelims} flag having the value {@code true}
                     or {@code false}:
                     &lt;ul&gt;
                     &lt;li&gt;If the flag is {@code false}, delimiter characters serve to
                         separate tokens. A token is a maximal sequence of consecutive
                         characters that are not delimiters.
                     &lt;li&gt;If the flag is {@code true}, delimiter characters are themselves
                         considered to be tokens. A token is thus either one delimiter
                         character, or a maximal sequence of consecutive characters that are
                         not delimiters.
                     &lt;/ul&gt;&lt;p&gt;
                     A {@code StringTokenizer} object internally maintains a current
                     position within the string to be tokenized. Some operations advance this
                     current position past the characters processed.&lt;p&gt;
                     A token is returned by taking a substring of the string that was used to
                     create the {@code StringTokenizer} object.
                     &lt;p&gt;
                     The following is one example of the use of the tokenizer. The code:
                     &lt;blockquote&gt;&lt;pre&gt;
                         StringTokenizer st = new StringTokenizer("this is a test");
                         while (st.hasMoreTokens()) {
                             System.out.println(st.nextToken());
                         }
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     &lt;p&gt;
                     prints the following output:
                     &lt;blockquote&gt;&lt;pre&gt;
                         this
                         is
                         a
                         test
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt;
                     {@code StringTokenizer} is a legacy class that is retained for
                     compatibility reasons although its use is discouraged in new code. It is
                     recommended that anyone seeking this functionality use the {@code split}
                     method of {@code String} or the java.util.regex package instead.
                     &lt;p&gt;
                     The following example illustrates how the {@code String.split}
                     method can be used to break up a string into its basic tokens:
                     &lt;blockquote&gt;&lt;pre&gt;
                         String[] result = "this is a test".split("\\s");
                         for (int x=0; x&amp;lt;result.length; x++)
                             System.out.println(result[x]);
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     &lt;p&gt;
                     prints the following output:
                     &lt;blockquote&gt;&lt;pre&gt;
                         this
                         is
                         a
                         test
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     @author  unascribed
                     @see     java.io.StreamTokenizer
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="BigDecimalLayoutForm" access="PUBLIC" declaringClass="Formatter" kind="TYPE" typeKind="ENUM" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="OptionalLong" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A container object which may or may not contain a {@code long} value.
                     If a value is present, {@code isPresent()} returns {@code true}. If no
                     value is present, the object is considered &lt;i&gt;empty&lt;/i&gt; and
                     {@code isPresent()} returns {@code false}.
                    
                     &lt;p&gt;Additional methods that depend on the presence or absence of a contained
                     value are provided, such as {@link #orElse(long) orElse()}
                     (returns a default value if no value is present) and
                     {@link #ifPresent(LongConsumer) ifPresent()} (performs an
                     action if a value is present).
                    
                     &lt;p&gt;This is a &lt;a href="../lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code OptionalLong} may have unpredictable results and should be avoided.
                    
                     @apiNote
                     {@code OptionalLong} is primarily intended for use as a method return type where
                     there is a clear need to represent "no result." A variable whose type is
                     {@code OptionalLong} should never itself be {@code null}; it should always point
                     to an {@code OptionalLong} instance.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="IllegalFormatException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.IllegalArgumentException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Unchecked exception thrown when a format string contains an illegal syntax
                     or a format specifier that is incompatible with the given arguments.  Only
                     explicit subtypes of this exception which correspond to specific errors
                     should be instantiated.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="MissingFormatWidthException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.IllegalFormatException"/>
                    <superType superType="java.lang.IllegalArgumentException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Unchecked exception thrown when the format width is required.
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
                     method or constructor in this class will cause a {@link
                     NullPointerException} to be thrown.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="LinkedHashSet" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Set"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.util.HashSet"/>
                    <superType superType="java.util.AbstractSet"/>
                    <superType superType="java.util.AbstractCollection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;p&gt;Hash table and linked list implementation of the {@code Set} interface,
                     with predictable iteration order.  This implementation differs from
                     {@code HashSet} in that it maintains a doubly-linked list running through
                     all of its entries.  This linked list defines the iteration ordering,
                     which is the order in which elements were inserted into the set
                     (&lt;i&gt;insertion-order&lt;/i&gt;).  Note that insertion order is &lt;i&gt;not&lt;/i&gt; affected
                     if an element is &lt;i&gt;re-inserted&lt;/i&gt; into the set.  (An element {@code e}
                     is reinserted into a set {@code s} if {@code s.add(e)} is invoked when
                     {@code s.contains(e)} would return {@code true} immediately prior to
                     the invocation.)
                    
                     &lt;p&gt;This implementation spares its clients from the unspecified, generally
                     chaotic ordering provided by {@link HashSet}, without incurring the
                     increased cost associated with {@link TreeSet}.  It can be used to
                     produce a copy of a set that has the same order as the original, regardless
                     of the original set's implementation:
                     &lt;pre&gt;
                         void foo(Set s) {
                             Set copy = new LinkedHashSet(s);
                             ...
                         }
                     &lt;/pre&gt;
                     This technique is particularly useful if a module takes a set on input,
                     copies it, and later returns results whose order is determined by that of
                     the copy.  (Clients generally appreciate having things returned in the same
                     order they were presented.)
                    
                     &lt;p&gt;This class provides all of the optional {@code Set} operations, and
                     permits null elements.  Like {@code HashSet}, it provides constant-time
                     performance for the basic operations ({@code add}, {@code contains} and
                     {@code remove}), assuming the hash function disperses elements
                     properly among the buckets.  Performance is likely to be just slightly
                     below that of {@code HashSet}, due to the added expense of maintaining the
                     linked list, with one exception: Iteration over a {@code LinkedHashSet}
                     requires time proportional to the &lt;i&gt;size&lt;/i&gt; of the set, regardless of
                     its capacity.  Iteration over a {@code HashSet} is likely to be more
                     expensive, requiring time proportional to its &lt;i&gt;capacity&lt;/i&gt;.
                    
                     &lt;p&gt;A linked hash set has two parameters that affect its performance:
                     &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  They are defined precisely
                     as for {@code HashSet}.  Note, however, that the penalty for choosing an
                     excessively high value for initial capacity is less severe for this class
                     than for {@code HashSet}, as iteration times for this class are unaffected
                     by capacity.
                    
                     &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
                     If multiple threads access a linked hash set concurrently, and at least
                     one of the threads modifies the set, it &lt;em&gt;must&lt;/em&gt; be synchronized
                     externally.  This is typically accomplished by synchronizing on some
                     object that naturally encapsulates the set.
                    
                     If no such object exists, the set should be "wrapped" using the
                     {@link Collections#synchronizedSet Collections.synchronizedSet}
                     method.  This is best done at creation time, to prevent accidental
                     unsynchronized access to the set: &lt;pre&gt;
                       Set s = Collections.synchronizedSet(new LinkedHashSet(...));&lt;/pre&gt;
                    
                     &lt;p&gt;The iterators returned by this class's {@code iterator} method are
                     &lt;em&gt;fail-fast&lt;/em&gt;: if the set is modified at any time after the iterator
                     is created, in any way except through the iterator's own {@code remove}
                     method, the iterator will throw a {@link ConcurrentModificationException}.
                     Thus, in the face of concurrent modification, the iterator fails quickly
                     and cleanly, rather than risking arbitrary, non-deterministic behavior at
                     an undetermined time in the future.
                    
                     &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                     as it is, generally speaking, impossible to make any hard guarantees in the
                     presence of unsynchronized concurrent modification.  Fail-fast iterators
                     throw {@code ConcurrentModificationException} on a best-effort basis.
                     Therefore, it would be wrong to write a program that depended on this
                     exception for its correctness:   &lt;i&gt;the fail-fast behavior of iterators
                     should be used only to detect bugs.&lt;/i&gt;
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;E&gt; the type of elements maintained by this set
                    
                     @author  Josh Bloch
                     @see     Object#hashCode()
                     @see     Collection
                     @see     Set
                     @see     HashSet
                     @see     TreeSet
                     @see     Hashtable
                     @since   1.4
                    </javadoc>
            </acts>
            <acts name="Locale" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A &lt;code&gt;Locale&lt;/code&gt; object represents a specific geographical, political,
                     or cultural region. An operation that requires a &lt;code&gt;Locale&lt;/code&gt; to perform
                     its task is called &lt;em&gt;locale-sensitive&lt;/em&gt; and uses the &lt;code&gt;Locale&lt;/code&gt;
                     to tailor information for the user. For example, displaying a number
                     is a locale-sensitive operation&amp;mdash; the number should be formatted
                     according to the customs and conventions of the user's native country,
                     region, or culture.
                    
                     &lt;p&gt; The {@code Locale} class implements IETF BCP 47 which is composed of
                     &lt;a href="http://tools.ietf.org/html/rfc4647"&gt;RFC 4647 "Matching of Language
                     Tags"&lt;/a&gt; and &lt;a href="http://tools.ietf.org/html/rfc5646"&gt;RFC 5646 "Tags
                     for Identifying Languages"&lt;/a&gt; with support for the LDML (UTS#35, "Unicode
                     Locale Data Markup Language") BCP 47-compatible extensions for locale data
                     exchange.
                    
                     &lt;p&gt; A &lt;code&gt;Locale&lt;/code&gt; object logically consists of the fields
                     described below.
                    
                     &lt;dl&gt;
                       &lt;dt&gt;&lt;a id="def_language"&gt;&lt;b&gt;language&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
                    
                       &lt;dd&gt;ISO 639 alpha-2 or alpha-3 language code, or registered
                       language subtags up to 8 alpha letters (for future enhancements).
                       When a language has both an alpha-2 code and an alpha-3 code, the
                       alpha-2 code must be used.  You can find a full list of valid
                       language codes in the IANA Language Subtag Registry (search for
                       "Type: language").  The language field is case insensitive, but
                       &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to lower case.&lt;/dd&gt;
                    
                       &lt;dd&gt;Well-formed language values have the form
                       &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt;.  Note that this is not the full
                       BCP47 language production, since it excludes extlang.  They are
                       not needed since modern three-letter language codes replace
                       them.&lt;/dd&gt;
                    
                       &lt;dd&gt;Example: "en" (English), "ja" (Japanese), "kok" (Konkani)&lt;/dd&gt;
                    
                       &lt;dt&gt;&lt;a id="def_script"&gt;&lt;b&gt;script&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
                    
                       &lt;dd&gt;ISO 15924 alpha-4 script code.  You can find a full list of
                       valid script codes in the IANA Language Subtag Registry (search
                       for "Type: script").  The script field is case insensitive, but
                       &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to title case (the first
                       letter is upper case and the rest of the letters are lower
                       case).&lt;/dd&gt;
                    
                       &lt;dd&gt;Well-formed script values have the form
                       &lt;code&gt;[a-zA-Z]{4}&lt;/code&gt;&lt;/dd&gt;
                    
                       &lt;dd&gt;Example: "Latn" (Latin), "Cyrl" (Cyrillic)&lt;/dd&gt;
                    
                       &lt;dt&gt;&lt;a id="def_region"&gt;&lt;b&gt;country (region)&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
                    
                       &lt;dd&gt;ISO 3166 alpha-2 country code or UN M.49 numeric-3 area code.
                       You can find a full list of valid country and region codes in the
                       IANA Language Subtag Registry (search for "Type: region").  The
                       country (region) field is case insensitive, but
                       &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to upper case.&lt;/dd&gt;
                    
                       &lt;dd&gt;Well-formed country/region values have
                       the form &lt;code&gt;[a-zA-Z]{2} | [0-9]{3}&lt;/code&gt;&lt;/dd&gt;
                    
                       &lt;dd&gt;Example: "US" (United States), "FR" (France), "029"
                       (Caribbean)&lt;/dd&gt;
                    
                       &lt;dt&gt;&lt;a id="def_variant"&gt;&lt;b&gt;variant&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
                    
                       &lt;dd&gt;Any arbitrary value used to indicate a variation of a
                       &lt;code&gt;Locale&lt;/code&gt;.  Where there are two or more variant values
                       each indicating its own semantics, these values should be ordered
                       by importance, with most important first, separated by
                       underscore('_').  The variant field is case sensitive.&lt;/dd&gt;
                    
                       &lt;dd&gt;Note: IETF BCP 47 places syntactic restrictions on variant
                       subtags.  Also BCP 47 subtags are strictly used to indicate
                       additional variations that define a language or its dialects that
                       are not covered by any combinations of language, script and
                       region subtags.  You can find a full list of valid variant codes
                       in the IANA Language Subtag Registry (search for "Type: variant").
                    
                       &lt;p&gt;However, the variant field in &lt;code&gt;Locale&lt;/code&gt; has
                       historically been used for any kind of variation, not just
                       language variations.  For example, some supported variants
                       available in Java SE Runtime Environments indicate alternative
                       cultural behaviors such as calendar type or number script.  In
                       BCP 47 this kind of information, which does not identify the
                       language, is supported by extension subtags or private use
                       subtags.&lt;/dd&gt;
                    
                       &lt;dd&gt;Well-formed variant values have the form &lt;code&gt;SUBTAG
                       (('_'|'-') SUBTAG)*&lt;/code&gt; where &lt;code&gt;SUBTAG =
                       [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}&lt;/code&gt;. (Note: BCP 47 only
                       uses hyphen ('-') as a delimiter, this is more lenient).&lt;/dd&gt;
                    
                       &lt;dd&gt;Example: "polyton" (Polytonic Greek), "POSIX"&lt;/dd&gt;
                    
                       &lt;dt&gt;&lt;a id="def_extensions"&gt;&lt;b&gt;extensions&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
                    
                       &lt;dd&gt;A map from single character keys to string values, indicating
                       extensions apart from language identification.  The extensions in
                       &lt;code&gt;Locale&lt;/code&gt; implement the semantics and syntax of BCP 47
                       extension subtags and private use subtags. The extensions are
                       case insensitive, but &lt;code&gt;Locale&lt;/code&gt; canonicalizes all
                       extension keys and values to lower case. Note that extensions
                       cannot have empty values.&lt;/dd&gt;
                    
                       &lt;dd&gt;Well-formed keys are single characters from the set
                       &lt;code&gt;[0-9a-zA-Z]&lt;/code&gt;.  Well-formed values have the form
                       &lt;code&gt;SUBTAG ('-' SUBTAG)*&lt;/code&gt; where for the key 'x'
                       &lt;code&gt;SUBTAG = [0-9a-zA-Z]{1,8}&lt;/code&gt; and for other keys
                       &lt;code&gt;SUBTAG = [0-9a-zA-Z]{2,8}&lt;/code&gt; (that is, 'x' allows
                       single-character subtags).&lt;/dd&gt;
                    
                       &lt;dd&gt;Example: key="u"/value="ca-japanese" (Japanese Calendar),
                       key="x"/value="java-1-7"&lt;/dd&gt;
                     &lt;/dl&gt;
                    
                     &lt;b&gt;Note:&lt;/b&gt; Although BCP 47 requires field values to be registered
                     in the IANA Language Subtag Registry, the &lt;code&gt;Locale&lt;/code&gt; class
                     does not provide any validation features.  The &lt;code&gt;Builder&lt;/code&gt;
                     only checks if an individual field satisfies the syntactic
                     requirement (is well-formed), but does not validate the value
                     itself.  See {@link Builder} for details.
                    
                     &lt;h3&gt;&lt;a id="def_locale_extension"&gt;Unicode locale/language extension&lt;/a&gt;&lt;/h3&gt;
                    
                     &lt;p&gt;UTS#35, "Unicode Locale Data Markup Language" defines optional
                     attributes and keywords to override or refine the default behavior
                     associated with a locale.  A keyword is represented by a pair of
                     key and type.  For example, "nu-thai" indicates that Thai local
                     digits (value:"thai") should be used for formatting numbers
                     (key:"nu").
                    
                     &lt;p&gt;The keywords are mapped to a BCP 47 extension value using the
                     extension key 'u' ({@link #UNICODE_LOCALE_EXTENSION}).  The above
                     example, "nu-thai", becomes the extension "u-nu-thai".
                    
                     &lt;p&gt;Thus, when a &lt;code&gt;Locale&lt;/code&gt; object contains Unicode locale
                     attributes and keywords,
                     &lt;code&gt;getExtension(UNICODE_LOCALE_EXTENSION)&lt;/code&gt; will return a
                     String representing this information, for example, "nu-thai".  The
                     &lt;code&gt;Locale&lt;/code&gt; class also provides {@link
                     #getUnicodeLocaleAttributes}, {@link #getUnicodeLocaleKeys}, and
                     {@link #getUnicodeLocaleType} which allow you to access Unicode
                     locale attributes and key/type pairs directly.  When represented as
                     a string, the Unicode Locale Extension lists attributes
                     alphabetically, followed by key/type sequences with keys listed
                     alphabetically (the order of subtags comprising a key's type is
                     fixed when the type is defined)
                    
                     &lt;p&gt;A well-formed locale key has the form
                     &lt;code&gt;[0-9a-zA-Z]{2}&lt;/code&gt;.  A well-formed locale type has the
                     form &lt;code&gt;"" | [0-9a-zA-Z]{3,8} ('-' [0-9a-zA-Z]{3,8})*&lt;/code&gt; (it
                     can be empty, or a series of subtags 3-8 alphanums in length).  A
                     well-formed locale attribute has the form
                     &lt;code&gt;[0-9a-zA-Z]{3,8}&lt;/code&gt; (it is a single subtag with the same
                     form as a locale type subtag).
                    
                     &lt;p&gt;The Unicode locale extension specifies optional behavior in
                     locale-sensitive services.  Although the LDML specification defines
                     various keys and values, actual locale-sensitive service
                     implementations in a Java Runtime Environment might not support any
                     particular Unicode locale attributes or key/type pairs.
                    
                     &lt;h4&gt;Creating a Locale&lt;/h4&gt;
                    
                     &lt;p&gt;There are several different ways to create a &lt;code&gt;Locale&lt;/code&gt;
                     object.
                    
                     &lt;h5&gt;Builder&lt;/h5&gt;
                    
                     &lt;p&gt;Using {@link Builder} you can construct a &lt;code&gt;Locale&lt;/code&gt; object
                     that conforms to BCP 47 syntax.
                    
                     &lt;h5&gt;Constructors&lt;/h5&gt;
                    
                     &lt;p&gt;The &lt;code&gt;Locale&lt;/code&gt; class provides three constructors:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                         {@link #Locale(String language)}
                         {@link #Locale(String language, String country)}
                         {@link #Locale(String language, String country, String variant)}
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                     These constructors allow you to create a &lt;code&gt;Locale&lt;/code&gt; object
                     with language, country and variant, but you cannot specify
                     script or extensions.
                    
                     &lt;h5&gt;Factory Methods&lt;/h5&gt;
                    
                     &lt;p&gt;The method {@link #forLanguageTag} creates a &lt;code&gt;Locale&lt;/code&gt;
                     object for a well-formed BCP 47 language tag.
                    
                     &lt;h5&gt;Locale Constants&lt;/h5&gt;
                    
                     &lt;p&gt;The &lt;code&gt;Locale&lt;/code&gt; class provides a number of convenient constants
                     that you can use to create &lt;code&gt;Locale&lt;/code&gt; objects for commonly used
                     locales. For example, the following creates a &lt;code&gt;Locale&lt;/code&gt; object
                     for the United States:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                         Locale.US
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;h4&gt;&lt;a id="LocaleMatching"&gt;Locale Matching&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;p&gt;If an application or a system is internationalized and provides localized
                     resources for multiple locales, it sometimes needs to find one or more
                     locales (or language tags) which meet each user's specific preferences. Note
                     that a term "language tag" is used interchangeably with "locale" in this
                     locale matching documentation.
                    
                     &lt;p&gt;In order to do matching a user's preferred locales to a set of language
                     tags, &lt;a href="http://tools.ietf.org/html/rfc4647"&gt;RFC 4647 Matching of
                     Language Tags&lt;/a&gt; defines two mechanisms: filtering and lookup.
                     &lt;em&gt;Filtering&lt;/em&gt; is used to get all matching locales, whereas
                     &lt;em&gt;lookup&lt;/em&gt; is to choose the best matching locale.
                     Matching is done case-insensitively. These matching mechanisms are described
                     in the following sections.
                    
                     &lt;p&gt;A user's preference is called a &lt;em&gt;Language Priority List&lt;/em&gt; and is
                     expressed as a list of language ranges. There are syntactically two types of
                     language ranges: basic and extended. See
                     {@link Locale.LanguageRange Locale.LanguageRange} for details.
                    
                     &lt;h5&gt;Filtering&lt;/h5&gt;
                    
                     &lt;p&gt;The filtering operation returns all matching language tags. It is defined
                     in RFC 4647 as follows:
                     "In filtering, each language range represents the least specific language
                     tag (that is, the language tag with fewest number of subtags) that is an
                     acceptable match. All of the language tags in the matching set of tags will
                     have an equal or greater number of subtags than the language range. Every
                     non-wildcard subtag in the language range will appear in every one of the
                     matching language tags."
                    
                     &lt;p&gt;There are two types of filtering: filtering for basic language ranges
                     (called "basic filtering") and filtering for extended language ranges
                     (called "extended filtering"). They may return different results by what
                     kind of language ranges are included in the given Language Priority List.
                     {@link Locale.FilteringMode} is a parameter to specify how filtering should
                     be done.
                    
                     &lt;h5&gt;Lookup&lt;/h5&gt;
                    
                     &lt;p&gt;The lookup operation returns the best matching language tags. It is
                     defined in RFC 4647 as follows:
                     "By contrast with filtering, each language range represents the most
                     specific tag that is an acceptable match.  The first matching tag found,
                     according to the user's priority, is considered the closest match and is the
                     item returned."
                    
                     &lt;p&gt;For example, if a Language Priority List consists of two language ranges,
                     {@code "zh-Hant-TW"} and {@code "en-US"}, in prioritized order, lookup
                     method progressively searches the language tags below in order to find the
                     best matching language tag.
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                        1. zh-Hant-TW
                        2. zh-Hant
                        3. zh
                        4. en-US
                        5. en
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                     If there is a language tag which matches completely to a language range
                     above, the language tag is returned.
                    
                     &lt;p&gt;{@code "*"} is the special language range, and it is ignored in lookup.
                    
                     &lt;p&gt;If multiple language tags match as a result of the subtag {@code '*'}
                     included in a language range, the first matching language tag returned by
                     an {@link Iterator} over a {@link Collection} of language tags is treated as
                     the best matching one.
                    
                     &lt;h4&gt;Use of Locale&lt;/h4&gt;
                    
                     &lt;p&gt;Once you've created a &lt;code&gt;Locale&lt;/code&gt; you can query it for information
                     about itself. Use &lt;code&gt;getCountry&lt;/code&gt; to get the country (or region)
                     code and &lt;code&gt;getLanguage&lt;/code&gt; to get the language code.
                     You can use &lt;code&gt;getDisplayCountry&lt;/code&gt; to get the
                     name of the country suitable for displaying to the user. Similarly,
                     you can use &lt;code&gt;getDisplayLanguage&lt;/code&gt; to get the name of
                     the language suitable for displaying to the user. Interestingly,
                     the &lt;code&gt;getDisplayXXX&lt;/code&gt; methods are themselves locale-sensitive
                     and have two versions: one that uses the default
                     {@link Locale.Category#DISPLAY DISPLAY} locale and one
                     that uses the locale specified as an argument.
                    
                     &lt;p&gt;The Java Platform provides a number of classes that perform locale-sensitive
                     operations. For example, the &lt;code&gt;NumberFormat&lt;/code&gt; class formats
                     numbers, currency, and percentages in a locale-sensitive manner. Classes
                     such as &lt;code&gt;NumberFormat&lt;/code&gt; have several convenience methods
                     for creating a default object of that type. For example, the
                     &lt;code&gt;NumberFormat&lt;/code&gt; class provides these three convenience methods
                     for creating a default &lt;code&gt;NumberFormat&lt;/code&gt; object:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                         NumberFormat.getInstance()
                         NumberFormat.getCurrencyInstance()
                         NumberFormat.getPercentInstance()
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                     Each of these methods has two variants; one with an explicit locale
                     and one without; the latter uses the default
                     {@link Locale.Category#FORMAT FORMAT} locale:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                         NumberFormat.getInstance(myLocale)
                         NumberFormat.getCurrencyInstance(myLocale)
                         NumberFormat.getPercentInstance(myLocale)
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                     A &lt;code&gt;Locale&lt;/code&gt; is the mechanism for identifying the kind of object
                     (&lt;code&gt;NumberFormat&lt;/code&gt;) that you would like to get. The locale is
                     &lt;STRONG&gt;just&lt;/STRONG&gt; a mechanism for identifying objects,
                     &lt;STRONG&gt;not&lt;/STRONG&gt; a container for the objects themselves.
                    
                     &lt;h4&gt;Compatibility&lt;/h4&gt;
                    
                     &lt;p&gt;In order to maintain compatibility with existing usage, Locale's
                     constructors retain their behavior prior to the Java Runtime
                     Environment version 1.7.  The same is largely true for the
                     &lt;code&gt;toString&lt;/code&gt; method. Thus Locale objects can continue to
                     be used as they were. In particular, clients who parse the output
                     of toString into language, country, and variant fields can continue
                     to do so (although this is strongly discouraged), although the
                     variant field will have additional information in it if script or
                     extensions are present.
                    
                     &lt;p&gt;In addition, BCP 47 imposes syntax restrictions that are not
                     imposed by Locale's constructors. This means that conversions
                     between some Locales and BCP 47 language tags cannot be made without
                     losing information. Thus &lt;code&gt;toLanguageTag&lt;/code&gt; cannot
                     represent the state of locales whose language, country, or variant
                     do not conform to BCP 47.
                    
                     &lt;p&gt;Because of these issues, it is recommended that clients migrate
                     away from constructing non-conforming locales and use the
                     &lt;code&gt;forLanguageTag&lt;/code&gt; and &lt;code&gt;Locale.Builder&lt;/code&gt; APIs instead.
                     Clients desiring a string representation of the complete locale can
                     then always rely on &lt;code&gt;toLanguageTag&lt;/code&gt; for this purpose.
                    
                     &lt;h5&gt;&lt;a id="special_cases_constructor"&gt;Special cases&lt;/a&gt;&lt;/h5&gt;
                    
                     &lt;p&gt;For compatibility reasons, two
                     non-conforming locales are treated as special cases.  These are
                     &lt;b&gt;{@code ja_JP_JP}&lt;/b&gt; and &lt;b&gt;{@code th_TH_TH}&lt;/b&gt;. These are ill-formed
                     in BCP 47 since the variants are too short. To ease migration to BCP 47,
                     these are treated specially during construction.  These two cases (and only
                     these) cause a constructor to generate an extension, all other values behave
                     exactly as they did prior to Java 7.
                    
                     &lt;p&gt;Java has used {@code ja_JP_JP} to represent Japanese as used in
                     Japan together with the Japanese Imperial calendar. This is now
                     representable using a Unicode locale extension, by specifying the
                     Unicode locale key {@code ca} (for "calendar") and type
                     {@code japanese}. When the Locale constructor is called with the
                     arguments "ja", "JP", "JP", the extension "u-ca-japanese" is
                     automatically added.
                    
                     &lt;p&gt;Java has used {@code th_TH_TH} to represent Thai as used in
                     Thailand together with Thai digits. This is also now representable using
                     a Unicode locale extension, by specifying the Unicode locale key
                     {@code nu} (for "number") and value {@code thai}. When the Locale
                     constructor is called with the arguments "th", "TH", "TH", the
                     extension "u-nu-thai" is automatically added.
                    
                     &lt;h5&gt;Serialization&lt;/h5&gt;
                    
                     &lt;p&gt;During serialization, writeObject writes all fields to the output
                     stream, including extensions.
                    
                     &lt;p&gt;During deserialization, readResolve adds extensions as described
                     in &lt;a href="#special_cases_constructor"&gt;Special Cases&lt;/a&gt;, only
                     for the two cases th_TH_TH and ja_JP_JP.
                    
                     &lt;h5&gt;Legacy language codes&lt;/h5&gt;
                    
                     &lt;p&gt;Locale's constructor has always converted three language codes to
                     their earlier, obsoleted forms: {@code he} maps to {@code iw},
                     {@code yi} maps to {@code ji}, and {@code id} maps to
                     {@code in}.  This continues to be the case, in order to not break
                     backwards compatibility.
                    
                     &lt;p&gt;The APIs added in 1.7 map between the old and new language codes,
                     maintaining the old codes internal to Locale (so that
                     &lt;code&gt;getLanguage&lt;/code&gt; and &lt;code&gt;toString&lt;/code&gt; reflect the old
                     code), but using the new codes in the BCP 47 language tag APIs (so
                     that &lt;code&gt;toLanguageTag&lt;/code&gt; reflects the new one). This
                     preserves the equivalence between Locales no matter which code or
                     API is used to construct them. Java's default resource bundle
                     lookup mechanism also implements this mapping, so that resources
                     can be named using either convention, see {@link ResourceBundle.Control}.
                    
                     &lt;h5&gt;Three-letter language/country(region) codes&lt;/h5&gt;
                    
                     &lt;p&gt;The Locale constructors have always specified that the language
                     and the country param be two characters in length, although in
                     practice they have accepted any length.  The specification has now
                     been relaxed to allow language codes of two to eight characters and
                     country (region) codes of two to three characters, and in
                     particular, three-letter language codes and three-digit region
                     codes as specified in the IANA Language Subtag Registry.  For
                     compatibility, the implementation still does not impose a length
                     constraint.
                    
                     @see Builder
                     @see ResourceBundle
                     @see java.text.Format
                     @see java.text.NumberFormat
                     @see java.text.Collator
                     @author Mark Davis
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="HashMap" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Map"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.util.AbstractMap"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Hash table based implementation of the {@code Map} interface.  This
                     implementation provides all of the optional map operations, and permits
                     {@code null} values and the {@code null} key.  (The {@code HashMap}
                     class is roughly equivalent to {@code Hashtable}, except that it is
                     unsynchronized and permits nulls.)  This class makes no guarantees as to
                     the order of the map; in particular, it does not guarantee that the order
                     will remain constant over time.
                    
                     &lt;p&gt;This implementation provides constant-time performance for the basic
                     operations ({@code get} and {@code put}), assuming the hash function
                     disperses the elements properly among the buckets.  Iteration over
                     collection views requires time proportional to the "capacity" of the
                     {@code HashMap} instance (the number of buckets) plus its size (the number
                     of key-value mappings).  Thus, it's very important not to set the initial
                     capacity too high (or the load factor too low) if iteration performance is
                     important.
                    
                     &lt;p&gt;An instance of {@code HashMap} has two parameters that affect its
                     performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The
                     &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial
                     capacity is simply the capacity at the time the hash table is created.  The
                     &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to
                     get before its capacity is automatically increased.  When the number of
                     entries in the hash table exceeds the product of the load factor and the
                     current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data
                     structures are rebuilt) so that the hash table has approximately twice the
                     number of buckets.
                    
                     &lt;p&gt;As a general rule, the default load factor (.75) offers a good
                     tradeoff between time and space costs.  Higher values decrease the
                     space overhead but increase the lookup cost (reflected in most of
                     the operations of the {@code HashMap} class, including
                     {@code get} and {@code put}).  The expected number of entries in
                     the map and its load factor should be taken into account when
                     setting its initial capacity, so as to minimize the number of
                     rehash operations.  If the initial capacity is greater than the
                     maximum number of entries divided by the load factor, no rehash
                     operations will ever occur.
                    
                     &lt;p&gt;If many mappings are to be stored in a {@code HashMap}
                     instance, creating it with a sufficiently large capacity will allow
                     the mappings to be stored more efficiently than letting it perform
                     automatic rehashing as needed to grow the table.  Note that using
                     many keys with the same {@code hashCode()} is a sure way to slow
                     down performance of any hash table. To ameliorate impact, when keys
                     are {@link Comparable}, this class may use comparison order among
                     keys to help break ties.
                    
                     &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
                     If multiple threads access a hash map concurrently, and at least one of
                     the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be
                     synchronized externally.  (A structural modification is any operation
                     that adds or deletes one or more mappings; merely changing the value
                     associated with a key that an instance already contains is not a
                     structural modification.)  This is typically accomplished by
                     synchronizing on some object that naturally encapsulates the map.
                    
                     If no such object exists, the map should be "wrapped" using the
                     {@link Collections#synchronizedMap Collections.synchronizedMap}
                     method.  This is best done at creation time, to prevent accidental
                     unsynchronized access to the map:&lt;pre&gt;
                       Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt;
                    
                     &lt;p&gt;The iterators returned by all of this class's "collection view methods"
                     are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after
                     the iterator is created, in any way except through the iterator's own
                     {@code remove} method, the iterator will throw a
                     {@link ConcurrentModificationException}.  Thus, in the face of concurrent
                     modification, the iterator fails quickly and cleanly, rather than risking
                     arbitrary, non-deterministic behavior at an undetermined time in the
                     future.
                    
                     &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                     as it is, generally speaking, impossible to make any hard guarantees in the
                     presence of unsynchronized concurrent modification.  Fail-fast iterators
                     throw {@code ConcurrentModificationException} on a best-effort basis.
                     Therefore, it would be wrong to write a program that depended on this
                     exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators
                     should be used only to detect bugs.&lt;/i&gt;
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;K&gt; the type of keys maintained by this map
                     @param &lt;V&gt; the type of mapped values
                    
                     @author  Doug Lea
                     @author  Josh Bloch
                     @author  Arthur van Hoff
                     @author  Neal Gafter
                     @see     Object#hashCode()
                     @see     Collection
                     @see     Map
                     @see     TreeMap
                     @see     Hashtable
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="IdentityHashMap" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Map"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.util.AbstractMap"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class implements the {@code Map} interface with a hash table, using
                     reference-equality in place of object-equality when comparing keys (and
                     values).  In other words, in an {@code IdentityHashMap}, two keys
                     {@code k1} and {@code k2} are considered equal if and only if
                     {@code (k1==k2)}.  (In normal {@code Map} implementations (like
                     {@code HashMap}) two keys {@code k1} and {@code k2} are considered equal
                     if and only if {@code (k1==null ? k2==null : k1.equals(k2))}.)
                    
                     &lt;p&gt;&lt;b&gt;This class is &lt;i&gt;not&lt;/i&gt; a general-purpose {@code Map}
                     implementation!  While this class implements the {@code Map} interface, it
                     intentionally violates {@code Map's} general contract, which mandates the
                     use of the {@code equals} method when comparing objects.  This class is
                     designed for use only in the rare cases wherein reference-equality
                     semantics are required.&lt;/b&gt;
                    
                     &lt;p&gt;A typical use of this class is &lt;i&gt;topology-preserving object graph
                     transformations&lt;/i&gt;, such as serialization or deep-copying.  To perform such
                     a transformation, a program must maintain a "node table" that keeps track
                     of all the object references that have already been processed.  The node
                     table must not equate distinct objects even if they happen to be equal.
                     Another typical use of this class is to maintain &lt;i&gt;proxy objects&lt;/i&gt;.  For
                     example, a debugging facility might wish to maintain a proxy object for
                     each object in the program being debugged.
                    
                     &lt;p&gt;This class provides all of the optional map operations, and permits
                     {@code null} values and the {@code null} key.  This class makes no
                     guarantees as to the order of the map; in particular, it does not guarantee
                     that the order will remain constant over time.
                    
                     &lt;p&gt;This class provides constant-time performance for the basic
                     operations ({@code get} and {@code put}), assuming the system
                     identity hash function ({@link System#identityHashCode(Object)})
                     disperses elements properly among the buckets.
                    
                     &lt;p&gt;This class has one tuning parameter (which affects performance but not
                     semantics): &lt;i&gt;expected maximum size&lt;/i&gt;.  This parameter is the maximum
                     number of key-value mappings that the map is expected to hold.  Internally,
                     this parameter is used to determine the number of buckets initially
                     comprising the hash table.  The precise relationship between the expected
                     maximum size and the number of buckets is unspecified.
                    
                     &lt;p&gt;If the size of the map (the number of key-value mappings) sufficiently
                     exceeds the expected maximum size, the number of buckets is increased.
                     Increasing the number of buckets ("rehashing") may be fairly expensive, so
                     it pays to create identity hash maps with a sufficiently large expected
                     maximum size.  On the other hand, iteration over collection views requires
                     time proportional to the number of buckets in the hash table, so it
                     pays not to set the expected maximum size too high if you are especially
                     concerned with iteration performance or memory usage.
                    
                     &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
                     If multiple threads access an identity hash map concurrently, and at
                     least one of the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt;
                     be synchronized externally.  (A structural modification is any operation
                     that adds or deletes one or more mappings; merely changing the value
                     associated with a key that an instance already contains is not a
                     structural modification.)  This is typically accomplished by
                     synchronizing on some object that naturally encapsulates the map.
                    
                     If no such object exists, the map should be "wrapped" using the
                     {@link Collections#synchronizedMap Collections.synchronizedMap}
                     method.  This is best done at creation time, to prevent accidental
                     unsynchronized access to the map:&lt;pre&gt;
                       Map m = Collections.synchronizedMap(new IdentityHashMap(...));&lt;/pre&gt;
                    
                     &lt;p&gt;The iterators returned by the {@code iterator} method of the
                     collections returned by all of this class's "collection view
                     methods" are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified
                     at any time after the iterator is created, in any way except
                     through the iterator's own {@code remove} method, the iterator
                     will throw a {@link ConcurrentModificationException}.  Thus, in the
                     face of concurrent modification, the iterator fails quickly and
                     cleanly, rather than risking arbitrary, non-deterministic behavior
                     at an undetermined time in the future.
                    
                     &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                     as it is, generally speaking, impossible to make any hard guarantees in the
                     presence of unsynchronized concurrent modification.  Fail-fast iterators
                     throw {@code ConcurrentModificationException} on a best-effort basis.
                     Therefore, it would be wrong to write a program that depended on this
                     exception for its correctness: &lt;i&gt;fail-fast iterators should be used only
                     to detect bugs.&lt;/i&gt;
                    
                     &lt;p&gt;Implementation note: This is a simple &lt;i&gt;linear-probe&lt;/i&gt; hash table,
                     as described for example in texts by Sedgewick and Knuth.  The array
                     alternates holding keys and values.  (This has better locality for large
                     tables than does using separate arrays.)  For many JRE implementations
                     and operation mixes, this class will yield better performance than
                     {@link HashMap} (which uses &lt;i&gt;chaining&lt;/i&gt; rather than linear-probing).
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @see     System#identityHashCode(Object)
                     @see     Object#hashCode()
                     @see     Collection
                     @see     Map
                     @see     HashMap
                     @see     TreeMap
                     @author  Doug Lea and Josh Bloch
                     @since   1.4
                    </javadoc>
            </acts>
            <acts name="MissingResourceException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that a resource is missing.
                     @see java.lang.Exception
                     @see ResourceBundle
                     @author      Mark Davis
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="OfPrimitive" access="PUBLIC" declaringClass="Spliterator" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Spliterator"/>
                </superTypes>
            </acts>
            <acts name="AbstractSequentialList" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.AbstractList"/>
                    <superType superType="java.util.AbstractCollection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class provides a skeletal implementation of the {@code List}
                     interface to minimize the effort required to implement this interface
                     backed by a "sequential access" data store (such as a linked list).  For
                     random access data (such as an array), {@code AbstractList} should be used
                     in preference to this class.&lt;p&gt;
                    
                     This class is the opposite of the {@code AbstractList} class in the sense
                     that it implements the "random access" methods ({@code get(int index)},
                     {@code set(int index, E element)}, {@code add(int index, E element)} and
                     {@code remove(int index)}) on top of the list's list iterator, instead of
                     the other way around.&lt;p&gt;
                    
                     To implement a list the programmer needs only to extend this class and
                     provide implementations for the {@code listIterator} and {@code size}
                     methods.  For an unmodifiable list, the programmer need only implement the
                     list iterator's {@code hasNext}, {@code next}, {@code hasPrevious},
                     {@code previous} and {@code index} methods.&lt;p&gt;
                    
                     For a modifiable list the programmer should additionally implement the list
                     iterator's {@code set} method.  For a variable-size list the programmer
                     should additionally implement the list iterator's {@code remove} and
                     {@code add} methods.&lt;p&gt;
                    
                     The programmer should generally provide a void (no argument) and collection
                     constructor, as per the recommendation in the {@code Collection} interface
                     specification.&lt;p&gt;
                    
                     This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @author  Josh Bloch
                     @author  Neal Gafter
                     @see Collection
                     @see List
                     @see AbstractList
                     @see AbstractCollection
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="Comparator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes/>
                <javadoc xml:space="preserve">
                     A comparison function, which imposes a &lt;i&gt;total ordering&lt;/i&gt; on some
                     collection of objects.  Comparators can be passed to a sort method (such
                     as {@link Collections#sort(List,Comparator) Collections.sort} or {@link
                     Arrays#sort(Object[],Comparator) Arrays.sort}) to allow precise control
                     over the sort order.  Comparators can also be used to control the order of
                     certain data structures (such as {@link SortedSet sorted sets} or {@link
                     SortedMap sorted maps}), or to provide an ordering for collections of
                     objects that don't have a {@link Comparable natural ordering}.&lt;p&gt;
                    
                     The ordering imposed by a comparator {@code c} on a set of elements
                     {@code S} is said to be &lt;i&gt;consistent with equals&lt;/i&gt; if and only if
                     {@code c.compare(e1, e2)==0} has the same boolean value as
                     {@code e1.equals(e2)} for every {@code e1} and {@code e2} in
                     {@code S}.&lt;p&gt;
                    
                     Caution should be exercised when using a comparator capable of imposing an
                     ordering inconsistent with equals to order a sorted set (or sorted map).
                     Suppose a sorted set (or sorted map) with an explicit comparator {@code c}
                     is used with elements (or keys) drawn from a set {@code S}.  If the
                     ordering imposed by {@code c} on {@code S} is inconsistent with equals,
                     the sorted set (or sorted map) will behave "strangely."  In particular the
                     sorted set (or sorted map) will violate the general contract for set (or
                     map), which is defined in terms of {@code equals}.&lt;p&gt;
                    
                     For example, suppose one adds two elements {@code a} and {@code b} such that
                     {@code (a.equals(b) &amp;&amp; c.compare(a, b) != 0)}
                     to an empty {@code TreeSet} with comparator {@code c}.
                     The second {@code add} operation will return
                     true (and the size of the tree set will increase) because {@code a} and
                     {@code b} are not equivalent from the tree set's perspective, even though
                     this is contrary to the specification of the
                     {@link Set#add Set.add} method.&lt;p&gt;
                    
                     Note: It is generally a good idea for comparators to also implement
                     {@code java.io.Serializable}, as they may be used as ordering methods in
                     serializable data structures (like {@link TreeSet}, {@link TreeMap}).  In
                     order for the data structure to serialize successfully, the comparator (if
                     provided) must implement {@code Serializable}.&lt;p&gt;
                    
                     For the mathematically inclined, the &lt;i&gt;relation&lt;/i&gt; that defines the
                     &lt;i&gt;imposed ordering&lt;/i&gt; that a given comparator {@code c} imposes on a
                     given set of objects {@code S} is:&lt;pre&gt;
                           {(x, y) such that c.compare(x, y) &amp;lt;= 0}.
                     &lt;/pre&gt; The &lt;i&gt;quotient&lt;/i&gt; for this total order is:&lt;pre&gt;
                           {(x, y) such that c.compare(x, y) == 0}.
                     &lt;/pre&gt;
                    
                     It follows immediately from the contract for {@code compare} that the
                     quotient is an &lt;i&gt;equivalence relation&lt;/i&gt; on {@code S}, and that the
                     imposed ordering is a &lt;i&gt;total order&lt;/i&gt; on {@code S}.  When we say that
                     the ordering imposed by {@code c} on {@code S} is &lt;i&gt;consistent with
                     equals&lt;/i&gt;, we mean that the quotient for the ordering is the equivalence
                     relation defined by the objects' {@link Object#equals(Object)
                     equals(Object)} method(s):&lt;pre&gt;
                         {(x, y) such that x.equals(y)}. &lt;/pre&gt;
                    
                     &lt;p&gt;Unlike {@code Comparable}, a comparator may optionally permit
                     comparison of null arguments, while maintaining the requirements for
                     an equivalence relation.
                    
                     &lt;p&gt;This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;T&gt; the type of objects that may be compared by this comparator
                    
                     @author  Josh Bloch
                     @author  Neal Gafter
                     @see Comparable
                     @see java.io.Serializable
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="LinkedHashMap" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Map"/>
                    <superType superType="java.util.HashMap"/>
                    <superType superType="java.util.AbstractMap"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;p&gt;Hash table and linked list implementation of the {@code Map} interface,
                     with predictable iteration order.  This implementation differs from
                     {@code HashMap} in that it maintains a doubly-linked list running through
                     all of its entries.  This linked list defines the iteration ordering,
                     which is normally the order in which keys were inserted into the map
                     (&lt;i&gt;insertion-order&lt;/i&gt;).  Note that insertion order is not affected
                     if a key is &lt;i&gt;re-inserted&lt;/i&gt; into the map.  (A key {@code k} is
                     reinserted into a map {@code m} if {@code m.put(k, v)} is invoked when
                     {@code m.containsKey(k)} would return {@code true} immediately prior to
                     the invocation.)
                    
                     &lt;p&gt;This implementation spares its clients from the unspecified, generally
                     chaotic ordering provided by {@link HashMap} (and {@link Hashtable}),
                     without incurring the increased cost associated with {@link TreeMap}.  It
                     can be used to produce a copy of a map that has the same order as the
                     original, regardless of the original map's implementation:
                     &lt;pre&gt;
                         void foo(Map m) {
                             Map copy = new LinkedHashMap(m);
                             ...
                         }
                     &lt;/pre&gt;
                     This technique is particularly useful if a module takes a map on input,
                     copies it, and later returns results whose order is determined by that of
                     the copy.  (Clients generally appreciate having things returned in the same
                     order they were presented.)
                    
                     &lt;p&gt;A special {@link #LinkedHashMap(int,float,boolean) constructor} is
                     provided to create a linked hash map whose order of iteration is the order
                     in which its entries were last accessed, from least-recently accessed to
                     most-recently (&lt;i&gt;access-order&lt;/i&gt;).  This kind of map is well-suited to
                     building LRU caches.  Invoking the {@code put}, {@code putIfAbsent},
                     {@code get}, {@code getOrDefault}, {@code compute}, {@code computeIfAbsent},
                     {@code computeIfPresent}, or {@code merge} methods results
                     in an access to the corresponding entry (assuming it exists after the
                     invocation completes). The {@code replace} methods only result in an access
                     of the entry if the value is replaced.  The {@code putAll} method generates one
                     entry access for each mapping in the specified map, in the order that
                     key-value mappings are provided by the specified map's entry set iterator.
                     &lt;i&gt;No other methods generate entry accesses.&lt;/i&gt;  In particular, operations
                     on collection-views do &lt;i&gt;not&lt;/i&gt; affect the order of iteration of the
                     backing map.
                    
                     &lt;p&gt;The {@link #removeEldestEntry(Map.Entry)} method may be overridden to
                     impose a policy for removing stale mappings automatically when new mappings
                     are added to the map.
                    
                     &lt;p&gt;This class provides all of the optional {@code Map} operations, and
                     permits null elements.  Like {@code HashMap}, it provides constant-time
                     performance for the basic operations ({@code add}, {@code contains} and
                     {@code remove}), assuming the hash function disperses elements
                     properly among the buckets.  Performance is likely to be just slightly
                     below that of {@code HashMap}, due to the added expense of maintaining the
                     linked list, with one exception: Iteration over the collection-views
                     of a {@code LinkedHashMap} requires time proportional to the &lt;i&gt;size&lt;/i&gt;
                     of the map, regardless of its capacity.  Iteration over a {@code HashMap}
                     is likely to be more expensive, requiring time proportional to its
                     &lt;i&gt;capacity&lt;/i&gt;.
                    
                     &lt;p&gt;A linked hash map has two parameters that affect its performance:
                     &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  They are defined precisely
                     as for {@code HashMap}.  Note, however, that the penalty for choosing an
                     excessively high value for initial capacity is less severe for this class
                     than for {@code HashMap}, as iteration times for this class are unaffected
                     by capacity.
                    
                     &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
                     If multiple threads access a linked hash map concurrently, and at least
                     one of the threads modifies the map structurally, it &lt;em&gt;must&lt;/em&gt; be
                     synchronized externally.  This is typically accomplished by
                     synchronizing on some object that naturally encapsulates the map.
                    
                     If no such object exists, the map should be "wrapped" using the
                     {@link Collections#synchronizedMap Collections.synchronizedMap}
                     method.  This is best done at creation time, to prevent accidental
                     unsynchronized access to the map:&lt;pre&gt;
                       Map m = Collections.synchronizedMap(new LinkedHashMap(...));&lt;/pre&gt;
                    
                     A structural modification is any operation that adds or deletes one or more
                     mappings or, in the case of access-ordered linked hash maps, affects
                     iteration order.  In insertion-ordered linked hash maps, merely changing
                     the value associated with a key that is already contained in the map is not
                     a structural modification.  &lt;strong&gt;In access-ordered linked hash maps,
                     merely querying the map with {@code get} is a structural modification.
                     &lt;/strong&gt;)
                    
                     &lt;p&gt;The iterators returned by the {@code iterator} method of the collections
                     returned by all of this class's collection view methods are
                     &lt;em&gt;fail-fast&lt;/em&gt;: if the map is structurally modified at any time after
                     the iterator is created, in any way except through the iterator's own
                     {@code remove} method, the iterator will throw a {@link
                     ConcurrentModificationException}.  Thus, in the face of concurrent
                     modification, the iterator fails quickly and cleanly, rather than risking
                     arbitrary, non-deterministic behavior at an undetermined time in the future.
                    
                     &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                     as it is, generally speaking, impossible to make any hard guarantees in the
                     presence of unsynchronized concurrent modification.  Fail-fast iterators
                     throw {@code ConcurrentModificationException} on a best-effort basis.
                     Therefore, it would be wrong to write a program that depended on this
                     exception for its correctness:   &lt;i&gt;the fail-fast behavior of iterators
                     should be used only to detect bugs.&lt;/i&gt;
                    
                     &lt;p&gt;The spliterators returned by the spliterator method of the collections
                     returned by all of this class's collection view methods are
                     &lt;em&gt;&lt;a href="Spliterator.html#binding"&gt;late-binding&lt;/a&gt;&lt;/em&gt;,
                     &lt;em&gt;fail-fast&lt;/em&gt;, and additionally report {@link Spliterator#ORDERED}.
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @implNote
                     The spliterators returned by the spliterator method of the collections
                     returned by all of this class's collection view methods are created from
                     the iterators of the corresponding collections.
                    
                     @param &lt;K&gt; the type of keys maintained by this map
                     @param &lt;V&gt; the type of mapped values
                    
                     @author  Josh Bloch
                     @see     Object#hashCode()
                     @see     Collection
                     @see     Map
                     @see     HashMap
                     @see     TreeMap
                     @see     Hashtable
                     @since   1.4
                    </javadoc>
            </acts>
            <acts name="EmptyStackException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown by methods in the {@code Stack} class to indicate
                     that the stack is empty.
                    
                     @author  Jonathan Payne
                     @see     java.util.Stack
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Encoder" access="PUBLIC" declaringClass="Base64" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Random" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An instance of this class is used to generate a stream of
                     pseudorandom numbers. The class uses a 48-bit seed, which is
                     modified using a linear congruential formula. (See Donald Knuth,
                     &lt;i&gt;The Art of Computer Programming, Volume 2&lt;/i&gt;, Section 3.2.1.)
                     &lt;p&gt;
                     If two instances of {@code Random} are created with the same
                     seed, and the same sequence of method calls is made for each, they
                     will generate and return identical sequences of numbers. In order to
                     guarantee this property, particular algorithms are specified for the
                     class {@code Random}. Java implementations must use all the algorithms
                     shown here for the class {@code Random}, for the sake of absolute
                     portability of Java code. However, subclasses of class {@code Random}
                     are permitted to use other algorithms, so long as they adhere to the
                     general contracts for all the methods.
                     &lt;p&gt;
                     The algorithms implemented by class {@code Random} use a
                     {@code protected} utility method that on each invocation can supply
                     up to 32 pseudorandomly generated bits.
                     &lt;p&gt;
                     Many applications will find the method {@link Math#random} simpler to use.
                    
                     &lt;p&gt;Instances of {@code java.util.Random} are threadsafe.
                     However, the concurrent use of the same {@code java.util.Random}
                     instance across threads may encounter contention and consequent
                     poor performance. Consider instead using
                     {@link java.util.concurrent.ThreadLocalRandom} in multithreaded
                     designs.
                    
                     &lt;p&gt;Instances of {@code java.util.Random} are not cryptographically
                     secure.  Consider instead using {@link java.security.SecureRandom} to
                     get a cryptographically secure pseudo-random number generator for use
                     by security-sensitive applications.
                    
                     @author  Frank Yellin
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="IllegalFormatPrecisionException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.IllegalFormatException"/>
                    <superType superType="java.lang.IllegalArgumentException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Unchecked exception thrown when the precision is a negative value other than
                     {@code -1}, the conversion does not support a precision, or the value is
                     otherwise unsupported.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="List" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Collection"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An ordered collection (also known as a &lt;i&gt;sequence&lt;/i&gt;).  The user of this
                     interface has precise control over where in the list each element is
                     inserted.  The user can access elements by their integer index (position in
                     the list), and search for elements in the list.&lt;p&gt;
                    
                     Unlike sets, lists typically allow duplicate elements.  More formally,
                     lists typically allow pairs of elements {@code e1} and {@code e2}
                     such that {@code e1.equals(e2)}, and they typically allow multiple
                     null elements if they allow null elements at all.  It is not inconceivable
                     that someone might wish to implement a list that prohibits duplicates, by
                     throwing runtime exceptions when the user attempts to insert them, but we
                     expect this usage to be rare.&lt;p&gt;
                    
                     The {@code List} interface places additional stipulations, beyond those
                     specified in the {@code Collection} interface, on the contracts of the
                     {@code iterator}, {@code add}, {@code remove}, {@code equals}, and
                     {@code hashCode} methods.  Declarations for other inherited methods are
                     also included here for convenience.&lt;p&gt;
                    
                     The {@code List} interface provides four methods for positional (indexed)
                     access to list elements.  Lists (like Java arrays) are zero based.  Note
                     that these operations may execute in time proportional to the index value
                     for some implementations (the {@code LinkedList} class, for
                     example). Thus, iterating over the elements in a list is typically
                     preferable to indexing through it if the caller does not know the
                     implementation.&lt;p&gt;
                    
                     The {@code List} interface provides a special iterator, called a
                     {@code ListIterator}, that allows element insertion and replacement, and
                     bidirectional access in addition to the normal operations that the
                     {@code Iterator} interface provides.  A method is provided to obtain a
                     list iterator that starts at a specified position in the list.&lt;p&gt;
                    
                     The {@code List} interface provides two methods to search for a specified
                     object.  From a performance standpoint, these methods should be used with
                     caution.  In many implementations they will perform costly linear
                     searches.&lt;p&gt;
                    
                     The {@code List} interface provides two methods to efficiently insert and
                     remove multiple elements at an arbitrary point in the list.&lt;p&gt;
                    
                     Note: While it is permissible for lists to contain themselves as elements,
                     extreme caution is advised: the {@code equals} and {@code hashCode}
                     methods are no longer well defined on such a list.
                    
                     &lt;p&gt;Some list implementations have restrictions on the elements that
                     they may contain.  For example, some implementations prohibit null elements,
                     and some have restrictions on the types of their elements.  Attempting to
                     add an ineligible element throws an unchecked exception, typically
                     {@code NullPointerException} or {@code ClassCastException}.  Attempting
                     to query the presence of an ineligible element may throw an exception,
                     or it may simply return false; some implementations will exhibit the former
                     behavior and some will exhibit the latter.  More generally, attempting an
                     operation on an ineligible element whose completion would not result in
                     the insertion of an ineligible element into the list may throw an
                     exception or it may succeed, at the option of the implementation.
                     Such exceptions are marked as "optional" in the specification for this
                     interface.
                    
                     &lt;h2&gt;&lt;a id="unmodifiable"&gt;Unmodifiable Lists&lt;/a&gt;&lt;/h2&gt;
                     &lt;p&gt;The {@link List#of(Object...) List.of} and
                     {@link List#copyOf List.copyOf} static factory methods
                     provide a convenient way to create unmodifiable lists. The {@code List}
                     instances created by these methods have the following characteristics:
                    
                     &lt;ul&gt;
                     &lt;li&gt;They are &lt;a href="Collection.html#unmodifiable"&gt;&lt;i&gt;unmodifiable&lt;/i&gt;&lt;/a&gt;. Elements cannot
                     be added, removed, or replaced. Calling any mutator method on the List
                     will always cause {@code UnsupportedOperationException} to be thrown.
                     However, if the contained elements are themselves mutable,
                     this may cause the List's contents to appear to change.
                     &lt;li&gt;They disallow {@code null} elements. Attempts to create them with
                     {@code null} elements result in {@code NullPointerException}.
                     &lt;li&gt;They are serializable if all elements are serializable.
                     &lt;li&gt;The order of elements in the list is the same as the order of the
                     provided arguments, or of the elements in the provided array.
                     &lt;li&gt;They are &lt;a href="../lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;.
                     Callers should make no assumptions about the identity of the returned instances.
                     Factories are free to create new instances or reuse existing ones. Therefore,
                     identity-sensitive operations on these instances (reference equality ({@code ==}),
                     identity hash code, and synchronization) are unreliable and should be avoided.
                     &lt;li&gt;They are serialized as specified on the
                     &lt;a href="{@docRoot}/serialized-form.html#java.util.CollSer"&gt;Serialized Form&lt;/a&gt;
                     page.
                     &lt;/ul&gt;
                    
                     &lt;p&gt;This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;E&gt; the type of elements in this list
                    
                     @author  Josh Bloch
                     @author  Neal Gafter
                     @see Collection
                     @see Set
                     @see ArrayList
                     @see LinkedList
                     @see Vector
                     @see Arrays#asList(Object[])
                     @see Collections#nCopies(int, Object)
                     @see Collections#EMPTY_LIST
                     @see AbstractList
                     @see AbstractSequentialList
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="Collections" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class consists exclusively of static methods that operate on or return
                     collections.  It contains polymorphic algorithms that operate on
                     collections, "wrappers", which return a new collection backed by a
                     specified collection, and a few other odds and ends.
                    
                     &lt;p&gt;The methods of this class all throw a {@code NullPointerException}
                     if the collections or class objects provided to them are null.
                    
                     &lt;p&gt;The documentation for the polymorphic algorithms contained in this class
                     generally includes a brief description of the &lt;i&gt;implementation&lt;/i&gt;.  Such
                     descriptions should be regarded as &lt;i&gt;implementation notes&lt;/i&gt;, rather than
                     parts of the &lt;i&gt;specification&lt;/i&gt;.  Implementors should feel free to
                     substitute other algorithms, so long as the specification itself is adhered
                     to.  (For example, the algorithm used by {@code sort} does not have to be
                     a mergesort, but it does have to be &lt;i&gt;stable&lt;/i&gt;.)
                    
                     &lt;p&gt;The "destructive" algorithms contained in this class, that is, the
                     algorithms that modify the collection on which they operate, are specified
                     to throw {@code UnsupportedOperationException} if the collection does not
                     support the appropriate mutation primitive(s), such as the {@code set}
                     method.  These algorithms may, but are not required to, throw this
                     exception if an invocation would have no effect on the collection.  For
                     example, invoking the {@code sort} method on an unmodifiable list that is
                     already sorted may or may not throw {@code UnsupportedOperationException}.
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @author  Josh Bloch
                     @author  Neal Gafter
                     @see     Collection
                     @see     Set
                     @see     List
                     @see     Map
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="UUID" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A class that represents an immutable universally unique identifier (UUID).
                     A UUID represents a 128-bit value.
                    
                     &lt;p&gt; There exist different variants of these global identifiers.  The methods
                     of this class are for manipulating the Leach-Salz variant, although the
                     constructors allow the creation of any variant of UUID (described below).
                    
                     &lt;p&gt; The layout of a variant 2 (Leach-Salz) UUID is as follows:
                    
                     The most significant long consists of the following unsigned fields:
                     &lt;pre&gt;
                     0xFFFFFFFF00000000 time_low
                     0x00000000FFFF0000 time_mid
                     0x000000000000F000 version
                     0x0000000000000FFF time_hi
                     &lt;/pre&gt;
                     The least significant long consists of the following unsigned fields:
                     &lt;pre&gt;
                     0xC000000000000000 variant
                     0x3FFF000000000000 clock_seq
                     0x0000FFFFFFFFFFFF node
                     &lt;/pre&gt;
                    
                     &lt;p&gt; The variant field contains a value which identifies the layout of the
                     {@code UUID}.  The bit layout described above is valid only for a {@code
                     UUID} with a variant value of 2, which indicates the Leach-Salz variant.
                    
                     &lt;p&gt; The version field holds a value that describes the type of this {@code
                     UUID}.  There are four different basic types of UUIDs: time-based, DCE
                     security, name-based, and randomly generated UUIDs.  These types have a
                     version value of 1, 2, 3 and 4, respectively.
                    
                     &lt;p&gt; For more information including algorithms used to create {@code UUID}s,
                     see &lt;a href="http://www.ietf.org/rfc/rfc4122.txt"&gt; &lt;i&gt;RFC&amp;nbsp;4122: A
                     Universally Unique IDentifier (UUID) URN Namespace&lt;/i&gt;&lt;/a&gt;, section 4.2
                     &amp;quot;Algorithms for Creating a Time-Based UUID&amp;quot;.
                    
                     @since   1.5
                    </javadoc>
            </acts>
            <acts name="HashSet" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Set"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.util.AbstractSet"/>
                    <superType superType="java.util.AbstractCollection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class implements the {@code Set} interface, backed by a hash table
                     (actually a {@code HashMap} instance).  It makes no guarantees as to the
                     iteration order of the set; in particular, it does not guarantee that the
                     order will remain constant over time.  This class permits the {@code null}
                     element.
                    
                     &lt;p&gt;This class offers constant time performance for the basic operations
                     ({@code add}, {@code remove}, {@code contains} and {@code size}),
                     assuming the hash function disperses the elements properly among the
                     buckets.  Iterating over this set requires time proportional to the sum of
                     the {@code HashSet} instance's size (the number of elements) plus the
                     "capacity" of the backing {@code HashMap} instance (the number of
                     buckets).  Thus, it's very important not to set the initial capacity too
                     high (or the load factor too low) if iteration performance is important.
                    
                     &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
                     If multiple threads access a hash set concurrently, and at least one of
                     the threads modifies the set, it &lt;i&gt;must&lt;/i&gt; be synchronized externally.
                     This is typically accomplished by synchronizing on some object that
                     naturally encapsulates the set.
                    
                     If no such object exists, the set should be "wrapped" using the
                     {@link Collections#synchronizedSet Collections.synchronizedSet}
                     method.  This is best done at creation time, to prevent accidental
                     unsynchronized access to the set:&lt;pre&gt;
                       Set s = Collections.synchronizedSet(new HashSet(...));&lt;/pre&gt;
                    
                     &lt;p&gt;The iterators returned by this class's {@code iterator} method are
                     &lt;i&gt;fail-fast&lt;/i&gt;: if the set is modified at any time after the iterator is
                     created, in any way except through the iterator's own {@code remove}
                     method, the Iterator throws a {@link ConcurrentModificationException}.
                     Thus, in the face of concurrent modification, the iterator fails quickly
                     and cleanly, rather than risking arbitrary, non-deterministic behavior at
                     an undetermined time in the future.
                    
                     &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                     as it is, generally speaking, impossible to make any hard guarantees in the
                     presence of unsynchronized concurrent modification.  Fail-fast iterators
                     throw {@code ConcurrentModificationException} on a best-effort basis.
                     Therefore, it would be wrong to write a program that depended on this
                     exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators
                     should be used only to detect bugs.&lt;/i&gt;
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;E&gt; the type of elements maintained by this set
                    
                     @author  Josh Bloch
                     @author  Neal Gafter
                     @see     Collection
                     @see     Set
                     @see     TreeSet
                     @see     HashMap
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="AbstractList" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.List"/>
                    <superType superType="java.util.AbstractCollection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class provides a skeletal implementation of the {@link List}
                     interface to minimize the effort required to implement this interface
                     backed by a "random access" data store (such as an array).  For sequential
                     access data (such as a linked list), {@link AbstractSequentialList} should
                     be used in preference to this class.
                    
                     &lt;p&gt;To implement an unmodifiable list, the programmer needs only to extend
                     this class and provide implementations for the {@link #get(int)} and
                     {@link List#size() size()} methods.
                    
                     &lt;p&gt;To implement a modifiable list, the programmer must additionally
                     override the {@link #set(int, Object) set(int, E)} method (which otherwise
                     throws an {@code UnsupportedOperationException}).  If the list is
                     variable-size the programmer must additionally override the
                     {@link #add(int, Object) add(int, E)} and {@link #remove(int)} methods.
                    
                     &lt;p&gt;The programmer should generally provide a void (no argument) and collection
                     constructor, as per the recommendation in the {@link Collection} interface
                     specification.
                    
                     &lt;p&gt;Unlike the other abstract collection implementations, the programmer does
                     &lt;i&gt;not&lt;/i&gt; have to provide an iterator implementation; the iterator and
                     list iterator are implemented by this class, on top of the "random access"
                     methods:
                     {@link #get(int)},
                     {@link #set(int, Object) set(int, E)},
                     {@link #add(int, Object) add(int, E)} and
                     {@link #remove(int)}.
                    
                     &lt;p&gt;The documentation for each non-abstract method in this class describes its
                     implementation in detail.  Each of these methods may be overridden if the
                     collection being implemented admits a more efficient implementation.
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @author  Josh Bloch
                     @author  Neal Gafter
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="Optional" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A container object which may or may not contain a non-{@code null} value.
                     If a value is present, {@code isPresent()} returns {@code true}. If no
                     value is present, the object is considered &lt;i&gt;empty&lt;/i&gt; and
                     {@code isPresent()} returns {@code false}.
                    
                     &lt;p&gt;Additional methods that depend on the presence or absence of a contained
                     value are provided, such as {@link #orElse(Object) orElse()}
                     (returns a default value if no value is present) and
                     {@link #ifPresent(Consumer) ifPresent()} (performs an
                     action if a value is present).
                    
                     &lt;p&gt;This is a &lt;a href="../lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code Optional} may have unpredictable results and should be avoided.
                    
                     @apiNote
                     {@code Optional} is primarily intended for use as a method return type where
                     there is a clear need to represent "no result," and where using {@code null}
                     is likely to cause errors. A variable whose type is {@code Optional} should
                     never itself be {@code null}; it should always point to an {@code Optional}
                     instance.
                    
                     @param &lt;T&gt; the type of value
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="BitSet" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class implements a vector of bits that grows as needed. Each
                     component of the bit set has a {@code boolean} value. The
                     bits of a {@code BitSet} are indexed by nonnegative integers.
                     Individual indexed bits can be examined, set, or cleared. One
                     {@code BitSet} may be used to modify the contents of another
                     {@code BitSet} through logical AND, logical inclusive OR, and
                     logical exclusive OR operations.
                    
                     &lt;p&gt;By default, all bits in the set initially have the value
                     {@code false}.
                    
                     &lt;p&gt;Every bit set has a current size, which is the number of bits
                     of space currently in use by the bit set. Note that the size is
                     related to the implementation of a bit set, so it may change with
                     implementation. The length of a bit set relates to logical length
                     of a bit set and is defined independently of implementation.
                    
                     &lt;p&gt;Unless otherwise noted, passing a null parameter to any of the
                     methods in a {@code BitSet} will result in a
                     {@code NullPointerException}.
                    
                     &lt;p&gt;A {@code BitSet} is not safe for multithreaded use without
                     external synchronization.
                    
                     @author  Arthur van Hoff
                     @author  Michael McCloskey
                     @author  Martin Buchholz
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ListIterator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Iterator"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An iterator for lists that allows the programmer
                     to traverse the list in either direction, modify
                     the list during iteration, and obtain the iterator's
                     current position in the list. A {@code ListIterator}
                     has no current element; its &lt;I&gt;cursor position&lt;/I&gt; always
                     lies between the element that would be returned by a call
                     to {@code previous()} and the element that would be
                     returned by a call to {@code next()}.
                     An iterator for a list of length {@code n} has {@code n+1} possible
                     cursor positions, as illustrated by the carets ({@code ^}) below:
                     &lt;PRE&gt;
                                          Element(0)   Element(1)   Element(2)   ... Element(n-1)
                     cursor positions:  ^            ^            ^            ^                  ^
                     &lt;/PRE&gt;
                     Note that the {@link #remove} and {@link #set(Object)} methods are
                     &lt;i&gt;not&lt;/i&gt; defined in terms of the cursor position;  they are defined to
                     operate on the last element returned by a call to {@link #next} or
                     {@link #previous()}.
                    
                     &lt;p&gt;This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @author  Josh Bloch
                     @see Collection
                     @see List
                     @see Iterator
                     @see Enumeration
                     @see List#listIterator()
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="PriorityQueue" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.util.AbstractQueue"/>
                    <superType superType="java.util.AbstractCollection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An unbounded priority {@linkplain Queue queue} based on a priority heap.
                     The elements of the priority queue are ordered according to their
                     {@linkplain Comparable natural ordering}, or by a {@link Comparator}
                     provided at queue construction time, depending on which constructor is
                     used.  A priority queue does not permit {@code null} elements.
                     A priority queue relying on natural ordering also does not permit
                     insertion of non-comparable objects (doing so may result in
                     {@code ClassCastException}).
                    
                     &lt;p&gt;The &lt;em&gt;head&lt;/em&gt; of this queue is the &lt;em&gt;least&lt;/em&gt; element
                     with respect to the specified ordering.  If multiple elements are
                     tied for least value, the head is one of those elements -- ties are
                     broken arbitrarily.  The queue retrieval operations {@code poll},
                     {@code remove}, {@code peek}, and {@code element} access the
                     element at the head of the queue.
                    
                     &lt;p&gt;A priority queue is unbounded, but has an internal
                     &lt;i&gt;capacity&lt;/i&gt; governing the size of an array used to store the
                     elements on the queue.  It is always at least as large as the queue
                     size.  As elements are added to a priority queue, its capacity
                     grows automatically.  The details of the growth policy are not
                     specified.
                    
                     &lt;p&gt;This class and its iterator implement all of the
                     &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link
                     Iterator} interfaces.  The Iterator provided in method {@link
                     #iterator()} and the Spliterator provided in method {@link #spliterator()}
                     are &lt;em&gt;not&lt;/em&gt; guaranteed to traverse the elements of
                     the priority queue in any particular order. If you need ordered
                     traversal, consider using {@code Arrays.sort(pq.toArray())}.
                    
                     &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
                     Multiple threads should not access a {@code PriorityQueue}
                     instance concurrently if any of the threads modifies the queue.
                     Instead, use the thread-safe {@link
                     java.util.concurrent.PriorityBlockingQueue} class.
                    
                     &lt;p&gt;Implementation note: this implementation provides
                     O(log(n)) time for the enqueuing and dequeuing methods
                     ({@code offer}, {@code poll}, {@code remove()} and {@code add});
                     linear time for the {@code remove(Object)} and {@code contains(Object)}
                     methods; and constant time for the retrieval methods
                     ({@code peek}, {@code element}, and {@code size}).
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @since 1.5
                     @author Josh Bloch, Doug Lea
                     @param &lt;E&gt; the type of elements held in this queue
                    </javadoc>
            </acts>
            <acts name="EventObject" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;p&gt;
                     The root class from which all event state objects shall be derived.
                     &lt;p&gt;
                     All Events are constructed with a reference to the object, the "source",
                     that is logically deemed to be the object upon which the Event in question
                     initially occurred upon.
                    
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="LinkedList" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.List"/>
                    <superType superType="java.util.Deque"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.util.AbstractSequentialList"/>
                    <superType superType="java.util.AbstractList"/>
                    <superType superType="java.util.AbstractCollection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Doubly-linked list implementation of the {@code List} and {@code Deque}
                     interfaces.  Implements all optional list operations, and permits all
                     elements (including {@code null}).
                    
                     &lt;p&gt;All of the operations perform as could be expected for a doubly-linked
                     list.  Operations that index into the list will traverse the list from
                     the beginning or the end, whichever is closer to the specified index.
                    
                     &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
                     If multiple threads access a linked list concurrently, and at least
                     one of the threads modifies the list structurally, it &lt;i&gt;must&lt;/i&gt; be
                     synchronized externally.  (A structural modification is any operation
                     that adds or deletes one or more elements; merely setting the value of
                     an element is not a structural modification.)  This is typically
                     accomplished by synchronizing on some object that naturally
                     encapsulates the list.
                    
                     If no such object exists, the list should be "wrapped" using the
                     {@link Collections#synchronizedList Collections.synchronizedList}
                     method.  This is best done at creation time, to prevent accidental
                     unsynchronized access to the list:&lt;pre&gt;
                       List list = Collections.synchronizedList(new LinkedList(...));&lt;/pre&gt;
                    
                     &lt;p&gt;The iterators returned by this class's {@code iterator} and
                     {@code listIterator} methods are &lt;i&gt;fail-fast&lt;/i&gt;: if the list is
                     structurally modified at any time after the iterator is created, in
                     any way except through the Iterator's own {@code remove} or
                     {@code add} methods, the iterator will throw a {@link
                     ConcurrentModificationException}.  Thus, in the face of concurrent
                     modification, the iterator fails quickly and cleanly, rather than
                     risking arbitrary, non-deterministic behavior at an undetermined
                     time in the future.
                    
                     &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                     as it is, generally speaking, impossible to make any hard guarantees in the
                     presence of unsynchronized concurrent modification.  Fail-fast iterators
                     throw {@code ConcurrentModificationException} on a best-effort basis.
                     Therefore, it would be wrong to write a program that depended on this
                     exception for its correctness:   &lt;i&gt;the fail-fast behavior of iterators
                     should be used only to detect bugs.&lt;/i&gt;
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @author  Josh Bloch
                     @see     List
                     @see     ArrayList
                     @since 1.2
                     @param &lt;E&gt; the type of elements held in this collection
                    </javadoc>
            </acts>
            <acts name="Stack" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Vector"/>
                    <superType superType="java.util.AbstractList"/>
                    <superType superType="java.util.AbstractCollection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Stack} class represents a last-in-first-out
                     (LIFO) stack of objects. It extends class {@code Vector} with five
                     operations that allow a vector to be treated as a stack. The usual
                     {@code push} and {@code pop} operations are provided, as well as a
                     method to {@code peek} at the top item on the stack, a method to test
                     for whether the stack is {@code empty}, and a method to {@code search}
                     the stack for an item and discover how far it is from the top.
                     &lt;p&gt;
                     When a stack is first created, it contains no items.
                    
                     &lt;p&gt;A more complete and consistent set of LIFO stack operations is
                     provided by the {@link Deque} interface and its implementations, which
                     should be used in preference to this class.  For example:
                     &lt;pre&gt;   {@code
                       Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();}&lt;/pre&gt;
                    
                     @author  Jonathan Payne
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="LanguageRange" access="PUBLIC" declaringClass="Locale" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="OfDouble" access="PUBLIC" declaringClass="Spliterator" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Spliterator$OfPrimitive"/>
                </superTypes>
            </acts>
            <acts name="Spliterators" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Static classes and methods for operating on or creating instances of
                     {@link Spliterator} and its primitive specializations
                     {@link Spliterator.OfInt}, {@link Spliterator.OfLong}, and
                     {@link Spliterator.OfDouble}.
                    
                     @see Spliterator
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="EventListenerProxy" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.EventListener"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An abstract wrapper class for an {@code EventListener} class
                     which associates a set of additional parameters with the listener.
                     Subclasses must provide the storage and accessor methods
                     for the additional arguments or parameters.
                     &lt;p&gt;
                     For example, a bean which supports named properties
                     would have a two argument method signature for adding
                     a {@code PropertyChangeListener} for a property:
                     &lt;pre&gt;
                     public void addPropertyChangeListener(String propertyName,
                                                           PropertyChangeListener listener)
                     &lt;/pre&gt;
                     If the bean also implemented the zero argument get listener method:
                     &lt;pre&gt;
                     public PropertyChangeListener[] getPropertyChangeListeners()
                     &lt;/pre&gt;
                     then the array may contain inner {@code PropertyChangeListeners}
                     which are also {@code PropertyChangeListenerProxy} objects.
                     &lt;p&gt;
                     If the calling method is interested in retrieving the named property
                     then it would have to test the element to see if it is a proxy class.
                    
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="Control" access="PUBLIC" declaringClass="ResourceBundle" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Objects" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class consists of {@code static} utility methods for operating
                     on objects, or checking certain conditions before operation.  These utilities
                     include {@code null}-safe or {@code null}-tolerant methods for computing the
                     hash code of an object, returning a string for an object, comparing two
                     objects, and checking if indexes or sub-range values are out of bounds.
                    
                     @apiNote
                     Static methods such as {@link Objects#checkIndex},
                     {@link Objects#checkFromToIndex}, and {@link Objects#checkFromIndexSize} are
                     provided for the convenience of checking if values corresponding to indexes
                     and sub-ranges are out of bounds.
                     Variations of these static methods support customization of the runtime
                     exception, and corresponding exception detail message, that is thrown when
                     values are out of bounds.  Such methods accept a functional interface
                     argument, instances of {@code BiFunction}, that maps out-of-bound values to a
                     runtime exception.  Care should be taken when using such methods in
                     combination with an argument that is a lambda expression, method reference or
                     class that capture values.  In such cases the cost of capture, related to
                     functional interface allocation, may exceed the cost of checking bounds.
                    
                     @since 1.7
                    </javadoc>
            </acts>
            <acts name="Collection" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Iterable"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The root interface in the &lt;i&gt;collection hierarchy&lt;/i&gt;.  A collection
                     represents a group of objects, known as its &lt;i&gt;elements&lt;/i&gt;.  Some
                     collections allow duplicate elements and others do not.  Some are ordered
                     and others unordered.  The JDK does not provide any &lt;i&gt;direct&lt;/i&gt;
                     implementations of this interface: it provides implementations of more
                     specific subinterfaces like {@code Set} and {@code List}.  This interface
                     is typically used to pass collections around and manipulate them where
                     maximum generality is desired.
                    
                     &lt;p&gt;&lt;i&gt;Bags&lt;/i&gt; or &lt;i&gt;multisets&lt;/i&gt; (unordered collections that may contain
                     duplicate elements) should implement this interface directly.
                    
                     &lt;p&gt;All general-purpose {@code Collection} implementation classes (which
                     typically implement {@code Collection} indirectly through one of its
                     subinterfaces) should provide two "standard" constructors: a void (no
                     arguments) constructor, which creates an empty collection, and a
                     constructor with a single argument of type {@code Collection}, which
                     creates a new collection with the same elements as its argument.  In
                     effect, the latter constructor allows the user to copy any collection,
                     producing an equivalent collection of the desired implementation type.
                     There is no way to enforce this convention (as interfaces cannot contain
                     constructors) but all of the general-purpose {@code Collection}
                     implementations in the Java platform libraries comply.
                    
                     &lt;p&gt;Certain methods are specified to be
                     &lt;i&gt;optional&lt;/i&gt;. If a collection implementation doesn't implement a
                     particular operation, it should define the corresponding method to throw
                     {@code UnsupportedOperationException}. Such methods are marked "optional
                     operation" in method specifications of the collections interfaces.
                    
                     &lt;p&gt;&lt;a id="optional-restrictions"&gt;&lt;/a&gt;Some collection implementations
                     have restrictions on the elements that they may contain.
                     For example, some implementations prohibit null elements,
                     and some have restrictions on the types of their elements.  Attempting to
                     add an ineligible element throws an unchecked exception, typically
                     {@code NullPointerException} or {@code ClassCastException}.  Attempting
                     to query the presence of an ineligible element may throw an exception,
                     or it may simply return false; some implementations will exhibit the former
                     behavior and some will exhibit the latter.  More generally, attempting an
                     operation on an ineligible element whose completion would not result in
                     the insertion of an ineligible element into the collection may throw an
                     exception or it may succeed, at the option of the implementation.
                     Such exceptions are marked as "optional" in the specification for this
                     interface.
                    
                     &lt;p&gt;It is up to each collection to determine its own synchronization
                     policy.  In the absence of a stronger guarantee by the
                     implementation, undefined behavior may result from the invocation
                     of any method on a collection that is being mutated by another
                     thread; this includes direct invocations, passing the collection to
                     a method that might perform invocations, and using an existing
                     iterator to examine the collection.
                    
                     &lt;p&gt;Many methods in Collections Framework interfaces are defined in
                     terms of the {@link Object#equals(Object) equals} method.  For example,
                     the specification for the {@link #contains(Object) contains(Object o)}
                     method says: "returns {@code true} if and only if this collection
                     contains at least one element {@code e} such that
                     {@code (o==null ? e==null : o.equals(e))}."  This specification should
                     &lt;i&gt;not&lt;/i&gt; be construed to imply that invoking {@code Collection.contains}
                     with a non-null argument {@code o} will cause {@code o.equals(e)} to be
                     invoked for any element {@code e}.  Implementations are free to implement
                     optimizations whereby the {@code equals} invocation is avoided, for
                     example, by first comparing the hash codes of the two elements.  (The
                     {@link Object#hashCode()} specification guarantees that two objects with
                     unequal hash codes cannot be equal.)  More generally, implementations of
                     the various Collections Framework interfaces are free to take advantage of
                     the specified behavior of underlying {@link Object} methods wherever the
                     implementor deems it appropriate.
                    
                     &lt;p&gt;Some collection operations which perform recursive traversal of the
                     collection may fail with an exception for self-referential instances where
                     the collection directly or indirectly contains itself. This includes the
                     {@code clone()}, {@code equals()}, {@code hashCode()} and {@code toString()}
                     methods. Implementations may optionally handle the self-referential scenario,
                     however most current implementations do not do so.
                    
                     &lt;h2&gt;&lt;a id="view"&gt;View Collections&lt;/a&gt;&lt;/h2&gt;
                    
                     &lt;p&gt;Most collections manage storage for elements they contain. By contrast, &lt;i&gt;view
                     collections&lt;/i&gt; themselves do not store elements, but instead they rely on a
                     backing collection to store the actual elements. Operations that are not handled
                     by the view collection itself are delegated to the backing collection. Examples of
                     view collections include the wrapper collections returned by methods such as
                     {@link Collections#checkedCollection Collections.checkedCollection},
                     {@link Collections#synchronizedCollection Collections.synchronizedCollection}, and
                     {@link Collections#unmodifiableCollection Collections.unmodifiableCollection}.
                     Other examples of view collections include collections that provide a
                     different representation of the same elements, for example, as
                     provided by {@link List#subList List.subList},
                     {@link NavigableSet#subSet NavigableSet.subSet}, or
                     {@link Map#entrySet Map.entrySet}.
                     Any changes made to the backing collection are visible in the view collection.
                     Correspondingly, any changes made to the view collection &amp;mdash; if changes
                     are permitted &amp;mdash; are written through to the backing collection.
                     Although they technically aren't collections, instances of
                     {@link Iterator} and {@link ListIterator} can also allow modifications
                     to be written through to the backing collection, and in some cases,
                     modifications to the backing collection will be visible to the Iterator
                     during iteration.
                    
                     &lt;h2&gt;&lt;a id="unmodifiable"&gt;Unmodifiable Collections&lt;/a&gt;&lt;/h2&gt;
                    
                     &lt;p&gt;Certain methods of this interface are considered "destructive" and are called
                     "mutator" methods in that they modify the group of objects contained within
                     the collection on which they operate. They can be specified to throw
                     {@code UnsupportedOperationException} if this collection implementation
                     does not support the operation. Such methods should (but are not required
                     to) throw an {@code UnsupportedOperationException} if the invocation would
                     have no effect on the collection. For example, consider a collection that
                     does not support the {@link #add add} operation. What will happen if the
                     {@link #addAll addAll} method is invoked on this collection, with an empty
                     collection as the argument? The addition of zero elements has no effect,
                     so it is permissible for this collection simply to do nothing and not to throw
                     an exception. However, it is recommended that such cases throw an exception
                     unconditionally, as throwing only in certain cases can lead to
                     programming errors.
                    
                     &lt;p&gt;An &lt;i&gt;unmodifiable collection&lt;/i&gt; is a collection, all of whose
                     mutator methods (as defined above) are specified to throw
                     {@code UnsupportedOperationException}. Such a collection thus cannot be
                     modified by calling any methods on it. For a collection to be properly
                     unmodifiable, any view collections derived from it must also be unmodifiable.
                     For example, if a List is unmodifiable, the List returned by
                     {@link List#subList List.subList} is also unmodifiable.
                    
                     &lt;p&gt;An unmodifiable collection is not necessarily immutable. If the
                     contained elements are mutable, the entire collection is clearly
                     mutable, even though it might be unmodifiable. For example, consider
                     two unmodifiable lists containing mutable elements. The result of calling
                     {@code list1.equals(list2)} might differ from one call to the next if
                     the elements had been mutated, even though both lists are unmodifiable.
                     However, if an unmodifiable collection contains all immutable elements,
                     it can be considered effectively immutable.
                    
                     &lt;h2&gt;&lt;a id="unmodview"&gt;Unmodifiable View Collections&lt;/a&gt;&lt;/h2&gt;
                    
                     &lt;p&gt;An &lt;i&gt;unmodifiable view collection&lt;/i&gt; is a collection that is unmodifiable
                     and that is also a view onto a backing collection. Its mutator methods throw
                     {@code UnsupportedOperationException}, as described above, while
                     reading and querying methods are delegated to the backing collection.
                     The effect is to provide read-only access to the backing collection.
                     This is useful for a component to provide users with read access to
                     an internal collection, while preventing them from modifying such
                     collections unexpectedly. Examples of unmodifiable view collections
                     are those returned by the
                     {@link Collections#unmodifiableCollection Collections.unmodifiableCollection},
                     {@link Collections#unmodifiableList Collections.unmodifiableList}, and
                     related methods.
                    
                     &lt;p&gt;Note that changes to the backing collection might still be possible,
                     and if they occur, they are visible through the unmodifiable view. Thus,
                     an unmodifiable view collection is not necessarily immutable. However,
                     if the backing collection of an unmodifiable view is effectively immutable,
                     or if the only reference to the backing collection is through an
                     unmodifiable view, the view can be considered effectively immutable.
                    
                     &lt;p&gt;This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @implSpec
                     The default method implementations (inherited or otherwise) do not apply any
                     synchronization protocol.  If a {@code Collection} implementation has a
                     specific synchronization protocol, then it must override default
                     implementations to apply that protocol.
                    
                     @param &lt;E&gt; the type of elements in this collection
                    
                     @author  Josh Bloch
                     @author  Neal Gafter
                     @see     Set
                     @see     List
                     @see     Map
                     @see     SortedSet
                     @see     SortedMap
                     @see     HashSet
                     @see     TreeSet
                     @see     ArrayList
                     @see     LinkedList
                     @see     Vector
                     @see     Collections
                     @see     Arrays
                     @see     AbstractCollection
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="ResourceBundle" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                    
                     Resource bundles contain locale-specific objects.  When your program needs a
                     locale-specific resource, a &lt;code&gt;String&lt;/code&gt; for example, your program can
                     load it from the resource bundle that is appropriate for the current user's
                     locale. In this way, you can write program code that is largely independent
                     of the user's locale isolating most, if not all, of the locale-specific
                     information in resource bundles.
                    
                     &lt;p&gt;
                     This allows you to write programs that can:
                     &lt;UL&gt;
                     &lt;LI&gt; be easily localized, or translated, into different languages
                     &lt;LI&gt; handle multiple locales at once
                     &lt;LI&gt; be easily modified later to support even more locales
                     &lt;/UL&gt;
                    
                     &lt;P&gt;
                     Resource bundles belong to families whose members share a common base
                     name, but whose names also have additional components that identify
                     their locales. For example, the base name of a family of resource
                     bundles might be "MyResources". The family should have a default
                     resource bundle which simply has the same name as its family -
                     "MyResources" - and will be used as the bundle of last resort if a
                     specific locale is not supported. The family can then provide as
                     many locale-specific members as needed, for example a German one
                     named "MyResources_de".
                    
                     &lt;P&gt;
                     Each resource bundle in a family contains the same items, but the items have
                     been translated for the locale represented by that resource bundle.
                     For example, both "MyResources" and "MyResources_de" may have a
                     &lt;code&gt;String&lt;/code&gt; that's used on a button for canceling operations.
                     In "MyResources" the &lt;code&gt;String&lt;/code&gt; may contain "Cancel" and in
                     "MyResources_de" it may contain "Abbrechen".
                    
                     &lt;P&gt;
                     If there are different resources for different countries, you
                     can make specializations: for example, "MyResources_de_CH" contains objects for
                     the German language (de) in Switzerland (CH). If you want to only
                     modify some of the resources
                     in the specialization, you can do so.
                    
                     &lt;P&gt;
                     When your program needs a locale-specific object, it loads
                     the &lt;code&gt;ResourceBundle&lt;/code&gt; class using the
                     {@link #getBundle(java.lang.String, java.util.Locale) getBundle}
                     method:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     ResourceBundle myResources =
                          ResourceBundle.getBundle("MyResources", currentLocale);
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;P&gt;
                     Resource bundles contain key/value pairs. The keys uniquely
                     identify a locale-specific object in the bundle. Here's an
                     example of a &lt;code&gt;ListResourceBundle&lt;/code&gt; that contains
                     two key/value pairs:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     public class MyResources extends ListResourceBundle {
                         protected Object[][] getContents() {
                             return new Object[][] {
                                 // LOCALIZE THE SECOND STRING OF EACH ARRAY (e.g., "OK")
                                 {"OkKey", "OK"},
                                 {"CancelKey", "Cancel"},
                                 // END OF MATERIAL TO LOCALIZE
                            };
                         }
                     }
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                     Keys are always &lt;code&gt;String&lt;/code&gt;s.
                     In this example, the keys are "OkKey" and "CancelKey".
                     In the above example, the values
                     are also &lt;code&gt;String&lt;/code&gt;s--"OK" and "Cancel"--but
                     they don't have to be. The values can be any type of object.
                    
                     &lt;P&gt;
                     You retrieve an object from resource bundle using the appropriate
                     getter method. Because "OkKey" and "CancelKey"
                     are both strings, you would use &lt;code&gt;getString&lt;/code&gt; to retrieve them:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     button1 = new Button(myResources.getString("OkKey"));
                     button2 = new Button(myResources.getString("CancelKey"));
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                     The getter methods all require the key as an argument and return
                     the object if found. If the object is not found, the getter method
                     throws a &lt;code&gt;MissingResourceException&lt;/code&gt;.
                    
                     &lt;P&gt;
                     Besides &lt;code&gt;getString&lt;/code&gt;, &lt;code&gt;ResourceBundle&lt;/code&gt; also provides
                     a method for getting string arrays, &lt;code&gt;getStringArray&lt;/code&gt;,
                     as well as a generic &lt;code&gt;getObject&lt;/code&gt; method for any other
                     type of object. When using &lt;code&gt;getObject&lt;/code&gt;, you'll
                     have to cast the result to the appropriate type. For example:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     int[] myIntegers = (int[]) myResources.getObject("intList");
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;P&gt;
                     The Java Platform provides two subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt;,
                     &lt;code&gt;ListResourceBundle&lt;/code&gt; and &lt;code&gt;PropertyResourceBundle&lt;/code&gt;,
                     that provide a fairly simple way to create resources.
                     As you saw briefly in a previous example, &lt;code&gt;ListResourceBundle&lt;/code&gt;
                     manages its resource as a list of key/value pairs.
                     &lt;code&gt;PropertyResourceBundle&lt;/code&gt; uses a properties file to manage
                     its resources.
                    
                     &lt;p&gt;
                     If &lt;code&gt;ListResourceBundle&lt;/code&gt; or &lt;code&gt;PropertyResourceBundle&lt;/code&gt;
                     do not suit your needs, you can write your own &lt;code&gt;ResourceBundle&lt;/code&gt;
                     subclass.  Your subclasses must override two methods: &lt;code&gt;handleGetObject&lt;/code&gt;
                     and &lt;code&gt;getKeys()&lt;/code&gt;.
                    
                     &lt;p&gt;
                     The implementation of a {@code ResourceBundle} subclass must be thread-safe
                     if it's simultaneously used by multiple threads. The default implementations
                     of the non-abstract methods in this class, and the methods in the direct
                     known concrete subclasses {@code ListResourceBundle} and
                     {@code PropertyResourceBundle} are thread-safe.
                    
                     &lt;h3&gt;&lt;a id="resource-bundle-modules"&gt;Resource Bundles and Named Modules&lt;/a&gt;&lt;/h3&gt;
                    
                     Resource bundles can be deployed in modules in the following ways:
                    
                     &lt;h4&gt;Resource bundles together with an application&lt;/h4&gt;
                    
                     Resource bundles can be deployed together with an application in the same
                     module.  In that case, the resource bundles are loaded
                     by code in the module by calling the {@link #getBundle(String)}
                     or {@link #getBundle(String, Locale)} method.
                    
                     &lt;h4&gt;&lt;a id="service-providers"&gt;Resource bundles as service providers&lt;/a&gt;&lt;/h4&gt;
                    
                     Resource bundles can be deployed in one or more &lt;em&gt;service provider modules&lt;/em&gt;
                     and they can be located using {@link ServiceLoader}.
                     A {@linkplain ResourceBundleProvider service} interface or class must be
                     defined. The caller module declares that it uses the service, the service
                     provider modules declare that they provide implementations of the service.
                     Refer to {@link ResourceBundleProvider} for developing resource bundle
                     services and deploying resource bundle providers.
                     The module obtaining the resource bundle can be a resource bundle
                     provider itself; in which case this module only locates the resource bundle
                     via service provider mechanism.
                    
                     &lt;p&gt;A {@linkplain ResourceBundleProvider resource bundle provider} can
                     provide resource bundles in any format such XML which replaces the need
                     of {@link Control ResourceBundle.Control}.
                    
                     &lt;h4&gt;&lt;a id="other-modules"&gt;Resource bundles in other modules and class path&lt;/a&gt;&lt;/h4&gt;
                    
                     Resource bundles in a named module may be &lt;em&gt;encapsulated&lt;/em&gt; so that
                     it cannot be located by code in other modules.  Resource bundles
                     in unnamed modules and class path are open for any module to access.
                     Resource bundle follows the resource encapsulation rules as specified
                     in {@link Module#getResourceAsStream(String)}.
                    
                     &lt;p&gt;The {@code getBundle} factory methods with no {@code Control} parameter
                     locate and load resource bundles from
                     {@linkplain ResourceBundleProvider service providers}.
                     It may continue the search as if calling {@link Module#getResourceAsStream(String)}
                     to find the named resource from a given module and calling
                     {@link ClassLoader#getResourceAsStream(String)}; refer to
                     the specification of the {@code getBundle} method for details.
                     Only non-encapsulated resource bundles of "{@code java.class}"
                     or "{@code java.properties}" format are searched.
                    
                     &lt;p&gt;If the caller module is a
                     &lt;a href="{@docRoot}/java.base/java/util/spi/ResourceBundleProvider.html#obtain-resource-bundle"&gt;
                     resource bundle provider&lt;/a&gt;, it does not fall back to the
                     class loader search.
                    
                     &lt;h4&gt;Resource bundles in automatic modules&lt;/h4&gt;
                    
                     A common format of resource bundles is in {@linkplain PropertyResourceBundle
                     .properties} file format.  Typically {@code .properties} resource bundles
                     are packaged in a JAR file.  Resource bundle only JAR file can be readily
                     deployed as an &lt;a href="{@docRoot}/java.base/java/lang/module/ModuleFinder.html#automatic-modules"&gt;
                     automatic module&lt;/a&gt;.  For example, if the JAR file contains the
                     entry "{@code p/q/Foo_ja.properties}" and no {@code .class} entry,
                     when resolved and defined as an automatic module, no package is derived
                     for this module.  This allows resource bundles in {@code .properties}
                     format packaged in one or more JAR files that may contain entries
                     in the same directory and can be resolved successfully as
                     automatic modules.
                    
                     &lt;h3&gt;ResourceBundle.Control&lt;/h3&gt;
                    
                     The {@link ResourceBundle.Control} class provides information necessary
                     to perform the bundle loading process by the &lt;code&gt;getBundle&lt;/code&gt;
                     factory methods that take a &lt;code&gt;ResourceBundle.Control&lt;/code&gt;
                     instance. You can implement your own subclass in order to enable
                     non-standard resource bundle formats, change the search strategy, or
                     define caching parameters. Refer to the descriptions of the class and the
                     {@link #getBundle(String, Locale, ClassLoader, Control) getBundle}
                     factory method for details.
                    
                     &lt;p&gt; {@link ResourceBundle.Control} is designed for an application deployed
                     in an unnamed module, for example to support resource bundles in
                     non-standard formats or package localized resources in a non-traditional
                     convention. {@link ResourceBundleProvider} is the replacement for
                     {@code ResourceBundle.Control} when migrating to modules.
                     {@code UnsupportedOperationException} will be thrown when a factory
                     method that takes the {@code ResourceBundle.Control} parameter is called.
                    
                     &lt;p&gt;&lt;a id="modify_default_behavior"&gt;For the {@code getBundle} factory&lt;/a&gt;
                     methods that take no {@link Control} instance, their &lt;a
                     href="#default_behavior"&gt; default behavior&lt;/a&gt; of resource bundle loading
                     can be modified with custom {@link
                     ResourceBundleControlProvider} implementations.
                     If any of the
                     providers provides a {@link Control} for the given base name, that {@link
                     Control} will be used instead of the default {@link Control}. If there is
                     more than one service provider for supporting the same base name,
                     the first one returned from {@link ServiceLoader} will be used.
                     A custom {@link Control} implementation is ignored by named modules.
                    
                     &lt;h3&gt;Cache Management&lt;/h3&gt;
                    
                     Resource bundle instances created by the &lt;code&gt;getBundle&lt;/code&gt; factory
                     methods are cached by default, and the factory methods return the same
                     resource bundle instance multiple times if it has been
                     cached. &lt;code&gt;getBundle&lt;/code&gt; clients may clear the cache, manage the
                     lifetime of cached resource bundle instances using time-to-live values,
                     or specify not to cache resource bundle instances. Refer to the
                     descriptions of the {@linkplain #getBundle(String, Locale, ClassLoader,
                     Control) &lt;code&gt;getBundle&lt;/code&gt; factory method}, {@link
                     #clearCache(ClassLoader) clearCache}, {@link
                     Control#getTimeToLive(String, Locale)
                     ResourceBundle.Control.getTimeToLive}, and {@link
                     Control#needsReload(String, Locale, String, ClassLoader, ResourceBundle,
                     long) ResourceBundle.Control.needsReload} for details.
                    
                     &lt;h3&gt;Example&lt;/h3&gt;
                    
                     The following is a very simple example of a &lt;code&gt;ResourceBundle&lt;/code&gt;
                     subclass, &lt;code&gt;MyResources&lt;/code&gt;, that manages two resources (for a larger number of
                     resources you would probably use a &lt;code&gt;Map&lt;/code&gt;).
                     Notice that you don't need to supply a value if
                     a "parent-level" &lt;code&gt;ResourceBundle&lt;/code&gt; handles the same
                     key with the same value (as for the okKey below).
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     // default (English language, United States)
                     public class MyResources extends ResourceBundle {
                         public Object handleGetObject(String key) {
                             if (key.equals("okKey")) return "Ok";
                             if (key.equals("cancelKey")) return "Cancel";
                             return null;
                         }
                    
                         public Enumeration&amp;lt;String&amp;gt; getKeys() {
                             return Collections.enumeration(keySet());
                         }
                    
                         // Overrides handleKeySet() so that the getKeys() implementation
                         // can rely on the keySet() value.
                         protected Set&amp;lt;String&amp;gt; handleKeySet() {
                             return new HashSet&amp;lt;String&amp;gt;(Arrays.asList("okKey", "cancelKey"));
                         }
                     }
                    
                     // German language
                     public class MyResources_de extends MyResources {
                         public Object handleGetObject(String key) {
                             // don't need okKey, since parent level handles it.
                             if (key.equals("cancelKey")) return "Abbrechen";
                             return null;
                         }
                    
                         protected Set&amp;lt;String&amp;gt; handleKeySet() {
                             return new HashSet&amp;lt;String&amp;gt;(Arrays.asList("cancelKey"));
                         }
                     }
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                     You do not have to restrict yourself to using a single family of
                     &lt;code&gt;ResourceBundle&lt;/code&gt;s. For example, you could have a set of bundles for
                     exception messages, &lt;code&gt;ExceptionResources&lt;/code&gt;
                     (&lt;code&gt;ExceptionResources_fr&lt;/code&gt;, &lt;code&gt;ExceptionResources_de&lt;/code&gt;, ...),
                     and one for widgets, &lt;code&gt;WidgetResource&lt;/code&gt; (&lt;code&gt;WidgetResources_fr&lt;/code&gt;,
                     &lt;code&gt;WidgetResources_de&lt;/code&gt;, ...); breaking up the resources however you like.
                    
                     @see ListResourceBundle
                     @see PropertyResourceBundle
                     @see MissingResourceException
                     @see ResourceBundleProvider
                     @since 1.1
                     @revised 9
                     @spec JPMS
                    </javadoc>
            </acts>
            <acts name="OfInt" access="PUBLIC" declaringClass="Spliterator" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Spliterator$OfPrimitive"/>
                </superTypes>
            </acts>
            <acts name="IllegalFormatWidthException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.IllegalFormatException"/>
                    <superType superType="java.lang.IllegalArgumentException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Unchecked exception thrown when the format width is a negative value other
                     than {@code -1} or is otherwise unsupported.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="OfInt" access="PUBLIC" declaringClass="PrimitiveIterator" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.PrimitiveIterator"/>
                </superTypes>
            </acts>
            <acts name="Dictionary" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Dictionary} class is the abstract parent of any
                     class, such as {@code Hashtable}, which maps keys to values.
                     Every key and every value is an object. In any one {@code Dictionary}
                     object, every key is associated with at most one value. Given a
                     {@code Dictionary} and a key, the associated element can be looked up.
                     Any non-{@code null} object can be used as a key and as a value.
                     &lt;p&gt;
                     As a rule, the {@code equals} method should be used by
                     implementations of this class to decide if two keys are the same.
                     &lt;p&gt;
                     &lt;strong&gt;NOTE: This class is obsolete.  New implementations should
                     implement the Map interface, rather than extending this class.&lt;/strong&gt;
                    
                     @author  unascribed
                     @see     java.util.Map
                     @see     java.lang.Object#equals(java.lang.Object)
                     @see     java.lang.Object#hashCode()
                     @see     java.util.Hashtable
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Scanner" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Iterator"/>
                    <superType superType="java.io.Closeable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A simple text scanner which can parse primitive types and strings using
                     regular expressions.
                    
                     &lt;p&gt;A {@code Scanner} breaks its input into tokens using a
                     delimiter pattern, which by default matches whitespace. The resulting
                     tokens may then be converted into values of different types using the
                     various {@code next} methods.
                    
                     &lt;p&gt;For example, this code allows a user to read a number from
                     {@code System.in}:
                     &lt;blockquote&gt;&lt;pre&gt;{@code
                         Scanner sc = new Scanner(System.in);
                         int i = sc.nextInt();
                     }&lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt;As another example, this code allows {@code long} types to be
                     assigned from entries in a file {@code myNumbers}:
                     &lt;blockquote&gt;&lt;pre&gt;{@code
                          Scanner sc = new Scanner(new File("myNumbers"));
                          while (sc.hasNextLong()) {
                              long aLong = sc.nextLong();
                          }
                     }&lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt;The scanner can also use delimiters other than whitespace. This
                     example reads several items in from a string:
                     &lt;blockquote&gt;&lt;pre&gt;{@code
                         String input = "1 fish 2 fish red fish blue fish";
                         Scanner s = new Scanner(input).useDelimiter("\\s*fish\\s*");
                         System.out.println(s.nextInt());
                         System.out.println(s.nextInt());
                         System.out.println(s.next());
                         System.out.println(s.next());
                         s.close();
                     }&lt;/pre&gt;&lt;/blockquote&gt;
                     &lt;p&gt;
                     prints the following output:
                     &lt;blockquote&gt;&lt;pre&gt;{@code
                         1
                         2
                         red
                         blue
                     }&lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt;The same output can be generated with this code, which uses a regular
                     expression to parse all four tokens at once:
                     &lt;blockquote&gt;&lt;pre&gt;{@code
                         String input = "1 fish 2 fish red fish blue fish";
                         Scanner s = new Scanner(input);
                         s.findInLine("(\\d+) fish (\\d+) fish (\\w+) fish (\\w+)");
                         MatchResult result = s.match();
                         for (int i=1; i&lt;=result.groupCount(); i++)
                             System.out.println(result.group(i));
                         s.close();
                     }&lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt;The &lt;a id="default-delimiter"&gt;default whitespace delimiter&lt;/a&gt; used
                     by a scanner is as recognized by {@link Character#isWhitespace(char)
                     Character.isWhitespace()}. The {@link #reset reset()}
                     method will reset the value of the scanner's delimiter to the default
                     whitespace delimiter regardless of whether it was previously changed.
                    
                     &lt;p&gt;A scanning operation may block waiting for input.
                    
                     &lt;p&gt;The {@link #next} and {@link #hasNext} methods and their
                     companion methods (such as {@link #nextInt} and
                     {@link #hasNextInt}) first skip any input that matches the delimiter
                     pattern, and then attempt to return the next token. Both {@code hasNext()}
                     and {@code next()} methods may block waiting for further input.  Whether a
                     {@code hasNext()} method blocks has no connection to whether or not its
                     associated {@code next()} method will block. The {@link #tokens} method
                     may also block waiting for input.
                    
                     &lt;p&gt;The {@link #findInLine findInLine()},
                     {@link #findWithinHorizon findWithinHorizon()},
                     {@link #skip skip()}, and {@link #findAll findAll()}
                     methods operate independently of the delimiter pattern. These methods will
                     attempt to match the specified pattern with no regard to delimiters in the
                     input and thus can be used in special circumstances where delimiters are
                     not relevant. These methods may block waiting for more input.
                    
                     &lt;p&gt;When a scanner throws an {@link InputMismatchException}, the scanner
                     will not pass the token that caused the exception, so that it may be
                     retrieved or skipped via some other method.
                    
                     &lt;p&gt;Depending upon the type of delimiting pattern, empty tokens may be
                     returned. For example, the pattern {@code "\\s+"} will return no empty
                     tokens since it matches multiple instances of the delimiter. The delimiting
                     pattern {@code "\\s"} could return empty tokens since it only passes one
                     space at a time.
                    
                     &lt;p&gt; A scanner can read text from any object which implements the {@link
                     java.lang.Readable} interface.  If an invocation of the underlying
                     readable's {@link java.lang.Readable#read read()} method throws an {@link
                     java.io.IOException} then the scanner assumes that the end of the input
                     has been reached.  The most recent {@code IOException} thrown by the
                     underlying readable can be retrieved via the {@link #ioException} method.
                    
                     &lt;p&gt;When a {@code Scanner} is closed, it will close its input source
                     if the source implements the {@link java.io.Closeable} interface.
                    
                     &lt;p&gt;A {@code Scanner} is not safe for multithreaded use without
                     external synchronization.
                    
                     &lt;p&gt;Unless otherwise mentioned, passing a {@code null} parameter into
                     any method of a {@code Scanner} will cause a
                     {@code NullPointerException} to be thrown.
                    
                     &lt;p&gt;A scanner will default to interpreting numbers as decimal unless a
                     different radix has been set by using the {@link #useRadix} method. The
                     {@link #reset} method will reset the value of the scanner's radix to
                     {@code 10} regardless of whether it was previously changed.
                    
                     &lt;h3&gt; &lt;a id="localized-numbers"&gt;Localized numbers&lt;/a&gt; &lt;/h3&gt;
                    
                     &lt;p&gt; An instance of this class is capable of scanning numbers in the standard
                     formats as well as in the formats of the scanner's locale. A scanner's
                     &lt;a id="initial-locale"&gt;initial locale &lt;/a&gt;is the value returned by the {@link
                     java.util.Locale#getDefault(Locale.Category)
                     Locale.getDefault(Locale.Category.FORMAT)} method; it may be changed via the {@link
                     #useLocale useLocale()} method. The {@link #reset} method will reset the value of the
                     scanner's locale to the initial locale regardless of whether it was
                     previously changed.
                    
                     &lt;p&gt;The localized formats are defined in terms of the following parameters,
                     which for a particular locale are taken from that locale's {@link
                     java.text.DecimalFormat DecimalFormat} object, {@code df}, and its and
                     {@link java.text.DecimalFormatSymbols DecimalFormatSymbols} object,
                     {@code dfs}.
                    
                     &lt;blockquote&gt;&lt;dl&gt;
                         &lt;dt&gt;&lt;i&gt;LocalGroupSeparator&amp;nbsp;&amp;nbsp;&lt;/i&gt;
                             &lt;dd&gt;The character used to separate thousands groups,
                             &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;{@code dfs.}{@link
                             java.text.DecimalFormatSymbols#getGroupingSeparator
                             getGroupingSeparator()}
                         &lt;dt&gt;&lt;i&gt;LocalDecimalSeparator&amp;nbsp;&amp;nbsp;&lt;/i&gt;
                             &lt;dd&gt;The character used for the decimal point,
                         &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;{@code dfs.}{@link
                         java.text.DecimalFormatSymbols#getDecimalSeparator
                         getDecimalSeparator()}
                         &lt;dt&gt;&lt;i&gt;LocalPositivePrefix&amp;nbsp;&amp;nbsp;&lt;/i&gt;
                             &lt;dd&gt;The string that appears before a positive number (may
                             be empty), &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;{@code df.}{@link
                             java.text.DecimalFormat#getPositivePrefix
                             getPositivePrefix()}
                         &lt;dt&gt;&lt;i&gt;LocalPositiveSuffix&amp;nbsp;&amp;nbsp;&lt;/i&gt;
                             &lt;dd&gt;The string that appears after a positive number (may be
                             empty), &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;{@code df.}{@link
                             java.text.DecimalFormat#getPositiveSuffix
                             getPositiveSuffix()}
                         &lt;dt&gt;&lt;i&gt;LocalNegativePrefix&amp;nbsp;&amp;nbsp;&lt;/i&gt;
                             &lt;dd&gt;The string that appears before a negative number (may
                             be empty), &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;{@code df.}{@link
                             java.text.DecimalFormat#getNegativePrefix
                             getNegativePrefix()}
                         &lt;dt&gt;&lt;i&gt;LocalNegativeSuffix&amp;nbsp;&amp;nbsp;&lt;/i&gt;
                             &lt;dd&gt;The string that appears after a negative number (may be
                             empty), &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;{@code df.}{@link
                         java.text.DecimalFormat#getNegativeSuffix
                         getNegativeSuffix()}
                         &lt;dt&gt;&lt;i&gt;LocalNaN&amp;nbsp;&amp;nbsp;&lt;/i&gt;
                             &lt;dd&gt;The string that represents not-a-number for
                             floating-point values,
                             &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;{@code dfs.}{@link
                             java.text.DecimalFormatSymbols#getNaN
                             getNaN()}
                         &lt;dt&gt;&lt;i&gt;LocalInfinity&amp;nbsp;&amp;nbsp;&lt;/i&gt;
                             &lt;dd&gt;The string that represents infinity for floating-point
                             values, &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;{@code dfs.}{@link
                             java.text.DecimalFormatSymbols#getInfinity
                             getInfinity()}
                     &lt;/dl&gt;&lt;/blockquote&gt;
                    
                     &lt;h4&gt; &lt;a id="number-syntax"&gt;Number syntax&lt;/a&gt; &lt;/h4&gt;
                    
                     &lt;p&gt; The strings that can be parsed as numbers by an instance of this class
                     are specified in terms of the following regular-expression grammar, where
                     Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10).
                    
                     &lt;dl&gt;
                       &lt;dt&gt;&lt;i&gt;NonAsciiDigit&lt;/i&gt;:
                           &lt;dd&gt;A non-ASCII character c for which
                                {@link java.lang.Character#isDigit Character.isDigit}{@code (c)}
                                            returns&amp;nbsp;true
                    
                       &lt;dt&gt;&lt;i&gt;Non0Digit&lt;/i&gt;:
                           &lt;dd&gt;{@code [1-}&lt;i&gt;Rmax&lt;/i&gt;{@code ] | }&lt;i&gt;NonASCIIDigit&lt;/i&gt;
                    
                       &lt;dt&gt;&lt;i&gt;Digit&lt;/i&gt;:
                           &lt;dd&gt;{@code [0-}&lt;i&gt;Rmax&lt;/i&gt;{@code ] | }&lt;i&gt;NonASCIIDigit&lt;/i&gt;
                    
                       &lt;dt&gt;&lt;i&gt;GroupedNumeral&lt;/i&gt;:
                           &lt;dd&gt;&lt;code&gt;(&amp;nbsp;&lt;/code&gt;&lt;i&gt;Non0Digit&lt;/i&gt;
                                       &lt;i&gt;Digit&lt;/i&gt;{@code ?
                                       }&lt;i&gt;Digit&lt;/i&gt;{@code ?}
                           &lt;dd&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;(&amp;nbsp;&lt;/code&gt;&lt;i&gt;LocalGroupSeparator&lt;/i&gt;
                                             &lt;i&gt;Digit&lt;/i&gt;
                                             &lt;i&gt;Digit&lt;/i&gt;
                                             &lt;i&gt;Digit&lt;/i&gt;{@code  )+ )}
                    
                       &lt;dt&gt;&lt;i&gt;Numeral&lt;/i&gt;:
                           &lt;dd&gt;{@code ( ( }&lt;i&gt;Digit&lt;/i&gt;{@code + )
                                   | }&lt;i&gt;GroupedNumeral&lt;/i&gt;{@code  )}
                    
                       &lt;dt&gt;&lt;a id="Integer-regex"&gt;&lt;i&gt;Integer&lt;/i&gt;:&lt;/a&gt;
                           &lt;dd&gt;{@code ( [-+]? ( }&lt;i&gt;Numeral&lt;/i&gt;{@code
                                                   ) )}
                           &lt;dd&gt;{@code | }&lt;i&gt;LocalPositivePrefix&lt;/i&gt; &lt;i&gt;Numeral&lt;/i&gt;
                                          &lt;i&gt;LocalPositiveSuffix&lt;/i&gt;
                           &lt;dd&gt;{@code | }&lt;i&gt;LocalNegativePrefix&lt;/i&gt; &lt;i&gt;Numeral&lt;/i&gt;
                                     &lt;i&gt;LocalNegativeSuffix&lt;/i&gt;
                    
                       &lt;dt&gt;&lt;i&gt;DecimalNumeral&lt;/i&gt;:
                           &lt;dd&gt;&lt;i&gt;Numeral&lt;/i&gt;
                           &lt;dd&gt;{@code | }&lt;i&gt;Numeral&lt;/i&gt;
                                     &lt;i&gt;LocalDecimalSeparator&lt;/i&gt;
                                     &lt;i&gt;Digit&lt;/i&gt;{@code *}
                           &lt;dd&gt;{@code | }&lt;i&gt;LocalDecimalSeparator&lt;/i&gt;
                                     &lt;i&gt;Digit&lt;/i&gt;{@code +}
                    
                       &lt;dt&gt;&lt;i&gt;Exponent&lt;/i&gt;:
                           &lt;dd&gt;{@code ( [eE] [+-]? }&lt;i&gt;Digit&lt;/i&gt;{@code + )}
                    
                       &lt;dt&gt;&lt;a id="Decimal-regex"&gt;&lt;i&gt;Decimal&lt;/i&gt;:&lt;/a&gt;
                           &lt;dd&gt;{@code ( [-+]? }&lt;i&gt;DecimalNumeral&lt;/i&gt;
                                             &lt;i&gt;Exponent&lt;/i&gt;{@code ? )}
                           &lt;dd&gt;{@code | }&lt;i&gt;LocalPositivePrefix&lt;/i&gt;
                                     &lt;i&gt;DecimalNumeral&lt;/i&gt;
                                     &lt;i&gt;LocalPositiveSuffix&lt;/i&gt;
                                     &lt;i&gt;Exponent&lt;/i&gt;{@code ?}
                           &lt;dd&gt;{@code | }&lt;i&gt;LocalNegativePrefix&lt;/i&gt;
                                     &lt;i&gt;DecimalNumeral&lt;/i&gt;
                                     &lt;i&gt;LocalNegativeSuffix&lt;/i&gt;
                                     &lt;i&gt;Exponent&lt;/i&gt;{@code ?}
                    
                       &lt;dt&gt;&lt;i&gt;HexFloat&lt;/i&gt;:
                           &lt;dd&gt;{@code [-+]? 0[xX][0-9a-fA-F]*\.[0-9a-fA-F]+
                                     ([pP][-+]?[0-9]+)?}
                    
                       &lt;dt&gt;&lt;i&gt;NonNumber&lt;/i&gt;:
                           &lt;dd&gt;{@code NaN
                                              | }&lt;i&gt;LocalNan&lt;/i&gt;{@code
                                              | Infinity
                                              | }&lt;i&gt;LocalInfinity&lt;/i&gt;
                    
                       &lt;dt&gt;&lt;i&gt;SignedNonNumber&lt;/i&gt;:
                           &lt;dd&gt;{@code ( [-+]? }&lt;i&gt;NonNumber&lt;/i&gt;{@code  )}
                           &lt;dd&gt;{@code | }&lt;i&gt;LocalPositivePrefix&lt;/i&gt;
                                     &lt;i&gt;NonNumber&lt;/i&gt;
                                     &lt;i&gt;LocalPositiveSuffix&lt;/i&gt;
                           &lt;dd&gt;{@code | }&lt;i&gt;LocalNegativePrefix&lt;/i&gt;
                                     &lt;i&gt;NonNumber&lt;/i&gt;
                                     &lt;i&gt;LocalNegativeSuffix&lt;/i&gt;
                    
                       &lt;dt&gt;&lt;a id="Float-regex"&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt;:
                           &lt;dd&gt;&lt;i&gt;Decimal&lt;/i&gt;
                               {@code | }&lt;i&gt;HexFloat&lt;/i&gt;
                               {@code | }&lt;i&gt;SignedNonNumber&lt;/i&gt;
                    
                     &lt;/dl&gt;
                     &lt;p&gt;Whitespace is not significant in the above regular expressions.
                    
                     @since   1.5
                    </javadoc>
            </acts>
            <acts name="NavigableSet" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.SortedSet"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@link SortedSet} extended with navigation methods reporting
                     closest matches for given search targets. Methods {@link #lower},
                     {@link #floor}, {@link #ceiling}, and {@link #higher} return elements
                     respectively less than, less than or equal, greater than or equal,
                     and greater than a given element, returning {@code null} if there
                     is no such element.
                    
                     &lt;p&gt;A {@code NavigableSet} may be accessed and traversed in either
                     ascending or descending order.  The {@link #descendingSet} method
                     returns a view of the set with the senses of all relational and
                     directional methods inverted. The performance of ascending
                     operations and views is likely to be faster than that of descending
                     ones.  This interface additionally defines methods {@link
                     #pollFirst} and {@link #pollLast} that return and remove the lowest
                     and highest element, if one exists, else returning {@code null}.
                     Methods
                     {@link #subSet(Object, boolean, Object, boolean) subSet(E, boolean, E, boolean)},
                     {@link #headSet(Object, boolean) headSet(E, boolean)}, and
                     {@link #tailSet(Object, boolean) tailSet(E, boolean)}
                     differ from the like-named {@code SortedSet} methods in accepting
                     additional arguments describing whether lower and upper bounds are
                     inclusive versus exclusive.  Subsets of any {@code NavigableSet}
                     must implement the {@code NavigableSet} interface.
                    
                     &lt;p&gt;The return values of navigation methods may be ambiguous in
                     implementations that permit {@code null} elements. However, even
                     in this case the result can be disambiguated by checking
                     {@code contains(null)}. To avoid such issues, implementations of
                     this interface are encouraged to &lt;em&gt;not&lt;/em&gt; permit insertion of
                     {@code null} elements. (Note that sorted sets of {@link
                     Comparable} elements intrinsically do not permit {@code null}.)
                    
                     &lt;p&gt;Methods
                     {@link #subSet(Object, Object) subSet(E, E)},
                     {@link #headSet(Object) headSet(E)}, and
                     {@link #tailSet(Object) tailSet(E)}
                     are specified to return {@code SortedSet} to allow existing
                     implementations of {@code SortedSet} to be compatibly retrofitted to
                     implement {@code NavigableSet}, but extensions and implementations
                     of this interface are encouraged to override these methods to return
                     {@code NavigableSet}.
                    
                     &lt;p&gt;This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @author Doug Lea
                     @author Josh Bloch
                     @param &lt;E&gt; the type of elements maintained by this set
                     @since 1.6
                    </javadoc>
            </acts>
            <acts name="OfLong" access="PUBLIC" declaringClass="PrimitiveIterator" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.PrimitiveIterator"/>
                </superTypes>
            </acts>
            <acts name="DuplicateFormatFlagsException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.IllegalFormatException"/>
                    <superType superType="java.lang.IllegalArgumentException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Unchecked exception thrown when duplicate flags are provided in the format
                     specifier.
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
                     method or constructor in this class will cause a {@link
                     NullPointerException} to be thrown.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="FormattableFlags" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     FormattableFlags are passed to the {@link Formattable#formatTo
                     Formattable.formatTo()} method and modify the output format for {@linkplain
                     Formattable Formattables}.  Implementations of {@link Formattable} are
                     responsible for interpreting and validating any flags.
                    
                     @since  1.5
                    </javadoc>
            </acts>
            <acts name="NavigableMap" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.SortedMap"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@link SortedMap} extended with navigation methods returning the
                     closest matches for given search targets. Methods
                     {@link #lowerEntry}, {@link #floorEntry}, {@link #ceilingEntry},
                     and {@link #higherEntry} return {@code Map.Entry} objects
                     associated with keys respectively less than, less than or equal,
                     greater than or equal, and greater than a given key, returning
                     {@code null} if there is no such key.  Similarly, methods
                     {@link #lowerKey}, {@link #floorKey}, {@link #ceilingKey}, and
                     {@link #higherKey} return only the associated keys. All of these
                     methods are designed for locating, not traversing entries.
                    
                     &lt;p&gt;A {@code NavigableMap} may be accessed and traversed in either
                     ascending or descending key order.  The {@link #descendingMap}
                     method returns a view of the map with the senses of all relational
                     and directional methods inverted. The performance of ascending
                     operations and views is likely to be faster than that of descending
                     ones.  Methods
                     {@link #subMap(Object, boolean, Object, boolean) subMap(K, boolean, K, boolean)},
                     {@link #headMap(Object, boolean) headMap(K, boolean)}, and
                     {@link #tailMap(Object, boolean) tailMap(K, boolean)}
                     differ from the like-named {@code SortedMap} methods in accepting
                     additional arguments describing whether lower and upper bounds are
                     inclusive versus exclusive.  Submaps of any {@code NavigableMap}
                     must implement the {@code NavigableMap} interface.
                    
                     &lt;p&gt;This interface additionally defines methods {@link #firstEntry},
                     {@link #pollFirstEntry}, {@link #lastEntry}, and
                     {@link #pollLastEntry} that return and/or remove the least and
                     greatest mappings, if any exist, else returning {@code null}.
                    
                     &lt;p&gt;Implementations of entry-returning methods are expected to
                     return {@code Map.Entry} pairs representing snapshots of mappings
                     at the time they were produced, and thus generally do &lt;em&gt;not&lt;/em&gt;
                     support the optional {@code Entry.setValue} method. Note however
                     that it is possible to change mappings in the associated map using
                     method {@code put}.
                    
                     &lt;p&gt;Methods
                     {@link #subMap(Object, Object) subMap(K, K)},
                     {@link #headMap(Object) headMap(K)}, and
                     {@link #tailMap(Object) tailMap(K)}
                     are specified to return {@code SortedMap} to allow existing
                     implementations of {@code SortedMap} to be compatibly retrofitted to
                     implement {@code NavigableMap}, but extensions and implementations
                     of this interface are encouraged to override these methods to return
                     {@code NavigableMap}.  Similarly,
                     {@link #keySet()} can be overridden to return {@link NavigableSet}.
                    
                     &lt;p&gt;This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @author Doug Lea
                     @author Josh Bloch
                     @param &lt;K&gt; the type of keys maintained by this map
                     @param &lt;V&gt; the type of mapped values
                     @since 1.6
                    </javadoc>
            </acts>
            <acts name="Formatter" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.io.Closeable"/>
                    <superType superType="java.io.Flushable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An interpreter for printf-style format strings.  This class provides support
                     for layout justification and alignment, common formats for numeric, string,
                     and date/time data, and locale-specific output.  Common Java types such as
                     {@code byte}, {@link java.math.BigDecimal BigDecimal}, and {@link Calendar}
                     are supported.  Limited formatting customization for arbitrary user types is
                     provided through the {@link Formattable} interface.
                    
                     &lt;p&gt; Formatters are not necessarily safe for multithreaded access.  Thread
                     safety is optional and is the responsibility of users of methods in this
                     class.
                    
                     &lt;p&gt; Formatted printing for the Java language is heavily inspired by C's
                     {@code printf}.  Although the format strings are similar to C, some
                     customizations have been made to accommodate the Java language and exploit
                     some of its features.  Also, Java formatting is more strict than C's; for
                     example, if a conversion is incompatible with a flag, an exception will be
                     thrown.  In C inapplicable flags are silently ignored.  The format strings
                     are thus intended to be recognizable to C programmers but not necessarily
                     completely compatible with those in C.
                    
                     &lt;p&gt; Examples of expected usage:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                       StringBuilder sb = new StringBuilder();
                       // Send all output to the Appendable object sb
                       Formatter formatter = new Formatter(sb, Locale.US);
                    
                       // Explicit argument indices may be used to re-order output.
                       formatter.format("%4$2s %3$2s %2$2s %1$2s", "a", "b", "c", "d")
                       // -&amp;gt; " d  c  b  a"
                    
                       // Optional locale as the first argument can be used to get
                       // locale-specific formatting of numbers.  The precision and width can be
                       // given to round and align the value.
                       formatter.format(Locale.FRANCE, "e = %+10.4f", Math.E);
                       // -&amp;gt; "e =    +2,7183"
                    
                       // The '(' numeric flag may be used to format negative numbers with
                       // parentheses rather than a minus sign.  Group separators are
                       // automatically inserted.
                       formatter.format("Amount gained or lost since last statement: $ %(,.2f",
                                        balanceDelta);
                       // -&amp;gt; "Amount gained or lost since last statement: $ (6,217.58)"
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt; Convenience methods for common formatting requests exist as illustrated
                     by the following invocations:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                       // Writes a formatted string to System.out.
                       System.out.format("Local time: %tT", Calendar.getInstance());
                       // -&amp;gt; "Local time: 13:34:18"
                    
                       // Writes formatted output to System.err.
                       System.err.printf("Unable to open file '%1$s': %2$s",
                                         fileName, exception.getMessage());
                       // -&amp;gt; "Unable to open file 'food': No such file or directory"
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt; Like C's {@code sprintf(3)}, Strings may be formatted using the static
                     method {@link String#format(String,Object...) String.format}:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                       // Format a string containing a date.
                       import java.util.Calendar;
                       import java.util.GregorianCalendar;
                       import static java.util.Calendar.*;
                    
                       Calendar c = new GregorianCalendar(1995, MAY, 23);
                       String s = String.format("Duke's Birthday: %1$tb %1$te, %1$tY", c);
                       // -&amp;gt; s == "Duke's Birthday: May 23, 1995"
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;h3&gt;&lt;a id="org"&gt;Organization&lt;/a&gt;&lt;/h3&gt;
                    
                     &lt;p&gt; This specification is divided into two sections.  The first section, &lt;a
                     href="#summary"&gt;Summary&lt;/a&gt;, covers the basic formatting concepts.  This
                     section is intended for users who want to get started quickly and are
                     familiar with formatted printing in other programming languages.  The second
                     section, &lt;a href="#detail"&gt;Details&lt;/a&gt;, covers the specific implementation
                     details.  It is intended for users who want more precise specification of
                     formatting behavior.
                    
                     &lt;h3&gt;&lt;a id="summary"&gt;Summary&lt;/a&gt;&lt;/h3&gt;
                    
                     &lt;p&gt; This section is intended to provide a brief overview of formatting
                     concepts.  For precise behavioral details, refer to the &lt;a
                     href="#detail"&gt;Details&lt;/a&gt; section.
                    
                     &lt;h4&gt;&lt;a id="syntax"&gt;Format String Syntax&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;p&gt; Every method which produces formatted output requires a &lt;i&gt;format
                     string&lt;/i&gt; and an &lt;i&gt;argument list&lt;/i&gt;.  The format string is a {@link
                     String} which may contain fixed text and one or more embedded &lt;i&gt;format
                     specifiers&lt;/i&gt;.  Consider the following example:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                       Calendar c = ...;
                       String s = String.format("Duke's Birthday: %1$tm %1$te,%1$tY", c);
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     This format string is the first argument to the {@code format} method.  It
                     contains three format specifiers "{@code %1$tm}", "{@code %1$te}", and
                     "{@code %1$tY}" which indicate how the arguments should be processed and
                     where they should be inserted in the text.  The remaining portions of the
                     format string are fixed text including {@code "Dukes Birthday: "} and any
                     other spaces or punctuation.
                    
                     The argument list consists of all arguments passed to the method after the
                     format string.  In the above example, the argument list is of size one and
                     consists of the {@link java.util.Calendar Calendar} object {@code c}.
                    
                     &lt;ul&gt;
                    
                     &lt;li&gt; The format specifiers for general, character, and numeric types have
                     the following syntax:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                       %[argument_index$][flags][width][.precision]conversion
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt; The optional &lt;i&gt;argument_index&lt;/i&gt; is a decimal integer indicating the
                     position of the argument in the argument list.  The first argument is
                     referenced by "{@code 1$}", the second by "{@code 2$}", etc.
                    
                     &lt;p&gt; The optional &lt;i&gt;flags&lt;/i&gt; is a set of characters that modify the output
                     format.  The set of valid flags depends on the conversion.
                    
                     &lt;p&gt; The optional &lt;i&gt;width&lt;/i&gt; is a positive decimal integer indicating
                     the minimum number of characters to be written to the output.
                    
                     &lt;p&gt; The optional &lt;i&gt;precision&lt;/i&gt; is a non-negative decimal integer usually
                     used to restrict the number of characters.  The specific behavior depends on
                     the conversion.
                    
                     &lt;p&gt; The required &lt;i&gt;conversion&lt;/i&gt; is a character indicating how the
                     argument should be formatted.  The set of valid conversions for a given
                     argument depends on the argument's data type.
                    
                     &lt;li&gt; The format specifiers for types which are used to represents dates and
                     times have the following syntax:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                       %[argument_index$][flags][width]conversion
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt; The optional &lt;i&gt;argument_index&lt;/i&gt;, &lt;i&gt;flags&lt;/i&gt; and &lt;i&gt;width&lt;/i&gt; are
                     defined as above.
                    
                     &lt;p&gt; The required &lt;i&gt;conversion&lt;/i&gt; is a two character sequence.  The first
                     character is {@code 't'} or {@code 'T'}.  The second character indicates
                     the format to be used.  These characters are similar to but not completely
                     identical to those defined by GNU {@code date} and POSIX
                     {@code strftime(3c)}.
                    
                     &lt;li&gt; The format specifiers which do not correspond to arguments have the
                     following syntax:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                       %[flags][width]conversion
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt; The optional &lt;i&gt;flags&lt;/i&gt; and &lt;i&gt;width&lt;/i&gt; is defined as above.
                    
                     &lt;p&gt; The required &lt;i&gt;conversion&lt;/i&gt; is a character indicating content to be
                     inserted in the output.
                    
                     &lt;/ul&gt;
                    
                     &lt;h4&gt; Conversions &lt;/h4&gt;
                    
                     &lt;p&gt; Conversions are divided into the following categories:
                    
                     &lt;ol&gt;
                    
                     &lt;li&gt; &lt;b&gt;General&lt;/b&gt; - may be applied to any argument
                     type
                    
                     &lt;li&gt; &lt;b&gt;Character&lt;/b&gt; - may be applied to basic types which represent
                     Unicode characters: {@code char}, {@link Character}, {@code byte}, {@link
                     Byte}, {@code short}, and {@link Short}. This conversion may also be
                     applied to the types {@code int} and {@link Integer} when {@link
                     Character#isValidCodePoint} returns {@code true}
                    
                     &lt;li&gt; &lt;b&gt;Numeric&lt;/b&gt;
                    
                     &lt;ol&gt;
                    
                     &lt;li&gt; &lt;b&gt;Integral&lt;/b&gt; - may be applied to Java integral types: {@code byte},
                     {@link Byte}, {@code short}, {@link Short}, {@code int} and {@link
                     Integer}, {@code long}, {@link Long}, and {@link java.math.BigInteger
                     BigInteger} (but not {@code char} or {@link Character})
                    
                     &lt;li&gt;&lt;b&gt;Floating Point&lt;/b&gt; - may be applied to Java floating-point types:
                     {@code float}, {@link Float}, {@code double}, {@link Double}, and {@link
                     java.math.BigDecimal BigDecimal}
                    
                     &lt;/ol&gt;
                    
                     &lt;li&gt; &lt;b&gt;Date/Time&lt;/b&gt; - may be applied to Java types which are capable of
                     encoding a date or time: {@code long}, {@link Long}, {@link Calendar},
                     {@link Date} and {@link TemporalAccessor TemporalAccessor}
                    
                     &lt;li&gt; &lt;b&gt;Percent&lt;/b&gt; - produces a literal {@code '%'}
                     (&lt;code&gt;'&amp;#92;u0025'&lt;/code&gt;)
                    
                     &lt;li&gt; &lt;b&gt;Line Separator&lt;/b&gt; - produces the platform-specific line separator
                    
                     &lt;/ol&gt;
                    
                     &lt;p&gt; For category &lt;i&gt;General&lt;/i&gt;, &lt;i&gt;Character&lt;/i&gt;, &lt;i&gt;Numberic&lt;/i&gt;,
                     &lt;i&gt;Integral&lt;/i&gt; and &lt;i&gt;Date/Time&lt;/i&gt; conversion, unless otherwise specified,
                     if the argument &lt;i&gt;arg&lt;/i&gt; is {@code null}, then the result is "{@code null}".
                    
                     &lt;p&gt; The following table summarizes the supported conversions.  Conversions
                     denoted by an upper-case character (i.e. {@code 'B'}, {@code 'H'},
                     {@code 'S'}, {@code 'C'}, {@code 'X'}, {@code 'E'}, {@code 'G'},
                     {@code 'A'}, and {@code 'T'}) are the same as those for the corresponding
                     lower-case conversion characters except that the result is converted to
                     upper case according to the rules of the prevailing {@link java.util.Locale
                     Locale}. If there is no explicit locale specified, either at the
                     construction of the instance or as a parameter to its method
                     invocation, then the {@link java.util.Locale.Category#FORMAT default locale}
                     is used.
                    
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;genConv&lt;/caption&gt;
                     &lt;thead&gt;
                     &lt;tr&gt;&lt;th scope="col" style="vertical-align:bottom"&gt; Conversion
                         &lt;th scope="col" style="vertical-align:bottom"&gt; Argument Category
                         &lt;th scope="col" style="vertical-align:bottom"&gt; Description
                     &lt;/thead&gt;
                     &lt;tbody&gt;
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'b'}, {@code 'B'}
                         &lt;td style="vertical-align:top"&gt; general
                         &lt;td&gt; If the argument &lt;i&gt;arg&lt;/i&gt; is {@code null}, then the result is
                         "{@code false}".  If &lt;i&gt;arg&lt;/i&gt; is a {@code boolean} or {@link
                         Boolean}, then the result is the string returned by {@link
                         String#valueOf(boolean) String.valueOf(arg)}.  Otherwise, the result is
                         "true".
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'h'}, {@code 'H'}
                         &lt;td style="vertical-align:top"&gt; general
                         &lt;td&gt; The result is obtained by invoking
                         {@code Integer.toHexString(arg.hashCode())}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 's'}, {@code 'S'}
                         &lt;td style="vertical-align:top"&gt; general
                         &lt;td&gt; If &lt;i&gt;arg&lt;/i&gt; implements {@link Formattable}, then
                         {@link Formattable#formatTo arg.formatTo} is invoked. Otherwise, the
                         result is obtained by invoking {@code arg.toString()}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'c'}, {@code 'C'}
                         &lt;td style="vertical-align:top"&gt; character
                         &lt;td&gt; The result is a Unicode character
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'd'}
                         &lt;td style="vertical-align:top"&gt; integral
                         &lt;td&gt; The result is formatted as a decimal integer
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'o'}
                         &lt;td style="vertical-align:top"&gt; integral
                         &lt;td&gt; The result is formatted as an octal integer
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'x'}, {@code 'X'}
                         &lt;td style="vertical-align:top"&gt; integral
                         &lt;td&gt; The result is formatted as a hexadecimal integer
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'e'}, {@code 'E'}
                         &lt;td style="vertical-align:top"&gt; floating point
                         &lt;td&gt; The result is formatted as a decimal number in computerized
                         scientific notation
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'f'}
                         &lt;td style="vertical-align:top"&gt; floating point
                         &lt;td&gt; The result is formatted as a decimal number
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'g'}, {@code 'G'}
                         &lt;td style="vertical-align:top"&gt; floating point
                         &lt;td&gt; The result is formatted using computerized scientific notation or
                         decimal format, depending on the precision and the value after rounding.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'a'}, {@code 'A'}
                         &lt;td style="vertical-align:top"&gt; floating point
                         &lt;td&gt; The result is formatted as a hexadecimal floating-point number with
                         a significand and an exponent. This conversion is &lt;b&gt;not&lt;/b&gt; supported
                         for the {@code BigDecimal} type despite the latter's being in the
                         &lt;i&gt;floating point&lt;/i&gt; argument category.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 't'}, {@code 'T'}
                         &lt;td style="vertical-align:top"&gt; date/time
                         &lt;td&gt; Prefix for date and time conversion characters.  See &lt;a
                         href="#dt"&gt;Date/Time Conversions&lt;/a&gt;.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code '%'}
                         &lt;td style="vertical-align:top"&gt; percent
                         &lt;td&gt; The result is a literal {@code '%'} (&lt;code&gt;'&amp;#92;u0025'&lt;/code&gt;)
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'n'}
                         &lt;td style="vertical-align:top"&gt; line separator
                         &lt;td&gt; The result is the platform-specific line separator
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; Any characters not explicitly defined as conversions are illegal and are
                     reserved for future extensions.
                    
                     &lt;h4&gt;&lt;a id="dt"&gt;Date/Time Conversions&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;p&gt; The following date and time conversion suffix characters are defined for
                     the {@code 't'} and {@code 'T'} conversions.  The types are similar to but
                     not completely identical to those defined by GNU {@code date} and POSIX
                     {@code strftime(3c)}.  Additional conversion types are provided to access
                     Java-specific functionality (e.g. {@code 'L'} for milliseconds within the
                     second).
                    
                     &lt;p&gt; The following conversion characters are used for formatting times:
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;time&lt;/caption&gt;
                     &lt;tbody&gt;
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'H'}
                         &lt;td&gt; Hour of the day for the 24-hour clock, formatted as two digits with
                         a leading zero as necessary i.e. {@code 00 - 23}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'I'}
                         &lt;td&gt; Hour for the 12-hour clock, formatted as two digits with a leading
                         zero as necessary, i.e.  {@code 01 - 12}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'k'}
                         &lt;td&gt; Hour of the day for the 24-hour clock, i.e. {@code 0 - 23}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'l'}
                         &lt;td&gt; Hour for the 12-hour clock, i.e. {@code 1 - 12}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'M'}
                         &lt;td&gt; Minute within the hour formatted as two digits with a leading zero
                         as necessary, i.e.  {@code 00 - 59}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'S'}
                         &lt;td&gt; Seconds within the minute, formatted as two digits with a leading
                         zero as necessary, i.e. {@code 00 - 60} ("{@code 60}" is a special
                         value required to support leap seconds).
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'L'}
                         &lt;td&gt; Millisecond within the second formatted as three digits with
                         leading zeros as necessary, i.e. {@code 000 - 999}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'N'}
                         &lt;td&gt; Nanosecond within the second, formatted as nine digits with leading
                         zeros as necessary, i.e. {@code 000000000 - 999999999}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'p'}
                         &lt;td&gt; Locale-specific {@linkplain
                         java.text.DateFormatSymbols#getAmPmStrings morning or afternoon} marker
                         in lower case, e.g."{@code am}" or "{@code pm}". Use of the conversion
                         prefix {@code 'T'} forces this output to upper case.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'z'}
                         &lt;td&gt; &lt;a href="http://www.ietf.org/rfc/rfc0822.txt"&gt;RFC&amp;nbsp;822&lt;/a&gt;
                         style numeric time zone offset from GMT, e.g. {@code -0800}.  This
                         value will be adjusted as necessary for Daylight Saving Time.  For
                         {@code long}, {@link Long}, and {@link Date} the time zone used is
                         the {@linkplain TimeZone#getDefault() default time zone} for this
                         instance of the Java virtual machine.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'Z'}
                         &lt;td&gt; A string representing the abbreviation for the time zone.  This
                         value will be adjusted as necessary for Daylight Saving Time.  For
                         {@code long}, {@link Long}, and {@link Date} the  time zone used is
                         the {@linkplain TimeZone#getDefault() default time zone} for this
                         instance of the Java virtual machine.  The Formatter's locale will
                         supersede the locale of the argument (if any).
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 's'}
                         &lt;td&gt; Seconds since the beginning of the epoch starting at 1 January 1970
                         {@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE/1000} to
                         {@code Long.MAX_VALUE/1000}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'Q'}
                         &lt;td&gt; Milliseconds since the beginning of the epoch starting at 1 January
                         1970 {@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE} to
                         {@code Long.MAX_VALUE}.
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; The following conversion characters are used for formatting dates:
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;date&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'B'}
                         &lt;td&gt; Locale-specific {@linkplain java.text.DateFormatSymbols#getMonths
                         full month name}, e.g. {@code "January"}, {@code "February"}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'b'}
                         &lt;td&gt; Locale-specific {@linkplain
                         java.text.DateFormatSymbols#getShortMonths abbreviated month name},
                         e.g. {@code "Jan"}, {@code "Feb"}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'h'}
                         &lt;td&gt; Same as {@code 'b'}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'A'}
                         &lt;td&gt; Locale-specific full name of the {@linkplain
                         java.text.DateFormatSymbols#getWeekdays day of the week},
                         e.g. {@code "Sunday"}, {@code "Monday"}
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'a'}
                         &lt;td&gt; Locale-specific short name of the {@linkplain
                         java.text.DateFormatSymbols#getShortWeekdays day of the week},
                         e.g. {@code "Sun"}, {@code "Mon"}
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'C'}
                         &lt;td&gt; Four-digit year divided by {@code 100}, formatted as two digits
                         with leading zero as necessary, i.e. {@code 00 - 99}
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'Y'}
                         &lt;td&gt; Year, formatted as at least four digits with leading zeros as
                         necessary, e.g. {@code 0092} equals {@code 92} CE for the Gregorian
                         calendar.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'y'}
                         &lt;td&gt; Last two digits of the year, formatted with leading zeros as
                         necessary, i.e. {@code 00 - 99}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'j'}
                         &lt;td&gt; Day of year, formatted as three digits with leading zeros as
                         necessary, e.g. {@code 001 - 366} for the Gregorian calendar.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'm'}
                         &lt;td&gt; Month, formatted as two digits with leading zeros as necessary,
                         i.e. {@code 01 - 13}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'd'}
                         &lt;td&gt; Day of month, formatted as two digits with leading zeros as
                         necessary, i.e. {@code 01 - 31}
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'e'}
                         &lt;td&gt; Day of month, formatted as two digits, i.e. {@code 1 - 31}.
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; The following conversion characters are used for formatting common
                     date/time compositions.
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;composites&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'R'}
                         &lt;td&gt; Time formatted for the 24-hour clock as {@code "%tH:%tM"}
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'T'}
                         &lt;td&gt; Time formatted for the 24-hour clock as {@code "%tH:%tM:%tS"}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'r'}
                         &lt;td&gt; Time formatted for the 12-hour clock as {@code "%tI:%tM:%tS %Tp"}.
                         The location of the morning or afternoon marker ({@code '%Tp'}) may be
                         locale-dependent.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'D'}
                         &lt;td&gt; Date formatted as {@code "%tm/%td/%ty"}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'F'}
                         &lt;td&gt; &lt;a href="http://www.w3.org/TR/NOTE-datetime"&gt;ISO&amp;nbsp;8601&lt;/a&gt;
                         complete date formatted as {@code "%tY-%tm-%td"}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'c'}
                         &lt;td&gt; Date and time formatted as {@code "%ta %tb %td %tT %tZ %tY"},
                         e.g. {@code "Sun Jul 20 16:17:00 EDT 1969"}.
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; Any characters not explicitly defined as date/time conversion suffixes
                     are illegal and are reserved for future extensions.
                    
                     &lt;h4&gt; Flags &lt;/h4&gt;
                    
                     &lt;p&gt; The following table summarizes the supported flags.  &lt;i&gt;y&lt;/i&gt; means the
                     flag is supported for the indicated argument types.
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;genConv&lt;/caption&gt;
                     &lt;thead&gt;
                     &lt;tr&gt;&lt;th scope="col" style="vertical-align:bottom"&gt; Flag &lt;th scope="col" style="vertical-align:bottom"&gt; General
                         &lt;th scope="col" style="vertical-align:bottom"&gt; Character &lt;th scope="col" style="vertical-align:bottom"&gt; Integral
                         &lt;th scope="col" style="vertical-align:bottom"&gt; Floating Point
                         &lt;th scope="col" style="vertical-align:bottom"&gt; Date/Time
                         &lt;th scope="col" style="vertical-align:bottom"&gt; Description
                     &lt;/thead&gt;
                     &lt;tbody&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt; '-' &lt;td style="text-align:center; vertical-align:top"&gt; y
                         &lt;td style="text-align:center; vertical-align:top"&gt; y
                         &lt;td style="text-align:center; vertical-align:top"&gt; y
                         &lt;td style="text-align:center; vertical-align:top"&gt; y
                         &lt;td style="text-align:center; vertical-align:top"&gt; y
                         &lt;td&gt; The result will be left-justified.
                    
                     &lt;tr&gt;&lt;th scope="row"&gt; '#' &lt;td style="text-align:center; vertical-align:top"&gt; y&lt;sup&gt;1&lt;/sup&gt;
                         &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td style="text-align:center; vertical-align:top"&gt; y&lt;sup&gt;3&lt;/sup&gt;
                         &lt;td style="text-align:center; vertical-align:top"&gt; y
                         &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td&gt; The result should use a conversion-dependent alternate form
                    
                     &lt;tr&gt;&lt;th scope="row"&gt; '+' &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td style="text-align:center; vertical-align:top"&gt; y&lt;sup&gt;4&lt;/sup&gt;
                         &lt;td style="text-align:center; vertical-align:top"&gt; y
                         &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td&gt; The result will always include a sign
                    
                     &lt;tr&gt;&lt;th scope="row"&gt; '&amp;nbsp;&amp;nbsp;' &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td style="text-align:center; vertical-align:top"&gt; y&lt;sup&gt;4&lt;/sup&gt;
                         &lt;td style="text-align:center; vertical-align:top"&gt; y
                         &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td&gt; The result will include a leading space for positive values
                    
                     &lt;tr&gt;&lt;th scope="row"&gt; '0' &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td style="text-align:center; vertical-align:top"&gt; y
                         &lt;td style="text-align:center; vertical-align:top"&gt; y
                         &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td&gt; The result will be zero-padded
                    
                     &lt;tr&gt;&lt;th scope="row"&gt; ',' &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td style="text-align:center; vertical-align:top"&gt; y&lt;sup&gt;2&lt;/sup&gt;
                         &lt;td style="text-align:center; vertical-align:top"&gt; y&lt;sup&gt;5&lt;/sup&gt;
                         &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td&gt; The result will include locale-specific {@linkplain
                         java.text.DecimalFormatSymbols#getGroupingSeparator grouping separators}
                    
                     &lt;tr&gt;&lt;th scope="row"&gt; '(' &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td style="text-align:center; vertical-align:top"&gt; -
                         &lt;td style="text-align:center; vertical-align:top"&gt; y&lt;sup&gt;4&lt;/sup&gt;
                         &lt;td style="text-align:center; vertical-align:top"&gt; y&lt;sup&gt;5&lt;/sup&gt;
                         &lt;td style="text-align:center"&gt; -
                         &lt;td&gt; The result will enclose negative numbers in parentheses
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; &lt;sup&gt;1&lt;/sup&gt; Depends on the definition of {@link Formattable}.
                    
                     &lt;p&gt; &lt;sup&gt;2&lt;/sup&gt; For {@code 'd'} conversion only.
                    
                     &lt;p&gt; &lt;sup&gt;3&lt;/sup&gt; For {@code 'o'}, {@code 'x'}, and {@code 'X'}
                     conversions only.
                    
                     &lt;p&gt; &lt;sup&gt;4&lt;/sup&gt; For {@code 'd'}, {@code 'o'}, {@code 'x'}, and
                     {@code 'X'} conversions applied to {@link java.math.BigInteger BigInteger}
                     or {@code 'd'} applied to {@code byte}, {@link Byte}, {@code short}, {@link
                     Short}, {@code int} and {@link Integer}, {@code long}, and {@link Long}.
                    
                     &lt;p&gt; &lt;sup&gt;5&lt;/sup&gt; For {@code 'e'}, {@code 'E'}, {@code 'f'},
                     {@code 'g'}, and {@code 'G'} conversions only.
                    
                     &lt;p&gt; Any characters not explicitly defined as flags are illegal and are
                     reserved for future extensions.
                    
                     &lt;h4&gt; Width &lt;/h4&gt;
                    
                     &lt;p&gt; The width is the minimum number of characters to be written to the
                     output.  For the line separator conversion, width is not applicable; if it
                     is provided, an exception will be thrown.
                    
                     &lt;h4&gt; Precision &lt;/h4&gt;
                    
                     &lt;p&gt; For general argument types, the precision is the maximum number of
                     characters to be written to the output.
                    
                     &lt;p&gt; For the floating-point conversions {@code 'a'}, {@code 'A'}, {@code 'e'},
                     {@code 'E'}, and {@code 'f'} the precision is the number of digits after the
                     radix point.  If the conversion is {@code 'g'} or {@code 'G'}, then the
                     precision is the total number of digits in the resulting magnitude after
                     rounding.
                    
                     &lt;p&gt; For character, integral, and date/time argument types and the percent
                     and line separator conversions, the precision is not applicable; if a
                     precision is provided, an exception will be thrown.
                    
                     &lt;h4&gt; Argument Index &lt;/h4&gt;
                    
                     &lt;p&gt; The argument index is a decimal integer indicating the position of the
                     argument in the argument list.  The first argument is referenced by
                     "{@code 1$}", the second by "{@code 2$}", etc.
                    
                     &lt;p&gt; Another way to reference arguments by position is to use the
                     {@code '&lt;'} (&lt;code&gt;'&amp;#92;u003c'&lt;/code&gt;) flag, which causes the argument for
                     the previous format specifier to be re-used.  For example, the following two
                     statements would produce identical strings:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                       Calendar c = ...;
                       String s1 = String.format("Duke's Birthday: %1$tm %1$te,%1$tY", c);
                    
                       String s2 = String.format("Duke's Birthday: %1$tm %&amp;lt;te,%&amp;lt;tY", c);
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;hr&gt;
                     &lt;h3&gt;&lt;a id="detail"&gt;Details&lt;/a&gt;&lt;/h3&gt;
                    
                     &lt;p&gt; This section is intended to provide behavioral details for formatting,
                     including conditions and exceptions, supported data types, localization, and
                     interactions between flags, conversions, and data types.  For an overview of
                     formatting concepts, refer to the &lt;a href="#summary"&gt;Summary&lt;/a&gt;
                    
                     &lt;p&gt; Any characters not explicitly defined as conversions, date/time
                     conversion suffixes, or flags are illegal and are reserved for
                     future extensions.  Use of such a character in a format string will
                     cause an {@link UnknownFormatConversionException} or {@link
                     UnknownFormatFlagsException} to be thrown.
                    
                     &lt;p&gt; If the format specifier contains a width or precision with an invalid
                     value or which is otherwise unsupported, then a {@link
                     IllegalFormatWidthException} or {@link IllegalFormatPrecisionException}
                     respectively will be thrown.
                    
                     &lt;p&gt; If a format specifier contains a conversion character that is not
                     applicable to the corresponding argument, then an {@link
                     IllegalFormatConversionException} will be thrown.
                    
                     &lt;p&gt; All specified exceptions may be thrown by any of the {@code format}
                     methods of {@code Formatter} as well as by any {@code format} convenience
                     methods such as {@link String#format(String,Object...) String.format} and
                     {@link java.io.PrintStream#printf(String,Object...) PrintStream.printf}.
                    
                     &lt;p&gt; For category &lt;i&gt;General&lt;/i&gt;, &lt;i&gt;Character&lt;/i&gt;, &lt;i&gt;Numberic&lt;/i&gt;,
                     &lt;i&gt;Integral&lt;/i&gt; and &lt;i&gt;Date/Time&lt;/i&gt; conversion, unless otherwise specified,
                     if the argument &lt;i&gt;arg&lt;/i&gt; is {@code null}, then the result is "{@code null}".
                    
                     &lt;p&gt; Conversions denoted by an upper-case character (i.e. {@code 'B'},
                     {@code 'H'}, {@code 'S'}, {@code 'C'}, {@code 'X'}, {@code 'E'},
                     {@code 'G'}, {@code 'A'}, and {@code 'T'}) are the same as those for the
                     corresponding lower-case conversion characters except that the result is
                     converted to upper case according to the rules of the prevailing {@link
                     java.util.Locale Locale}. If there is no explicit locale specified,
                     either at the construction of the instance or as a parameter to its method
                     invocation, then the {@link java.util.Locale.Category#FORMAT default locale}
                     is used.
                    
                     &lt;h4&gt;&lt;a id="dgen"&gt;General&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;p&gt; The following general conversions may be applied to any argument type:
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;dgConv&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'b'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0062'&lt;/code&gt;
                         &lt;td&gt; Produces either "{@code true}" or "{@code false}" as returned by
                         {@link Boolean#toString(boolean)}.
                    
                         &lt;p&gt; If the argument is {@code null}, then the result is
                         "{@code false}".  If the argument is a {@code boolean} or {@link
                         Boolean}, then the result is the string returned by {@link
                         String#valueOf(boolean) String.valueOf()}.  Otherwise, the result is
                         "{@code true}".
                    
                         &lt;p&gt; If the {@code '#'} flag is given, then a {@link
                         FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'B'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0042'&lt;/code&gt;
                         &lt;td&gt; The upper-case variant of {@code 'b'}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'h'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0068'&lt;/code&gt;
                         &lt;td&gt; Produces a string representing the hash code value of the object.
                    
                         &lt;p&gt; The result is obtained by invoking
                         {@code Integer.toHexString(arg.hashCode())}.
                    
                         &lt;p&gt; If the {@code '#'} flag is given, then a {@link
                         FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'H'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0048'&lt;/code&gt;
                         &lt;td&gt; The upper-case variant of {@code 'h'}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 's'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0073'&lt;/code&gt;
                         &lt;td&gt; Produces a string.
                    
                         &lt;p&gt; If the argument implements {@link Formattable}, then
                         its {@link Formattable#formatTo formatTo} method is invoked.
                         Otherwise, the result is obtained by invoking the argument's
                         {@code toString()} method.
                    
                         &lt;p&gt; If the {@code '#'} flag is given and the argument is not a {@link
                         Formattable} , then a {@link FormatFlagsConversionMismatchException}
                         will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'S'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0053'&lt;/code&gt;
                         &lt;td&gt; The upper-case variant of {@code 's'}.
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; The following &lt;a id="dFlags"&gt;flags&lt;/a&gt; apply to general conversions:
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;dFlags&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code '-'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u002d'&lt;/code&gt;
                         &lt;td&gt; Left justifies the output.  Spaces (&lt;code&gt;'&amp;#92;u0020'&lt;/code&gt;) will be
                         added at the end of the converted value as required to fill the minimum
                         width of the field.  If the width is not provided, then a {@link
                         MissingFormatWidthException} will be thrown.  If this flag is not given
                         then the output will be right-justified.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code '#'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0023'&lt;/code&gt;
                         &lt;td&gt; Requires the output use an alternate form.  The definition of the
                         form is specified by the conversion.
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; The &lt;a id="genWidth"&gt;width&lt;/a&gt; is the minimum number of characters to
                     be written to the
                     output.  If the length of the converted value is less than the width then
                     the output will be padded by &lt;code&gt;'&amp;nbsp;&amp;nbsp;'&lt;/code&gt; (&lt;code&gt;'&amp;#92;u0020'&lt;/code&gt;)
                     until the total number of characters equals the width.  The padding is on
                     the left by default.  If the {@code '-'} flag is given, then the padding
                     will be on the right.  If the width is not specified then there is no
                     minimum.
                    
                     &lt;p&gt; The precision is the maximum number of characters to be written to the
                     output.  The precision is applied before the width, thus the output will be
                     truncated to {@code precision} characters even if the width is greater than
                     the precision.  If the precision is not specified then there is no explicit
                     limit on the number of characters.
                    
                     &lt;h4&gt;&lt;a id="dchar"&gt;Character&lt;/a&gt;&lt;/h4&gt;
                    
                     This conversion may be applied to {@code char} and {@link Character}.  It
                     may also be applied to the types {@code byte}, {@link Byte},
                     {@code short}, and {@link Short}, {@code int} and {@link Integer} when
                     {@link Character#isValidCodePoint} returns {@code true}.  If it returns
                     {@code false} then an {@link IllegalFormatCodePointException} will be
                     thrown.
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;charConv&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'c'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0063'&lt;/code&gt;
                         &lt;td&gt; Formats the argument as a Unicode character as described in &lt;a
                         href="../lang/Character.html#unicode"&gt;Unicode Character
                         Representation&lt;/a&gt;.  This may be more than one 16-bit {@code char} in
                         the case where the argument represents a supplementary character.
                    
                         &lt;p&gt; If the {@code '#'} flag is given, then a {@link
                         FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'C'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0043'&lt;/code&gt;
                         &lt;td&gt; The upper-case variant of {@code 'c'}.
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; The {@code '-'} flag defined for &lt;a href="#dFlags"&gt;General
                     conversions&lt;/a&gt; applies.  If the {@code '#'} flag is given, then a {@link
                     FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;p&gt; The width is defined as for &lt;a href="#genWidth"&gt;General conversions&lt;/a&gt;.
                    
                     &lt;p&gt; The precision is not applicable.  If the precision is specified then an
                     {@link IllegalFormatPrecisionException} will be thrown.
                    
                     &lt;h4&gt;&lt;a id="dnum"&gt;Numeric&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;p&gt; Numeric conversions are divided into the following categories:
                    
                     &lt;ol&gt;
                    
                     &lt;li&gt; &lt;a href="#dnint"&gt;&lt;b&gt;Byte, Short, Integer, and Long&lt;/b&gt;&lt;/a&gt;
                    
                     &lt;li&gt; &lt;a href="#dnbint"&gt;&lt;b&gt;BigInteger&lt;/b&gt;&lt;/a&gt;
                    
                     &lt;li&gt; &lt;a href="#dndec"&gt;&lt;b&gt;Float and Double&lt;/b&gt;&lt;/a&gt;
                    
                     &lt;li&gt; &lt;a href="#dnbdec"&gt;&lt;b&gt;BigDecimal&lt;/b&gt;&lt;/a&gt;
                    
                     &lt;/ol&gt;
                    
                     &lt;p&gt; Numeric types will be formatted according to the following algorithm:
                    
                     &lt;p&gt;&lt;b&gt;&lt;a id="L10nAlgorithm"&gt; Number Localization Algorithm&lt;/a&gt;&lt;/b&gt;
                    
                     &lt;p&gt; After digits are obtained for the integer part, fractional part, and
                     exponent (as appropriate for the data type), the following transformation
                     is applied:
                    
                     &lt;ol&gt;
                    
                     &lt;li&gt; Each digit character &lt;i&gt;d&lt;/i&gt; in the string is replaced by a
                     locale-specific digit computed relative to the current locale's
                     {@linkplain java.text.DecimalFormatSymbols#getZeroDigit() zero digit}
                     &lt;i&gt;z&lt;/i&gt;; that is &lt;i&gt;d&amp;nbsp;-&amp;nbsp;&lt;/i&gt; {@code '0'}
                     &lt;i&gt;&amp;nbsp;+&amp;nbsp;z&lt;/i&gt;.
                    
                     &lt;li&gt; If a decimal separator is present, a locale-specific {@linkplain
                     java.text.DecimalFormatSymbols#getDecimalSeparator decimal separator} is
                     substituted.
                    
                     &lt;li&gt; If the {@code ','} (&lt;code&gt;'&amp;#92;u002c'&lt;/code&gt;)
                     &lt;a id="L10nGroup"&gt;flag&lt;/a&gt; is given, then the locale-specific {@linkplain
                     java.text.DecimalFormatSymbols#getGroupingSeparator grouping separator} is
                     inserted by scanning the integer part of the string from least significant
                     to most significant digits and inserting a separator at intervals defined by
                     the locale's {@linkplain java.text.DecimalFormat#getGroupingSize() grouping
                     size}.
                    
                     &lt;li&gt; If the {@code '0'} flag is given, then the locale-specific {@linkplain
                     java.text.DecimalFormatSymbols#getZeroDigit() zero digits} are inserted
                     after the sign character, if any, and before the first non-zero digit, until
                     the length of the string is equal to the requested field width.
                    
                     &lt;li&gt; If the value is negative and the {@code '('} flag is given, then a
                     {@code '('} (&lt;code&gt;'&amp;#92;u0028'&lt;/code&gt;) is prepended and a {@code ')'}
                     (&lt;code&gt;'&amp;#92;u0029'&lt;/code&gt;) is appended.
                    
                     &lt;li&gt; If the value is negative (or floating-point negative zero) and
                     {@code '('} flag is not given, then a {@code '-'} (&lt;code&gt;'&amp;#92;u002d'&lt;/code&gt;)
                     is prepended.
                    
                     &lt;li&gt; If the {@code '+'} flag is given and the value is positive or zero (or
                     floating-point positive zero), then a {@code '+'} (&lt;code&gt;'&amp;#92;u002b'&lt;/code&gt;)
                     will be prepended.
                    
                     &lt;/ol&gt;
                    
                     &lt;p&gt; If the value is NaN or positive infinity the literal strings "NaN" or
                     "Infinity" respectively, will be output.  If the value is negative infinity,
                     then the output will be "(Infinity)" if the {@code '('} flag is given
                     otherwise the output will be "-Infinity".  These values are not localized.
                    
                     &lt;p&gt;&lt;a id="dnint"&gt;&lt;b&gt; Byte, Short, Integer, and Long &lt;/b&gt;&lt;/a&gt;
                    
                     &lt;p&gt; The following conversions may be applied to {@code byte}, {@link Byte},
                     {@code short}, {@link Short}, {@code int} and {@link Integer},
                     {@code long}, and {@link Long}.
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;IntConv&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'd'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0064'&lt;/code&gt;
                         &lt;td&gt; Formats the argument as a decimal integer. The &lt;a
                         href="#L10nAlgorithm"&gt;localization algorithm&lt;/a&gt; is applied.
                    
                         &lt;p&gt; If the {@code '0'} flag is given and the value is negative, then
                         the zero padding will occur after the sign.
                    
                         &lt;p&gt; If the {@code '#'} flag is given then a {@link
                         FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'o'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u006f'&lt;/code&gt;
                         &lt;td&gt; Formats the argument as an integer in base eight.  No localization
                         is applied.
                    
                         &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be an unsigned value
                         generated by adding 2&lt;sup&gt;n&lt;/sup&gt; to the value where {@code n} is the
                         number of bits in the type as returned by the static {@code SIZE} field
                         in the {@linkplain Byte#SIZE Byte}, {@linkplain Short#SIZE Short},
                         {@linkplain Integer#SIZE Integer}, or {@linkplain Long#SIZE Long}
                         classes as appropriate.
                    
                         &lt;p&gt; If the {@code '#'} flag is given then the output will always begin
                         with the radix indicator {@code '0'}.
                    
                         &lt;p&gt; If the {@code '0'} flag is given then the output will be padded
                         with leading zeros to the field width following any indication of sign.
                    
                         &lt;p&gt; If {@code '('}, {@code '+'}, '&amp;nbsp;&amp;nbsp;', or {@code ','} flags
                         are given then a {@link FormatFlagsConversionMismatchException} will be
                         thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'x'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0078'&lt;/code&gt;
                         &lt;td&gt; Formats the argument as an integer in base sixteen. No
                         localization is applied.
                    
                         &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be an unsigned value
                         generated by adding 2&lt;sup&gt;n&lt;/sup&gt; to the value where {@code n} is the
                         number of bits in the type as returned by the static {@code SIZE} field
                         in the {@linkplain Byte#SIZE Byte}, {@linkplain Short#SIZE Short},
                         {@linkplain Integer#SIZE Integer}, or {@linkplain Long#SIZE Long}
                         classes as appropriate.
                    
                         &lt;p&gt; If the {@code '#'} flag is given then the output will always begin
                         with the radix indicator {@code "0x"}.
                    
                         &lt;p&gt; If the {@code '0'} flag is given then the output will be padded to
                         the field width with leading zeros after the radix indicator or sign (if
                         present).
                    
                         &lt;p&gt; If {@code '('}, &lt;code&gt;'&amp;nbsp;&amp;nbsp;'&lt;/code&gt;, {@code '+'}, or
                         {@code ','} flags are given then a {@link
                         FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'X'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0058'&lt;/code&gt;
                         &lt;td&gt; The upper-case variant of {@code 'x'}.  The entire string
                         representing the number will be converted to {@linkplain
                         String#toUpperCase upper case} including the {@code 'x'} (if any) and
                         all hexadecimal digits {@code 'a'} - {@code 'f'}
                         (&lt;code&gt;'&amp;#92;u0061'&lt;/code&gt; -  &lt;code&gt;'&amp;#92;u0066'&lt;/code&gt;).
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; If the conversion is {@code 'o'}, {@code 'x'}, or {@code 'X'} and
                     both the {@code '#'} and the {@code '0'} flags are given, then result will
                     contain the radix indicator ({@code '0'} for octal and {@code "0x"} or
                     {@code "0X"} for hexadecimal), some number of zeros (based on the width),
                     and the value.
                    
                     &lt;p&gt; If the {@code '-'} flag is not given, then the space padding will occur
                     before the sign.
                    
                     &lt;p&gt; The following &lt;a id="intFlags"&gt;flags&lt;/a&gt; apply to numeric integral
                     conversions:
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;intFlags&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code '+'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u002b'&lt;/code&gt;
                         &lt;td&gt; Requires the output to include a positive sign for all positive
                         numbers.  If this flag is not given then only negative values will
                         include a sign.
                    
                         &lt;p&gt; If both the {@code '+'} and &lt;code&gt;'&amp;nbsp;&amp;nbsp;'&lt;/code&gt; flags are given
                         then an {@link IllegalFormatFlagsException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; &lt;code&gt;'&amp;nbsp;&amp;nbsp;'&lt;/code&gt;
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0020'&lt;/code&gt;
                         &lt;td&gt; Requires the output to include a single extra space
                         (&lt;code&gt;'&amp;#92;u0020'&lt;/code&gt;) for non-negative values.
                    
                         &lt;p&gt; If both the {@code '+'} and &lt;code&gt;'&amp;nbsp;&amp;nbsp;'&lt;/code&gt; flags are given
                         then an {@link IllegalFormatFlagsException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code '0'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0030'&lt;/code&gt;
                         &lt;td&gt; Requires the output to be padded with leading {@linkplain
                         java.text.DecimalFormatSymbols#getZeroDigit zeros} to the minimum field
                         width following any sign or radix indicator except when converting NaN
                         or infinity.  If the width is not provided, then a {@link
                         MissingFormatWidthException} will be thrown.
                    
                         &lt;p&gt; If both the {@code '-'} and {@code '0'} flags are given then an
                         {@link IllegalFormatFlagsException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code ','}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u002c'&lt;/code&gt;
                         &lt;td&gt; Requires the output to include the locale-specific {@linkplain
                         java.text.DecimalFormatSymbols#getGroupingSeparator group separators} as
                         described in the &lt;a href="#L10nGroup"&gt;"group" section&lt;/a&gt; of the
                         localization algorithm.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code '('}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0028'&lt;/code&gt;
                         &lt;td&gt; Requires the output to prepend a {@code '('}
                         (&lt;code&gt;'&amp;#92;u0028'&lt;/code&gt;) and append a {@code ')'}
                         (&lt;code&gt;'&amp;#92;u0029'&lt;/code&gt;) to negative values.
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; If no &lt;a id="intdFlags"&gt;flags&lt;/a&gt; are given the default formatting is
                     as follows:
                    
                     &lt;ul&gt;
                    
                     &lt;li&gt; The output is right-justified within the {@code width}
                    
                     &lt;li&gt; Negative numbers begin with a {@code '-'} (&lt;code&gt;'&amp;#92;u002d'&lt;/code&gt;)
                    
                     &lt;li&gt; Positive numbers and zero do not include a sign or extra leading
                     space
                    
                     &lt;li&gt; No grouping separators are included
                    
                     &lt;/ul&gt;
                    
                     &lt;p&gt; The &lt;a id="intWidth"&gt;width&lt;/a&gt; is the minimum number of characters to
                     be written to the output.  This includes any signs, digits, grouping
                     separators, radix indicator, and parentheses.  If the length of the
                     converted value is less than the width then the output will be padded by
                     spaces (&lt;code&gt;'&amp;#92;u0020'&lt;/code&gt;) until the total number of characters equals
                     width.  The padding is on the left by default.  If {@code '-'} flag is
                     given then the padding will be on the right.  If width is not specified then
                     there is no minimum.
                    
                     &lt;p&gt; The precision is not applicable.  If precision is specified then an
                     {@link IllegalFormatPrecisionException} will be thrown.
                    
                     &lt;p&gt;&lt;a id="dnbint"&gt;&lt;b&gt; BigInteger &lt;/b&gt;&lt;/a&gt;
                    
                     &lt;p&gt; The following conversions may be applied to {@link
                     java.math.BigInteger}.
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;bIntConv&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'd'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0064'&lt;/code&gt;
                         &lt;td&gt; Requires the output to be formatted as a decimal integer. The &lt;a
                         href="#L10nAlgorithm"&gt;localization algorithm&lt;/a&gt; is applied.
                    
                         &lt;p&gt; If the {@code '#'} flag is given {@link
                         FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'o'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u006f'&lt;/code&gt;
                         &lt;td&gt; Requires the output to be formatted as an integer in base eight.
                         No localization is applied.
                    
                         &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be a signed value
                         beginning with {@code '-'} (&lt;code&gt;'&amp;#92;u002d'&lt;/code&gt;).  Signed output is
                         allowed for this type because unlike the primitive types it is not
                         possible to create an unsigned equivalent without assuming an explicit
                         data-type size.
                    
                         &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is positive or zero and the {@code '+'} flag is given
                         then the result will begin with {@code '+'} (&lt;code&gt;'&amp;#92;u002b'&lt;/code&gt;).
                    
                         &lt;p&gt; If the {@code '#'} flag is given then the output will always begin
                         with {@code '0'} prefix.
                    
                         &lt;p&gt; If the {@code '0'} flag is given then the output will be padded
                         with leading zeros to the field width following any indication of sign.
                    
                         &lt;p&gt; If the {@code ','} flag is given then a {@link
                         FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'x'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0078'&lt;/code&gt;
                         &lt;td&gt; Requires the output to be formatted as an integer in base
                         sixteen.  No localization is applied.
                    
                         &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be a signed value
                         beginning with {@code '-'} (&lt;code&gt;'&amp;#92;u002d'&lt;/code&gt;).  Signed output is
                         allowed for this type because unlike the primitive types it is not
                         possible to create an unsigned equivalent without assuming an explicit
                         data-type size.
                    
                         &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is positive or zero and the {@code '+'} flag is given
                         then the result will begin with {@code '+'} (&lt;code&gt;'&amp;#92;u002b'&lt;/code&gt;).
                    
                         &lt;p&gt; If the {@code '#'} flag is given then the output will always begin
                         with the radix indicator {@code "0x"}.
                    
                         &lt;p&gt; If the {@code '0'} flag is given then the output will be padded to
                         the field width with leading zeros after the radix indicator or sign (if
                         present).
                    
                         &lt;p&gt; If the {@code ','} flag is given then a {@link
                         FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'X'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0058'&lt;/code&gt;
                         &lt;td&gt; The upper-case variant of {@code 'x'}.  The entire string
                         representing the number will be converted to {@linkplain
                         String#toUpperCase upper case} including the {@code 'x'} (if any) and
                         all hexadecimal digits {@code 'a'} - {@code 'f'}
                         (&lt;code&gt;'&amp;#92;u0061'&lt;/code&gt; - &lt;code&gt;'&amp;#92;u0066'&lt;/code&gt;).
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; If the conversion is {@code 'o'}, {@code 'x'}, or {@code 'X'} and
                     both the {@code '#'} and the {@code '0'} flags are given, then result will
                     contain the base indicator ({@code '0'} for octal and {@code "0x"} or
                     {@code "0X"} for hexadecimal), some number of zeros (based on the width),
                     and the value.
                    
                     &lt;p&gt; If the {@code '0'} flag is given and the value is negative, then the
                     zero padding will occur after the sign.
                    
                     &lt;p&gt; If the {@code '-'} flag is not given, then the space padding will occur
                     before the sign.
                    
                     &lt;p&gt; All &lt;a href="#intFlags"&gt;flags&lt;/a&gt; defined for Byte, Short, Integer, and
                     Long apply.  The &lt;a href="#intdFlags"&gt;default behavior&lt;/a&gt; when no flags are
                     given is the same as for Byte, Short, Integer, and Long.
                    
                     &lt;p&gt; The specification of &lt;a href="#intWidth"&gt;width&lt;/a&gt; is the same as
                     defined for Byte, Short, Integer, and Long.
                    
                     &lt;p&gt; The precision is not applicable.  If precision is specified then an
                     {@link IllegalFormatPrecisionException} will be thrown.
                    
                     &lt;p&gt;&lt;a id="dndec"&gt;&lt;b&gt; Float and Double&lt;/b&gt;&lt;/a&gt;
                    
                     &lt;p&gt; The following conversions may be applied to {@code float}, {@link
                     Float}, {@code double} and {@link Double}.
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;floatConv&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'e'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0065'&lt;/code&gt;
                         &lt;td&gt; Requires the output to be formatted using &lt;a
                         id="scientific"&gt;computerized scientific notation&lt;/a&gt;.  The &lt;a
                         href="#L10nAlgorithm"&gt;localization algorithm&lt;/a&gt; is applied.
                    
                         &lt;p&gt; The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its value.
                    
                         &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is NaN or infinite, the literal strings "NaN" or
                         "Infinity", respectively, will be output.  These values are not
                         localized.
                    
                         &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is positive-zero or negative-zero, then the exponent
                         will be {@code "+00"}.
                    
                         &lt;p&gt; Otherwise, the result is a string that represents the sign and
                         magnitude (absolute value) of the argument.  The formatting of the sign
                         is described in the &lt;a href="#L10nAlgorithm"&gt;localization
                         algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
                         value.
                    
                         &lt;p&gt; Let &lt;i&gt;n&lt;/i&gt; be the unique integer such that 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt;
                         &amp;lt;= &lt;i&gt;m&lt;/i&gt; &amp;lt; 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;+1&lt;/sup&gt;; then let &lt;i&gt;a&lt;/i&gt; be the
                         mathematically exact quotient of &lt;i&gt;m&lt;/i&gt; and 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; so
                         that 1 &amp;lt;= &lt;i&gt;a&lt;/i&gt; &amp;lt; 10. The magnitude is then represented as the
                         integer part of &lt;i&gt;a&lt;/i&gt;, as a single decimal digit, followed by the
                         decimal separator followed by decimal digits representing the fractional
                         part of &lt;i&gt;a&lt;/i&gt;, followed by the exponent symbol {@code 'e'}
                         (&lt;code&gt;'&amp;#92;u0065'&lt;/code&gt;), followed by the sign of the exponent, followed
                         by a representation of &lt;i&gt;n&lt;/i&gt; as a decimal integer, as produced by the
                         method {@link Long#toString(long, int)}, and zero-padded to include at
                         least two digits.
                    
                         &lt;p&gt; The number of digits in the result for the fractional part of
                         &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision.  If the precision is not
                         specified then the default value is {@code 6}. If the precision is less
                         than the number of digits which would appear after the decimal point in
                         the string returned by {@link Float#toString(float)} or {@link
                         Double#toString(double)} respectively, then the value will be rounded
                         using the {@linkplain java.math.RoundingMode#HALF_UP round half up
                         algorithm}.  Otherwise, zeros may be appended to reach the precision.
                         For a canonical representation of the value, use {@link
                         Float#toString(float)} or {@link Double#toString(double)} as
                         appropriate.
                    
                         &lt;p&gt;If the {@code ','} flag is given, then an {@link
                         FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'E'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0045'&lt;/code&gt;
                         &lt;td&gt; The upper-case variant of {@code 'e'}.  The exponent symbol
                         will be {@code 'E'} (&lt;code&gt;'&amp;#92;u0045'&lt;/code&gt;).
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'g'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0067'&lt;/code&gt;
                         &lt;td&gt; Requires the output to be formatted in general scientific notation
                         as described below. The &lt;a href="#L10nAlgorithm"&gt;localization
                         algorithm&lt;/a&gt; is applied.
                    
                         &lt;p&gt; After rounding for the precision, the formatting of the resulting
                         magnitude &lt;i&gt;m&lt;/i&gt; depends on its value.
                    
                         &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is greater than or equal to 10&lt;sup&gt;-4&lt;/sup&gt; but less
                         than 10&lt;sup&gt;precision&lt;/sup&gt; then it is represented in &lt;i&gt;&lt;a
                         href="#decimal"&gt;decimal format&lt;/a&gt;&lt;/i&gt;.
                    
                         &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is less than 10&lt;sup&gt;-4&lt;/sup&gt; or greater than or equal to
                         10&lt;sup&gt;precision&lt;/sup&gt;, then it is represented in &lt;i&gt;&lt;a
                         href="#scientific"&gt;computerized scientific notation&lt;/a&gt;&lt;/i&gt;.
                    
                         &lt;p&gt; The total number of significant digits in &lt;i&gt;m&lt;/i&gt; is equal to the
                         precision.  If the precision is not specified, then the default value is
                         {@code 6}.  If the precision is {@code 0}, then it is taken to be
                         {@code 1}.
                    
                         &lt;p&gt; If the {@code '#'} flag is given then an {@link
                         FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'G'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0047'&lt;/code&gt;
                         &lt;td&gt; The upper-case variant of {@code 'g'}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'f'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0066'&lt;/code&gt;
                         &lt;td&gt; Requires the output to be formatted using &lt;a id="decimal"&gt;decimal
                         format&lt;/a&gt;.  The &lt;a href="#L10nAlgorithm"&gt;localization algorithm&lt;/a&gt; is
                         applied.
                    
                         &lt;p&gt; The result is a string that represents the sign and magnitude
                         (absolute value) of the argument.  The formatting of the sign is
                         described in the &lt;a href="#L10nAlgorithm"&gt;localization
                         algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
                         value.
                    
                         &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; NaN or infinite, the literal strings "NaN" or
                         "Infinity", respectively, will be output.  These values are not
                         localized.
                    
                         &lt;p&gt; The magnitude is formatted as the integer part of &lt;i&gt;m&lt;/i&gt;, with no
                         leading zeroes, followed by the decimal separator followed by one or
                         more decimal digits representing the fractional part of &lt;i&gt;m&lt;/i&gt;.
                    
                         &lt;p&gt; The number of digits in the result for the fractional part of
                         &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision.  If the precision is not
                         specified then the default value is {@code 6}. If the precision is less
                         than the number of digits which would appear after the decimal point in
                         the string returned by {@link Float#toString(float)} or {@link
                         Double#toString(double)} respectively, then the value will be rounded
                         using the {@linkplain java.math.RoundingMode#HALF_UP round half up
                         algorithm}.  Otherwise, zeros may be appended to reach the precision.
                         For a canonical representation of the value, use {@link
                         Float#toString(float)} or {@link Double#toString(double)} as
                         appropriate.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'a'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0061'&lt;/code&gt;
                         &lt;td&gt; Requires the output to be formatted in hexadecimal exponential
                         form.  No localization is applied.
                    
                         &lt;p&gt; The result is a string that represents the sign and magnitude
                         (absolute value) of the argument &lt;i&gt;x&lt;/i&gt;.
                    
                         &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative or a negative-zero value then the result
                         will begin with {@code '-'} (&lt;code&gt;'&amp;#92;u002d'&lt;/code&gt;).
                    
                         &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is positive or a positive-zero value and the
                         {@code '+'} flag is given then the result will begin with {@code '+'}
                         (&lt;code&gt;'&amp;#92;u002b'&lt;/code&gt;).
                    
                         &lt;p&gt; The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its value.
                    
                         &lt;ul&gt;
                    
                         &lt;li&gt; If the value is NaN or infinite, the literal strings "NaN" or
                         "Infinity", respectively, will be output.
                    
                         &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is zero then it is represented by the string
                         {@code "0x0.0p0"}.
                    
                         &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is a {@code double} value with a normalized
                         representation then substrings are used to represent the significand and
                         exponent fields.  The significand is represented by the characters
                         {@code "0x1."} followed by the hexadecimal representation of the rest
                         of the significand as a fraction.  The exponent is represented by
                         {@code 'p'} (&lt;code&gt;'&amp;#92;u0070'&lt;/code&gt;) followed by a decimal string of the
                         unbiased exponent as if produced by invoking {@link
                         Integer#toString(int) Integer.toString} on the exponent value.  If the
                         precision is specified, the value is rounded to the given number of
                         hexadecimal digits.
                    
                         &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is a {@code double} value with a subnormal
                         representation then, unless the precision is specified to be in the range
                         1 through 12, inclusive, the significand is represented by the characters
                         {@code '0x0.'} followed by the hexadecimal representation of the rest of
                         the significand as a fraction, and the exponent represented by
                         {@code 'p-1022'}.  If the precision is in the interval
                         [1,&amp;nbsp;12], the subnormal value is normalized such that it
                         begins with the characters {@code '0x1.'}, rounded to the number of
                         hexadecimal digits of precision, and the exponent adjusted
                         accordingly.  Note that there must be at least one nonzero digit in a
                         subnormal significand.
                    
                         &lt;/ul&gt;
                    
                         &lt;p&gt; If the {@code '('} or {@code ','} flags are given, then a {@link
                         FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'A'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0041'&lt;/code&gt;
                         &lt;td&gt; The upper-case variant of {@code 'a'}.  The entire string
                         representing the number will be converted to upper case including the
                         {@code 'x'} (&lt;code&gt;'&amp;#92;u0078'&lt;/code&gt;) and {@code 'p'}
                         (&lt;code&gt;'&amp;#92;u0070'&lt;/code&gt; and all hexadecimal digits {@code 'a'} -
                         {@code 'f'} (&lt;code&gt;'&amp;#92;u0061'&lt;/code&gt; - &lt;code&gt;'&amp;#92;u0066'&lt;/code&gt;).
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; All &lt;a href="#intFlags"&gt;flags&lt;/a&gt; defined for Byte, Short, Integer, and
                     Long apply.
                    
                     &lt;p&gt; If the {@code '#'} flag is given, then the decimal separator will
                     always be present.
                    
                     &lt;p&gt; If no &lt;a id="floatdFlags"&gt;flags&lt;/a&gt; are given the default formatting
                     is as follows:
                    
                     &lt;ul&gt;
                    
                     &lt;li&gt; The output is right-justified within the {@code width}
                    
                     &lt;li&gt; Negative numbers begin with a {@code '-'}
                    
                     &lt;li&gt; Positive numbers and positive zero do not include a sign or extra
                     leading space
                    
                     &lt;li&gt; No grouping separators are included
                    
                     &lt;li&gt; The decimal separator will only appear if a digit follows it
                    
                     &lt;/ul&gt;
                    
                     &lt;p&gt; The &lt;a id="floatDWidth"&gt;width&lt;/a&gt; is the minimum number of characters
                     to be written to the output.  This includes any signs, digits, grouping
                     separators, decimal separators, exponential symbol, radix indicator,
                     parentheses, and strings representing infinity and NaN as applicable.  If
                     the length of the converted value is less than the width then the output
                     will be padded by spaces (&lt;code&gt;'&amp;#92;u0020'&lt;/code&gt;) until the total number of
                     characters equals width.  The padding is on the left by default.  If the
                     {@code '-'} flag is given then the padding will be on the right.  If width
                     is not specified then there is no minimum.
                    
                     &lt;p&gt; If the &lt;a id="floatDPrec"&gt;conversion&lt;/a&gt; is {@code 'e'},
                     {@code 'E'} or {@code 'f'}, then the precision is the number of digits
                     after the decimal separator.  If the precision is not specified, then it is
                     assumed to be {@code 6}.
                    
                     &lt;p&gt; If the conversion is {@code 'g'} or {@code 'G'}, then the precision is
                     the total number of significant digits in the resulting magnitude after
                     rounding.  If the precision is not specified, then the default value is
                     {@code 6}.  If the precision is {@code 0}, then it is taken to be
                     {@code 1}.
                    
                     &lt;p&gt; If the conversion is {@code 'a'} or {@code 'A'}, then the precision
                     is the number of hexadecimal digits after the radix point.  If the
                     precision is not provided, then all of the digits as returned by {@link
                     Double#toHexString(double)} will be output.
                    
                     &lt;p&gt;&lt;a id="dnbdec"&gt;&lt;b&gt; BigDecimal &lt;/b&gt;&lt;/a&gt;
                    
                     &lt;p&gt; The following conversions may be applied {@link java.math.BigDecimal
                     BigDecimal}.
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;floatConv&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'e'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0065'&lt;/code&gt;
                         &lt;td&gt; Requires the output to be formatted using &lt;a
                         id="bscientific"&gt;computerized scientific notation&lt;/a&gt;.  The &lt;a
                         href="#L10nAlgorithm"&gt;localization algorithm&lt;/a&gt; is applied.
                    
                         &lt;p&gt; The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its value.
                    
                         &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is positive-zero or negative-zero, then the exponent
                         will be {@code "+00"}.
                    
                         &lt;p&gt; Otherwise, the result is a string that represents the sign and
                         magnitude (absolute value) of the argument.  The formatting of the sign
                         is described in the &lt;a href="#L10nAlgorithm"&gt;localization
                         algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
                         value.
                    
                         &lt;p&gt; Let &lt;i&gt;n&lt;/i&gt; be the unique integer such that 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt;
                         &amp;lt;= &lt;i&gt;m&lt;/i&gt; &amp;lt; 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;+1&lt;/sup&gt;; then let &lt;i&gt;a&lt;/i&gt; be the
                         mathematically exact quotient of &lt;i&gt;m&lt;/i&gt; and 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; so
                         that 1 &amp;lt;= &lt;i&gt;a&lt;/i&gt; &amp;lt; 10. The magnitude is then represented as the
                         integer part of &lt;i&gt;a&lt;/i&gt;, as a single decimal digit, followed by the
                         decimal separator followed by decimal digits representing the fractional
                         part of &lt;i&gt;a&lt;/i&gt;, followed by the exponent symbol {@code 'e'}
                         (&lt;code&gt;'&amp;#92;u0065'&lt;/code&gt;), followed by the sign of the exponent, followed
                         by a representation of &lt;i&gt;n&lt;/i&gt; as a decimal integer, as produced by the
                         method {@link Long#toString(long, int)}, and zero-padded to include at
                         least two digits.
                    
                         &lt;p&gt; The number of digits in the result for the fractional part of
                         &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision.  If the precision is not
                         specified then the default value is {@code 6}.  If the precision is
                         less than the number of digits to the right of the decimal point then
                         the value will be rounded using the
                         {@linkplain java.math.RoundingMode#HALF_UP round half up
                         algorithm}.  Otherwise, zeros may be appended to reach the precision.
                         For a canonical representation of the value, use {@link
                         BigDecimal#toString()}.
                    
                         &lt;p&gt; If the {@code ','} flag is given, then an {@link
                         FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'E'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0045'&lt;/code&gt;
                         &lt;td&gt; The upper-case variant of {@code 'e'}.  The exponent symbol
                         will be {@code 'E'} (&lt;code&gt;'&amp;#92;u0045'&lt;/code&gt;).
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'g'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0067'&lt;/code&gt;
                         &lt;td&gt; Requires the output to be formatted in general scientific notation
                         as described below. The &lt;a href="#L10nAlgorithm"&gt;localization
                         algorithm&lt;/a&gt; is applied.
                    
                         &lt;p&gt; After rounding for the precision, the formatting of the resulting
                         magnitude &lt;i&gt;m&lt;/i&gt; depends on its value.
                    
                         &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is greater than or equal to 10&lt;sup&gt;-4&lt;/sup&gt; but less
                         than 10&lt;sup&gt;precision&lt;/sup&gt; then it is represented in &lt;i&gt;&lt;a
                         href="#bdecimal"&gt;decimal format&lt;/a&gt;&lt;/i&gt;.
                    
                         &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is less than 10&lt;sup&gt;-4&lt;/sup&gt; or greater than or equal to
                         10&lt;sup&gt;precision&lt;/sup&gt;, then it is represented in &lt;i&gt;&lt;a
                         href="#bscientific"&gt;computerized scientific notation&lt;/a&gt;&lt;/i&gt;.
                    
                         &lt;p&gt; The total number of significant digits in &lt;i&gt;m&lt;/i&gt; is equal to the
                         precision.  If the precision is not specified, then the default value is
                         {@code 6}.  If the precision is {@code 0}, then it is taken to be
                         {@code 1}.
                    
                         &lt;p&gt; If the {@code '#'} flag is given then an {@link
                         FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'G'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0047'&lt;/code&gt;
                         &lt;td&gt; The upper-case variant of {@code 'g'}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'f'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0066'&lt;/code&gt;
                         &lt;td&gt; Requires the output to be formatted using &lt;a id="bdecimal"&gt;decimal
                         format&lt;/a&gt;.  The &lt;a href="#L10nAlgorithm"&gt;localization algorithm&lt;/a&gt; is
                         applied.
                    
                         &lt;p&gt; The result is a string that represents the sign and magnitude
                         (absolute value) of the argument.  The formatting of the sign is
                         described in the &lt;a href="#L10nAlgorithm"&gt;localization
                         algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
                         value.
                    
                         &lt;p&gt; The magnitude is formatted as the integer part of &lt;i&gt;m&lt;/i&gt;, with no
                         leading zeroes, followed by the decimal separator followed by one or
                         more decimal digits representing the fractional part of &lt;i&gt;m&lt;/i&gt;.
                    
                         &lt;p&gt; The number of digits in the result for the fractional part of
                         &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision. If the precision is not
                         specified then the default value is {@code 6}.  If the precision is
                         less than the number of digits to the right of the decimal point
                         then the value will be rounded using the
                         {@linkplain java.math.RoundingMode#HALF_UP round half up
                         algorithm}.  Otherwise, zeros may be appended to reach the precision.
                         For a canonical representation of the value, use {@link
                         BigDecimal#toString()}.
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; All &lt;a href="#intFlags"&gt;flags&lt;/a&gt; defined for Byte, Short, Integer, and
                     Long apply.
                    
                     &lt;p&gt; If the {@code '#'} flag is given, then the decimal separator will
                     always be present.
                    
                     &lt;p&gt; The &lt;a href="#floatdFlags"&gt;default behavior&lt;/a&gt; when no flags are
                     given is the same as for Float and Double.
                    
                     &lt;p&gt; The specification of &lt;a href="#floatDWidth"&gt;width&lt;/a&gt; and &lt;a
                     href="#floatDPrec"&gt;precision&lt;/a&gt; is the same as defined for Float and
                     Double.
                    
                     &lt;h4&gt;&lt;a id="ddt"&gt;Date/Time&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;p&gt; This conversion may be applied to {@code long}, {@link Long}, {@link
                     Calendar}, {@link Date} and {@link TemporalAccessor TemporalAccessor}
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;DTConv&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 't'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0074'&lt;/code&gt;
                         &lt;td&gt; Prefix for date and time conversion characters.
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'T'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0054'&lt;/code&gt;
                         &lt;td&gt; The upper-case variant of {@code 't'}.
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; The following date and time conversion character suffixes are defined
                     for the {@code 't'} and {@code 'T'} conversions.  The types are similar to
                     but not completely identical to those defined by GNU {@code date} and
                     POSIX {@code strftime(3c)}.  Additional conversion types are provided to
                     access Java-specific functionality (e.g. {@code 'L'} for milliseconds
                     within the second).
                    
                     &lt;p&gt; The following conversion characters are used for formatting times:
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;time&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt; {@code 'H'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0048'&lt;/code&gt;
                         &lt;td&gt; Hour of the day for the 24-hour clock, formatted as two digits with
                         a leading zero as necessary i.e. {@code 00 - 23}. {@code 00}
                         corresponds to midnight.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'I'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0049'&lt;/code&gt;
                         &lt;td&gt; Hour for the 12-hour clock, formatted as two digits with a leading
                         zero as necessary, i.e.  {@code 01 - 12}.  {@code 01} corresponds to
                         one o'clock (either morning or afternoon).
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'k'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u006b'&lt;/code&gt;
                         &lt;td&gt; Hour of the day for the 24-hour clock, i.e. {@code 0 - 23}.
                         {@code 0} corresponds to midnight.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'l'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u006c'&lt;/code&gt;
                         &lt;td&gt; Hour for the 12-hour clock, i.e. {@code 1 - 12}.  {@code 1}
                         corresponds to one o'clock (either morning or afternoon).
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'M'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u004d'&lt;/code&gt;
                         &lt;td&gt; Minute within the hour formatted as two digits with a leading zero
                         as necessary, i.e.  {@code 00 - 59}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'S'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0053'&lt;/code&gt;
                         &lt;td&gt; Seconds within the minute, formatted as two digits with a leading
                         zero as necessary, i.e. {@code 00 - 60} ("{@code 60}" is a special
                         value required to support leap seconds).
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'L'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u004c'&lt;/code&gt;
                         &lt;td&gt; Millisecond within the second formatted as three digits with
                         leading zeros as necessary, i.e. {@code 000 - 999}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'N'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u004e'&lt;/code&gt;
                         &lt;td&gt; Nanosecond within the second, formatted as nine digits with leading
                         zeros as necessary, i.e. {@code 000000000 - 999999999}.  The precision
                         of this value is limited by the resolution of the underlying operating
                         system or hardware.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'p'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0070'&lt;/code&gt;
                         &lt;td&gt; Locale-specific {@linkplain
                         java.text.DateFormatSymbols#getAmPmStrings morning or afternoon} marker
                         in lower case, e.g."{@code am}" or "{@code pm}".  Use of the
                         conversion prefix {@code 'T'} forces this output to upper case.  (Note
                         that {@code 'p'} produces lower-case output.  This is different from
                         GNU {@code date} and POSIX {@code strftime(3c)} which produce
                         upper-case output.)
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'z'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u007a'&lt;/code&gt;
                         &lt;td&gt; &lt;a href="http://www.ietf.org/rfc/rfc0822.txt"&gt;RFC&amp;nbsp;822&lt;/a&gt;
                         style numeric time zone offset from GMT, e.g. {@code -0800}.  This
                         value will be adjusted as necessary for Daylight Saving Time.  For
                         {@code long}, {@link Long}, and {@link Date} the time zone used is
                         the {@linkplain TimeZone#getDefault() default time zone} for this
                         instance of the Java virtual machine.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'Z'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u005a'&lt;/code&gt;
                         &lt;td&gt; A string representing the abbreviation for the time zone.  This
                         value will be adjusted as necessary for Daylight Saving Time.  For
                         {@code long}, {@link Long}, and {@link Date} the time zone used is
                         the {@linkplain TimeZone#getDefault() default time zone} for this
                         instance of the Java virtual machine.  The Formatter's locale will
                         supersede the locale of the argument (if any).
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 's'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0073'&lt;/code&gt;
                         &lt;td&gt; Seconds since the beginning of the epoch starting at 1 January 1970
                         {@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE/1000} to
                         {@code Long.MAX_VALUE/1000}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'Q'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u004f'&lt;/code&gt;
                         &lt;td&gt; Milliseconds since the beginning of the epoch starting at 1 January
                         1970 {@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE} to
                         {@code Long.MAX_VALUE}. The precision of this value is limited by
                         the resolution of the underlying operating system or hardware.
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; The following conversion characters are used for formatting dates:
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;date&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'B'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0042'&lt;/code&gt;
                         &lt;td&gt; Locale-specific {@linkplain java.text.DateFormatSymbols#getMonths
                         full month name}, e.g. {@code "January"}, {@code "February"}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'b'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0062'&lt;/code&gt;
                         &lt;td&gt; Locale-specific {@linkplain
                         java.text.DateFormatSymbols#getShortMonths abbreviated month name},
                         e.g. {@code "Jan"}, {@code "Feb"}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'h'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0068'&lt;/code&gt;
                         &lt;td&gt; Same as {@code 'b'}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'A'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0041'&lt;/code&gt;
                         &lt;td&gt; Locale-specific full name of the {@linkplain
                         java.text.DateFormatSymbols#getWeekdays day of the week},
                         e.g. {@code "Sunday"}, {@code "Monday"}
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'a'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0061'&lt;/code&gt;
                         &lt;td&gt; Locale-specific short name of the {@linkplain
                         java.text.DateFormatSymbols#getShortWeekdays day of the week},
                         e.g. {@code "Sun"}, {@code "Mon"}
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'C'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0043'&lt;/code&gt;
                         &lt;td&gt; Four-digit year divided by {@code 100}, formatted as two digits
                         with leading zero as necessary, i.e. {@code 00 - 99}
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'Y'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0059'&lt;/code&gt; &lt;td&gt; Year, formatted to at least
                         four digits with leading zeros as necessary, e.g. {@code 0092} equals
                         {@code 92} CE for the Gregorian calendar.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'y'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0079'&lt;/code&gt;
                         &lt;td&gt; Last two digits of the year, formatted with leading zeros as
                         necessary, i.e. {@code 00 - 99}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'j'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u006a'&lt;/code&gt;
                         &lt;td&gt; Day of year, formatted as three digits with leading zeros as
                         necessary, e.g. {@code 001 - 366} for the Gregorian calendar.
                         {@code 001} corresponds to the first day of the year.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'm'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u006d'&lt;/code&gt;
                         &lt;td&gt; Month, formatted as two digits with leading zeros as necessary,
                         i.e. {@code 01 - 13}, where "{@code 01}" is the first month of the
                         year and ("{@code 13}" is a special value required to support lunar
                         calendars).
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'd'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0064'&lt;/code&gt;
                         &lt;td&gt; Day of month, formatted as two digits with leading zeros as
                         necessary, i.e. {@code 01 - 31}, where "{@code 01}" is the first day
                         of the month.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'e'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0065'&lt;/code&gt;
                         &lt;td&gt; Day of month, formatted as two digits, i.e. {@code 1 - 31} where
                         "{@code 1}" is the first day of the month.
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; The following conversion characters are used for formatting common
                     date/time compositions.
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;composites&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'R'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0052'&lt;/code&gt;
                         &lt;td&gt; Time formatted for the 24-hour clock as {@code "%tH:%tM"}
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'T'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0054'&lt;/code&gt;
                         &lt;td&gt; Time formatted for the 24-hour clock as {@code "%tH:%tM:%tS"}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'r'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0072'&lt;/code&gt;
                         &lt;td&gt; Time formatted for the 12-hour clock as {@code "%tI:%tM:%tS
                         %Tp"}.  The location of the morning or afternoon marker
                         ({@code '%Tp'}) may be locale-dependent.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'D'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0044'&lt;/code&gt;
                         &lt;td&gt; Date formatted as {@code "%tm/%td/%ty"}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'F'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0046'&lt;/code&gt;
                         &lt;td&gt; &lt;a href="http://www.w3.org/TR/NOTE-datetime"&gt;ISO&amp;nbsp;8601&lt;/a&gt;
                         complete date formatted as {@code "%tY-%tm-%td"}.
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'c'}
                         &lt;td style="vertical-align:top"&gt; &lt;code&gt;'&amp;#92;u0063'&lt;/code&gt;
                         &lt;td&gt; Date and time formatted as {@code "%ta %tb %td %tT %tZ %tY"},
                         e.g. {@code "Sun Jul 20 16:17:00 EDT 1969"}.
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; The {@code '-'} flag defined for &lt;a href="#dFlags"&gt;General
                     conversions&lt;/a&gt; applies.  If the {@code '#'} flag is given, then a {@link
                     FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;p&gt; The width is the minimum number of characters to
                     be written to the output.  If the length of the converted value is less than
                     the {@code width} then the output will be padded by spaces
                     (&lt;code&gt;'&amp;#92;u0020'&lt;/code&gt;) until the total number of characters equals width.
                     The padding is on the left by default.  If the {@code '-'} flag is given
                     then the padding will be on the right.  If width is not specified then there
                     is no minimum.
                    
                     &lt;p&gt; The precision is not applicable.  If the precision is specified then an
                     {@link IllegalFormatPrecisionException} will be thrown.
                    
                     &lt;h4&gt;&lt;a id="dper"&gt;Percent&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;p&gt; The conversion does not correspond to any argument.
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;DTConv&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code '%'}
                         &lt;td&gt; The result is a literal {@code '%'} (&lt;code&gt;'&amp;#92;u0025'&lt;/code&gt;)
                    
                     &lt;p&gt; The width is the minimum number of characters to
                     be written to the output including the {@code '%'}.  If the length of the
                     converted value is less than the {@code width} then the output will be
                     padded by spaces (&lt;code&gt;'&amp;#92;u0020'&lt;/code&gt;) until the total number of
                     characters equals width.  The padding is on the left.  If width is not
                     specified then just the {@code '%'} is output.
                    
                     &lt;p&gt; The {@code '-'} flag defined for &lt;a href="#dFlags"&gt;General
                     conversions&lt;/a&gt; applies.  If any other flags are provided, then a
                     {@link FormatFlagsConversionMismatchException} will be thrown.
                    
                     &lt;p&gt; The precision is not applicable.  If the precision is specified an
                     {@link IllegalFormatPrecisionException} will be thrown.
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;h4&gt;&lt;a id="dls"&gt;Line Separator&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;p&gt; The conversion does not correspond to any argument.
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;DTConv&lt;/caption&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;{@code 'n'}
                         &lt;td&gt; the platform-specific line separator as returned by {@link
                         System#lineSeparator()}.
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt; Flags, width, and precision are not applicable.  If any are provided an
                     {@link IllegalFormatFlagsException}, {@link IllegalFormatWidthException},
                     and {@link IllegalFormatPrecisionException}, respectively will be thrown.
                    
                     &lt;h4&gt;&lt;a id="dpos"&gt;Argument Index&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;p&gt; Format specifiers can reference arguments in three ways:
                    
                     &lt;ul&gt;
                    
                     &lt;li&gt; &lt;i&gt;Explicit indexing&lt;/i&gt; is used when the format specifier contains an
                     argument index.  The argument index is a decimal integer indicating the
                     position of the argument in the argument list.  The first argument is
                     referenced by "{@code 1$}", the second by "{@code 2$}", etc.  An argument
                     may be referenced more than once.
                    
                     &lt;p&gt; For example:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                       formatter.format("%4$s %3$s %2$s %1$s %4$s %3$s %2$s %1$s",
                                        "a", "b", "c", "d")
                       // -&amp;gt; "d c b a d c b a"
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;li&gt; &lt;i&gt;Relative indexing&lt;/i&gt; is used when the format specifier contains a
                     {@code '&lt;'} (&lt;code&gt;'&amp;#92;u003c'&lt;/code&gt;) flag which causes the argument for
                     the previous format specifier to be re-used.  If there is no previous
                     argument, then a {@link MissingFormatArgumentException} is thrown.
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                        formatter.format("%s %s %&amp;lt;s %&amp;lt;s", "a", "b", "c", "d")
                        // -&amp;gt; "a b b b"
                        // "c" and "d" are ignored because they are not referenced
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;li&gt; &lt;i&gt;Ordinary indexing&lt;/i&gt; is used when the format specifier contains
                     neither an argument index nor a {@code '&lt;'} flag.  Each format specifier
                     which uses ordinary indexing is assigned a sequential implicit index into
                     argument list which is independent of the indices used by explicit or
                     relative indexing.
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                       formatter.format("%s %s %s %s", "a", "b", "c", "d")
                       // -&amp;gt; "a b c d"
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;/ul&gt;
                    
                     &lt;p&gt; It is possible to have a format string which uses all forms of indexing,
                     for example:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                       formatter.format("%2$s %s %&amp;lt;s %s", "a", "b", "c", "d")
                       // -&amp;gt; "b a a b"
                       // "c" and "d" are ignored because they are not referenced
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt; The maximum number of arguments is limited by the maximum dimension of a
                     Java array as defined by
                     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
                     If the argument index does not correspond to an
                     available argument, then a {@link MissingFormatArgumentException} is thrown.
                    
                     &lt;p&gt; If there are more arguments than format specifiers, the extra arguments
                     are ignored.
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
                     method or constructor in this class will cause a {@link
                     NullPointerException} to be thrown.
                    
                     @author  Iris Clark
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="AbstractSpliterator" access="PUBLIC" declaringClass="Spliterators" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Spliterator"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="FilteringMode" access="PUBLIC" declaringClass="Locale" kind="TYPE" typeKind="ENUM" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="ServiceConfigurationError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Error thrown when something goes wrong while locating, loading, or
                     instantiating a service provider.
                    
                     @author Mark Reinhold
                     @since 1.6
                     @see ServiceLoader
                    </javadoc>
            </acts>
            <acts name="Properties" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Hashtable"/>
                    <superType superType="java.util.Dictionary"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Properties} class represents a persistent set of
                     properties. The {@code Properties} can be saved to a stream
                     or loaded from a stream. Each key and its corresponding value in
                     the property list is a string.
                     &lt;p&gt;
                     A property list can contain another property list as its
                     "defaults"; this second property list is searched if
                     the property key is not found in the original property list.
                     &lt;p&gt;
                     Because {@code Properties} inherits from {@code Hashtable}, the
                     {@code put} and {@code putAll} methods can be applied to a
                     {@code Properties} object.  Their use is strongly discouraged as they
                     allow the caller to insert entries whose keys or values are not
                     {@code Strings}.  The {@code setProperty} method should be used
                     instead.  If the {@code store} or {@code save} method is called
                     on a "compromised" {@code Properties} object that contains a
                     non-{@code String} key or value, the call will fail. Similarly,
                     the call to the {@code propertyNames} or {@code list} method
                     will fail if it is called on a "compromised" {@code Properties}
                     object that contains a non-{@code String} key.
                    
                     &lt;p&gt;
                     The iterators returned by the {@code iterator} method of this class's
                     "collection views" (that is, {@code entrySet()}, {@code keySet()}, and
                     {@code values()}) may not fail-fast (unlike the Hashtable implementation).
                     These iterators are guaranteed to traverse elements as they existed upon
                     construction exactly once, and may (but are not guaranteed to) reflect any
                     modifications subsequent to construction.
                     &lt;p&gt;
                     The {@link #load(java.io.Reader) load(Reader)} {@code /}
                     {@link #store(java.io.Writer, java.lang.String) store(Writer, String)}
                     methods load and store properties from and to a character based stream
                     in a simple line-oriented format specified below.
                    
                     The {@link #load(java.io.InputStream) load(InputStream)} {@code /}
                     {@link #store(java.io.OutputStream, java.lang.String) store(OutputStream, String)}
                     methods work the same way as the load(Reader)/store(Writer, String) pair, except
                     the input/output stream is encoded in ISO 8859-1 character encoding.
                     Characters that cannot be directly represented in this encoding can be written using
                     Unicode escapes as defined in section 3.3 of
                     &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;;
                     only a single 'u' character is allowed in an escape
                     sequence.
                    
                     &lt;p&gt; The {@link #loadFromXML(InputStream)} and {@link
                     #storeToXML(OutputStream, String, String)} methods load and store properties
                     in a simple XML format.  By default the UTF-8 character encoding is used,
                     however a specific encoding may be specified if required. Implementations
                     are required to support UTF-8 and UTF-16 and may support other encodings.
                     An XML properties document has the following DOCTYPE declaration:
                    
                     &lt;pre&gt;
                     &amp;lt;!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd"&amp;gt;
                     &lt;/pre&gt;
                     Note that the system URI (http://java.sun.com/dtd/properties.dtd) is
                     &lt;i&gt;not&lt;/i&gt; accessed when exporting or importing properties; it merely
                     serves as a string to uniquely identify the DTD, which is:
                     &lt;pre&gt;
                        &amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
                    
                        &amp;lt;!-- DTD for properties --&amp;gt;
                    
                        &amp;lt;!ELEMENT properties ( comment?, entry* ) &amp;gt;
                    
                        &amp;lt;!ATTLIST properties version CDATA #FIXED "1.0"&amp;gt;
                    
                        &amp;lt;!ELEMENT comment (#PCDATA) &amp;gt;
                    
                        &amp;lt;!ELEMENT entry (#PCDATA) &amp;gt;
                    
                        &amp;lt;!ATTLIST entry key CDATA #REQUIRED&amp;gt;
                     &lt;/pre&gt;
                    
                     &lt;p&gt;This class is thread-safe: multiple threads can share a single
                     {@code Properties} object without the need for external synchronization.
                    
                     @apiNote
                     The {@code Properties} class does not inherit the concept of a load factor
                     from its superclass, {@code Hashtable}.
                    
                     @author  Arthur van Hoff
                     @author  Michael McCloskey
                     @author  Xueming Shen
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="AbstractLongSpliterator" access="PUBLIC" declaringClass="Spliterators" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Spliterator$OfLong"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="TimerTask" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Runnable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A task that can be scheduled for one-time or repeated execution by a
                     {@link Timer}.
                    
                     &lt;p&gt;A timer task is &lt;em&gt;not&lt;/em&gt; reusable.  Once a task has been scheduled
                     for execution on a {@code Timer} or cancelled, subsequent attempts to
                     schedule it for execution will throw {@code IllegalStateException}.
                    
                     @author  Josh Bloch
                     @since   1.3
                    </javadoc>
            </acts>
            <acts name="InvalidPropertiesFormatException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that an operation could not complete because
                     the input did not conform to the appropriate XML document type
                     for a collection of properties, as per the {@link Properties}
                     specification.&lt;p&gt;
                    
                     Note, that although InvalidPropertiesFormatException inherits Serializable
                     interface from Exception, it is not intended to be Serializable. Appropriate
                     serialization methods are implemented to throw NotSerializableException.
                    
                     @see     Properties
                     @since   1.5
                     @serial exclude
                    </javadoc>
            </acts>
            <acts name="Iterator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes/>
                <javadoc xml:space="preserve">
                     An iterator over a collection.  {@code Iterator} takes the place of
                     {@link Enumeration} in the Java Collections Framework.  Iterators
                     differ from enumerations in two ways:
                    
                     &lt;ul&gt;
                          &lt;li&gt; Iterators allow the caller to remove elements from the
                               underlying collection during the iteration with well-defined
                               semantics.
                          &lt;li&gt; Method names have been improved.
                     &lt;/ul&gt;
                    
                     &lt;p&gt;This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @apiNote
                     An {@link Enumeration} can be converted into an {@code Iterator} by
                     using the {@link Enumeration#asIterator} method.
                    
                     @param &lt;E&gt; the type of elements returned by this iterator
                    
                     @author  Josh Bloch
                     @see Collection
                     @see ListIterator
                     @see Iterable
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="IllegalFormatFlagsException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.IllegalFormatException"/>
                    <superType superType="java.lang.IllegalArgumentException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Unchecked exception thrown when an illegal combination flags is given.
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
                     method or constructor in this class will cause a {@link
                     NullPointerException} to be thrown.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="OfLong" access="PUBLIC" declaringClass="Spliterator" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Spliterator$OfPrimitive"/>
                </superTypes>
            </acts>
            <acts name="PrimitiveIterator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Iterator"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A base type for primitive specializations of {@code Iterator}.  Specialized
                     subtypes are provided for {@link OfInt int}, {@link OfLong long}, and
                     {@link OfDouble double} values.
                    
                     &lt;p&gt;The specialized subtype default implementations of {@link Iterator#next}
                     and {@link Iterator#forEachRemaining(java.util.function.Consumer)} box
                     primitive values to instances of their corresponding wrapper class.  Such
                     boxing may offset any advantages gained when using the primitive
                     specializations.  To avoid boxing, the corresponding primitive-based methods
                     should be used.  For example, {@link PrimitiveIterator.OfInt#nextInt()} and
                     {@link PrimitiveIterator.OfInt#forEachRemaining(java.util.function.IntConsumer)}
                     should be used in preference to {@link PrimitiveIterator.OfInt#next()} and
                     {@link PrimitiveIterator.OfInt#forEachRemaining(java.util.function.Consumer)}.
                    
                     &lt;p&gt;Iteration of primitive values using boxing-based methods
                     {@link Iterator#next next()} and
                     {@link Iterator#forEachRemaining(java.util.function.Consumer) forEachRemaining()},
                     does not affect the order in which the values, transformed to boxed values,
                     are encountered.
                    
                     @implNote
                     If the boolean system property {@code org.openjdk.java.util.stream.tripwire}
                     is set to {@code true} then diagnostic warnings are reported if boxing of
                     primitive values occur when operating on primitive subtype specializations.
                    
                     @param &lt;T&gt; the type of elements returned by this PrimitiveIterator.  The
                            type must be a wrapper type for a primitive type, such as
                            {@code Integer} for the primitive {@code int} type.
                     @param &lt;T_CONS&gt; the type of primitive consumer.  The type must be a
                            primitive specialization of {@link java.util.function.Consumer} for
                            {@code T}, such as {@link java.util.function.IntConsumer} for
                            {@code Integer}.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="FormatFlagsConversionMismatchException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.IllegalFormatException"/>
                    <superType superType="java.lang.IllegalArgumentException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Unchecked exception thrown when a conversion and flag are incompatible.
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
                     method or constructor in this class will cause a {@link
                     NullPointerException} to be thrown.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="Entry" access="PUBLIC" declaringClass="Map" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes/>
            </acts>
            <acts name="EnumSet" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.util.AbstractSet"/>
                    <superType superType="java.util.AbstractCollection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A specialized {@link Set} implementation for use with enum types.  All of
                     the elements in an enum set must come from a single enum type that is
                     specified, explicitly or implicitly, when the set is created.  Enum sets
                     are represented internally as bit vectors.  This representation is
                     extremely compact and efficient. The space and time performance of this
                     class should be good enough to allow its use as a high-quality, typesafe
                     alternative to traditional {@code int}-based "bit flags."  Even bulk
                     operations (such as {@code containsAll} and {@code retainAll}) should
                     run very quickly if their argument is also an enum set.
                    
                     &lt;p&gt;The iterator returned by the {@code iterator} method traverses the
                     elements in their &lt;i&gt;natural order&lt;/i&gt; (the order in which the enum
                     constants are declared).  The returned iterator is &lt;i&gt;weakly
                     consistent&lt;/i&gt;: it will never throw {@link ConcurrentModificationException}
                     and it may or may not show the effects of any modifications to the set that
                     occur while the iteration is in progress.
                    
                     &lt;p&gt;Null elements are not permitted.  Attempts to insert a null element
                     will throw {@link NullPointerException}.  Attempts to test for the
                     presence of a null element or to remove one will, however, function
                     properly.
                    
                     &lt;P&gt;Like most collection implementations, {@code EnumSet} is not
                     synchronized.  If multiple threads access an enum set concurrently, and at
                     least one of the threads modifies the set, it should be synchronized
                     externally.  This is typically accomplished by synchronizing on some
                     object that naturally encapsulates the enum set.  If no such object exists,
                     the set should be "wrapped" using the {@link Collections#synchronizedSet}
                     method.  This is best done at creation time, to prevent accidental
                     unsynchronized access:
                    
                     &lt;pre&gt;
                     Set&amp;lt;MyEnum&amp;gt; s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class));
                     &lt;/pre&gt;
                    
                     &lt;p&gt;Implementation note: All basic operations execute in constant time.
                     They are likely (though not guaranteed) to be much faster than their
                     {@link HashSet} counterparts.  Even bulk operations execute in
                     constant time if their argument is also an enum set.
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @author Josh Bloch
                     @since 1.5
                     @see EnumMap
                    </javadoc>
            </acts>
            <acts name="ArrayDeque" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Deque"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.util.AbstractCollection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Resizable-array implementation of the {@link Deque} interface.  Array
                     deques have no capacity restrictions; they grow as necessary to support
                     usage.  They are not thread-safe; in the absence of external
                     synchronization, they do not support concurrent access by multiple threads.
                     Null elements are prohibited.  This class is likely to be faster than
                     {@link Stack} when used as a stack, and faster than {@link LinkedList}
                     when used as a queue.
                    
                     &lt;p&gt;Most {@code ArrayDeque} operations run in amortized constant time.
                     Exceptions include
                     {@link #remove(Object) remove},
                     {@link #removeFirstOccurrence removeFirstOccurrence},
                     {@link #removeLastOccurrence removeLastOccurrence},
                     {@link #contains contains},
                     {@link #iterator iterator.remove()},
                     and the bulk operations, all of which run in linear time.
                    
                     &lt;p&gt;The iterators returned by this class's {@link #iterator() iterator}
                     method are &lt;em&gt;fail-fast&lt;/em&gt;: If the deque is modified at any time after
                     the iterator is created, in any way except through the iterator's own
                     {@code remove} method, the iterator will generally throw a {@link
                     ConcurrentModificationException}.  Thus, in the face of concurrent
                     modification, the iterator fails quickly and cleanly, rather than risking
                     arbitrary, non-deterministic behavior at an undetermined time in the
                     future.
                    
                     &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                     as it is, generally speaking, impossible to make any hard guarantees in the
                     presence of unsynchronized concurrent modification.  Fail-fast iterators
                     throw {@code ConcurrentModificationException} on a best-effort basis.
                     Therefore, it would be wrong to write a program that depended on this
                     exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators
                     should be used only to detect bugs.&lt;/i&gt;
                    
                     &lt;p&gt;This class and its iterator implement all of the
                     &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link
                     Iterator} interfaces.
                    
                     &lt;p&gt;This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @author  Josh Bloch and Doug Lea
                     @param &lt;E&gt; the type of elements held in this deque
                     @since   1.6
                    </javadoc>
            </acts>
            <acts name="Date" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The class {@code Date} represents a specific instant
                     in time, with millisecond precision.
                     &lt;p&gt;
                     Prior to JDK&amp;nbsp;1.1, the class {@code Date} had two additional
                     functions.  It allowed the interpretation of dates as year, month, day, hour,
                     minute, and second values.  It also allowed the formatting and parsing
                     of date strings.  Unfortunately, the API for these functions was not
                     amenable to internationalization.  As of JDK&amp;nbsp;1.1, the
                     {@code Calendar} class should be used to convert between dates and time
                     fields and the {@code DateFormat} class should be used to format and
                     parse date strings.
                     The corresponding methods in {@code Date} are deprecated.
                     &lt;p&gt;
                     Although the {@code Date} class is intended to reflect
                     coordinated universal time (UTC), it may not do so exactly,
                     depending on the host environment of the Java Virtual Machine.
                     Nearly all modern operating systems assume that 1&amp;nbsp;day&amp;nbsp;=
                     24&amp;nbsp;&amp;times;&amp;nbsp;60&amp;nbsp;&amp;times;&amp;nbsp;60&amp;nbsp;= 86400 seconds
                     in all cases. In UTC, however, about once every year or two there
                     is an extra second, called a "leap second." The leap
                     second is always added as the last second of the day, and always
                     on December 31 or June 30. For example, the last minute of the
                     year 1995 was 61 seconds long, thanks to an added leap second.
                     Most computer clocks are not accurate enough to be able to reflect
                     the leap-second distinction.
                     &lt;p&gt;
                     Some computer standards are defined in terms of Greenwich mean
                     time (GMT), which is equivalent to universal time (UT).  GMT is
                     the "civil" name for the standard; UT is the
                     "scientific" name for the same standard. The
                     distinction between UTC and UT is that UTC is based on an atomic
                     clock and UT is based on astronomical observations, which for all
                     practical purposes is an invisibly fine hair to split. Because the
                     earth's rotation is not uniform (it slows down and speeds up
                     in complicated ways), UT does not always flow uniformly. Leap
                     seconds are introduced as needed into UTC so as to keep UTC within
                     0.9 seconds of UT1, which is a version of UT with certain
                     corrections applied. There are other time and date systems as
                     well; for example, the time scale used by the satellite-based
                     global positioning system (GPS) is synchronized to UTC but is
                     &lt;i&gt;not&lt;/i&gt; adjusted for leap seconds. An interesting source of
                     further information is the United States Naval Observatory (USNO):
                     &lt;blockquote&gt;&lt;pre&gt;
                         &lt;a href="http://www.usno.navy.mil/USNO"&gt;http://www.usno.navy.mil/USNO&lt;/a&gt;
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     &lt;p&gt;
                     and the material regarding "Systems of Time" at:
                     &lt;blockquote&gt;&lt;pre&gt;
                         &lt;a href="http://www.usno.navy.mil/USNO/time/master-clock/systems-of-time"&gt;http://www.usno.navy.mil/USNO/time/master-clock/systems-of-time&lt;/a&gt;
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     &lt;p&gt;
                     which has descriptions of various different time systems including
                     UT, UT1, and UTC.
                     &lt;p&gt;
                     In all methods of class {@code Date} that accept or return
                     year, month, date, hours, minutes, and seconds values, the
                     following representations are used:
                     &lt;ul&gt;
                     &lt;li&gt;A year &lt;i&gt;y&lt;/i&gt; is represented by the integer
                         &lt;i&gt;y&lt;/i&gt;&amp;nbsp;{@code - 1900}.
                     &lt;li&gt;A month is represented by an integer from 0 to 11; 0 is January,
                         1 is February, and so forth; thus 11 is December.
                     &lt;li&gt;A date (day of month) is represented by an integer from 1 to 31
                         in the usual manner.
                     &lt;li&gt;An hour is represented by an integer from 0 to 23. Thus, the hour
                         from midnight to 1 a.m. is hour 0, and the hour from noon to 1
                         p.m. is hour 12.
                     &lt;li&gt;A minute is represented by an integer from 0 to 59 in the usual manner.
                     &lt;li&gt;A second is represented by an integer from 0 to 61; the values 60 and
                         61 occur only for leap seconds and even then only in Java
                         implementations that actually track leap seconds correctly. Because
                         of the manner in which leap seconds are currently introduced, it is
                         extremely unlikely that two leap seconds will occur in the same
                         minute, but this specification follows the date and time conventions
                         for ISO C.
                     &lt;/ul&gt;
                     &lt;p&gt;
                     In all cases, arguments given to methods for these purposes need
                     not fall within the indicated ranges; for example, a date may be
                     specified as January 32 and is interpreted as meaning February 1.
                    
                     @author  James Gosling
                     @author  Arthur van Hoff
                     @author  Alan Liu
                     @see     java.text.DateFormat
                     @see     java.util.Calendar
                     @see     java.util.TimeZone
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="OfDouble" access="PUBLIC" declaringClass="PrimitiveIterator" kind="TYPE" typeKind="INTERFACE" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.PrimitiveIterator"/>
                </superTypes>
            </acts>
            <acts name="Timer" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A facility for threads to schedule tasks for future execution in a
                     background thread.  Tasks may be scheduled for one-time execution, or for
                     repeated execution at regular intervals.
                    
                     &lt;p&gt;Corresponding to each {@code Timer} object is a single background
                     thread that is used to execute all of the timer's tasks, sequentially.
                     Timer tasks should complete quickly.  If a timer task takes excessive time
                     to complete, it "hogs" the timer's task execution thread.  This can, in
                     turn, delay the execution of subsequent tasks, which may "bunch up" and
                     execute in rapid succession when (and if) the offending task finally
                     completes.
                    
                     &lt;p&gt;After the last live reference to a {@code Timer} object goes away
                     &lt;i&gt;and&lt;/i&gt; all outstanding tasks have completed execution, the timer's task
                     execution thread terminates gracefully (and becomes subject to garbage
                     collection).  However, this can take arbitrarily long to occur.  By
                     default, the task execution thread does not run as a &lt;i&gt;daemon thread&lt;/i&gt;,
                     so it is capable of keeping an application from terminating.  If a caller
                     wants to terminate a timer's task execution thread rapidly, the caller
                     should invoke the timer's {@code cancel} method.
                    
                     &lt;p&gt;If the timer's task execution thread terminates unexpectedly, for
                     example, because its {@code stop} method is invoked, any further
                     attempt to schedule a task on the timer will result in an
                     {@code IllegalStateException}, as if the timer's {@code cancel}
                     method had been invoked.
                    
                     &lt;p&gt;This class is thread-safe: multiple threads can share a single
                     {@code Timer} object without the need for external synchronization.
                    
                     &lt;p&gt;This class does &lt;i&gt;not&lt;/i&gt; offer real-time guarantees: it schedules
                     tasks using the {@code Object.wait(long)} method.
                    
                     &lt;p&gt;Java 5.0 introduced the {@code java.util.concurrent} package and
                     one of the concurrency utilities therein is the {@link
                     java.util.concurrent.ScheduledThreadPoolExecutor
                     ScheduledThreadPoolExecutor} which is a thread pool for repeatedly
                     executing tasks at a given rate or delay.  It is effectively a more
                     versatile replacement for the {@code Timer}/{@code TimerTask}
                     combination, as it allows multiple service threads, accepts various
                     time units, and doesn't require subclassing {@code TimerTask} (just
                     implement {@code Runnable}).  Configuring {@code
                     ScheduledThreadPoolExecutor} with one thread makes it equivalent to
                     {@code Timer}.
                    
                     &lt;p&gt;Implementation note: This class scales to large numbers of concurrently
                     scheduled tasks (thousands should present no problem).  Internally,
                     it uses a binary heap to represent its task queue, so the cost to schedule
                     a task is O(log n), where n is the number of concurrently scheduled tasks.
                    
                     &lt;p&gt;Implementation note: All constructors start a timer thread.
                    
                     @author  Josh Bloch
                     @see     TimerTask
                     @see     Object#wait(long)
                     @since   1.3
                    </javadoc>
            </acts>
            <acts name="Builder" access="PUBLIC" declaringClass="Locale" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Decoder" access="PUBLIC" declaringClass="Base64" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="SplittableRandom" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A generator of uniform pseudorandom values applicable for use in
                     (among other contexts) isolated parallel computations that may
                     generate subtasks. Class {@code SplittableRandom} supports methods for
                     producing pseudorandom numbers of type {@code int}, {@code long},
                     and {@code double} with similar usages as for class
                     {@link java.util.Random} but differs in the following ways:
                    
                     &lt;ul&gt;
                    
                     &lt;li&gt;Series of generated values pass the DieHarder suite testing
                     independence and uniformity properties of random number generators.
                     (Most recently validated with &lt;a
                     href="http://www.phy.duke.edu/~rgb/General/dieharder.php"&gt; version
                     3.31.1&lt;/a&gt;.) These tests validate only the methods for certain
                     types and ranges, but similar properties are expected to hold, at
                     least approximately, for others as well. The &lt;em&gt;period&lt;/em&gt;
                     (length of any series of generated values before it repeats) is at
                     least 2&lt;sup&gt;64&lt;/sup&gt;.
                    
                     &lt;li&gt;Method {@link #split} constructs and returns a new
                     SplittableRandom instance that shares no mutable state with the
                     current instance. However, with very high probability, the
                     values collectively generated by the two objects have the same
                     statistical properties as if the same quantity of values were
                     generated by a single thread using a single {@code
                     SplittableRandom} object.
                    
                     &lt;li&gt;Instances of SplittableRandom are &lt;em&gt;not&lt;/em&gt; thread-safe.
                     They are designed to be split, not shared, across threads. For
                     example, a {@link java.util.concurrent.ForkJoinTask
                     fork/join-style} computation using random numbers might include a
                     construction of the form {@code new
                     Subtask(aSplittableRandom.split()).fork()}.
                    
                     &lt;li&gt;This class provides additional methods for generating random
                     streams, that employ the above techniques when used in {@code
                     stream.parallel()} mode.
                    
                     &lt;/ul&gt;
                    
                     &lt;p&gt;Instances of {@code SplittableRandom} are not cryptographically
                     secure.  Consider instead using {@link java.security.SecureRandom}
                     in security-sensitive applications. Additionally,
                     default-constructed instances do not use a cryptographically random
                     seed unless the {@linkplain System#getProperty system property}
                     {@code java.util.secureRandomSeed} is set to {@code true}.
                    
                     @author  Guy Steele
                     @author  Doug Lea
                     @since   1.8
                    </javadoc>
            </acts>
            <acts name="NoSuchElementException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown by various accessor methods to indicate that the element being requested
                     does not exist.
                    
                     @author  unascribed
                     @see     java.util.Enumeration#nextElement()
                     @see     java.util.Iterator#next()
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="AbstractDoubleSpliterator" access="PUBLIC" declaringClass="Spliterators" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util">
                <superTypes>
                    <superType superType="java.util.Spliterator$OfDouble"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <package name="zip"/>
            <package name="regex"/>
            <package name="stream">
                <acts name="BaseStream" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.lang.AutoCloseable"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Base interface for streams, which are sequences of elements supporting
                         sequential and parallel aggregate operations.  The following example
                         illustrates an aggregate operation using the stream types {@link Stream}
                         and {@link IntStream}, computing the sum of the weights of the red widgets:
                        
                         &lt;pre&gt;{@code
                             int sum = widgets.stream()
                                              .filter(w -&gt; w.getColor() == RED)
                                              .mapToInt(w -&gt; w.getWeight())
                                              .sum();
                         }&lt;/pre&gt;
                        
                         See the class documentation for {@link Stream} and the package documentation
                         for &lt;a href="package-summary.html"&gt;java.util.stream&lt;/a&gt; for additional
                         specification of streams, stream operations, stream pipelines, and
                         parallelism, which governs the behavior of all stream types.
                        
                         @param &lt;T&gt; the type of the stream elements
                         @param &lt;S&gt; the type of the stream implementing {@code BaseStream}
                         @since 1.8
                         @see Stream
                         @see IntStream
                         @see LongStream
                         @see DoubleStream
                         @see &lt;a href="package-summary.html"&gt;java.util.stream&lt;/a&gt;
                        </javadoc>
                </acts>
                <acts name="Characteristics" access="PUBLIC" declaringClass="Collector" kind="TYPE" typeKind="ENUM" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.lang.Enum"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                </acts>
                <acts name="Builder" access="PUBLIC" declaringClass="IntStream" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.function.IntConsumer"/>
                    </superTypes>
                </acts>
                <acts name="StreamSupport" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Low-level utility methods for creating and manipulating streams.
                        
                         &lt;p&gt;This class is mostly for library writers presenting stream views
                         of data structures; most static stream methods intended for end users are in
                         the various {@code Stream} classes.
                        
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="Builder" access="PUBLIC" declaringClass="Stream" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.function.Consumer"/>
                    </superTypes>
                </acts>
                <acts name="Builder" access="PUBLIC" declaringClass="DoubleStream" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.function.DoubleConsumer"/>
                    </superTypes>
                </acts>
                <acts name="ChainedLong" access="PUBLIC" declaringClass="Sink" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Sink$OfLong"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                </acts>
                <acts name="ChainedDouble" access="PUBLIC" declaringClass="Sink" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Sink$OfDouble"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                </acts>
                <acts name="ChainedReference" access="PUBLIC" declaringClass="Sink" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Sink"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                </acts>
                <acts name="OfInt" access="PUBLIC" declaringClass="Sink" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Sink"/>
                        <superType superType="java.util.function.IntConsumer"/>
                    </superTypes>
                </acts>
                <acts name="Collector" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         A &lt;a href="package-summary.html#Reduction"&gt;mutable reduction operation&lt;/a&gt; that
                         accumulates input elements into a mutable result container, optionally transforming
                         the accumulated result into a final representation after all input elements
                         have been processed.  Reduction operations can be performed either sequentially
                         or in parallel.
                        
                         &lt;p&gt;Examples of mutable reduction operations include:
                         accumulating elements into a {@code Collection}; concatenating
                         strings using a {@code StringBuilder}; computing summary information about
                         elements such as sum, min, max, or average; computing "pivot table" summaries
                         such as "maximum valued transaction by seller", etc.  The class {@link Collectors}
                         provides implementations of many common mutable reductions.
                        
                         &lt;p&gt;A {@code Collector} is specified by four functions that work together to
                         accumulate entries into a mutable result container, and optionally perform
                         a final transform on the result.  They are: &lt;ul&gt;
                             &lt;li&gt;creation of a new result container ({@link #supplier()})&lt;/li&gt;
                             &lt;li&gt;incorporating a new data element into a result container ({@link #accumulator()})&lt;/li&gt;
                             &lt;li&gt;combining two result containers into one ({@link #combiner()})&lt;/li&gt;
                             &lt;li&gt;performing an optional final transform on the container ({@link #finisher()})&lt;/li&gt;
                         &lt;/ul&gt;
                        
                         &lt;p&gt;Collectors also have a set of characteristics, such as
                         {@link Characteristics#CONCURRENT}, that provide hints that can be used by a
                         reduction implementation to provide better performance.
                        
                         &lt;p&gt;A sequential implementation of a reduction using a collector would
                         create a single result container using the supplier function, and invoke the
                         accumulator function once for each input element.  A parallel implementation
                         would partition the input, create a result container for each partition,
                         accumulate the contents of each partition into a subresult for that partition,
                         and then use the combiner function to merge the subresults into a combined
                         result.
                        
                         &lt;p&gt;To ensure that sequential and parallel executions produce equivalent
                         results, the collector functions must satisfy an &lt;em&gt;identity&lt;/em&gt; and an
                         &lt;a href="package-summary.html#Associativity"&gt;associativity&lt;/a&gt; constraints.
                        
                         &lt;p&gt;The identity constraint says that for any partially accumulated result,
                         combining it with an empty result container must produce an equivalent
                         result.  That is, for a partially accumulated result {@code a} that is the
                         result of any series of accumulator and combiner invocations, {@code a} must
                         be equivalent to {@code combiner.apply(a, supplier.get())}.
                        
                         &lt;p&gt;The associativity constraint says that splitting the computation must
                         produce an equivalent result.  That is, for any input elements {@code t1}
                         and {@code t2}, the results {@code r1} and {@code r2} in the computation
                         below must be equivalent:
                         &lt;pre&gt;{@code
                             A a1 = supplier.get();
                             accumulator.accept(a1, t1);
                             accumulator.accept(a1, t2);
                             R r1 = finisher.apply(a1);  // result without splitting
                        
                             A a2 = supplier.get();
                             accumulator.accept(a2, t1);
                             A a3 = supplier.get();
                             accumulator.accept(a3, t2);
                             R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting
                         } &lt;/pre&gt;
                        
                         &lt;p&gt;For collectors that do not have the {@code UNORDERED} characteristic,
                         two accumulated results {@code a1} and {@code a2} are equivalent if
                         {@code finisher.apply(a1).equals(finisher.apply(a2))}.  For unordered
                         collectors, equivalence is relaxed to allow for non-equality related to
                         differences in order.  (For example, an unordered collector that accumulated
                         elements to a {@code List} would consider two lists equivalent if they
                         contained the same elements, ignoring order.)
                        
                         &lt;p&gt;Libraries that implement reduction based on {@code Collector}, such as
                         {@link Stream#collect(Collector)}, must adhere to the following constraints:
                         &lt;ul&gt;
                             &lt;li&gt;The first argument passed to the accumulator function, both
                             arguments passed to the combiner function, and the argument passed to the
                             finisher function must be the result of a previous invocation of the
                             result supplier, accumulator, or combiner functions.&lt;/li&gt;
                             &lt;li&gt;The implementation should not do anything with the result of any of
                             the result supplier, accumulator, or combiner functions other than to
                             pass them again to the accumulator, combiner, or finisher functions,
                             or return them to the caller of the reduction operation.&lt;/li&gt;
                             &lt;li&gt;If a result is passed to the combiner or finisher
                             function, and the same object is not returned from that function, it is
                             never used again.&lt;/li&gt;
                             &lt;li&gt;Once a result is passed to the combiner or finisher function, it
                             is never passed to the accumulator function again.&lt;/li&gt;
                             &lt;li&gt;For non-concurrent collectors, any result returned from the result
                             supplier, accumulator, or combiner functions must be serially
                             thread-confined.  This enables collection to occur in parallel without
                             the {@code Collector} needing to implement any additional synchronization.
                             The reduction implementation must manage that the input is properly
                             partitioned, that partitions are processed in isolation, and combining
                             happens only after accumulation is complete.&lt;/li&gt;
                             &lt;li&gt;For concurrent collectors, an implementation is free to (but not
                             required to) implement reduction concurrently.  A concurrent reduction
                             is one where the accumulator function is called concurrently from
                             multiple threads, using the same concurrently-modifiable result container,
                             rather than keeping the result isolated during accumulation.
                             A concurrent reduction should only be applied if the collector has the
                             {@link Characteristics#UNORDERED} characteristics or if the
                             originating data is unordered.&lt;/li&gt;
                         &lt;/ul&gt;
                        
                         &lt;p&gt;In addition to the predefined implementations in {@link Collectors}, the
                         static factory methods {@link #of(Supplier, BiConsumer, BinaryOperator, Characteristics...)}
                         can be used to construct collectors.  For example, you could create a collector
                         that accumulates widgets into a {@code TreeSet} with:
                        
                         &lt;pre&gt;{@code
                             Collector&lt;Widget, ?, TreeSet&lt;Widget&gt;&gt; intoSet =
                                 Collector.of(TreeSet::new, TreeSet::add,
                                              (left, right) -&gt; { left.addAll(right); return left; });
                         }&lt;/pre&gt;
                        
                         (This behavior is also implemented by the predefined collector
                         {@link Collectors#toCollection(Supplier)}).
                        
                         @apiNote
                         Performing a reduction operation with a {@code Collector} should produce a
                         result equivalent to:
                         &lt;pre&gt;{@code
                             R container = collector.supplier().get();
                             for (T t : data)
                                 collector.accumulator().accept(container, t);
                             return collector.finisher().apply(container);
                         }&lt;/pre&gt;
                        
                         &lt;p&gt;However, the library is free to partition the input, perform the reduction
                         on the partitions, and then use the combiner function to combine the partial
                         results to achieve a parallel reduction.  (Depending on the specific reduction
                         operation, this may perform better or worse, depending on the relative cost
                         of the accumulator and combiner functions.)
                        
                         &lt;p&gt;Collectors are designed to be &lt;em&gt;composed&lt;/em&gt;; many of the methods
                         in {@link Collectors} are functions that take a collector and produce
                         a new collector.  For example, given the following collector that computes
                         the sum of the salaries of a stream of employees:
                        
                         &lt;pre&gt;{@code
                             Collector&lt;Employee, ?, Integer&gt; summingSalaries
                                 = Collectors.summingInt(Employee::getSalary))
                         }&lt;/pre&gt;
                        
                         If we wanted to create a collector to tabulate the sum of salaries by
                         department, we could reuse the "sum of salaries" logic using
                         {@link Collectors#groupingBy(Function, Collector)}:
                        
                         &lt;pre&gt;{@code
                             Collector&lt;Employee, ?, Map&lt;Department, Integer&gt;&gt; summingSalariesByDept
                                 = Collectors.groupingBy(Employee::getDepartment, summingSalaries);
                         }&lt;/pre&gt;
                        
                         @see Stream#collect(Collector)
                         @see Collectors
                        
                         @param &lt;T&gt; the type of input elements to the reduction operation
                         @param &lt;A&gt; the mutable accumulation type of the reduction operation (often
                                    hidden as an implementation detail)
                         @param &lt;R&gt; the result type of the reduction operation
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="Builder" access="PUBLIC" declaringClass="Node" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Sink"/>
                    </superTypes>
                </acts>
                <acts name="Stream" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.BaseStream"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A sequence of elements supporting sequential and parallel aggregate
                         operations.  The following example illustrates an aggregate operation using
                         {@link Stream} and {@link IntStream}:
                        
                         &lt;pre&gt;{@code
                             int sum = widgets.stream()
                                              .filter(w -&gt; w.getColor() == RED)
                                              .mapToInt(w -&gt; w.getWeight())
                                              .sum();
                         }&lt;/pre&gt;
                        
                         In this example, {@code widgets} is a {@code Collection&lt;Widget&gt;}.  We create
                         a stream of {@code Widget} objects via {@link Collection#stream Collection.stream()},
                         filter it to produce a stream containing only the red widgets, and then
                         transform it into a stream of {@code int} values representing the weight of
                         each red widget. Then this stream is summed to produce a total weight.
                        
                         &lt;p&gt;In addition to {@code Stream}, which is a stream of object references,
                         there are primitive specializations for {@link IntStream}, {@link LongStream},
                         and {@link DoubleStream}, all of which are referred to as "streams" and
                         conform to the characteristics and restrictions described here.
                        
                         &lt;p&gt;To perform a computation, stream
                         &lt;a href="package-summary.html#StreamOps"&gt;operations&lt;/a&gt; are composed into a
                         &lt;em&gt;stream pipeline&lt;/em&gt;.  A stream pipeline consists of a source (which
                         might be an array, a collection, a generator function, an I/O channel,
                         etc), zero or more &lt;em&gt;intermediate operations&lt;/em&gt; (which transform a
                         stream into another stream, such as {@link Stream#filter(Predicate)}), and a
                         &lt;em&gt;terminal operation&lt;/em&gt; (which produces a result or side-effect, such
                         as {@link Stream#count()} or {@link Stream#forEach(Consumer)}).
                         Streams are lazy; computation on the source data is only performed when the
                         terminal operation is initiated, and source elements are consumed only
                         as needed.
                        
                         &lt;p&gt;A stream implementation is permitted significant latitude in optimizing
                         the computation of the result.  For example, a stream implementation is free
                         to elide operations (or entire stages) from a stream pipeline -- and
                         therefore elide invocation of behavioral parameters -- if it can prove that
                         it would not affect the result of the computation.  This means that
                         side-effects of behavioral parameters may not always be executed and should
                         not be relied upon, unless otherwise specified (such as by the terminal
                         operations {@code forEach} and {@code forEachOrdered}). (For a specific
                         example of such an optimization, see the API note documented on the
                         {@link #count} operation.  For more detail, see the
                         &lt;a href="package-summary.html#SideEffects"&gt;side-effects&lt;/a&gt; section of the
                         stream package documentation.)
                        
                         &lt;p&gt;Collections and streams, while bearing some superficial similarities,
                         have different goals.  Collections are primarily concerned with the efficient
                         management of, and access to, their elements.  By contrast, streams do not
                         provide a means to directly access or manipulate their elements, and are
                         instead concerned with declaratively describing their source and the
                         computational operations which will be performed in aggregate on that source.
                         However, if the provided stream operations do not offer the desired
                         functionality, the {@link #iterator()} and {@link #spliterator()} operations
                         can be used to perform a controlled traversal.
                        
                         &lt;p&gt;A stream pipeline, like the "widgets" example above, can be viewed as
                         a &lt;em&gt;query&lt;/em&gt; on the stream source.  Unless the source was explicitly
                         designed for concurrent modification (such as a {@link ConcurrentHashMap}),
                         unpredictable or erroneous behavior may result from modifying the stream
                         source while it is being queried.
                        
                         &lt;p&gt;Most stream operations accept parameters that describe user-specified
                         behavior, such as the lambda expression {@code w -&gt; w.getWeight()} passed to
                         {@code mapToInt} in the example above.  To preserve correct behavior,
                         these &lt;em&gt;behavioral parameters&lt;/em&gt;:
                         &lt;ul&gt;
                         &lt;li&gt;must be &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;
                         (they do not modify the stream source); and&lt;/li&gt;
                         &lt;li&gt;in most cases must be &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt;
                         (their result should not depend on any state that might change during execution
                         of the stream pipeline).&lt;/li&gt;
                         &lt;/ul&gt;
                        
                         &lt;p&gt;Such parameters are always instances of a
                         &lt;a href="../function/package-summary.html"&gt;functional interface&lt;/a&gt; such
                         as {@link java.util.function.Function}, and are often lambda expressions or
                         method references.  Unless otherwise specified these parameters must be
                         &lt;em&gt;non-null&lt;/em&gt;.
                        
                         &lt;p&gt;A stream should be operated on (invoking an intermediate or terminal stream
                         operation) only once.  This rules out, for example, "forked" streams, where
                         the same source feeds two or more pipelines, or multiple traversals of the
                         same stream.  A stream implementation may throw {@link IllegalStateException}
                         if it detects that the stream is being reused. However, since some stream
                         operations may return their receiver rather than a new stream object, it may
                         not be possible to detect reuse in all cases.
                        
                         &lt;p&gt;Streams have a {@link #close()} method and implement {@link AutoCloseable}.
                         Operating on a stream after it has been closed will throw {@link IllegalStateException}.
                         Most stream instances do not actually need to be closed after use, as they
                         are backed by collections, arrays, or generating functions, which require no
                         special resource management. Generally, only streams whose source is an IO channel,
                         such as those returned by {@link Files#lines(Path)}, will require closing. If a
                         stream does require closing, it must be opened as a resource within a try-with-resources
                         statement or similar control structure to ensure that it is closed promptly after its
                         operations have completed.
                        
                         &lt;p&gt;Stream pipelines may execute either sequentially or in
                         &lt;a href="package-summary.html#Parallelism"&gt;parallel&lt;/a&gt;.  This
                         execution mode is a property of the stream.  Streams are created
                         with an initial choice of sequential or parallel execution.  (For example,
                         {@link Collection#stream() Collection.stream()} creates a sequential stream,
                         and {@link Collection#parallelStream() Collection.parallelStream()} creates
                         a parallel one.)  This choice of execution mode may be modified by the
                         {@link #sequential()} or {@link #parallel()} methods, and may be queried with
                         the {@link #isParallel()} method.
                        
                         @param &lt;T&gt; the type of the stream elements
                         @since 1.8
                         @see IntStream
                         @see LongStream
                         @see DoubleStream
                         @see &lt;a href="package-summary.html"&gt;java.util.stream&lt;/a&gt;
                        </javadoc>
                </acts>
                <acts name="OfDouble" access="PUBLIC" declaringClass="Node.Builder" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Node$Builder"/>
                        <superType superType="java.util.stream.Sink$OfDouble"/>
                    </superTypes>
                </acts>
                <acts name="OfDouble" access="PUBLIC" declaringClass="Node" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Node$OfPrimitive"/>
                    </superTypes>
                </acts>
                <acts name="OfLong" access="PUBLIC" declaringClass="Node" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Node$OfPrimitive"/>
                    </superTypes>
                </acts>
                <acts name="OfLong" access="PUBLIC" declaringClass="Sink" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Sink"/>
                        <superType superType="java.util.function.LongConsumer"/>
                    </superTypes>
                </acts>
                <acts name="Collectors" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Implementations of {@link Collector} that implement various useful reduction
                         operations, such as accumulating elements into collections, summarizing
                         elements according to various criteria, etc.
                        
                         &lt;p&gt;The following are examples of using the predefined collectors to perform
                         common mutable reduction tasks:
                        
                         &lt;pre&gt;{@code
                         // Accumulate names into a List
                         List&lt;String&gt; list = people.stream()
                           .map(Person::getName)
                           .collect(Collectors.toList());
                        
                         // Accumulate names into a TreeSet
                         Set&lt;String&gt; set = people.stream()
                           .map(Person::getName)
                           .collect(Collectors.toCollection(TreeSet::new));
                        
                         // Convert elements to strings and concatenate them, separated by commas
                         String joined = things.stream()
                           .map(Object::toString)
                           .collect(Collectors.joining(", "));
                        
                         // Compute sum of salaries of employee
                         int total = employees.stream()
                           .collect(Collectors.summingInt(Employee::getSalary));
                        
                         // Group employees by department
                         Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()
                           .collect(Collectors.groupingBy(Employee::getDepartment));
                        
                         // Compute sum of salaries by department
                         Map&lt;Department, Integer&gt; totalByDept = employees.stream()
                           .collect(Collectors.groupingBy(Employee::getDepartment,
                                                          Collectors.summingInt(Employee::getSalary)));
                        
                         // Partition students into passing and failing
                         Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()
                           .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));
                        
                         }&lt;/pre&gt;
                        
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="OfPrimitive" access="PUBLIC" declaringClass="Node" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Node"/>
                    </superTypes>
                </acts>
                <acts name="OfLong" access="PUBLIC" declaringClass="Node.Builder" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Node$Builder"/>
                        <superType superType="java.util.stream.Sink$OfLong"/>
                    </superTypes>
                </acts>
                <acts name="OfInt" access="PUBLIC" declaringClass="Node.Builder" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Node$Builder"/>
                        <superType superType="java.util.stream.Sink$OfInt"/>
                    </superTypes>
                </acts>
                <acts name="ChainedInt" access="PUBLIC" declaringClass="Sink" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Sink$OfInt"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                </acts>
                <acts name="LongStream" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.BaseStream"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A sequence of primitive long-valued elements supporting sequential and parallel
                         aggregate operations.  This is the {@code long} primitive specialization of
                         {@link Stream}.
                        
                         &lt;p&gt;The following example illustrates an aggregate operation using
                         {@link Stream} and {@link LongStream}, computing the sum of the weights of the
                         red widgets:
                        
                         &lt;pre&gt;{@code
                             long sum = widgets.stream()
                                               .filter(w -&gt; w.getColor() == RED)
                                               .mapToLong(w -&gt; w.getWeight())
                                               .sum();
                         }&lt;/pre&gt;
                        
                         See the class documentation for {@link Stream} and the package documentation
                         for &lt;a href="package-summary.html"&gt;java.util.stream&lt;/a&gt; for additional
                         specification of streams, stream operations, stream pipelines, and
                         parallelism.
                        
                         @since 1.8
                         @see Stream
                         @see &lt;a href="package-summary.html"&gt;java.util.stream&lt;/a&gt;
                        </javadoc>
                </acts>
                <acts name="Builder" access="PUBLIC" declaringClass="LongStream" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.function.LongConsumer"/>
                    </superTypes>
                </acts>
                <acts name="OfInt" access="PUBLIC" declaringClass="Node" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Node$OfPrimitive"/>
                    </superTypes>
                </acts>
                <acts name="DoubleStream" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.BaseStream"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A sequence of primitive double-valued elements supporting sequential and parallel
                         aggregate operations.  This is the {@code double} primitive specialization of
                         {@link Stream}.
                        
                         &lt;p&gt;The following example illustrates an aggregate operation using
                         {@link Stream} and {@link DoubleStream}, computing the sum of the weights of the
                         red widgets:
                        
                         &lt;pre&gt;{@code
                             double sum = widgets.stream()
                                                 .filter(w -&gt; w.getColor() == RED)
                                                 .mapToDouble(w -&gt; w.getWeight())
                                                 .sum();
                         }&lt;/pre&gt;
                        
                         See the class documentation for {@link Stream} and the package documentation
                         for &lt;a href="package-summary.html"&gt;java.util.stream&lt;/a&gt; for additional
                         specification of streams, stream operations, stream pipelines, and
                         parallelism.
                        
                         @since 1.8
                         @see Stream
                         @see &lt;a href="package-summary.html"&gt;java.util.stream&lt;/a&gt;
                        </javadoc>
                </acts>
                <acts name="OfDouble" access="PUBLIC" declaringClass="Sink" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.Sink"/>
                        <superType superType="java.util.function.DoubleConsumer"/>
                    </superTypes>
                </acts>
                <acts name="IntStream" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.stream">
                    <superTypes>
                        <superType superType="java.util.stream.BaseStream"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A sequence of primitive int-valued elements supporting sequential and parallel
                         aggregate operations.  This is the {@code int} primitive specialization of
                         {@link Stream}.
                        
                         &lt;p&gt;The following example illustrates an aggregate operation using
                         {@link Stream} and {@link IntStream}, computing the sum of the weights of the
                         red widgets:
                        
                         &lt;pre&gt;{@code
                             int sum = widgets.stream()
                                              .filter(w -&gt; w.getColor() == RED)
                                              .mapToInt(w -&gt; w.getWeight())
                                              .sum();
                         }&lt;/pre&gt;
                        
                         See the class documentation for {@link Stream} and the package documentation
                         for &lt;a href="package-summary.html"&gt;java.util.stream&lt;/a&gt; for additional
                         specification of streams, stream operations, stream pipelines, and
                         parallelism.
                        
                         @since 1.8
                         @see Stream
                         @see &lt;a href="package-summary.html"&gt;java.util.stream&lt;/a&gt;
                        </javadoc>
                </acts>
            </package>
            <package name="function">
                <acts name="IntSupplier" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a supplier of {@code int}-valued results.  This is the
                         {@code int}-producing primitive specialization of {@link Supplier}.
                        
                         &lt;p&gt;There is no requirement that a distinct result be returned each
                         time the supplier is invoked.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #getAsInt()}.
                        
                         @see Supplier
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="DoubleToLongFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that accepts a double-valued argument and produces a
                         long-valued result.  This is the {@code double}-to-{@code long} primitive
                         specialization for {@link Function}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsLong(double)}.
                        
                         @see Function
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="IntToDoubleFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that accepts an int-valued argument and produces a
                         double-valued result.  This is the {@code int}-to-{@code double} primitive
                         specialization for {@link Function}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsDouble(int)}.
                        
                         @see Function
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="IntUnaryOperator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents an operation on a single {@code int}-valued operand that produces
                         an {@code int}-valued result.  This is the primitive type specialization of
                         {@link UnaryOperator} for {@code int}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsInt(int)}.
                        
                         @see UnaryOperator
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="ObjDoubleConsumer" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents an operation that accepts an object-valued and a
                         {@code double}-valued argument, and returns no result.  This is the
                         {@code (reference, double)} specialization of {@link BiConsumer}.
                         Unlike most other functional interfaces, {@code ObjDoubleConsumer} is
                         expected to operate via side-effects.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #accept(Object, double)}.
                        
                         @param &lt;T&gt; the type of the object argument to the operation
                        
                         @see BiConsumer
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="Predicate" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a predicate (boolean-valued function) of one argument.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #test(Object)}.
                        
                         @param &lt;T&gt; the type of the input to the predicate
                        
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="Function" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that accepts one argument and produces a result.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #apply(Object)}.
                        
                         @param &lt;T&gt; the type of the input to the function
                         @param &lt;R&gt; the type of the result of the function
                        
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="ToLongFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that produces a long-valued result.  This is the
                         {@code long}-producing primitive specialization for {@link Function}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsLong(Object)}.
                        
                         @param &lt;T&gt; the type of the input to the function
                        
                         @see Function
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="Consumer" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents an operation that accepts a single input argument and returns no
                         result. Unlike most other functional interfaces, {@code Consumer} is expected
                         to operate via side-effects.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #accept(Object)}.
                        
                         @param &lt;T&gt; the type of the input to the operation
                        
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="ToIntBiFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that accepts two arguments and produces an int-valued
                         result.  This is the {@code int}-producing primitive specialization for
                         {@link BiFunction}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsInt(Object, Object)}.
                        
                         @param &lt;T&gt; the type of the first argument to the function
                         @param &lt;U&gt; the type of the second argument to the function
                        
                         @see BiFunction
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="LongToIntFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that accepts a long-valued argument and produces an
                         int-valued result.  This is the {@code long}-to-{@code int} primitive
                         specialization for {@link Function}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsInt(long)}.
                        
                         @see Function
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="ObjLongConsumer" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents an operation that accepts an object-valued and a
                         {@code long}-valued argument, and returns no result.  This is the
                         {@code (reference, long)} specialization of {@link BiConsumer}.
                         Unlike most other functional interfaces, {@code ObjLongConsumer} is
                         expected to operate via side-effects.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #accept(Object, long)}.
                        
                         @param &lt;T&gt; the type of the object argument to the operation
                        
                         @see BiConsumer
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="Supplier" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a supplier of results.
                        
                         &lt;p&gt;There is no requirement that a new or distinct result be returned each
                         time the supplier is invoked.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #get()}.
                        
                         @param &lt;T&gt; the type of results supplied by this supplier
                        
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="BinaryOperator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes>
                        <superType superType="java.util.function.BiFunction"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Represents an operation upon two operands of the same type, producing a result
                         of the same type as the operands.  This is a specialization of
                         {@link BiFunction} for the case where the operands and the result are all of
                         the same type.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #apply(Object, Object)}.
                        
                         @param &lt;T&gt; the type of the operands and result of the operator
                        
                         @see BiFunction
                         @see UnaryOperator
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="ObjIntConsumer" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents an operation that accepts an object-valued and a
                         {@code int}-valued argument, and returns no result.  This is the
                         {@code (reference, int)} specialization of {@link BiConsumer}.
                         Unlike most other functional interfaces, {@code ObjIntConsumer} is
                         expected to operate via side-effects.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #accept(Object, int)}.
                        
                         @param &lt;T&gt; the type of the object argument to the operation
                        
                         @see BiConsumer
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="UnaryOperator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes>
                        <superType superType="java.util.function.Function"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Represents an operation on a single operand that produces a result of the
                         same type as its operand.  This is a specialization of {@code Function} for
                         the case where the operand and result are of the same type.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #apply(Object)}.
                        
                         @param &lt;T&gt; the type of the operand and result of the operator
                        
                         @see Function
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="BooleanSupplier" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a supplier of {@code boolean}-valued results.  This is the
                         {@code boolean}-producing primitive specialization of {@link Supplier}.
                        
                         &lt;p&gt;There is no requirement that a new or distinct result be returned each
                         time the supplier is invoked.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #getAsBoolean()}.
                        
                         @see Supplier
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="DoubleUnaryOperator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents an operation on a single {@code double}-valued operand that produces
                         a {@code double}-valued result.  This is the primitive type specialization of
                         {@link UnaryOperator} for {@code double}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsDouble(double)}.
                        
                         @see UnaryOperator
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="ToDoubleFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that produces a double-valued result.  This is the
                         {@code double}-producing primitive specialization for {@link Function}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsDouble(Object)}.
                        
                         @param &lt;T&gt; the type of the input to the function
                        
                         @see Function
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="LongBinaryOperator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents an operation upon two {@code long}-valued operands and producing a
                         {@code long}-valued result.   This is the primitive type specialization of
                         {@link BinaryOperator} for {@code long}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsLong(long, long)}.
                        
                         @see BinaryOperator
                         @see LongUnaryOperator
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="DoublePredicate" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a predicate (boolean-valued function) of one {@code double}-valued
                         argument. This is the {@code double}-consuming primitive type specialization
                         of {@link Predicate}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #test(double)}.
                        
                         @see Predicate
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="IntPredicate" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a predicate (boolean-valued function) of one {@code int}-valued
                         argument. This is the {@code int}-consuming primitive type specialization of
                         {@link Predicate}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #test(int)}.
                        
                         @see Predicate
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="ToDoubleBiFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that accepts two arguments and produces a double-valued
                         result.  This is the {@code double}-producing primitive specialization for
                         {@link BiFunction}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsDouble(Object, Object)}.
                        
                         @param &lt;T&gt; the type of the first argument to the function
                         @param &lt;U&gt; the type of the second argument to the function
                        
                         @see BiFunction
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="LongPredicate" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a predicate (boolean-valued function) of one {@code long}-valued
                         argument. This is the {@code long}-consuming primitive type specialization of
                         {@link Predicate}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #test(long)}.
                        
                         @see Predicate
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="IntConsumer" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents an operation that accepts a single {@code int}-valued argument and
                         returns no result.  This is the primitive type specialization of
                         {@link Consumer} for {@code int}.  Unlike most other functional interfaces,
                         {@code IntConsumer} is expected to operate via side-effects.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #accept(int)}.
                        
                         @see Consumer
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="LongToDoubleFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that accepts a long-valued argument and produces a
                         double-valued result.  This is the {@code long}-to-{@code double} primitive
                         specialization for {@link Function}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsDouble(long)}.
                        
                         @see Function
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="DoubleFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that accepts a double-valued argument and produces a
                         result.  This is the {@code double}-consuming primitive specialization for
                         {@link Function}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #apply(double)}.
                        
                         @param &lt;R&gt; the type of the result of the function
                        
                         @see Function
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="LongConsumer" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents an operation that accepts a single {@code long}-valued argument and
                         returns no result.  This is the primitive type specialization of
                         {@link Consumer} for {@code long}.  Unlike most other functional interfaces,
                         {@code LongConsumer} is expected to operate via side-effects.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #accept(long)}.
                        
                         @see Consumer
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="DoubleBinaryOperator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents an operation upon two {@code double}-valued operands and producing a
                         {@code double}-valued result.   This is the primitive type specialization of
                         {@link BinaryOperator} for {@code double}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsDouble(double, double)}.
                        
                         @see BinaryOperator
                         @see DoubleUnaryOperator
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="DoubleConsumer" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents an operation that accepts a single {@code double}-valued argument and
                         returns no result.  This is the primitive type specialization of
                         {@link Consumer} for {@code double}.  Unlike most other functional interfaces,
                         {@code DoubleConsumer} is expected to operate via side-effects.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #accept(double)}.
                        
                         @see Consumer
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="LongFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that accepts a long-valued argument and produces a
                         result.  This is the {@code long}-consuming primitive specialization for
                         {@link Function}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #apply(long)}.
                        
                         @param &lt;R&gt; the type of the result of the function
                        
                         @see Function
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="BiFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that accepts two arguments and produces a result.
                         This is the two-arity specialization of {@link Function}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #apply(Object, Object)}.
                        
                         @param &lt;T&gt; the type of the first argument to the function
                         @param &lt;U&gt; the type of the second argument to the function
                         @param &lt;R&gt; the type of the result of the function
                        
                         @see Function
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="DoubleSupplier" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a supplier of {@code double}-valued results.  This is the
                         {@code double}-producing primitive specialization of {@link Supplier}.
                        
                         &lt;p&gt;There is no requirement that a distinct result be returned each
                         time the supplier is invoked.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #getAsDouble()}.
                        
                         @see Supplier
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="IntFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that accepts an int-valued argument and produces a
                         result.  This is the {@code int}-consuming primitive specialization for
                         {@link Function}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #apply(int)}.
                        
                         @param &lt;R&gt; the type of the result of the function
                        
                         @see Function
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="IntBinaryOperator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents an operation upon two {@code int}-valued operands and producing an
                         {@code int}-valued result.   This is the primitive type specialization of
                         {@link BinaryOperator} for {@code int}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsInt(int, int)}.
                        
                         @see BinaryOperator
                         @see IntUnaryOperator
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="LongUnaryOperator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents an operation on a single {@code long}-valued operand that produces
                         a {@code long}-valued result.  This is the primitive type specialization of
                         {@link UnaryOperator} for {@code long}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsLong(long)}.
                        
                         @see UnaryOperator
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="IntToLongFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that accepts an int-valued argument and produces a
                         long-valued result.  This is the {@code int}-to-{@code long} primitive
                         specialization for {@link Function}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsLong(int)}.
                        
                         @see Function
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="ToIntFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that produces an int-valued result.  This is the
                         {@code int}-producing primitive specialization for {@link Function}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsInt(Object)}.
                        
                         @param &lt;T&gt; the type of the input to the function
                        
                         @see Function
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="LongSupplier" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a supplier of {@code long}-valued results.  This is the
                         {@code long}-producing primitive specialization of {@link Supplier}.
                        
                         &lt;p&gt;There is no requirement that a distinct result be returned each
                         time the supplier is invoked.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #getAsLong()}.
                        
                         @see Supplier
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="ToLongBiFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that accepts two arguments and produces a long-valued
                         result.  This is the {@code long}-producing primitive specialization for
                         {@link BiFunction}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsLong(Object, Object)}.
                        
                         @param &lt;T&gt; the type of the first argument to the function
                         @param &lt;U&gt; the type of the second argument to the function
                        
                         @see BiFunction
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="BiConsumer" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents an operation that accepts two input arguments and returns no
                         result.  This is the two-arity specialization of {@link Consumer}.
                         Unlike most other functional interfaces, {@code BiConsumer} is expected
                         to operate via side-effects.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #accept(Object, Object)}.
                        
                         @param &lt;T&gt; the type of the first argument to the operation
                         @param &lt;U&gt; the type of the second argument to the operation
                        
                         @see Consumer
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="BiPredicate" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a predicate (boolean-valued function) of two arguments.  This is
                         the two-arity specialization of {@link Predicate}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #test(Object, Object)}.
                        
                         @param &lt;T&gt; the type of the first argument to the predicate
                         @param &lt;U&gt; the type of the second argument the predicate
                        
                         @see Predicate
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="DoubleToIntFunction" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.function">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         Represents a function that accepts a double-valued argument and produces an
                         int-valued result.  This is the {@code double}-to-{@code int} primitive
                         specialization for {@link Function}.
                        
                         &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;
                         whose functional method is {@link #applyAsInt(double)}.
                        
                         @see Function
                         @since 1.8
                        </javadoc>
                </acts>
            </package>
            <package name="concurrent">
                <acts name="ThreadFactory" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         An object that creates new threads on demand.  Using thread factories
                         removes hardwiring of calls to {@link Thread#Thread(Runnable) new Thread},
                         enabling applications to use special thread subclasses, priorities, etc.
                        
                         &lt;p&gt;
                         The simplest implementation of this interface is just:
                         &lt;pre&gt; {@code
                         class SimpleThreadFactory implements ThreadFactory {
                           public Thread newThread(Runnable r) {
                             return new Thread(r);
                           }
                         }}&lt;/pre&gt;
                        
                         The {@link Executors#defaultThreadFactory} method provides a more
                         useful simple implementation, that sets the created thread context
                         to known values before returning it.
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="BrokenBarrierException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Exception thrown when a thread tries to wait upon a barrier that is
                         in a broken state, or which enters the broken state while the thread
                         is waiting.
                        
                         @see CyclicBarrier
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="Exchanger" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A synchronization point at which threads can pair and swap elements
                         within pairs.  Each thread presents some object on entry to the
                         {@link #exchange exchange} method, matches with a partner thread,
                         and receives its partner's object on return.  An Exchanger may be
                         viewed as a bidirectional form of a {@link SynchronousQueue}.
                         Exchangers may be useful in applications such as genetic algorithms
                         and pipeline designs.
                        
                         &lt;p&gt;&lt;b&gt;Sample Usage:&lt;/b&gt;
                         Here are the highlights of a class that uses an {@code Exchanger}
                         to swap buffers between threads so that the thread filling the
                         buffer gets a freshly emptied one when it needs it, handing off the
                         filled one to the thread emptying the buffer.
                         &lt;pre&gt; {@code
                         class FillAndEmpty {
                           Exchanger&lt;DataBuffer&gt; exchanger = new Exchanger&lt;&gt;();
                           DataBuffer initialEmptyBuffer = ... a made-up type
                           DataBuffer initialFullBuffer = ...
                        
                           class FillingLoop implements Runnable {
                             public void run() {
                               DataBuffer currentBuffer = initialEmptyBuffer;
                               try {
                                 while (currentBuffer != null) {
                                   addToBuffer(currentBuffer);
                                   if (currentBuffer.isFull())
                                     currentBuffer = exchanger.exchange(currentBuffer);
                                 }
                               } catch (InterruptedException ex) { ... handle ... }
                             }
                           }
                        
                           class EmptyingLoop implements Runnable {
                             public void run() {
                               DataBuffer currentBuffer = initialFullBuffer;
                               try {
                                 while (currentBuffer != null) {
                                   takeFromBuffer(currentBuffer);
                                   if (currentBuffer.isEmpty())
                                     currentBuffer = exchanger.exchange(currentBuffer);
                                 }
                               } catch (InterruptedException ex) { ... handle ...}
                             }
                           }
                        
                           void start() {
                             new Thread(new FillingLoop()).start();
                             new Thread(new EmptyingLoop()).start();
                           }
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;Memory consistency effects: For each pair of threads that
                         successfully exchange objects via an {@code Exchanger}, actions
                         prior to the {@code exchange()} in each thread
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         those subsequent to a return from the corresponding {@code exchange()}
                         in the other thread.
                        
                         @since 1.5
                         @author Doug Lea and Bill Scherer and Michael Scott
                         @param &lt;V&gt; The type of objects that may be exchanged
                        </javadoc>
                </acts>
                <acts name="RecursiveTask" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.ForkJoinTask"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A recursive result-bearing {@link ForkJoinTask}.
                        
                         &lt;p&gt;For a classic example, here is a task computing Fibonacci numbers:
                        
                         &lt;pre&gt; {@code
                         class Fibonacci extends RecursiveTask&lt;Integer&gt; {
                           final int n;
                           Fibonacci(int n) { this.n = n; }
                           protected Integer compute() {
                             if (n &lt;= 1)
                               return n;
                             Fibonacci f1 = new Fibonacci(n - 1);
                             f1.fork();
                             Fibonacci f2 = new Fibonacci(n - 2);
                             return f2.compute() + f1.join();
                           }
                         }}&lt;/pre&gt;
                        
                         However, besides being a dumb way to compute Fibonacci functions
                         (there is a simple fast linear algorithm that you'd use in
                         practice), this is likely to perform poorly because the smallest
                         subtasks are too small to be worthwhile splitting up. Instead, as
                         is the case for nearly all fork/join applications, you'd pick some
                         minimum granularity size (for example 10 here) for which you always
                         sequentially solve rather than subdividing.
                        
                         @since 1.7
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="ScheduledThreadPoolExecutor" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.ScheduledExecutorService"/>
                        <superType superType="java.util.concurrent.ThreadPoolExecutor"/>
                        <superType superType="java.util.concurrent.AbstractExecutorService"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@link ThreadPoolExecutor} that can additionally schedule
                         commands to run after a given delay, or to execute periodically.
                         This class is preferable to {@link java.util.Timer} when multiple
                         worker threads are needed, or when the additional flexibility or
                         capabilities of {@link ThreadPoolExecutor} (which this class
                         extends) are required.
                        
                         &lt;p&gt;Delayed tasks execute no sooner than they are enabled, but
                         without any real-time guarantees about when, after they are
                         enabled, they will commence. Tasks scheduled for exactly the same
                         execution time are enabled in first-in-first-out (FIFO) order of
                         submission.
                        
                         &lt;p&gt;When a submitted task is cancelled before it is run, execution
                         is suppressed.  By default, such a cancelled task is not
                         automatically removed from the work queue until its delay elapses.
                         While this enables further inspection and monitoring, it may also
                         cause unbounded retention of cancelled tasks.  To avoid this, use
                         {@link #setRemoveOnCancelPolicy} to cause tasks to be immediately
                         removed from the work queue at time of cancellation.
                        
                         &lt;p&gt;Successive executions of a periodic task scheduled via
                         {@link #scheduleAtFixedRate scheduleAtFixedRate} or
                         {@link #scheduleWithFixedDelay scheduleWithFixedDelay}
                         do not overlap. While different executions may be performed by
                         different threads, the effects of prior executions
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         those of subsequent ones.
                        
                         &lt;p&gt;While this class inherits from {@link ThreadPoolExecutor}, a few
                         of the inherited tuning methods are not useful for it. In
                         particular, because it acts as a fixed-sized pool using
                         {@code corePoolSize} threads and an unbounded queue, adjustments
                         to {@code maximumPoolSize} have no useful effect. Additionally, it
                         is almost never a good idea to set {@code corePoolSize} to zero or
                         use {@code allowCoreThreadTimeOut} because this may leave the pool
                         without threads to handle tasks once they become eligible to run.
                        
                         &lt;p&gt;As with {@code ThreadPoolExecutor}, if not otherwise specified,
                         this class uses {@link Executors#defaultThreadFactory} as the
                         default thread factory, and {@link ThreadPoolExecutor.AbortPolicy}
                         as the default rejected execution handler.
                        
                         &lt;p&gt;&lt;b&gt;Extension notes:&lt;/b&gt; This class overrides the
                         {@link ThreadPoolExecutor#execute(Runnable) execute} and
                         {@link AbstractExecutorService#submit(Runnable) submit}
                         methods to generate internal {@link ScheduledFuture} objects to
                         control per-task delays and scheduling.  To preserve
                         functionality, any further overrides of these methods in
                         subclasses must invoke superclass versions, which effectively
                         disables additional task customization.  However, this class
                         provides alternative protected extension method
                         {@code decorateTask} (one version each for {@code Runnable} and
                         {@code Callable}) that can be used to customize the concrete task
                         types used to execute commands entered via {@code execute},
                         {@code submit}, {@code schedule}, {@code scheduleAtFixedRate},
                         and {@code scheduleWithFixedDelay}.  By default, a
                         {@code ScheduledThreadPoolExecutor} uses a task type extending
                         {@link FutureTask}. However, this may be modified or replaced using
                         subclasses of the form:
                        
                         &lt;pre&gt; {@code
                         public class CustomScheduledExecutor extends ScheduledThreadPoolExecutor {
                        
                           static class CustomTask&lt;V&gt; implements RunnableScheduledFuture&lt;V&gt; { ... }
                        
                           protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(
                                        Runnable r, RunnableScheduledFuture&lt;V&gt; task) {
                               return new CustomTask&lt;V&gt;(r, task);
                           }
                        
                           protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(
                                        Callable&lt;V&gt; c, RunnableScheduledFuture&lt;V&gt; task) {
                               return new CustomTask&lt;V&gt;(c, task);
                           }
                           // ... add constructors, etc.
                         }}&lt;/pre&gt;
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="ForkJoinTask" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.Future"/>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Abstract base class for tasks that run within a {@link ForkJoinPool}.
                         A {@code ForkJoinTask} is a thread-like entity that is much
                         lighter weight than a normal thread.  Huge numbers of tasks and
                         subtasks may be hosted by a small number of actual threads in a
                         ForkJoinPool, at the price of some usage limitations.
                        
                         &lt;p&gt;A "main" {@code ForkJoinTask} begins execution when it is
                         explicitly submitted to a {@link ForkJoinPool}, or, if not already
                         engaged in a ForkJoin computation, commenced in the {@link
                         ForkJoinPool#commonPool()} via {@link #fork}, {@link #invoke}, or
                         related methods.  Once started, it will usually in turn start other
                         subtasks.  As indicated by the name of this class, many programs
                         using {@code ForkJoinTask} employ only methods {@link #fork} and
                         {@link #join}, or derivatives such as {@link
                         #invokeAll(ForkJoinTask...) invokeAll}.  However, this class also
                         provides a number of other methods that can come into play in
                         advanced usages, as well as extension mechanics that allow support
                         of new forms of fork/join processing.
                        
                         &lt;p&gt;A {@code ForkJoinTask} is a lightweight form of {@link Future}.
                         The efficiency of {@code ForkJoinTask}s stems from a set of
                         restrictions (that are only partially statically enforceable)
                         reflecting their main use as computational tasks calculating pure
                         functions or operating on purely isolated objects.  The primary
                         coordination mechanisms are {@link #fork}, that arranges
                         asynchronous execution, and {@link #join}, that doesn't proceed
                         until the task's result has been computed.  Computations should
                         ideally avoid {@code synchronized} methods or blocks, and should
                         minimize other blocking synchronization apart from joining other
                         tasks or using synchronizers such as Phasers that are advertised to
                         cooperate with fork/join scheduling. Subdividable tasks should also
                         not perform blocking I/O, and should ideally access variables that
                         are completely independent of those accessed by other running
                         tasks. These guidelines are loosely enforced by not permitting
                         checked exceptions such as {@code IOExceptions} to be
                         thrown. However, computations may still encounter unchecked
                         exceptions, that are rethrown to callers attempting to join
                         them. These exceptions may additionally include {@link
                         RejectedExecutionException} stemming from internal resource
                         exhaustion, such as failure to allocate internal task
                         queues. Rethrown exceptions behave in the same way as regular
                         exceptions, but, when possible, contain stack traces (as displayed
                         for example using {@code ex.printStackTrace()}) of both the thread
                         that initiated the computation as well as the thread actually
                         encountering the exception; minimally only the latter.
                        
                         &lt;p&gt;It is possible to define and use ForkJoinTasks that may block,
                         but doing so requires three further considerations: (1) Completion
                         of few if any &lt;em&gt;other&lt;/em&gt; tasks should be dependent on a task
                         that blocks on external synchronization or I/O. Event-style async
                         tasks that are never joined (for example, those subclassing {@link
                         CountedCompleter}) often fall into this category.  (2) To minimize
                         resource impact, tasks should be small; ideally performing only the
                         (possibly) blocking action. (3) Unless the {@link
                         ForkJoinPool.ManagedBlocker} API is used, or the number of possibly
                         blocked tasks is known to be less than the pool's {@link
                         ForkJoinPool#getParallelism} level, the pool cannot guarantee that
                         enough threads will be available to ensure progress or good
                         performance.
                        
                         &lt;p&gt;The primary method for awaiting completion and extracting
                         results of a task is {@link #join}, but there are several variants:
                         The {@link Future#get} methods support interruptible and/or timed
                         waits for completion and report results using {@code Future}
                         conventions. Method {@link #invoke} is semantically
                         equivalent to {@code fork(); join()} but always attempts to begin
                         execution in the current thread. The "&lt;em&gt;quiet&lt;/em&gt;" forms of
                         these methods do not extract results or report exceptions. These
                         may be useful when a set of tasks are being executed, and you need
                         to delay processing of results or exceptions until all complete.
                         Method {@code invokeAll} (available in multiple versions)
                         performs the most common form of parallel invocation: forking a set
                         of tasks and joining them all.
                        
                         &lt;p&gt;In the most typical usages, a fork-join pair act like a call
                         (fork) and return (join) from a parallel recursive function. As is
                         the case with other forms of recursive calls, returns (joins)
                         should be performed innermost-first. For example, {@code a.fork();
                         b.fork(); b.join(); a.join();} is likely to be substantially more
                         efficient than joining {@code a} before {@code b}.
                        
                         &lt;p&gt;The execution status of tasks may be queried at several levels
                         of detail: {@link #isDone} is true if a task completed in any way
                         (including the case where a task was cancelled without executing);
                         {@link #isCompletedNormally} is true if a task completed without
                         cancellation or encountering an exception; {@link #isCancelled} is
                         true if the task was cancelled (in which case {@link #getException}
                         returns a {@link CancellationException}); and
                         {@link #isCompletedAbnormally} is true if a task was either
                         cancelled or encountered an exception, in which case {@link
                         #getException} will return either the encountered exception or
                         {@link CancellationException}.
                        
                         &lt;p&gt;The ForkJoinTask class is not usually directly subclassed.
                         Instead, you subclass one of the abstract classes that support a
                         particular style of fork/join processing, typically {@link
                         RecursiveAction} for most computations that do not return results,
                         {@link RecursiveTask} for those that do, and {@link
                         CountedCompleter} for those in which completed actions trigger
                         other actions.  Normally, a concrete ForkJoinTask subclass declares
                         fields comprising its parameters, established in a constructor, and
                         then defines a {@code compute} method that somehow uses the control
                         methods supplied by this base class.
                        
                         &lt;p&gt;Method {@link #join} and its variants are appropriate for use
                         only when completion dependencies are acyclic; that is, the
                         parallel computation can be described as a directed acyclic graph
                         (DAG). Otherwise, executions may encounter a form of deadlock as
                         tasks cyclically wait for each other.  However, this framework
                         supports other methods and techniques (for example the use of
                         {@link Phaser}, {@link #helpQuiesce}, and {@link #complete}) that
                         may be of use in constructing custom subclasses for problems that
                         are not statically structured as DAGs. To support such usages, a
                         ForkJoinTask may be atomically &lt;em&gt;tagged&lt;/em&gt; with a {@code short}
                         value using {@link #setForkJoinTaskTag} or {@link
                         #compareAndSetForkJoinTaskTag} and checked using {@link
                         #getForkJoinTaskTag}. The ForkJoinTask implementation does not use
                         these {@code protected} methods or tags for any purpose, but they
                         may be of use in the construction of specialized subclasses.  For
                         example, parallel graph traversals can use the supplied methods to
                         avoid revisiting nodes/tasks that have already been processed.
                         (Method names for tagging are bulky in part to encourage definition
                         of methods that reflect their usage patterns.)
                        
                         &lt;p&gt;Most base support methods are {@code final}, to prevent
                         overriding of implementations that are intrinsically tied to the
                         underlying lightweight task scheduling framework.  Developers
                         creating new basic styles of fork/join processing should minimally
                         implement {@code protected} methods {@link #exec}, {@link
                         #setRawResult}, and {@link #getRawResult}, while also introducing
                         an abstract computational method that can be implemented in its
                         subclasses, possibly relying on other {@code protected} methods
                         provided by this class.
                        
                         &lt;p&gt;ForkJoinTasks should perform relatively small amounts of
                         computation. Large tasks should be split into smaller subtasks,
                         usually via recursive decomposition. As a very rough rule of thumb,
                         a task should perform more than 100 and less than 10000 basic
                         computational steps, and should avoid indefinite looping. If tasks
                         are too big, then parallelism cannot improve throughput. If too
                         small, then memory and internal task maintenance overhead may
                         overwhelm processing.
                        
                         &lt;p&gt;This class provides {@code adapt} methods for {@link Runnable}
                         and {@link Callable}, that may be of use when mixing execution of
                         {@code ForkJoinTasks} with other kinds of tasks. When all tasks are
                         of this form, consider using a pool constructed in &lt;em&gt;asyncMode&lt;/em&gt;.
                        
                         &lt;p&gt;ForkJoinTasks are {@code Serializable}, which enables them to be
                         used in extensions such as remote execution frameworks. It is
                         sensible to serialize tasks only before or after, but not during,
                         execution. Serialization is not relied on during execution itself.
                        
                         @since 1.7
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="TransferQueue" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.BlockingQueue"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@link BlockingQueue} in which producers may wait for consumers
                         to receive elements.  A {@code TransferQueue} may be useful for
                         example in message passing applications in which producers
                         sometimes (using method {@link #transfer}) await receipt of
                         elements by consumers invoking {@code take} or {@code poll}, while
                         at other times enqueue elements (via method {@code put}) without
                         waiting for receipt.
                         {@linkplain #tryTransfer(Object) Non-blocking} and
                         {@linkplain #tryTransfer(Object,long,TimeUnit) time-out} versions of
                         {@code tryTransfer} are also available.
                         A {@code TransferQueue} may also be queried, via {@link
                         #hasWaitingConsumer}, whether there are any threads waiting for
                         items, which is a converse analogy to a {@code peek} operation.
                        
                         &lt;p&gt;Like other blocking queues, a {@code TransferQueue} may be
                         capacity bounded.  If so, an attempted transfer operation may
                         initially block waiting for available space, and/or subsequently
                         block waiting for reception by a consumer.  Note that in a queue
                         with zero capacity, such as {@link SynchronousQueue}, {@code put}
                         and {@code transfer} are effectively synonymous.
                        
                         &lt;p&gt;This interface is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.7
                         @author Doug Lea
                         @param &lt;E&gt; the type of elements held in this queue
                        </javadoc>
                </acts>
                <acts name="CallerRunsPolicy" access="PUBLIC" declaringClass="ThreadPoolExecutor" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.RejectedExecutionHandler"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                </acts>
                <acts name="Executors" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Factory and utility methods for {@link Executor}, {@link
                         ExecutorService}, {@link ScheduledExecutorService}, {@link
                         ThreadFactory}, and {@link Callable} classes defined in this
                         package. This class supports the following kinds of methods:
                        
                         &lt;ul&gt;
                           &lt;li&gt;Methods that create and return an {@link ExecutorService}
                               set up with commonly useful configuration settings.
                           &lt;li&gt;Methods that create and return a {@link ScheduledExecutorService}
                               set up with commonly useful configuration settings.
                           &lt;li&gt;Methods that create and return a "wrapped" ExecutorService, that
                               disables reconfiguration by making implementation-specific methods
                               inaccessible.
                           &lt;li&gt;Methods that create and return a {@link ThreadFactory}
                               that sets newly created threads to a known state.
                           &lt;li&gt;Methods that create and return a {@link Callable}
                               out of other closure-like forms, so they can be used
                               in execution methods requiring {@code Callable}.
                         &lt;/ul&gt;
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="LinkedBlockingQueue" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.BlockingQueue"/>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.util.AbstractQueue"/>
                        <superType superType="java.util.AbstractCollection"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An optionally-bounded {@linkplain BlockingQueue blocking queue} based on
                         linked nodes.
                         This queue orders elements FIFO (first-in-first-out).
                         The &lt;em&gt;head&lt;/em&gt; of the queue is that element that has been on the
                         queue the longest time.
                         The &lt;em&gt;tail&lt;/em&gt; of the queue is that element that has been on the
                         queue the shortest time. New elements
                         are inserted at the tail of the queue, and the queue retrieval
                         operations obtain elements at the head of the queue.
                         Linked queues typically have higher throughput than array-based queues but
                         less predictable performance in most concurrent applications.
                        
                         &lt;p&gt;The optional capacity bound constructor argument serves as a
                         way to prevent excessive queue expansion. The capacity, if unspecified,
                         is equal to {@link Integer#MAX_VALUE}.  Linked nodes are
                         dynamically created upon each insertion unless this would bring the
                         queue above capacity.
                        
                         &lt;p&gt;This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt;
                         methods of the {@link Collection} and {@link Iterator} interfaces.
                        
                         &lt;p&gt;This class is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.5
                         @author Doug Lea
                         @param &lt;E&gt; the type of elements held in this queue
                        </javadoc>
                </acts>
                <acts name="DelayQueue" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.BlockingQueue"/>
                        <superType superType="java.util.AbstractQueue"/>
                        <superType superType="java.util.AbstractCollection"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An unbounded {@linkplain BlockingQueue blocking queue} of
                         {@code Delayed} elements, in which an element can only be taken
                         when its delay has expired.  The &lt;em&gt;head&lt;/em&gt; of the queue is that
                         {@code Delayed} element whose delay expired furthest in the
                         past.  If no delay has expired there is no head and {@code poll}
                         will return {@code null}. Expiration occurs when an element's
                         {@code getDelay(TimeUnit.NANOSECONDS)} method returns a value less
                         than or equal to zero.  Even though unexpired elements cannot be
                         removed using {@code take} or {@code poll}, they are otherwise
                         treated as normal elements. For example, the {@code size} method
                         returns the count of both expired and unexpired elements.
                         This queue does not permit null elements.
                        
                         &lt;p&gt;This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt;
                         methods of the {@link Collection} and {@link Iterator} interfaces.
                         The Iterator provided in method {@link #iterator()} is &lt;em&gt;not&lt;/em&gt;
                         guaranteed to traverse the elements of the DelayQueue in any
                         particular order.
                        
                         &lt;p&gt;This class is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.5
                         @author Doug Lea
                         @param &lt;E&gt; the type of elements held in this queue
                        </javadoc>
                </acts>
                <acts name="RunnableScheduledFuture" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.RunnableFuture"/>
                        <superType superType="java.util.concurrent.ScheduledFuture"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@link ScheduledFuture} that is {@link Runnable}. Successful
                         execution of the {@code run} method causes completion of the
                         {@code Future} and allows access to its results.
                         @see FutureTask
                         @see Executor
                         @since 1.6
                         @author Doug Lea
                         @param &lt;V&gt; The result type returned by this Future's {@code get} method
                        </javadoc>
                </acts>
                <acts name="ArrayBlockingQueue" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.BlockingQueue"/>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.util.AbstractQueue"/>
                        <superType superType="java.util.AbstractCollection"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A bounded {@linkplain BlockingQueue blocking queue} backed by an
                         array.  This queue orders elements FIFO (first-in-first-out).  The
                         &lt;em&gt;head&lt;/em&gt; of the queue is that element that has been on the
                         queue the longest time.  The &lt;em&gt;tail&lt;/em&gt; of the queue is that
                         element that has been on the queue the shortest time. New elements
                         are inserted at the tail of the queue, and the queue retrieval
                         operations obtain elements at the head of the queue.
                        
                         &lt;p&gt;This is a classic &amp;quot;bounded buffer&amp;quot;, in which a
                         fixed-sized array holds elements inserted by producers and
                         extracted by consumers.  Once created, the capacity cannot be
                         changed.  Attempts to {@code put} an element into a full queue
                         will result in the operation blocking; attempts to {@code take} an
                         element from an empty queue will similarly block.
                        
                         &lt;p&gt;This class supports an optional fairness policy for ordering
                         waiting producer and consumer threads.  By default, this ordering
                         is not guaranteed. However, a queue constructed with fairness set
                         to {@code true} grants threads access in FIFO order. Fairness
                         generally decreases throughput but reduces variability and avoids
                         starvation.
                        
                         &lt;p&gt;This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt;
                         methods of the {@link Collection} and {@link Iterator} interfaces.
                        
                         &lt;p&gt;This class is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.5
                         @author Doug Lea
                         @param &lt;E&gt; the type of elements held in this queue
                        </javadoc>
                </acts>
                <acts name="Subscription" access="PUBLIC" declaringClass="Flow" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes/>
                </acts>
                <acts name="BlockingDeque" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.BlockingQueue"/>
                        <superType superType="java.util.Deque"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@link Deque} that additionally supports blocking operations that wait
                         for the deque to become non-empty when retrieving an element, and wait for
                         space to become available in the deque when storing an element.
                        
                         &lt;p&gt;{@code BlockingDeque} methods come in four forms, with different ways
                         of handling operations that cannot be satisfied immediately, but may be
                         satisfied at some point in the future:
                         one throws an exception, the second returns a special value (either
                         {@code null} or {@code false}, depending on the operation), the third
                         blocks the current thread indefinitely until the operation can succeed,
                         and the fourth blocks for only a given maximum time limit before giving
                         up.  These methods are summarized in the following table:
                        
                         &lt;table class="plain"&gt;
                         &lt;caption&gt;Summary of BlockingDeque methods&lt;/caption&gt;
                          &lt;tr&gt;
                            &lt;th id="First" colspan="5"&gt; First Element (Head)&lt;/th&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;td&gt;&lt;/td&gt;
                            &lt;th id="FThrow" style="font-weight:normal; font-style: italic"&gt;Throws exception&lt;/th&gt;
                            &lt;th id="FValue" style="font-weight:normal; font-style: italic"&gt;Special value&lt;/th&gt;
                            &lt;th id="FBlock" style="font-weight:normal; font-style: italic"&gt;Blocks&lt;/th&gt;
                            &lt;th id="FTimes" style="font-weight:normal; font-style: italic"&gt;Times out&lt;/th&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="FInsert" style="text-align:left"&gt;Insert&lt;/th&gt;
                            &lt;td headers="First FInsert FThrow"&gt;{@link #addFirst(Object) addFirst(e)}&lt;/td&gt;
                            &lt;td headers="First FInsert FValue"&gt;{@link #offerFirst(Object) offerFirst(e)}&lt;/td&gt;
                            &lt;td headers="First FInsert FBlock"&gt;{@link #putFirst(Object) putFirst(e)}&lt;/td&gt;
                            &lt;td headers="First FInsert FTimes"&gt;{@link #offerFirst(Object, long, TimeUnit) offerFirst(e, time, unit)}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="FRemove" style="text-align:left"&gt;Remove&lt;/th&gt;
                            &lt;td headers="First FRemove FThrow"&gt;{@link #removeFirst() removeFirst()}&lt;/td&gt;
                            &lt;td headers="First FRemove FValue"&gt;{@link #pollFirst() pollFirst()}&lt;/td&gt;
                            &lt;td headers="First FRemove FBlock"&gt;{@link #takeFirst() takeFirst()}&lt;/td&gt;
                            &lt;td headers="First FRemove FTimes"&gt;{@link #pollFirst(long, TimeUnit) pollFirst(time, unit)}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="FExamine" style="text-align:left"&gt;Examine&lt;/th&gt;
                            &lt;td headers="First FExamine FThrow"&gt;{@link #getFirst() getFirst()}&lt;/td&gt;
                            &lt;td headers="First FExamine FValue"&gt;{@link #peekFirst() peekFirst()}&lt;/td&gt;
                            &lt;td headers="First FExamine FBlock" style="font-style:italic"&gt;not applicable&lt;/td&gt;
                            &lt;td headers="First FExamine FTimes" style="font-style:italic"&gt;not applicable&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="Last" colspan="5"&gt; Last Element (Tail)&lt;/th&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;td&gt;&lt;/td&gt;
                            &lt;th id="LThrow" style="font-weight:normal; font-style: italic"&gt;Throws exception&lt;/th&gt;
                            &lt;th id="LValue" style="font-weight:normal; font-style: italic"&gt;Special value&lt;/th&gt;
                            &lt;th id="LBlock" style="font-weight:normal; font-style: italic"&gt;Blocks&lt;/th&gt;
                            &lt;th id="LTimes" style="font-weight:normal; font-style: italic"&gt;Times out&lt;/th&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="LInsert" style="text-align:left"&gt;Insert&lt;/th&gt;
                            &lt;td headers="Last LInsert LThrow"&gt;{@link #addLast(Object) addLast(e)}&lt;/td&gt;
                            &lt;td headers="Last LInsert LValue"&gt;{@link #offerLast(Object) offerLast(e)}&lt;/td&gt;
                            &lt;td headers="Last LInsert LBlock"&gt;{@link #putLast(Object) putLast(e)}&lt;/td&gt;
                            &lt;td headers="Last LInsert LTimes"&gt;{@link #offerLast(Object, long, TimeUnit) offerLast(e, time, unit)}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="LRemove" style="text-align:left"&gt;Remove&lt;/th&gt;
                            &lt;td headers="Last LRemove LThrow"&gt;{@link #removeLast() removeLast()}&lt;/td&gt;
                            &lt;td headers="Last LRemove LValue"&gt;{@link #pollLast() pollLast()}&lt;/td&gt;
                            &lt;td headers="Last LRemove LBlock"&gt;{@link #takeLast() takeLast()}&lt;/td&gt;
                            &lt;td headers="Last LRemove LTimes"&gt;{@link #pollLast(long, TimeUnit) pollLast(time, unit)}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="LExamine" style="text-align:left"&gt;Examine&lt;/th&gt;
                            &lt;td headers="Last LExamine LThrow"&gt;{@link #getLast() getLast()}&lt;/td&gt;
                            &lt;td headers="Last LExamine LValue"&gt;{@link #peekLast() peekLast()}&lt;/td&gt;
                            &lt;td headers="Last LExamine LBlock" style="font-style:italic"&gt;not applicable&lt;/td&gt;
                            &lt;td headers="Last LExamine LTimes" style="font-style:italic"&gt;not applicable&lt;/td&gt;
                          &lt;/tr&gt;
                         &lt;/table&gt;
                        
                         &lt;p&gt;Like any {@link BlockingQueue}, a {@code BlockingDeque} is thread safe,
                         does not permit null elements, and may (or may not) be
                         capacity-constrained.
                        
                         &lt;p&gt;A {@code BlockingDeque} implementation may be used directly as a FIFO
                         {@code BlockingQueue}. The methods inherited from the
                         {@code BlockingQueue} interface are precisely equivalent to
                         {@code BlockingDeque} methods as indicated in the following table:
                        
                         &lt;table class="plain"&gt;
                         &lt;caption&gt;Comparison of BlockingQueue and BlockingDeque methods&lt;/caption&gt;
                          &lt;tr&gt;
                            &lt;td&gt;&lt;/td&gt;
                            &lt;th id="BQueue"&gt; {@code BlockingQueue} Method&lt;/th&gt;
                            &lt;th id="BDeque"&gt; Equivalent {@code BlockingDeque} Method&lt;/th&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="Insert" rowspan="4" style="text-align:left; vertical-align:top"&gt;Insert&lt;/th&gt;
                            &lt;th id="add" style="font-weight:normal; text-align:left"&gt;{@link #add(Object) add(e)}&lt;/th&gt;
                            &lt;td headers="Insert BDeque add"&gt;{@link #addLast(Object) addLast(e)}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="offer1" style="font-weight:normal; text-align:left"&gt;{@link #offer(Object) offer(e)}&lt;/th&gt;
                            &lt;td headers="Insert BDeque offer1"&gt;{@link #offerLast(Object) offerLast(e)}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="put" style="font-weight:normal; text-align:left"&gt;{@link #put(Object) put(e)}&lt;/th&gt;
                            &lt;td headers="Insert BDeque put"&gt;{@link #putLast(Object) putLast(e)}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="offer2" style="font-weight:normal; text-align:left"&gt;{@link #offer(Object, long, TimeUnit) offer(e, time, unit)}&lt;/th&gt;
                            &lt;td headers="Insert BDeque offer2"&gt;{@link #offerLast(Object, long, TimeUnit) offerLast(e, time, unit)}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="Remove" rowspan="4" style="text-align:left; vertical-align:top"&gt;Remove&lt;/th&gt;
                            &lt;th id="remove" style="font-weight:normal; text-align:left"&gt;{@link #remove() remove()}&lt;/th&gt;
                            &lt;td headers="Remove BDeque remove"&gt;{@link #removeFirst() removeFirst()}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="poll1" style="font-weight:normal; text-align:left"&gt;{@link #poll() poll()}&lt;/th&gt;
                            &lt;td headers="Remove BDeque poll1"&gt;{@link #pollFirst() pollFirst()}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="take" style="font-weight:normal; text-align:left"&gt;{@link #take() take()}&lt;/th&gt;
                            &lt;td headers="Remove BDeque take"&gt;{@link #takeFirst() takeFirst()}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="poll2" style="font-weight:normal; text-align:left"&gt;{@link #poll(long, TimeUnit) poll(time, unit)}&lt;/th&gt;
                            &lt;td headers="Remove BDeque poll2"&gt;{@link #pollFirst(long, TimeUnit) pollFirst(time, unit)}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="Examine" rowspan="2" style="text-align:left; vertical-align:top"&gt;Examine&lt;/th&gt;
                            &lt;th id="element" style="font-weight:normal; text-align:left"&gt;{@link #element() element()}&lt;/th&gt;
                            &lt;td headers="Examine BDeque element"&gt;{@link #getFirst() getFirst()}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th id="peek" style="font-weight:normal; text-align:left"&gt;{@link #peek() peek()}&lt;/th&gt;
                            &lt;td headers="Examine BDeque peek"&gt;{@link #peekFirst() peekFirst()}&lt;/td&gt;
                          &lt;/tr&gt;
                         &lt;/table&gt;
                        
                         &lt;p&gt;Memory consistency effects: As with other concurrent
                         collections, actions in a thread prior to placing an object into a
                         {@code BlockingDeque}
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         actions subsequent to the access or removal of that element from
                         the {@code BlockingDeque} in another thread.
                        
                         &lt;p&gt;This interface is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.6
                         @author Doug Lea
                         @param &lt;E&gt; the type of elements held in this deque
                        </javadoc>
                </acts>
                <acts name="SynchronousQueue" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.BlockingQueue"/>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.util.AbstractQueue"/>
                        <superType superType="java.util.AbstractCollection"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@linkplain BlockingQueue blocking queue} in which each insert
                         operation must wait for a corresponding remove operation by another
                         thread, and vice versa.  A synchronous queue does not have any
                         internal capacity, not even a capacity of one.  You cannot
                         {@code peek} at a synchronous queue because an element is only
                         present when you try to remove it; you cannot insert an element
                         (using any method) unless another thread is trying to remove it;
                         you cannot iterate as there is nothing to iterate.  The
                         &lt;em&gt;head&lt;/em&gt; of the queue is the element that the first queued
                         inserting thread is trying to add to the queue; if there is no such
                         queued thread then no element is available for removal and
                         {@code poll()} will return {@code null}.  For purposes of other
                         {@code Collection} methods (for example {@code contains}), a
                         {@code SynchronousQueue} acts as an empty collection.  This queue
                         does not permit {@code null} elements.
                        
                         &lt;p&gt;Synchronous queues are similar to rendezvous channels used in
                         CSP and Ada. They are well suited for handoff designs, in which an
                         object running in one thread must sync up with an object running
                         in another thread in order to hand it some information, event, or
                         task.
                        
                         &lt;p&gt;This class supports an optional fairness policy for ordering
                         waiting producer and consumer threads.  By default, this ordering
                         is not guaranteed. However, a queue constructed with fairness set
                         to {@code true} grants threads access in FIFO order.
                        
                         &lt;p&gt;This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt;
                         methods of the {@link Collection} and {@link Iterator} interfaces.
                        
                         &lt;p&gt;This class is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.5
                         @author Doug Lea and Bill Scherer and Michael Scott
                         @param &lt;E&gt; the type of elements held in this queue
                        </javadoc>
                </acts>
                <acts name="TimeUnit" access="PUBLIC" kind="TYPE" typeKind="ENUM" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.Enum"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@code TimeUnit} represents time durations at a given unit of
                         granularity and provides utility methods to convert across units,
                         and to perform timing and delay operations in these units.  A
                         {@code TimeUnit} does not maintain time information, but only
                         helps organize and use time representations that may be maintained
                         separately across various contexts.  A nanosecond is defined as one
                         thousandth of a microsecond, a microsecond as one thousandth of a
                         millisecond, a millisecond as one thousandth of a second, a minute
                         as sixty seconds, an hour as sixty minutes, and a day as twenty four
                         hours.
                        
                         &lt;p&gt;A {@code TimeUnit} is mainly used to inform time-based methods
                         how a given timing parameter should be interpreted. For example,
                         the following code will timeout in 50 milliseconds if the {@link
                         java.util.concurrent.locks.Lock lock} is not available:
                        
                         &lt;pre&gt; {@code
                         Lock lock = ...;
                         if (lock.tryLock(50L, TimeUnit.MILLISECONDS)) ...}&lt;/pre&gt;
                        
                         while this code will timeout in 50 seconds:
                         &lt;pre&gt; {@code
                         Lock lock = ...;
                         if (lock.tryLock(50L, TimeUnit.SECONDS)) ...}&lt;/pre&gt;
                        
                         Note however, that there is no guarantee that a particular timeout
                         implementation will be able to notice the passage of time at the
                         same granularity as the given {@code TimeUnit}.
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="RunnableFuture" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.Runnable"/>
                        <superType superType="java.util.concurrent.Future"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@link Future} that is {@link Runnable}. Successful execution of
                         the {@code run} method causes completion of the {@code Future}
                         and allows access to its results.
                         @see FutureTask
                         @see Executor
                         @since 1.6
                         @author Doug Lea
                         @param &lt;V&gt; The result type returned by this Future's {@code get} method
                        </javadoc>
                </acts>
                <acts name="Phaser" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A reusable synchronization barrier, similar in functionality to
                         {@link CyclicBarrier} and {@link CountDownLatch} but supporting
                         more flexible usage.
                        
                         &lt;p&gt;&lt;b&gt;Registration.&lt;/b&gt; Unlike the case for other barriers, the
                         number of parties &lt;em&gt;registered&lt;/em&gt; to synchronize on a phaser
                         may vary over time.  Tasks may be registered at any time (using
                         methods {@link #register}, {@link #bulkRegister}, or forms of
                         constructors establishing initial numbers of parties), and
                         optionally deregistered upon any arrival (using {@link
                         #arriveAndDeregister}).  As is the case with most basic
                         synchronization constructs, registration and deregistration affect
                         only internal counts; they do not establish any further internal
                         bookkeeping, so tasks cannot query whether they are registered.
                         (However, you can introduce such bookkeeping by subclassing this
                         class.)
                        
                         &lt;p&gt;&lt;b&gt;Synchronization.&lt;/b&gt; Like a {@code CyclicBarrier}, a {@code
                         Phaser} may be repeatedly awaited.  Method {@link
                         #arriveAndAwaitAdvance} has effect analogous to {@link
                         java.util.concurrent.CyclicBarrier#await CyclicBarrier.await}. Each
                         generation of a phaser has an associated phase number. The phase
                         number starts at zero, and advances when all parties arrive at the
                         phaser, wrapping around to zero after reaching {@code
                         Integer.MAX_VALUE}. The use of phase numbers enables independent
                         control of actions upon arrival at a phaser and upon awaiting
                         others, via two kinds of methods that may be invoked by any
                         registered party:
                        
                         &lt;ul&gt;
                        
                           &lt;li&gt;&lt;b&gt;Arrival.&lt;/b&gt; Methods {@link #arrive} and
                               {@link #arriveAndDeregister} record arrival.  These methods
                               do not block, but return an associated &lt;em&gt;arrival phase
                               number&lt;/em&gt;; that is, the phase number of the phaser to which
                               the arrival applied. When the final party for a given phase
                               arrives, an optional action is performed and the phase
                               advances.  These actions are performed by the party
                               triggering a phase advance, and are arranged by overriding
                               method {@link #onAdvance(int, int)}, which also controls
                               termination. Overriding this method is similar to, but more
                               flexible than, providing a barrier action to a {@code
                               CyclicBarrier}.
                        
                           &lt;li&gt;&lt;b&gt;Waiting.&lt;/b&gt; Method {@link #awaitAdvance} requires an
                               argument indicating an arrival phase number, and returns when
                               the phaser advances to (or is already at) a different phase.
                               Unlike similar constructions using {@code CyclicBarrier},
                               method {@code awaitAdvance} continues to wait even if the
                               waiting thread is interrupted. Interruptible and timeout
                               versions are also available, but exceptions encountered while
                               tasks wait interruptibly or with timeout do not change the
                               state of the phaser. If necessary, you can perform any
                               associated recovery within handlers of those exceptions,
                               often after invoking {@code forceTermination}.  Phasers may
                               also be used by tasks executing in a {@link ForkJoinPool}.
                               Progress is ensured if the pool's parallelismLevel can
                               accommodate the maximum number of simultaneously blocked
                               parties.
                        
                         &lt;/ul&gt;
                        
                         &lt;p&gt;&lt;b&gt;Termination.&lt;/b&gt; A phaser may enter a &lt;em&gt;termination&lt;/em&gt;
                         state, that may be checked using method {@link #isTerminated}. Upon
                         termination, all synchronization methods immediately return without
                         waiting for advance, as indicated by a negative return value.
                         Similarly, attempts to register upon termination have no effect.
                         Termination is triggered when an invocation of {@code onAdvance}
                         returns {@code true}. The default implementation returns {@code
                         true} if a deregistration has caused the number of registered
                         parties to become zero.  As illustrated below, when phasers control
                         actions with a fixed number of iterations, it is often convenient
                         to override this method to cause termination when the current phase
                         number reaches a threshold. Method {@link #forceTermination} is
                         also available to abruptly release waiting threads and allow them
                         to terminate.
                        
                         &lt;p&gt;&lt;b&gt;Tiering.&lt;/b&gt; Phasers may be &lt;em&gt;tiered&lt;/em&gt; (i.e.,
                         constructed in tree structures) to reduce contention. Phasers with
                         large numbers of parties that would otherwise experience heavy
                         synchronization contention costs may instead be set up so that
                         groups of sub-phasers share a common parent.  This may greatly
                         increase throughput even though it incurs greater per-operation
                         overhead.
                        
                         &lt;p&gt;In a tree of tiered phasers, registration and deregistration of
                         child phasers with their parent are managed automatically.
                         Whenever the number of registered parties of a child phaser becomes
                         non-zero (as established in the {@link #Phaser(Phaser,int)}
                         constructor, {@link #register}, or {@link #bulkRegister}), the
                         child phaser is registered with its parent.  Whenever the number of
                         registered parties becomes zero as the result of an invocation of
                         {@link #arriveAndDeregister}, the child phaser is deregistered
                         from its parent.
                        
                         &lt;p&gt;&lt;b&gt;Monitoring.&lt;/b&gt; While synchronization methods may be invoked
                         only by registered parties, the current state of a phaser may be
                         monitored by any caller.  At any given moment there are {@link
                         #getRegisteredParties} parties in total, of which {@link
                         #getArrivedParties} have arrived at the current phase ({@link
                         #getPhase}).  When the remaining ({@link #getUnarrivedParties})
                         parties arrive, the phase advances.  The values returned by these
                         methods may reflect transient states and so are not in general
                         useful for synchronization control.  Method {@link #toString}
                         returns snapshots of these state queries in a form convenient for
                         informal monitoring.
                        
                         &lt;p&gt;&lt;b&gt;Sample usages:&lt;/b&gt;
                        
                         &lt;p&gt;A {@code Phaser} may be used instead of a {@code CountDownLatch}
                         to control a one-shot action serving a variable number of parties.
                         The typical idiom is for the method setting this up to first
                         register, then start all the actions, then deregister, as in:
                        
                         &lt;pre&gt; {@code
                         void runTasks(List&lt;Runnable&gt; tasks) {
                           Phaser startingGate = new Phaser(1); // "1" to register self
                           // create and start threads
                           for (Runnable task : tasks) {
                             startingGate.register();
                             new Thread(() -&gt; {
                               startingGate.arriveAndAwaitAdvance();
                               task.run();
                             }).start();
                           }
                        
                           // deregister self to allow threads to proceed
                           startingGate.arriveAndDeregister();
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;One way to cause a set of threads to repeatedly perform actions
                         for a given number of iterations is to override {@code onAdvance}:
                        
                         &lt;pre&gt; {@code
                         void startTasks(List&lt;Runnable&gt; tasks, int iterations) {
                           Phaser phaser = new Phaser() {
                             protected boolean onAdvance(int phase, int registeredParties) {
                               return phase &gt;= iterations - 1 || registeredParties == 0;
                             }
                           };
                           phaser.register();
                           for (Runnable task : tasks) {
                             phaser.register();
                             new Thread(() -&gt; {
                               do {
                                 task.run();
                                 phaser.arriveAndAwaitAdvance();
                               } while (!phaser.isTerminated());
                             }).start();
                           }
                           // allow threads to proceed; don't wait for them
                           phaser.arriveAndDeregister();
                         }}&lt;/pre&gt;
                        
                         If the main task must later await termination, it
                         may re-register and then execute a similar loop:
                         &lt;pre&gt; {@code
                           // ...
                           phaser.register();
                           while (!phaser.isTerminated())
                             phaser.arriveAndAwaitAdvance();}&lt;/pre&gt;
                        
                         &lt;p&gt;Related constructions may be used to await particular phase numbers
                         in contexts where you are sure that the phase will never wrap around
                         {@code Integer.MAX_VALUE}. For example:
                        
                         &lt;pre&gt; {@code
                         void awaitPhase(Phaser phaser, int phase) {
                           int p = phaser.register(); // assumes caller not already registered
                           while (p &lt; phase) {
                             if (phaser.isTerminated())
                               // ... deal with unexpected termination
                             else
                               p = phaser.arriveAndAwaitAdvance();
                           }
                           phaser.arriveAndDeregister();
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;To create a set of {@code n} tasks using a tree of phasers, you
                         could use code of the following form, assuming a Task class with a
                         constructor accepting a {@code Phaser} that it registers with upon
                         construction. After invocation of {@code build(new Task[n], 0, n,
                         new Phaser())}, these tasks could then be started, for example by
                         submitting to a pool:
                        
                         &lt;pre&gt; {@code
                         void build(Task[] tasks, int lo, int hi, Phaser ph) {
                           if (hi - lo &gt; TASKS_PER_PHASER) {
                             for (int i = lo; i &lt; hi; i += TASKS_PER_PHASER) {
                               int j = Math.min(i + TASKS_PER_PHASER, hi);
                               build(tasks, i, j, new Phaser(ph));
                             }
                           } else {
                             for (int i = lo; i &lt; hi; ++i)
                               tasks[i] = new Task(ph);
                               // assumes new Task(ph) performs ph.register()
                           }
                         }}&lt;/pre&gt;
                        
                         The best value of {@code TASKS_PER_PHASER} depends mainly on
                         expected synchronization rates. A value as low as four may
                         be appropriate for extremely small per-phase task bodies (thus
                         high rates), or up to hundreds for extremely large ones.
                        
                         &lt;p&gt;&lt;b&gt;Implementation notes&lt;/b&gt;: This implementation restricts the
                         maximum number of parties to 65535. Attempts to register additional
                         parties result in {@code IllegalStateException}. However, you can and
                         should create tiered phasers to accommodate arbitrarily large sets
                         of participants.
                        
                         @since 1.7
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="CountedCompleter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.ForkJoinTask"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@link ForkJoinTask} with a completion action performed when
                         triggered and there are no remaining pending actions.
                         CountedCompleters are in general more robust in the
                         presence of subtask stalls and blockage than are other forms of
                         ForkJoinTasks, but are less intuitive to program.  Uses of
                         CountedCompleter are similar to those of other completion based
                         components (such as {@link java.nio.channels.CompletionHandler})
                         except that multiple &lt;em&gt;pending&lt;/em&gt; completions may be necessary
                         to trigger the completion action {@link #onCompletion(CountedCompleter)},
                         not just one.
                         Unless initialized otherwise, the {@linkplain #getPendingCount pending
                         count} starts at zero, but may be (atomically) changed using
                         methods {@link #setPendingCount}, {@link #addToPendingCount}, and
                         {@link #compareAndSetPendingCount}. Upon invocation of {@link
                         #tryComplete}, if the pending action count is nonzero, it is
                         decremented; otherwise, the completion action is performed, and if
                         this completer itself has a completer, the process is continued
                         with its completer.  As is the case with related synchronization
                         components such as {@link Phaser} and {@link Semaphore}, these methods
                         affect only internal counts; they do not establish any further
                         internal bookkeeping. In particular, the identities of pending
                         tasks are not maintained. As illustrated below, you can create
                         subclasses that do record some or all pending tasks or their
                         results when needed.  As illustrated below, utility methods
                         supporting customization of completion traversals are also
                         provided. However, because CountedCompleters provide only basic
                         synchronization mechanisms, it may be useful to create further
                         abstract subclasses that maintain linkages, fields, and additional
                         support methods appropriate for a set of related usages.
                        
                         &lt;p&gt;A concrete CountedCompleter class must define method {@link
                         #compute}, that should in most cases (as illustrated below), invoke
                         {@code tryComplete()} once before returning. The class may also
                         optionally override method {@link #onCompletion(CountedCompleter)}
                         to perform an action upon normal completion, and method
                         {@link #onExceptionalCompletion(Throwable, CountedCompleter)} to
                         perform an action upon any exception.
                        
                         &lt;p&gt;CountedCompleters most often do not bear results, in which case
                         they are normally declared as {@code CountedCompleter&lt;Void&gt;}, and
                         will always return {@code null} as a result value.  In other cases,
                         you should override method {@link #getRawResult} to provide a
                         result from {@code join(), invoke()}, and related methods.  In
                         general, this method should return the value of a field (or a
                         function of one or more fields) of the CountedCompleter object that
                         holds the result upon completion. Method {@link #setRawResult} by
                         default plays no role in CountedCompleters.  It is possible, but
                         rarely applicable, to override this method to maintain other
                         objects or fields holding result data.
                        
                         &lt;p&gt;A CountedCompleter that does not itself have a completer (i.e.,
                         one for which {@link #getCompleter} returns {@code null}) can be
                         used as a regular ForkJoinTask with this added functionality.
                         However, any completer that in turn has another completer serves
                         only as an internal helper for other computations, so its own task
                         status (as reported in methods such as {@link ForkJoinTask#isDone})
                         is arbitrary; this status changes only upon explicit invocations of
                         {@link #complete}, {@link ForkJoinTask#cancel},
                         {@link ForkJoinTask#completeExceptionally(Throwable)} or upon
                         exceptional completion of method {@code compute}. Upon any
                         exceptional completion, the exception may be relayed to a task's
                         completer (and its completer, and so on), if one exists and it has
                         not otherwise already completed. Similarly, cancelling an internal
                         CountedCompleter has only a local effect on that completer, so is
                         not often useful.
                        
                         &lt;p&gt;&lt;b&gt;Sample Usages.&lt;/b&gt;
                        
                         &lt;p&gt;&lt;b&gt;Parallel recursive decomposition.&lt;/b&gt; CountedCompleters may
                         be arranged in trees similar to those often used with {@link
                         RecursiveAction}s, although the constructions involved in setting
                         them up typically vary. Here, the completer of each task is its
                         parent in the computation tree. Even though they entail a bit more
                         bookkeeping, CountedCompleters may be better choices when applying
                         a possibly time-consuming operation (that cannot be further
                         subdivided) to each element of an array or collection; especially
                         when the operation takes a significantly different amount of time
                         to complete for some elements than others, either because of
                         intrinsic variation (for example I/O) or auxiliary effects such as
                         garbage collection.  Because CountedCompleters provide their own
                         continuations, other tasks need not block waiting to perform them.
                        
                         &lt;p&gt;For example, here is an initial version of a utility method that
                         uses divide-by-two recursive decomposition to divide work into
                         single pieces (leaf tasks). Even when work is split into individual
                         calls, tree-based techniques are usually preferable to directly
                         forking leaf tasks, because they reduce inter-thread communication
                         and improve load balancing. In the recursive case, the second of
                         each pair of subtasks to finish triggers completion of their parent
                         (because no result combination is performed, the default no-op
                         implementation of method {@code onCompletion} is not overridden).
                         The utility method sets up the root task and invokes it (here,
                         implicitly using the {@link ForkJoinPool#commonPool()}).  It is
                         straightforward and reliable (but not optimal) to always set the
                         pending count to the number of child tasks and call {@code
                         tryComplete()} immediately before returning.
                        
                         &lt;pre&gt; {@code
                         public static &lt;E&gt; void forEach(E[] array, Consumer&lt;E&gt; action) {
                           class Task extends CountedCompleter&lt;Void&gt; {
                             final int lo, hi;
                             Task(Task parent, int lo, int hi) {
                               super(parent); this.lo = lo; this.hi = hi;
                             }
                        
                             public void compute() {
                               if (hi - lo &gt;= 2) {
                                 int mid = (lo + hi) &gt;&gt;&gt; 1;
                                 // must set pending count before fork
                                 setPendingCount(2);
                                 new Task(this, mid, hi).fork(); // right child
                                 new Task(this, lo, mid).fork(); // left child
                               }
                               else if (hi &gt; lo)
                                 action.accept(array[lo]);
                               tryComplete();
                             }
                           }
                           new Task(null, 0, array.length).invoke();
                         }}&lt;/pre&gt;
                        
                         This design can be improved by noticing that in the recursive case,
                         the task has nothing to do after forking its right task, so can
                         directly invoke its left task before returning. (This is an analog
                         of tail recursion removal.)  Also, when the last action in a task
                         is to fork or invoke a subtask (a "tail call"), the call to {@code
                         tryComplete()} can be optimized away, at the cost of making the
                         pending count look "off by one".
                        
                         &lt;pre&gt; {@code
                             public void compute() {
                               if (hi - lo &gt;= 2) {
                                 int mid = (lo + hi) &gt;&gt;&gt; 1;
                                 setPendingCount(1); // looks off by one, but correct!
                                 new Task(this, mid, hi).fork(); // right child
                                 new Task(this, lo, mid).compute(); // direct invoke
                               } else {
                                 if (hi &gt; lo)
                                   action.accept(array[lo]);
                                 tryComplete();
                               }
                             }}&lt;/pre&gt;
                        
                         As a further optimization, notice that the left task need not even exist.
                         Instead of creating a new one, we can continue using the original task,
                         and add a pending count for each fork.  Additionally, because no task
                         in this tree implements an {@link #onCompletion(CountedCompleter)} method,
                         {@code tryComplete} can be replaced with {@link #propagateCompletion}.
                        
                         &lt;pre&gt; {@code
                             public void compute() {
                               int n = hi - lo;
                               for (; n &gt;= 2; n /= 2) {
                                 addToPendingCount(1);
                                 new Task(this, lo + n/2, lo + n).fork();
                               }
                               if (n &gt; 0)
                                 action.accept(array[lo]);
                               propagateCompletion();
                             }}&lt;/pre&gt;
                        
                         When pending counts can be precomputed, they can be established in
                         the constructor:
                        
                         &lt;pre&gt; {@code
                         public static &lt;E&gt; void forEach(E[] array, Consumer&lt;E&gt; action) {
                           class Task extends CountedCompleter&lt;Void&gt; {
                             final int lo, hi;
                             Task(Task parent, int lo, int hi) {
                               super(parent, 31 - Integer.numberOfLeadingZeros(hi - lo));
                               this.lo = lo; this.hi = hi;
                             }
                        
                             public void compute() {
                               for (int n = hi - lo; n &gt;= 2; n /= 2)
                                 new Task(this, lo + n/2, lo + n).fork();
                               action.accept(array[lo]);
                               propagateCompletion();
                             }
                           }
                           if (array.length &gt; 0)
                             new Task(null, 0, array.length).invoke();
                         }}&lt;/pre&gt;
                        
                         Additional optimizations of such classes might entail specializing
                         classes for leaf steps, subdividing by say, four, instead of two
                         per iteration, and using an adaptive threshold instead of always
                         subdividing down to single elements.
                        
                         &lt;p&gt;&lt;b&gt;Searching.&lt;/b&gt; A tree of CountedCompleters can search for a
                         value or property in different parts of a data structure, and
                         report a result in an {@link
                         java.util.concurrent.atomic.AtomicReference AtomicReference} as
                         soon as one is found. The others can poll the result to avoid
                         unnecessary work. (You could additionally {@linkplain #cancel
                         cancel} other tasks, but it is usually simpler and more efficient
                         to just let them notice that the result is set and if so skip
                         further processing.)  Illustrating again with an array using full
                         partitioning (again, in practice, leaf tasks will almost always
                         process more than one element):
                        
                         &lt;pre&gt; {@code
                         class Searcher&lt;E&gt; extends CountedCompleter&lt;E&gt; {
                           final E[] array; final AtomicReference&lt;E&gt; result; final int lo, hi;
                           Searcher(CountedCompleter&lt;?&gt; p, E[] array, AtomicReference&lt;E&gt; result, int lo, int hi) {
                             super(p);
                             this.array = array; this.result = result; this.lo = lo; this.hi = hi;
                           }
                           public E getRawResult() { return result.get(); }
                           public void compute() { // similar to ForEach version 3
                             int l = lo, h = hi;
                             while (result.get() == null &amp;&amp; h &gt;= l) {
                               if (h - l &gt;= 2) {
                                 int mid = (l + h) &gt;&gt;&gt; 1;
                                 addToPendingCount(1);
                                 new Searcher(this, array, result, mid, h).fork();
                                 h = mid;
                               }
                               else {
                                 E x = array[l];
                                 if (matches(x) &amp;&amp; result.compareAndSet(null, x))
                                   quietlyCompleteRoot(); // root task is now joinable
                                 break;
                               }
                             }
                             tryComplete(); // normally complete whether or not found
                           }
                           boolean matches(E e) { ... } // return true if found
                        
                           public static &lt;E&gt; E search(E[] array) {
                               return new Searcher&lt;E&gt;(null, array, new AtomicReference&lt;E&gt;(), 0, array.length).invoke();
                           }
                         }}&lt;/pre&gt;
                        
                         In this example, as well as others in which tasks have no other
                         effects except to {@code compareAndSet} a common result, the
                         trailing unconditional invocation of {@code tryComplete} could be
                         made conditional ({@code if (result.get() == null) tryComplete();})
                         because no further bookkeeping is required to manage completions
                         once the root task completes.
                        
                         &lt;p&gt;&lt;b&gt;Recording subtasks.&lt;/b&gt; CountedCompleter tasks that combine
                         results of multiple subtasks usually need to access these results
                         in method {@link #onCompletion(CountedCompleter)}. As illustrated in the following
                         class (that performs a simplified form of map-reduce where mappings
                         and reductions are all of type {@code E}), one way to do this in
                         divide and conquer designs is to have each subtask record its
                         sibling, so that it can be accessed in method {@code onCompletion}.
                         This technique applies to reductions in which the order of
                         combining left and right results does not matter; ordered
                         reductions require explicit left/right designations.  Variants of
                         other streamlinings seen in the above examples may also apply.
                        
                         &lt;pre&gt; {@code
                         class MyMapper&lt;E&gt; { E apply(E v) {  ...  } }
                         class MyReducer&lt;E&gt; { E apply(E x, E y) {  ...  } }
                         class MapReducer&lt;E&gt; extends CountedCompleter&lt;E&gt; {
                           final E[] array; final MyMapper&lt;E&gt; mapper;
                           final MyReducer&lt;E&gt; reducer; final int lo, hi;
                           MapReducer&lt;E&gt; sibling;
                           E result;
                           MapReducer(CountedCompleter&lt;?&gt; p, E[] array, MyMapper&lt;E&gt; mapper,
                                      MyReducer&lt;E&gt; reducer, int lo, int hi) {
                             super(p);
                             this.array = array; this.mapper = mapper;
                             this.reducer = reducer; this.lo = lo; this.hi = hi;
                           }
                           public void compute() {
                             if (hi - lo &gt;= 2) {
                               int mid = (lo + hi) &gt;&gt;&gt; 1;
                               MapReducer&lt;E&gt; left = new MapReducer(this, array, mapper, reducer, lo, mid);
                               MapReducer&lt;E&gt; right = new MapReducer(this, array, mapper, reducer, mid, hi);
                               left.sibling = right;
                               right.sibling = left;
                               setPendingCount(1); // only right is pending
                               right.fork();
                               left.compute();     // directly execute left
                             }
                             else {
                               if (hi &gt; lo)
                                   result = mapper.apply(array[lo]);
                               tryComplete();
                             }
                           }
                           public void onCompletion(CountedCompleter&lt;?&gt; caller) {
                             if (caller != this) {
                               MapReducer&lt;E&gt; child = (MapReducer&lt;E&gt;)caller;
                               MapReducer&lt;E&gt; sib = child.sibling;
                               if (sib == null || sib.result == null)
                                 result = child.result;
                               else
                                 result = reducer.apply(child.result, sib.result);
                             }
                           }
                           public E getRawResult() { return result; }
                        
                           public static &lt;E&gt; E mapReduce(E[] array, MyMapper&lt;E&gt; mapper, MyReducer&lt;E&gt; reducer) {
                             return new MapReducer&lt;E&gt;(null, array, mapper, reducer,
                                                      0, array.length).invoke();
                           }
                         }}&lt;/pre&gt;
                        
                         Here, method {@code onCompletion} takes a form common to many
                         completion designs that combine results. This callback-style method
                         is triggered once per task, in either of the two different contexts
                         in which the pending count is, or becomes, zero: (1) by a task
                         itself, if its pending count is zero upon invocation of {@code
                         tryComplete}, or (2) by any of its subtasks when they complete and
                         decrement the pending count to zero. The {@code caller} argument
                         distinguishes cases.  Most often, when the caller is {@code this},
                         no action is necessary. Otherwise the caller argument can be used
                         (usually via a cast) to supply a value (and/or links to other
                         values) to be combined.  Assuming proper use of pending counts, the
                         actions inside {@code onCompletion} occur (once) upon completion of
                         a task and its subtasks. No additional synchronization is required
                         within this method to ensure thread safety of accesses to fields of
                         this task or other completed tasks.
                        
                         &lt;p&gt;&lt;b&gt;Completion Traversals&lt;/b&gt;. If using {@code onCompletion} to
                         process completions is inapplicable or inconvenient, you can use
                         methods {@link #firstComplete} and {@link #nextComplete} to create
                         custom traversals.  For example, to define a MapReducer that only
                         splits out right-hand tasks in the form of the third ForEach
                         example, the completions must cooperatively reduce along
                         unexhausted subtask links, which can be done as follows:
                        
                         &lt;pre&gt; {@code
                         class MapReducer&lt;E&gt; extends CountedCompleter&lt;E&gt; { // version 2
                           final E[] array; final MyMapper&lt;E&gt; mapper;
                           final MyReducer&lt;E&gt; reducer; final int lo, hi;
                           MapReducer&lt;E&gt; forks, next; // record subtask forks in list
                           E result;
                           MapReducer(CountedCompleter&lt;?&gt; p, E[] array, MyMapper&lt;E&gt; mapper,
                                      MyReducer&lt;E&gt; reducer, int lo, int hi, MapReducer&lt;E&gt; next) {
                             super(p);
                             this.array = array; this.mapper = mapper;
                             this.reducer = reducer; this.lo = lo; this.hi = hi;
                             this.next = next;
                           }
                           public void compute() {
                             int l = lo, h = hi;
                             while (h - l &gt;= 2) {
                               int mid = (l + h) &gt;&gt;&gt; 1;
                               addToPendingCount(1);
                               (forks = new MapReducer(this, array, mapper, reducer, mid, h, forks)).fork();
                               h = mid;
                             }
                             if (h &gt; l)
                               result = mapper.apply(array[l]);
                             // process completions by reducing along and advancing subtask links
                             for (CountedCompleter&lt;?&gt; c = firstComplete(); c != null; c = c.nextComplete()) {
                               for (MapReducer t = (MapReducer)c, s = t.forks; s != null; s = t.forks = s.next)
                                 t.result = reducer.apply(t.result, s.result);
                             }
                           }
                           public E getRawResult() { return result; }
                        
                           public static &lt;E&gt; E mapReduce(E[] array, MyMapper&lt;E&gt; mapper, MyReducer&lt;E&gt; reducer) {
                             return new MapReducer&lt;E&gt;(null, array, mapper, reducer,
                                                      0, array.length, null).invoke();
                           }
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;&lt;b&gt;Triggers.&lt;/b&gt; Some CountedCompleters are themselves never
                         forked, but instead serve as bits of plumbing in other designs;
                         including those in which the completion of one or more async tasks
                         triggers another async task. For example:
                        
                         &lt;pre&gt; {@code
                         class HeaderBuilder extends CountedCompleter&lt;...&gt; { ... }
                         class BodyBuilder extends CountedCompleter&lt;...&gt; { ... }
                         class PacketSender extends CountedCompleter&lt;...&gt; {
                           PacketSender(...) { super(null, 1); ... } // trigger on second completion
                           public void compute() { } // never called
                           public void onCompletion(CountedCompleter&lt;?&gt; caller) { sendPacket(); }
                         }
                         // sample use:
                         PacketSender p = new PacketSender();
                         new HeaderBuilder(p, ...).fork();
                         new BodyBuilder(p, ...).fork();}&lt;/pre&gt;
                        
                         @since 1.8
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="TimeoutException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Exception thrown when a blocking operation times out.  Blocking
                         operations for which a timeout is specified need a means to
                         indicate that the timeout has occurred. For many such operations it
                         is possible to return a value that indicates timeout; when that is
                         not possible or desirable then {@code TimeoutException} should be
                         declared and thrown.
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="BlockingQueue" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.Queue"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@link Queue} that additionally supports operations that wait for
                         the queue to become non-empty when retrieving an element, and wait
                         for space to become available in the queue when storing an element.
                        
                         &lt;p&gt;{@code BlockingQueue} methods come in four forms, with different ways
                         of handling operations that cannot be satisfied immediately, but may be
                         satisfied at some point in the future:
                         one throws an exception, the second returns a special value (either
                         {@code null} or {@code false}, depending on the operation), the third
                         blocks the current thread indefinitely until the operation can succeed,
                         and the fourth blocks for only a given maximum time limit before giving
                         up.  These methods are summarized in the following table:
                        
                         &lt;table class="plain"&gt;
                         &lt;caption&gt;Summary of BlockingQueue methods&lt;/caption&gt;
                          &lt;tr&gt;
                            &lt;td&gt;&lt;/td&gt;
                            &lt;th scope="col" style="font-weight:normal; font-style:italic"&gt;Throws exception&lt;/th&gt;
                            &lt;th scope="col" style="font-weight:normal; font-style:italic"&gt;Special value&lt;/th&gt;
                            &lt;th scope="col" style="font-weight:normal; font-style:italic"&gt;Blocks&lt;/th&gt;
                            &lt;th scope="col" style="font-weight:normal; font-style:italic"&gt;Times out&lt;/th&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th scope="row" style="text-align:left"&gt;Insert&lt;/th&gt;
                            &lt;td&gt;{@link #add(Object) add(e)}&lt;/td&gt;
                            &lt;td&gt;{@link #offer(Object) offer(e)}&lt;/td&gt;
                            &lt;td&gt;{@link #put(Object) put(e)}&lt;/td&gt;
                            &lt;td&gt;{@link #offer(Object, long, TimeUnit) offer(e, time, unit)}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th scope="row" style="text-align:left"&gt;Remove&lt;/th&gt;
                            &lt;td&gt;{@link #remove() remove()}&lt;/td&gt;
                            &lt;td&gt;{@link #poll() poll()}&lt;/td&gt;
                            &lt;td&gt;{@link #take() take()}&lt;/td&gt;
                            &lt;td&gt;{@link #poll(long, TimeUnit) poll(time, unit)}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th scope="row" style="text-align:left"&gt;Examine&lt;/th&gt;
                            &lt;td&gt;{@link #element() element()}&lt;/td&gt;
                            &lt;td&gt;{@link #peek() peek()}&lt;/td&gt;
                            &lt;td style="font-style: italic"&gt;not applicable&lt;/td&gt;
                            &lt;td style="font-style: italic"&gt;not applicable&lt;/td&gt;
                          &lt;/tr&gt;
                         &lt;/table&gt;
                        
                         &lt;p&gt;A {@code BlockingQueue} does not accept {@code null} elements.
                         Implementations throw {@code NullPointerException} on attempts
                         to {@code add}, {@code put} or {@code offer} a {@code null}.  A
                         {@code null} is used as a sentinel value to indicate failure of
                         {@code poll} operations.
                        
                         &lt;p&gt;A {@code BlockingQueue} may be capacity bounded. At any given
                         time it may have a {@code remainingCapacity} beyond which no
                         additional elements can be {@code put} without blocking.
                         A {@code BlockingQueue} without any intrinsic capacity constraints always
                         reports a remaining capacity of {@code Integer.MAX_VALUE}.
                        
                         &lt;p&gt;{@code BlockingQueue} implementations are designed to be used
                         primarily for producer-consumer queues, but additionally support
                         the {@link Collection} interface.  So, for example, it is
                         possible to remove an arbitrary element from a queue using
                         {@code remove(x)}. However, such operations are in general
                         &lt;em&gt;not&lt;/em&gt; performed very efficiently, and are intended for only
                         occasional use, such as when a queued message is cancelled.
                        
                         &lt;p&gt;{@code BlockingQueue} implementations are thread-safe.  All
                         queuing methods achieve their effects atomically using internal
                         locks or other forms of concurrency control. However, the
                         &lt;em&gt;bulk&lt;/em&gt; Collection operations {@code addAll},
                         {@code containsAll}, {@code retainAll} and {@code removeAll} are
                         &lt;em&gt;not&lt;/em&gt; necessarily performed atomically unless specified
                         otherwise in an implementation. So it is possible, for example, for
                         {@code addAll(c)} to fail (throwing an exception) after adding
                         only some of the elements in {@code c}.
                        
                         &lt;p&gt;A {@code BlockingQueue} does &lt;em&gt;not&lt;/em&gt; intrinsically support
                         any kind of &amp;quot;close&amp;quot; or &amp;quot;shutdown&amp;quot; operation to
                         indicate that no more items will be added.  The needs and usage of
                         such features tend to be implementation-dependent. For example, a
                         common tactic is for producers to insert special
                         &lt;em&gt;end-of-stream&lt;/em&gt; or &lt;em&gt;poison&lt;/em&gt; objects, that are
                         interpreted accordingly when taken by consumers.
                        
                         &lt;p&gt;
                         Usage example, based on a typical producer-consumer scenario.
                         Note that a {@code BlockingQueue} can safely be used with multiple
                         producers and multiple consumers.
                         &lt;pre&gt; {@code
                         class Producer implements Runnable {
                           private final BlockingQueue queue;
                           Producer(BlockingQueue q) { queue = q; }
                           public void run() {
                             try {
                               while (true) { queue.put(produce()); }
                             } catch (InterruptedException ex) { ... handle ...}
                           }
                           Object produce() { ... }
                         }
                        
                         class Consumer implements Runnable {
                           private final BlockingQueue queue;
                           Consumer(BlockingQueue q) { queue = q; }
                           public void run() {
                             try {
                               while (true) { consume(queue.take()); }
                             } catch (InterruptedException ex) { ... handle ...}
                           }
                           void consume(Object x) { ... }
                         }
                        
                         class Setup {
                           void main() {
                             BlockingQueue q = new SomeQueueImplementation();
                             Producer p = new Producer(q);
                             Consumer c1 = new Consumer(q);
                             Consumer c2 = new Consumer(q);
                             new Thread(p).start();
                             new Thread(c1).start();
                             new Thread(c2).start();
                           }
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;Memory consistency effects: As with other concurrent
                         collections, actions in a thread prior to placing an object into a
                         {@code BlockingQueue}
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         actions subsequent to the access or removal of that element from
                         the {@code BlockingQueue} in another thread.
                        
                         &lt;p&gt;This interface is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.5
                         @author Doug Lea
                         @param &lt;E&gt; the type of elements held in this queue
                        </javadoc>
                </acts>
                <acts name="ScheduledExecutorService" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.ExecutorService"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An {@link ExecutorService} that can schedule commands to run after a given
                         delay, or to execute periodically.
                        
                         &lt;p&gt;The {@code schedule} methods create tasks with various delays
                         and return a task object that can be used to cancel or check
                         execution. The {@code scheduleAtFixedRate} and
                         {@code scheduleWithFixedDelay} methods create and execute tasks
                         that run periodically until cancelled.
                        
                         &lt;p&gt;Commands submitted using the {@link Executor#execute(Runnable)}
                         and {@link ExecutorService} {@code submit} methods are scheduled
                         with a requested delay of zero. Zero and negative delays (but not
                         periods) are also allowed in {@code schedule} methods, and are
                         treated as requests for immediate execution.
                        
                         &lt;p&gt;All {@code schedule} methods accept &lt;em&gt;relative&lt;/em&gt; delays and
                         periods as arguments, not absolute times or dates. It is a simple
                         matter to transform an absolute time represented as a {@link
                         java.util.Date} to the required form. For example, to schedule at
                         a certain future {@code date}, you can use: {@code schedule(task,
                         date.getTime() - System.currentTimeMillis(),
                         TimeUnit.MILLISECONDS)}. Beware however that expiration of a
                         relative delay need not coincide with the current {@code Date} at
                         which the task is enabled due to network time synchronization
                         protocols, clock drift, or other factors.
                        
                         &lt;p&gt;The {@link Executors} class provides convenient factory methods for
                         the ScheduledExecutorService implementations provided in this package.
                        
                         &lt;h3&gt;Usage Example&lt;/h3&gt;
                        
                         Here is a class with a method that sets up a ScheduledExecutorService
                         to beep every ten seconds for an hour:
                        
                         &lt;pre&gt; {@code
                         import static java.util.concurrent.TimeUnit.*;
                         class BeeperControl {
                           private final ScheduledExecutorService scheduler =
                             Executors.newScheduledThreadPool(1);
                        
                           public void beepForAnHour() {
                             Runnable beeper = () -&gt; System.out.println("beep");
                             ScheduledFuture&lt;?&gt; beeperHandle =
                               scheduler.scheduleAtFixedRate(beeper, 10, 10, SECONDS);
                             Runnable canceller = () -&gt; beeperHandle.cancel(false);
                             scheduler.schedule(canceller, 1, HOURS);
                           }
                         }}&lt;/pre&gt;
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="Subscriber" access="PUBLIC" declaringClass="Flow" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes/>
                </acts>
                <acts name="SubmissionPublisher" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.Flow$Publisher"/>
                        <superType superType="java.lang.AutoCloseable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@link Flow.Publisher} that asynchronously issues submitted
                         (non-null) items to current subscribers until it is closed.  Each
                         current subscriber receives newly submitted items in the same order
                         unless drops or exceptions are encountered.  Using a
                         SubmissionPublisher allows item generators to act as compliant &lt;a
                         href="http://www.reactive-streams.org/"&gt; reactive-streams&lt;/a&gt;
                         Publishers relying on drop handling and/or blocking for flow
                         control.
                        
                         &lt;p&gt;A SubmissionPublisher uses the {@link Executor} supplied in its
                         constructor for delivery to subscribers. The best choice of
                         Executor depends on expected usage. If the generator(s) of
                         submitted items run in separate threads, and the number of
                         subscribers can be estimated, consider using a {@link
                         Executors#newFixedThreadPool}. Otherwise consider using the
                         default, normally the {@link ForkJoinPool#commonPool}.
                        
                         &lt;p&gt;Buffering allows producers and consumers to transiently operate
                         at different rates.  Each subscriber uses an independent buffer.
                         Buffers are created upon first use and expanded as needed up to the
                         given maximum. (The enforced capacity may be rounded up to the
                         nearest power of two and/or bounded by the largest value supported
                         by this implementation.)  Invocations of {@link
                         Flow.Subscription#request(long) request} do not directly result in
                         buffer expansion, but risk saturation if unfilled requests exceed
                         the maximum capacity.  The default value of {@link
                         Flow#defaultBufferSize()} may provide a useful starting point for
                         choosing a capacity based on expected rates, resources, and usages.
                        
                         &lt;p&gt;A single SubmissionPublisher may be shared among multiple
                         sources. Actions in a source thread prior to publishing an item or
                         issuing a signal &lt;a href="package-summary.html#MemoryVisibility"&gt;
                         &lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt; actions subsequent to the corresponding
                         access by each subscriber. But reported estimates of lag and demand
                         are designed for use in monitoring, not for synchronization
                         control, and may reflect stale or inaccurate views of progress.
                        
                         &lt;p&gt;Publication methods support different policies about what to do
                         when buffers are saturated. Method {@link #submit(Object) submit}
                         blocks until resources are available. This is simplest, but least
                         responsive.  The {@code offer} methods may drop items (either
                         immediately or with bounded timeout), but provide an opportunity to
                         interpose a handler and then retry.
                        
                         &lt;p&gt;If any Subscriber method throws an exception, its subscription
                         is cancelled.  If a handler is supplied as a constructor argument,
                         it is invoked before cancellation upon an exception in method
                         {@link Flow.Subscriber#onNext onNext}, but exceptions in methods
                         {@link Flow.Subscriber#onSubscribe onSubscribe},
                         {@link Flow.Subscriber#onError(Throwable) onError} and
                         {@link Flow.Subscriber#onComplete() onComplete} are not recorded or
                         handled before cancellation.  If the supplied Executor throws
                         {@link RejectedExecutionException} (or any other RuntimeException
                         or Error) when attempting to execute a task, or a drop handler
                         throws an exception when processing a dropped item, then the
                         exception is rethrown. In these cases, not all subscribers will
                         have been issued the published item. It is usually good practice to
                         {@link #closeExceptionally closeExceptionally} in these cases.
                        
                         &lt;p&gt;Method {@link #consume(Consumer)} simplifies support for a
                         common case in which the only action of a subscriber is to request
                         and process all items using a supplied function.
                        
                         &lt;p&gt;This class may also serve as a convenient base for subclasses
                         that generate items, and use the methods in this class to publish
                         them.  For example here is a class that periodically publishes the
                         items generated from a supplier. (In practice you might add methods
                         to independently start and stop generation, to share Executors
                         among publishers, and so on, or use a SubmissionPublisher as a
                         component rather than a superclass.)
                        
                         &lt;pre&gt; {@code
                         class PeriodicPublisher&lt;T&gt; extends SubmissionPublisher&lt;T&gt; {
                           final ScheduledFuture&lt;?&gt; periodicTask;
                           final ScheduledExecutorService scheduler;
                           PeriodicPublisher(Executor executor, int maxBufferCapacity,
                                             Supplier&lt;? extends T&gt; supplier,
                                             long period, TimeUnit unit) {
                             super(executor, maxBufferCapacity);
                             scheduler = new ScheduledThreadPoolExecutor(1);
                             periodicTask = scheduler.scheduleAtFixedRate(
                               () -&gt; submit(supplier.get()), 0, period, unit);
                           }
                           public void close() {
                             periodicTask.cancel(false);
                             scheduler.shutdown();
                             super.close();
                           }
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;Here is an example of a {@link Flow.Processor} implementation.
                         It uses single-step requests to its publisher for simplicity of
                         illustration. A more adaptive version could monitor flow using the
                         lag estimate returned from {@code submit}, along with other utility
                         methods.
                        
                         &lt;pre&gt; {@code
                         class TransformProcessor&lt;S,T&gt; extends SubmissionPublisher&lt;T&gt;
                           implements Flow.Processor&lt;S,T&gt; {
                           final Function&lt;? super S, ? extends T&gt; function;
                           Flow.Subscription subscription;
                           TransformProcessor(Executor executor, int maxBufferCapacity,
                                              Function&lt;? super S, ? extends T&gt; function) {
                             super(executor, maxBufferCapacity);
                             this.function = function;
                           }
                           public void onSubscribe(Flow.Subscription subscription) {
                             (this.subscription = subscription).request(1);
                           }
                           public void onNext(S item) {
                             subscription.request(1);
                             submit(function.apply(item));
                           }
                           public void onError(Throwable ex) { closeExceptionally(ex); }
                           public void onComplete() { close(); }
                         }}&lt;/pre&gt;
                        
                         @param &lt;T&gt; the published item type
                         @author Doug Lea
                         @since 9
                        </javadoc>
                </acts>
                <acts name="ConcurrentMap" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.Map"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@link Map} providing thread safety and atomicity guarantees.
                        
                         &lt;p&gt;To maintain the specified guarantees, default implementations of
                         methods including {@link #putIfAbsent} inherited from {@link Map}
                         must be overridden by implementations of this interface. Similarly,
                         implementations of the collections returned by methods {@link
                         #keySet}, {@link #values}, and {@link #entrySet} must override
                         methods such as {@code removeIf} when necessary to
                         preserve atomicity guarantees.
                        
                         &lt;p&gt;Memory consistency effects: As with other concurrent
                         collections, actions in a thread prior to placing an object into a
                         {@code ConcurrentMap} as a key or value
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         actions subsequent to the access or removal of that object from
                         the {@code ConcurrentMap} in another thread.
                        
                         &lt;p&gt;This interface is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.5
                         @author Doug Lea
                         @param &lt;K&gt; the type of keys maintained by this map
                         @param &lt;V&gt; the type of mapped values
                        </javadoc>
                </acts>
                <acts name="RecursiveAction" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.ForkJoinTask"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A recursive resultless {@link ForkJoinTask}.  This class
                         establishes conventions to parameterize resultless actions as
                         {@code Void} {@code ForkJoinTask}s. Because {@code null} is the
                         only valid value of type {@code Void}, methods such as {@code join}
                         always return {@code null} upon completion.
                        
                         &lt;p&gt;&lt;b&gt;Sample Usages.&lt;/b&gt; Here is a simple but complete ForkJoin
                         sort that sorts a given {@code long[]} array:
                        
                         &lt;pre&gt; {@code
                         static class SortTask extends RecursiveAction {
                           final long[] array; final int lo, hi;
                           SortTask(long[] array, int lo, int hi) {
                             this.array = array; this.lo = lo; this.hi = hi;
                           }
                           SortTask(long[] array) { this(array, 0, array.length); }
                           protected void compute() {
                             if (hi - lo &lt; THRESHOLD)
                               sortSequentially(lo, hi);
                             else {
                               int mid = (lo + hi) &gt;&gt;&gt; 1;
                               invokeAll(new SortTask(array, lo, mid),
                                         new SortTask(array, mid, hi));
                               merge(lo, mid, hi);
                             }
                           }
                           // implementation details follow:
                           static final int THRESHOLD = 1000;
                           void sortSequentially(int lo, int hi) {
                             Arrays.sort(array, lo, hi);
                           }
                           void merge(int lo, int mid, int hi) {
                             long[] buf = Arrays.copyOfRange(array, lo, mid);
                             for (int i = 0, j = lo, k = mid; i &lt; buf.length; j++)
                               array[j] = (k == hi || buf[i] &lt; array[k]) ?
                                 buf[i++] : array[k++];
                           }
                         }}&lt;/pre&gt;
                        
                         You could then sort {@code anArray} by creating {@code new
                         SortTask(anArray)} and invoking it in a ForkJoinPool.  As a more
                         concrete simple example, the following task increments each element
                         of an array:
                         &lt;pre&gt; {@code
                         class IncrementTask extends RecursiveAction {
                           final long[] array; final int lo, hi;
                           IncrementTask(long[] array, int lo, int hi) {
                             this.array = array; this.lo = lo; this.hi = hi;
                           }
                           protected void compute() {
                             if (hi - lo &lt; THRESHOLD) {
                               for (int i = lo; i &lt; hi; ++i)
                                 array[i]++;
                             }
                             else {
                               int mid = (lo + hi) &gt;&gt;&gt; 1;
                               invokeAll(new IncrementTask(array, lo, mid),
                                         new IncrementTask(array, mid, hi));
                             }
                           }
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;The following example illustrates some refinements and idioms
                         that may lead to better performance: RecursiveActions need not be
                         fully recursive, so long as they maintain the basic
                         divide-and-conquer approach. Here is a class that sums the squares
                         of each element of a double array, by subdividing out only the
                         right-hand-sides of repeated divisions by two, and keeping track of
                         them with a chain of {@code next} references. It uses a dynamic
                         threshold based on method {@code getSurplusQueuedTaskCount}, but
                         counterbalances potential excess partitioning by directly
                         performing leaf actions on unstolen tasks rather than further
                         subdividing.
                        
                         &lt;pre&gt; {@code
                         double sumOfSquares(ForkJoinPool pool, double[] array) {
                           int n = array.length;
                           Applyer a = new Applyer(array, 0, n, null);
                           pool.invoke(a);
                           return a.result;
                         }
                        
                         class Applyer extends RecursiveAction {
                           final double[] array;
                           final int lo, hi;
                           double result;
                           Applyer next; // keeps track of right-hand-side tasks
                           Applyer(double[] array, int lo, int hi, Applyer next) {
                             this.array = array; this.lo = lo; this.hi = hi;
                             this.next = next;
                           }
                        
                           double atLeaf(int l, int h) {
                             double sum = 0;
                             for (int i = l; i &lt; h; ++i) // perform leftmost base step
                               sum += array[i] * array[i];
                             return sum;
                           }
                        
                           protected void compute() {
                             int l = lo;
                             int h = hi;
                             Applyer right = null;
                             while (h - l &gt; 1 &amp;&amp; getSurplusQueuedTaskCount() &lt;= 3) {
                               int mid = (l + h) &gt;&gt;&gt; 1;
                               right = new Applyer(array, mid, h, right);
                               right.fork();
                               h = mid;
                             }
                             double sum = atLeaf(l, h);
                             while (right != null) {
                               if (right.tryUnfork()) // directly calculate if not stolen
                                 sum += right.atLeaf(right.lo, right.hi);
                               else {
                                 right.join();
                                 sum += right.result;
                               }
                               right = right.next;
                             }
                             result = sum;
                           }
                         }}&lt;/pre&gt;
                        
                         @since 1.7
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="PriorityBlockingQueue" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.BlockingQueue"/>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.util.AbstractQueue"/>
                        <superType superType="java.util.AbstractCollection"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An unbounded {@linkplain BlockingQueue blocking queue} that uses
                         the same ordering rules as class {@link PriorityQueue} and supplies
                         blocking retrieval operations.  While this queue is logically
                         unbounded, attempted additions may fail due to resource exhaustion
                         (causing {@code OutOfMemoryError}). This class does not permit
                         {@code null} elements.  A priority queue relying on {@linkplain
                         Comparable natural ordering} also does not permit insertion of
                         non-comparable objects (doing so results in
                         {@code ClassCastException}).
                        
                         &lt;p&gt;This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt;
                         methods of the {@link Collection} and {@link Iterator} interfaces.
                         The Iterator provided in method {@link #iterator()} and the
                         Spliterator provided in method {@link #spliterator()} are &lt;em&gt;not&lt;/em&gt;
                         guaranteed to traverse the elements of the PriorityBlockingQueue in
                         any particular order. If you need ordered traversal, consider using
                         {@code Arrays.sort(pq.toArray())}.  Also, method {@code drainTo} can
                         be used to &lt;em&gt;remove&lt;/em&gt; some or all elements in priority order and
                         place them in another collection.
                        
                         &lt;p&gt;Operations on this class make no guarantees about the ordering
                         of elements with equal priority. If you need to enforce an
                         ordering, you can define custom classes or comparators that use a
                         secondary key to break ties in primary priority values.  For
                         example, here is a class that applies first-in-first-out
                         tie-breaking to comparable elements. To use it, you would insert a
                         {@code new FIFOEntry(anEntry)} instead of a plain entry object.
                        
                         &lt;pre&gt; {@code
                         class FIFOEntry&lt;E extends Comparable&lt;? super E&gt;&gt;
                             implements Comparable&lt;FIFOEntry&lt;E&gt;&gt; {
                           static final AtomicLong seq = new AtomicLong(0);
                           final long seqNum;
                           final E entry;
                           public FIFOEntry(E entry) {
                             seqNum = seq.getAndIncrement();
                             this.entry = entry;
                           }
                           public E getEntry() { return entry; }
                           public int compareTo(FIFOEntry&lt;E&gt; other) {
                             int res = entry.compareTo(other.entry);
                             if (res == 0 &amp;&amp; other.entry != this.entry)
                               res = (seqNum &lt; other.seqNum ? -1 : 1);
                             return res;
                           }
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;This class is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.5
                         @author Doug Lea
                         @param &lt;E&gt; the type of elements held in this queue
                        </javadoc>
                </acts>
                <acts name="AsynchronousCompletionTask" access="PUBLIC" declaringClass="CompletableFuture" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes/>
                </acts>
                <acts name="CyclicBarrier" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A synchronization aid that allows a set of threads to all wait for
                         each other to reach a common barrier point.  CyclicBarriers are
                         useful in programs involving a fixed sized party of threads that
                         must occasionally wait for each other. The barrier is called
                         &lt;em&gt;cyclic&lt;/em&gt; because it can be re-used after the waiting threads
                         are released.
                        
                         &lt;p&gt;A {@code CyclicBarrier} supports an optional {@link Runnable} command
                         that is run once per barrier point, after the last thread in the party
                         arrives, but before any threads are released.
                         This &lt;em&gt;barrier action&lt;/em&gt; is useful
                         for updating shared-state before any of the parties continue.
                        
                         &lt;p&gt;&lt;b&gt;Sample usage:&lt;/b&gt; Here is an example of using a barrier in a
                         parallel decomposition design:
                        
                         &lt;pre&gt; {@code
                         class Solver {
                           final int N;
                           final float[][] data;
                           final CyclicBarrier barrier;
                        
                           class Worker implements Runnable {
                             int myRow;
                             Worker(int row) { myRow = row; }
                             public void run() {
                               while (!done()) {
                                 processRow(myRow);
                        
                                 try {
                                   barrier.await();
                                 } catch (InterruptedException ex) {
                                   return;
                                 } catch (BrokenBarrierException ex) {
                                   return;
                                 }
                               }
                             }
                           }
                        
                           public Solver(float[][] matrix) {
                             data = matrix;
                             N = matrix.length;
                             Runnable barrierAction = () -&gt; mergeRows(...);
                             barrier = new CyclicBarrier(N, barrierAction);
                        
                             List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(N);
                             for (int i = 0; i &lt; N; i++) {
                               Thread thread = new Thread(new Worker(i));
                               threads.add(thread);
                               thread.start();
                             }
                        
                             // wait until done
                             for (Thread thread : threads)
                               thread.join();
                           }
                         }}&lt;/pre&gt;
                        
                         Here, each worker thread processes a row of the matrix then waits at the
                         barrier until all rows have been processed. When all rows are processed
                         the supplied {@link Runnable} barrier action is executed and merges the
                         rows. If the merger
                         determines that a solution has been found then {@code done()} will return
                         {@code true} and each worker will terminate.
                        
                         &lt;p&gt;If the barrier action does not rely on the parties being suspended when
                         it is executed, then any of the threads in the party could execute that
                         action when it is released. To facilitate this, each invocation of
                         {@link #await} returns the arrival index of that thread at the barrier.
                         You can then choose which thread should execute the barrier action, for
                         example:
                         &lt;pre&gt; {@code
                         if (barrier.await() == 0) {
                           // log the completion of this iteration
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;The {@code CyclicBarrier} uses an all-or-none breakage model
                         for failed synchronization attempts: If a thread leaves a barrier
                         point prematurely because of interruption, failure, or timeout, all
                         other threads waiting at that barrier point will also leave
                         abnormally via {@link BrokenBarrierException} (or
                         {@link InterruptedException} if they too were interrupted at about
                         the same time).
                        
                         &lt;p&gt;Memory consistency effects: Actions in a thread prior to calling
                         {@code await()}
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         actions that are part of the barrier action, which in turn
                         &lt;i&gt;happen-before&lt;/i&gt; actions following a successful return from the
                         corresponding {@code await()} in other threads.
                        
                         @see CountDownLatch
                        
                         @author Doug Lea
                         @since 1.5
                        </javadoc>
                </acts>
                <acts name="DiscardOldestPolicy" access="PUBLIC" declaringClass="ThreadPoolExecutor" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.RejectedExecutionHandler"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                </acts>
                <acts name="CancellationException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.IllegalStateException"/>
                        <superType superType="java.lang.RuntimeException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Exception indicating that the result of a value-producing task,
                         such as a {@link FutureTask}, cannot be retrieved because the task
                         was cancelled.
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="CompletionService" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         A service that decouples the production of new asynchronous tasks
                         from the consumption of the results of completed tasks.  Producers
                         {@code submit} tasks for execution. Consumers {@code take}
                         completed tasks and process their results in the order they
                         complete.  A {@code CompletionService} can for example be used to
                         manage asynchronous I/O, in which tasks that perform reads are
                         submitted in one part of a program or system, and then acted upon
                         in a different part of the program when the reads complete,
                         possibly in a different order than they were requested.
                        
                         &lt;p&gt;Typically, a {@code CompletionService} relies on a separate
                         {@link Executor} to actually execute the tasks, in which case the
                         {@code CompletionService} only manages an internal completion
                         queue. The {@link ExecutorCompletionService} class provides an
                         implementation of this approach.
                        
                         &lt;p&gt;Memory consistency effects: Actions in a thread prior to
                         submitting a task to a {@code CompletionService}
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         actions taken by that task, which in turn &lt;i&gt;happen-before&lt;/i&gt;
                         actions following a successful return from the corresponding {@code take()}.
                        
                         @since 1.5
                        </javadoc>
                </acts>
                <acts name="KeySetView" access="PUBLIC" declaringClass="ConcurrentHashMap" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.Set"/>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.util.concurrent.ConcurrentHashMap$CollectionView"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                </acts>
                <acts name="ConcurrentLinkedQueue" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.Queue"/>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.util.AbstractQueue"/>
                        <superType superType="java.util.AbstractCollection"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An unbounded thread-safe {@linkplain Queue queue} based on linked nodes.
                         This queue orders elements FIFO (first-in-first-out).
                         The &lt;em&gt;head&lt;/em&gt; of the queue is that element that has been on the
                         queue the longest time.
                         The &lt;em&gt;tail&lt;/em&gt; of the queue is that element that has been on the
                         queue the shortest time. New elements
                         are inserted at the tail of the queue, and the queue retrieval
                         operations obtain elements at the head of the queue.
                         A {@code ConcurrentLinkedQueue} is an appropriate choice when
                         many threads will share access to a common collection.
                         Like most other concurrent collection implementations, this class
                         does not permit the use of {@code null} elements.
                        
                         &lt;p&gt;This implementation employs an efficient &lt;em&gt;non-blocking&lt;/em&gt;
                         algorithm based on one described in
                         &lt;a href="http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf"&gt;
                         Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue
                         Algorithms&lt;/a&gt; by Maged M. Michael and Michael L. Scott.
                        
                         &lt;p&gt;Iterators are &lt;i&gt;weakly consistent&lt;/i&gt;, returning elements
                         reflecting the state of the queue at some point at or since the
                         creation of the iterator.  They do &lt;em&gt;not&lt;/em&gt; throw {@link
                         java.util.ConcurrentModificationException}, and may proceed concurrently
                         with other operations.  Elements contained in the queue since the creation
                         of the iterator will be returned exactly once.
                        
                         &lt;p&gt;Beware that, unlike in most collections, the {@code size} method
                         is &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the
                         asynchronous nature of these queues, determining the current number
                         of elements requires a traversal of the elements, and so may report
                         inaccurate results if this collection is modified during traversal.
                        
                         &lt;p&gt;Bulk operations that add, remove, or examine multiple elements,
                         such as {@link #addAll}, {@link #removeIf} or {@link #forEach},
                         are &lt;em&gt;not&lt;/em&gt; guaranteed to be performed atomically.
                         For example, a {@code forEach} traversal concurrent with an {@code
                         addAll} operation might observe only some of the added elements.
                        
                         &lt;p&gt;This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt;
                         methods of the {@link Queue} and {@link Iterator} interfaces.
                        
                         &lt;p&gt;Memory consistency effects: As with other concurrent
                         collections, actions in a thread prior to placing an object into a
                         {@code ConcurrentLinkedQueue}
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         actions subsequent to the access or removal of that element from
                         the {@code ConcurrentLinkedQueue} in another thread.
                        
                         &lt;p&gt;This class is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.5
                         @author Doug Lea
                         @param &lt;E&gt; the type of elements held in this queue
                        </javadoc>
                </acts>
                <acts name="AbstractExecutorService" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.ExecutorService"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Provides default implementations of {@link ExecutorService}
                         execution methods. This class implements the {@code submit},
                         {@code invokeAny} and {@code invokeAll} methods using a
                         {@link RunnableFuture} returned by {@code newTaskFor}, which defaults
                         to the {@link FutureTask} class provided in this package.  For example,
                         the implementation of {@code submit(Runnable)} creates an
                         associated {@code RunnableFuture} that is executed and
                         returned. Subclasses may override the {@code newTaskFor} methods
                         to return {@code RunnableFuture} implementations other than
                         {@code FutureTask}.
                        
                         &lt;p&gt;&lt;b&gt;Extension example&lt;/b&gt;. Here is a sketch of a class
                         that customizes {@link ThreadPoolExecutor} to use
                         a {@code CustomTask} class instead of the default {@code FutureTask}:
                         &lt;pre&gt; {@code
                         public class CustomThreadPoolExecutor extends ThreadPoolExecutor {
                        
                           static class CustomTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {...}
                        
                           protected &lt;V&gt; RunnableFuture&lt;V&gt; newTaskFor(Callable&lt;V&gt; c) {
                               return new CustomTask&lt;V&gt;(c);
                           }
                           protected &lt;V&gt; RunnableFuture&lt;V&gt; newTaskFor(Runnable r, V v) {
                               return new CustomTask&lt;V&gt;(r, v);
                           }
                           // ... add constructors, etc.
                         }}&lt;/pre&gt;
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="CopyOnWriteArrayList" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.List"/>
                        <superType superType="java.util.RandomAccess"/>
                        <superType superType="java.lang.Cloneable"/>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A thread-safe variant of {@link java.util.ArrayList} in which all mutative
                         operations ({@code add}, {@code set}, and so on) are implemented by
                         making a fresh copy of the underlying array.
                        
                         &lt;p&gt;This is ordinarily too costly, but may be &lt;em&gt;more&lt;/em&gt; efficient
                         than alternatives when traversal operations vastly outnumber
                         mutations, and is useful when you cannot or don't want to
                         synchronize traversals, yet need to preclude interference among
                         concurrent threads.  The "snapshot" style iterator method uses a
                         reference to the state of the array at the point that the iterator
                         was created. This array never changes during the lifetime of the
                         iterator, so interference is impossible and the iterator is
                         guaranteed not to throw {@code ConcurrentModificationException}.
                         The iterator will not reflect additions, removals, or changes to
                         the list since the iterator was created.  Element-changing
                         operations on iterators themselves ({@code remove}, {@code set}, and
                         {@code add}) are not supported. These methods throw
                         {@code UnsupportedOperationException}.
                        
                         &lt;p&gt;All elements are permitted, including {@code null}.
                        
                         &lt;p&gt;Memory consistency effects: As with other concurrent
                         collections, actions in a thread prior to placing an object into a
                         {@code CopyOnWriteArrayList}
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         actions subsequent to the access or removal of that element from
                         the {@code CopyOnWriteArrayList} in another thread.
                        
                         &lt;p&gt;This class is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.5
                         @author Doug Lea
                         @param &lt;E&gt; the type of elements held in this list
                        </javadoc>
                </acts>
                <acts name="ForkJoinPool" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.AbstractExecutorService"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An {@link ExecutorService} for running {@link ForkJoinTask}s.
                         A {@code ForkJoinPool} provides the entry point for submissions
                         from non-{@code ForkJoinTask} clients, as well as management and
                         monitoring operations.
                        
                         &lt;p&gt;A {@code ForkJoinPool} differs from other kinds of {@link
                         ExecutorService} mainly by virtue of employing
                         &lt;em&gt;work-stealing&lt;/em&gt;: all threads in the pool attempt to find and
                         execute tasks submitted to the pool and/or created by other active
                         tasks (eventually blocking waiting for work if none exist). This
                         enables efficient processing when most tasks spawn other subtasks
                         (as do most {@code ForkJoinTask}s), as well as when many small
                         tasks are submitted to the pool from external clients.  Especially
                         when setting &lt;em&gt;asyncMode&lt;/em&gt; to true in constructors, {@code
                         ForkJoinPool}s may also be appropriate for use with event-style
                         tasks that are never joined. All worker threads are initialized
                         with {@link Thread#isDaemon} set {@code true}.
                        
                         &lt;p&gt;A static {@link #commonPool()} is available and appropriate for
                         most applications. The common pool is used by any ForkJoinTask that
                         is not explicitly submitted to a specified pool. Using the common
                         pool normally reduces resource usage (its threads are slowly
                         reclaimed during periods of non-use, and reinstated upon subsequent
                         use).
                        
                         &lt;p&gt;For applications that require separate or custom pools, a {@code
                         ForkJoinPool} may be constructed with a given target parallelism
                         level; by default, equal to the number of available processors.
                         The pool attempts to maintain enough active (or available) threads
                         by dynamically adding, suspending, or resuming internal worker
                         threads, even if some tasks are stalled waiting to join others.
                         However, no such adjustments are guaranteed in the face of blocked
                         I/O or other unmanaged synchronization. The nested {@link
                         ManagedBlocker} interface enables extension of the kinds of
                         synchronization accommodated. The default policies may be
                         overridden using a constructor with parameters corresponding to
                         those documented in class {@link ThreadPoolExecutor}.
                        
                         &lt;p&gt;In addition to execution and lifecycle control methods, this
                         class provides status check methods (for example
                         {@link #getStealCount}) that are intended to aid in developing,
                         tuning, and monitoring fork/join applications. Also, method
                         {@link #toString} returns indications of pool state in a
                         convenient form for informal monitoring.
                        
                         &lt;p&gt;As is the case with other ExecutorServices, there are three
                         main task execution methods summarized in the following table.
                         These are designed to be used primarily by clients not already
                         engaged in fork/join computations in the current pool.  The main
                         forms of these methods accept instances of {@code ForkJoinTask},
                         but overloaded forms also allow mixed execution of plain {@code
                         Runnable}- or {@code Callable}- based activities as well.  However,
                         tasks that are already executing in a pool should normally instead
                         use the within-computation forms listed in the table unless using
                         async event-style tasks that are not usually joined, in which case
                         there is little difference among choice of methods.
                        
                         &lt;table class="plain"&gt;
                         &lt;caption&gt;Summary of task execution methods&lt;/caption&gt;
                          &lt;tr&gt;
                            &lt;td&gt;&lt;/td&gt;
                            &lt;th scope="col"&gt; Call from non-fork/join clients&lt;/th&gt;
                            &lt;th scope="col"&gt; Call from within fork/join computations&lt;/th&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th scope="row" style="text-align:left"&gt; Arrange async execution&lt;/th&gt;
                            &lt;td&gt; {@link #execute(ForkJoinTask)}&lt;/td&gt;
                            &lt;td&gt; {@link ForkJoinTask#fork}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th scope="row" style="text-align:left"&gt; Await and obtain result&lt;/th&gt;
                            &lt;td&gt; {@link #invoke(ForkJoinTask)}&lt;/td&gt;
                            &lt;td&gt; {@link ForkJoinTask#invoke}&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                            &lt;th scope="row" style="text-align:left"&gt; Arrange exec and obtain Future&lt;/th&gt;
                            &lt;td&gt; {@link #submit(ForkJoinTask)}&lt;/td&gt;
                            &lt;td&gt; {@link ForkJoinTask#fork} (ForkJoinTasks &lt;em&gt;are&lt;/em&gt; Futures)&lt;/td&gt;
                          &lt;/tr&gt;
                         &lt;/table&gt;
                        
                         &lt;p&gt;The parameters used to construct the common pool may be controlled by
                         setting the following {@linkplain System#getProperty system properties}:
                         &lt;ul&gt;
                         &lt;li&gt;{@code java.util.concurrent.ForkJoinPool.common.parallelism}
                         - the parallelism level, a non-negative integer
                         &lt;li&gt;{@code java.util.concurrent.ForkJoinPool.common.threadFactory}
                         - the class name of a {@link ForkJoinWorkerThreadFactory}.
                         The {@linkplain ClassLoader#getSystemClassLoader() system class loader}
                         is used to load this class.
                         &lt;li&gt;{@code java.util.concurrent.ForkJoinPool.common.exceptionHandler}
                         - the class name of a {@link UncaughtExceptionHandler}.
                         The {@linkplain ClassLoader#getSystemClassLoader() system class loader}
                         is used to load this class.
                         &lt;li&gt;{@code java.util.concurrent.ForkJoinPool.common.maximumSpares}
                         - the maximum number of allowed extra threads to maintain target
                         parallelism (default 256).
                         &lt;/ul&gt;
                         If no thread factory is supplied via a system property, then the
                         common pool uses a factory that uses the system class loader as the
                         {@linkplain Thread#getContextClassLoader() thread context class loader}.
                         In addition, if a {@link SecurityManager} is present, then
                         the common pool uses a factory supplying threads that have no
                         {@link Permissions} enabled.
                        
                         Upon any error in establishing these settings, default parameters
                         are used. It is possible to disable or limit the use of threads in
                         the common pool by setting the parallelism property to zero, and/or
                         using a factory that may return {@code null}. However doing so may
                         cause unjoined tasks to never be executed.
                        
                         &lt;p&gt;&lt;b&gt;Implementation notes&lt;/b&gt;: This implementation restricts the
                         maximum number of running threads to 32767. Attempts to create
                         pools with greater than the maximum number result in
                         {@code IllegalArgumentException}.
                        
                         &lt;p&gt;This implementation rejects submitted tasks (that is, by throwing
                         {@link RejectedExecutionException}) only when the pool is shut down
                         or internal resources have been exhausted.
                        
                         @since 1.7
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="LinkedBlockingDeque" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.BlockingDeque"/>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.util.AbstractQueue"/>
                        <superType superType="java.util.AbstractCollection"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An optionally-bounded {@linkplain BlockingDeque blocking deque} based on
                         linked nodes.
                        
                         &lt;p&gt;The optional capacity bound constructor argument serves as a
                         way to prevent excessive expansion. The capacity, if unspecified,
                         is equal to {@link Integer#MAX_VALUE}.  Linked nodes are
                         dynamically created upon each insertion unless this would bring the
                         deque above capacity.
                        
                         &lt;p&gt;Most operations run in constant time (ignoring time spent
                         blocking).  Exceptions include {@link #remove(Object) remove},
                         {@link #removeFirstOccurrence removeFirstOccurrence}, {@link
                         #removeLastOccurrence removeLastOccurrence}, {@link #contains
                         contains}, {@link #iterator iterator.remove()}, and the bulk
                         operations, all of which run in linear time.
                        
                         &lt;p&gt;This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt;
                         methods of the {@link Collection} and {@link Iterator} interfaces.
                        
                         &lt;p&gt;This class is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.6
                         @author  Doug Lea
                         @param &lt;E&gt; the type of elements held in this deque
                        </javadoc>
                </acts>
                <acts name="ManagedBlocker" access="PUBLIC" declaringClass="ForkJoinPool" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes/>
                </acts>
                <acts name="ExecutorCompletionService" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.CompletionService"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@link CompletionService} that uses a supplied {@link Executor}
                         to execute tasks.  This class arranges that submitted tasks are,
                         upon completion, placed on a queue accessible using {@code take}.
                         The class is lightweight enough to be suitable for transient use
                         when processing groups of tasks.
                        
                         &lt;p&gt;
                        
                         &lt;b&gt;Usage Examples.&lt;/b&gt;
                        
                         Suppose you have a set of solvers for a certain problem, each
                         returning a value of some type {@code Result}, and would like to
                         run them concurrently, processing the results of each of them that
                         return a non-null value, in some method {@code use(Result r)}. You
                         could write this as:
                        
                         &lt;pre&gt; {@code
                         void solve(Executor e,
                                    Collection&lt;Callable&lt;Result&gt;&gt; solvers)
                             throws InterruptedException, ExecutionException {
                           CompletionService&lt;Result&gt; cs
                               = new ExecutorCompletionService&lt;&gt;(e);
                           solvers.forEach(cs::submit);
                           for (int i = solvers.size(); i &gt; 0; i--) {
                             Result r = cs.take().get();
                             if (r != null)
                               use(r);
                           }
                         }}&lt;/pre&gt;
                        
                         Suppose instead that you would like to use the first non-null result
                         of the set of tasks, ignoring any that encounter exceptions,
                         and cancelling all other tasks when the first one is ready:
                        
                         &lt;pre&gt; {@code
                         void solve(Executor e,
                                    Collection&lt;Callable&lt;Result&gt;&gt; solvers)
                             throws InterruptedException {
                           CompletionService&lt;Result&gt; cs
                               = new ExecutorCompletionService&lt;&gt;(e);
                           int n = solvers.size();
                           List&lt;Future&lt;Result&gt;&gt; futures = new ArrayList&lt;&gt;(n);
                           Result result = null;
                           try {
                             solvers.forEach(solver -&gt; futures.add(cs.submit(solver)));
                             for (int i = n; i &gt; 0; i--) {
                               try {
                                 Result r = cs.take().get();
                                 if (r != null) {
                                   result = r;
                                   break;
                                 }
                               } catch (ExecutionException ignore) {}
                             }
                           } finally {
                             futures.forEach(future -&gt; future.cancel(true));
                           }
                        
                           if (result != null)
                             use(result);
                         }}&lt;/pre&gt;
                        
                         @since 1.5
                        </javadoc>
                </acts>
                <acts name="CopyOnWriteArraySet" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.util.AbstractSet"/>
                        <superType superType="java.util.AbstractCollection"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@link Set} that uses an internal {@link CopyOnWriteArrayList}
                         for all of its operations.  Thus, it shares the same basic properties:
                         &lt;ul&gt;
                          &lt;li&gt;It is best suited for applications in which set sizes generally
                               stay small, read-only operations
                               vastly outnumber mutative operations, and you need
                               to prevent interference among threads during traversal.
                          &lt;li&gt;It is thread-safe.
                          &lt;li&gt;Mutative operations ({@code add}, {@code set}, {@code remove}, etc.)
                              are expensive since they usually entail copying the entire underlying
                              array.
                          &lt;li&gt;Iterators do not support the mutative {@code remove} operation.
                          &lt;li&gt;Traversal via iterators is fast and cannot encounter
                              interference from other threads. Iterators rely on
                              unchanging snapshots of the array at the time the iterators were
                              constructed.
                         &lt;/ul&gt;
                        
                         &lt;p&gt;&lt;b&gt;Sample Usage.&lt;/b&gt; The following code sketch uses a
                         copy-on-write set to maintain a set of Handler objects that
                         perform some action upon state updates.
                        
                         &lt;pre&gt; {@code
                         class Handler { void handle(); ... }
                        
                         class X {
                           private final CopyOnWriteArraySet&lt;Handler&gt; handlers
                             = new CopyOnWriteArraySet&lt;&gt;();
                           public void addHandler(Handler h) { handlers.add(h); }
                        
                           private long internalState;
                           private synchronized void changeState() { internalState = ...; }
                        
                           public void update() {
                             changeState();
                             for (Handler handler : handlers)
                               handler.handle();
                           }
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;This class is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @see CopyOnWriteArrayList
                         @since 1.5
                         @author Doug Lea
                         @param &lt;E&gt; the type of elements held in this set
                        </javadoc>
                </acts>
                <acts name="Publisher" access="PUBLIC" declaringClass="Flow" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes/>
                </acts>
                <acts name="Semaphore" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A counting semaphore.  Conceptually, a semaphore maintains a set of
                         permits.  Each {@link #acquire} blocks if necessary until a permit is
                         available, and then takes it.  Each {@link #release} adds a permit,
                         potentially releasing a blocking acquirer.
                         However, no actual permit objects are used; the {@code Semaphore} just
                         keeps a count of the number available and acts accordingly.
                        
                         &lt;p&gt;Semaphores are often used to restrict the number of threads than can
                         access some (physical or logical) resource. For example, here is
                         a class that uses a semaphore to control access to a pool of items:
                         &lt;pre&gt; {@code
                         class Pool {
                           private static final int MAX_AVAILABLE = 100;
                           private final Semaphore available = new Semaphore(MAX_AVAILABLE, true);
                        
                           public Object getItem() throws InterruptedException {
                             available.acquire();
                             return getNextAvailableItem();
                           }
                        
                           public void putItem(Object x) {
                             if (markAsUnused(x))
                               available.release();
                           }
                        
                           // Not a particularly efficient data structure; just for demo
                        
                           protected Object[] items = ... whatever kinds of items being managed
                           protected boolean[] used = new boolean[MAX_AVAILABLE];
                        
                           protected synchronized Object getNextAvailableItem() {
                             for (int i = 0; i &lt; MAX_AVAILABLE; ++i) {
                               if (!used[i]) {
                                 used[i] = true;
                                 return items[i];
                               }
                             }
                             return null; // not reached
                           }
                        
                           protected synchronized boolean markAsUnused(Object item) {
                             for (int i = 0; i &lt; MAX_AVAILABLE; ++i) {
                               if (item == items[i]) {
                                 if (used[i]) {
                                   used[i] = false;
                                   return true;
                                 } else
                                   return false;
                               }
                             }
                             return false;
                           }
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;Before obtaining an item each thread must acquire a permit from
                         the semaphore, guaranteeing that an item is available for use. When
                         the thread has finished with the item it is returned back to the
                         pool and a permit is returned to the semaphore, allowing another
                         thread to acquire that item.  Note that no synchronization lock is
                         held when {@link #acquire} is called as that would prevent an item
                         from being returned to the pool.  The semaphore encapsulates the
                         synchronization needed to restrict access to the pool, separately
                         from any synchronization needed to maintain the consistency of the
                         pool itself.
                        
                         &lt;p&gt;A semaphore initialized to one, and which is used such that it
                         only has at most one permit available, can serve as a mutual
                         exclusion lock.  This is more commonly known as a &lt;em&gt;binary
                         semaphore&lt;/em&gt;, because it only has two states: one permit
                         available, or zero permits available.  When used in this way, the
                         binary semaphore has the property (unlike many {@link java.util.concurrent.locks.Lock}
                         implementations), that the &amp;quot;lock&amp;quot; can be released by a
                         thread other than the owner (as semaphores have no notion of
                         ownership).  This can be useful in some specialized contexts, such
                         as deadlock recovery.
                        
                         &lt;p&gt;The constructor for this class optionally accepts a
                         &lt;em&gt;fairness&lt;/em&gt; parameter. When set false, this class makes no
                         guarantees about the order in which threads acquire permits. In
                         particular, &lt;em&gt;barging&lt;/em&gt; is permitted, that is, a thread
                         invoking {@link #acquire} can be allocated a permit ahead of a
                         thread that has been waiting - logically the new thread places itself at
                         the head of the queue of waiting threads. When fairness is set true, the
                         semaphore guarantees that threads invoking any of the {@link
                         #acquire() acquire} methods are selected to obtain permits in the order in
                         which their invocation of those methods was processed
                         (first-in-first-out; FIFO). Note that FIFO ordering necessarily
                         applies to specific internal points of execution within these
                         methods.  So, it is possible for one thread to invoke
                         {@code acquire} before another, but reach the ordering point after
                         the other, and similarly upon return from the method.
                         Also note that the untimed {@link #tryAcquire() tryAcquire} methods do not
                         honor the fairness setting, but will take any permits that are
                         available.
                        
                         &lt;p&gt;Generally, semaphores used to control resource access should be
                         initialized as fair, to ensure that no thread is starved out from
                         accessing a resource. When using semaphores for other kinds of
                         synchronization control, the throughput advantages of non-fair
                         ordering often outweigh fairness considerations.
                        
                         &lt;p&gt;This class also provides convenience methods to {@link
                         #acquire(int) acquire} and {@link #release(int) release} multiple
                         permits at a time. These methods are generally more efficient and
                         effective than loops. However, they do not establish any preference
                         order. For example, if thread A invokes {@code s.acquire(3}) and
                         thread B invokes {@code s.acquire(2)}, and two permits become
                         available, then there is no guarantee that thread B will obtain
                         them unless its acquire came first and Semaphore {@code s} is in
                         fair mode.
                        
                         &lt;p&gt;Memory consistency effects: Actions in a thread prior to calling
                         a "release" method such as {@code release()}
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         actions following a successful "acquire" method such as {@code acquire()}
                         in another thread.
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="Callable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         A task that returns a result and may throw an exception.
                         Implementors define a single method with no arguments called
                         {@code call}.
                        
                         &lt;p&gt;The {@code Callable} interface is similar to {@link
                         java.lang.Runnable}, in that both are designed for classes whose
                         instances are potentially executed by another thread.  A
                         {@code Runnable}, however, does not return a result and cannot
                         throw a checked exception.
                        
                         &lt;p&gt;The {@link Executors} class contains utility methods to
                         convert from other common forms to {@code Callable} classes.
                        
                         @see Executor
                         @since 1.5
                         @author Doug Lea
                         @param &lt;V&gt; the result type of method {@code call}
                        </javadoc>
                </acts>
                <acts name="LinkedTransferQueue" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.TransferQueue"/>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.util.AbstractQueue"/>
                        <superType superType="java.util.AbstractCollection"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An unbounded {@link TransferQueue} based on linked nodes.
                         This queue orders elements FIFO (first-in-first-out) with respect
                         to any given producer.  The &lt;em&gt;head&lt;/em&gt; of the queue is that
                         element that has been on the queue the longest time for some
                         producer.  The &lt;em&gt;tail&lt;/em&gt; of the queue is that element that has
                         been on the queue the shortest time for some producer.
                        
                         &lt;p&gt;Beware that, unlike in most collections, the {@code size} method
                         is &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the
                         asynchronous nature of these queues, determining the current number
                         of elements requires a traversal of the elements, and so may report
                         inaccurate results if this collection is modified during traversal.
                        
                         &lt;p&gt;Bulk operations that add, remove, or examine multiple elements,
                         such as {@link #addAll}, {@link #removeIf} or {@link #forEach},
                         are &lt;em&gt;not&lt;/em&gt; guaranteed to be performed atomically.
                         For example, a {@code forEach} traversal concurrent with an {@code
                         addAll} operation might observe only some of the added elements.
                        
                         &lt;p&gt;This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt;
                         methods of the {@link Collection} and {@link Iterator} interfaces.
                        
                         &lt;p&gt;Memory consistency effects: As with other concurrent
                         collections, actions in a thread prior to placing an object into a
                         {@code LinkedTransferQueue}
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         actions subsequent to the access or removal of that element from
                         the {@code LinkedTransferQueue} in another thread.
                        
                         &lt;p&gt;This class is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.7
                         @author Doug Lea
                         @param &lt;E&gt; the type of elements held in this queue
                        </javadoc>
                </acts>
                <acts name="CompletableFuture" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.Future"/>
                        <superType superType="java.util.concurrent.CompletionStage"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@link Future} that may be explicitly completed (setting its
                         value and status), and may be used as a {@link CompletionStage},
                         supporting dependent functions and actions that trigger upon its
                         completion.
                        
                         &lt;p&gt;When two or more threads attempt to
                         {@link #complete complete},
                         {@link #completeExceptionally completeExceptionally}, or
                         {@link #cancel cancel}
                         a CompletableFuture, only one of them succeeds.
                        
                         &lt;p&gt;In addition to these and related methods for directly
                         manipulating status and results, CompletableFuture implements
                         interface {@link CompletionStage} with the following policies: &lt;ul&gt;
                        
                         &lt;li&gt;Actions supplied for dependent completions of
                         &lt;em&gt;non-async&lt;/em&gt; methods may be performed by the thread that
                         completes the current CompletableFuture, or by any other caller of
                         a completion method.
                        
                         &lt;li&gt;All &lt;em&gt;async&lt;/em&gt; methods without an explicit Executor
                         argument are performed using the {@link ForkJoinPool#commonPool()}
                         (unless it does not support a parallelism level of at least two, in
                         which case, a new Thread is created to run each task).  This may be
                         overridden for non-static methods in subclasses by defining method
                         {@link #defaultExecutor()}. To simplify monitoring, debugging,
                         and tracking, all generated asynchronous tasks are instances of the
                         marker interface {@link AsynchronousCompletionTask}.  Operations
                         with time-delays can use adapter methods defined in this class, for
                         example: {@code supplyAsync(supplier, delayedExecutor(timeout,
                         timeUnit))}.  To support methods with delays and timeouts, this
                         class maintains at most one daemon thread for triggering and
                         cancelling actions, not for running them.
                        
                         &lt;li&gt;All CompletionStage methods are implemented independently of
                         other public methods, so the behavior of one method is not impacted
                         by overrides of others in subclasses.
                        
                         &lt;li&gt;All CompletionStage methods return CompletableFutures.  To
                         restrict usages to only those methods defined in interface
                         CompletionStage, use method {@link #minimalCompletionStage}. Or to
                         ensure only that clients do not themselves modify a future, use
                         method {@link #copy}.
                         &lt;/ul&gt;
                        
                         &lt;p&gt;CompletableFuture also implements {@link Future} with the following
                         policies: &lt;ul&gt;
                        
                         &lt;li&gt;Since (unlike {@link FutureTask}) this class has no direct
                         control over the computation that causes it to be completed,
                         cancellation is treated as just another form of exceptional
                         completion.  Method {@link #cancel cancel} has the same effect as
                         {@code completeExceptionally(new CancellationException())}. Method
                         {@link #isCompletedExceptionally} can be used to determine if a
                         CompletableFuture completed in any exceptional fashion.
                        
                         &lt;li&gt;In case of exceptional completion with a CompletionException,
                         methods {@link #get()} and {@link #get(long, TimeUnit)} throw an
                         {@link ExecutionException} with the same cause as held in the
                         corresponding CompletionException.  To simplify usage in most
                         contexts, this class also defines methods {@link #join()} and
                         {@link #getNow} that instead throw the CompletionException directly
                         in these cases.
                         &lt;/ul&gt;
                        
                         &lt;p&gt;Arguments used to pass a completion result (that is, for
                         parameters of type {@code T}) for methods accepting them may be
                         null, but passing a null value for any other parameter will result
                         in a {@link NullPointerException} being thrown.
                        
                         &lt;p&gt;Subclasses of this class should normally override the "virtual
                         constructor" method {@link #newIncompleteFuture}, which establishes
                         the concrete type returned by CompletionStage methods. For example,
                         here is a class that substitutes a different default Executor and
                         disables the {@code obtrude} methods:
                        
                         &lt;pre&gt; {@code
                         class MyCompletableFuture&lt;T&gt; extends CompletableFuture&lt;T&gt; {
                           static final Executor myExecutor = ...;
                           public MyCompletableFuture() { }
                           public &lt;U&gt; CompletableFuture&lt;U&gt; newIncompleteFuture() {
                             return new MyCompletableFuture&lt;U&gt;(); }
                           public Executor defaultExecutor() {
                             return myExecutor; }
                           public void obtrudeValue(T value) {
                             throw new UnsupportedOperationException(); }
                           public void obtrudeException(Throwable ex) {
                             throw new UnsupportedOperationException(); }
                         }}&lt;/pre&gt;
                        
                         @author Doug Lea
                         @param &lt;T&gt; The result type returned by this future's {@code join}
                         and {@code get} methods
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="Executor" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         An object that executes submitted {@link Runnable} tasks. This
                         interface provides a way of decoupling task submission from the
                         mechanics of how each task will be run, including details of thread
                         use, scheduling, etc.  An {@code Executor} is normally used
                         instead of explicitly creating threads. For example, rather than
                         invoking {@code new Thread(new RunnableTask()).start()} for each
                         of a set of tasks, you might use:
                        
                         &lt;pre&gt; {@code
                         Executor executor = anExecutor();
                         executor.execute(new RunnableTask1());
                         executor.execute(new RunnableTask2());
                         ...}&lt;/pre&gt;
                        
                         However, the {@code Executor} interface does not strictly require
                         that execution be asynchronous. In the simplest case, an executor
                         can run the submitted task immediately in the caller's thread:
                        
                         &lt;pre&gt; {@code
                         class DirectExecutor implements Executor {
                           public void execute(Runnable r) {
                             r.run();
                           }
                         }}&lt;/pre&gt;
                        
                         More typically, tasks are executed in some thread other than the
                         caller's thread.  The executor below spawns a new thread for each
                         task.
                        
                         &lt;pre&gt; {@code
                         class ThreadPerTaskExecutor implements Executor {
                           public void execute(Runnable r) {
                             new Thread(r).start();
                           }
                         }}&lt;/pre&gt;
                        
                         Many {@code Executor} implementations impose some sort of
                         limitation on how and when tasks are scheduled.  The executor below
                         serializes the submission of tasks to a second executor,
                         illustrating a composite executor.
                        
                         &lt;pre&gt; {@code
                         class SerialExecutor implements Executor {
                           final Queue&lt;Runnable&gt; tasks = new ArrayDeque&lt;&gt;();
                           final Executor executor;
                           Runnable active;
                        
                           SerialExecutor(Executor executor) {
                             this.executor = executor;
                           }
                        
                           public synchronized void execute(Runnable r) {
                             tasks.add(() -&gt; {
                               try {
                                 r.run();
                               } finally {
                                 scheduleNext();
                               }
                             });
                             if (active == null) {
                               scheduleNext();
                             }
                           }
                        
                           protected synchronized void scheduleNext() {
                             if ((active = tasks.poll()) != null) {
                               executor.execute(active);
                             }
                           }
                         }}&lt;/pre&gt;
                        
                         The {@code Executor} implementations provided in this package
                         implement {@link ExecutorService}, which is a more extensive
                         interface.  The {@link ThreadPoolExecutor} class provides an
                         extensible thread pool implementation. The {@link Executors} class
                         provides convenient factory methods for these Executors.
                        
                         &lt;p&gt;Memory consistency effects: Actions in a thread prior to
                         submitting a {@code Runnable} object to an {@code Executor}
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         its execution begins, perhaps in another thread.
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="FutureTask" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.RunnableFuture"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A cancellable asynchronous computation.  This class provides a base
                         implementation of {@link Future}, with methods to start and cancel
                         a computation, query to see if the computation is complete, and
                         retrieve the result of the computation.  The result can only be
                         retrieved when the computation has completed; the {@code get}
                         methods will block if the computation has not yet completed.  Once
                         the computation has completed, the computation cannot be restarted
                         or cancelled (unless the computation is invoked using
                         {@link #runAndReset}).
                        
                         &lt;p&gt;A {@code FutureTask} can be used to wrap a {@link Callable} or
                         {@link Runnable} object.  Because {@code FutureTask} implements
                         {@code Runnable}, a {@code FutureTask} can be submitted to an
                         {@link Executor} for execution.
                        
                         &lt;p&gt;In addition to serving as a standalone class, this class provides
                         {@code protected} functionality that may be useful when creating
                         customized task classes.
                        
                         @since 1.5
                         @author Doug Lea
                         @param &lt;V&gt; The result type returned by this FutureTask's {@code get} methods
                        </javadoc>
                </acts>
                <acts name="ForkJoinWorkerThread" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.Thread"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A thread managed by a {@link ForkJoinPool}, which executes
                         {@link ForkJoinTask}s.
                         This class is subclassable solely for the sake of adding
                         functionality -- there are no overridable methods dealing with
                         scheduling or execution.  However, you can override initialization
                         and termination methods surrounding the main task processing loop.
                         If you do create such a subclass, you will also need to supply a
                         custom {@link ForkJoinPool.ForkJoinWorkerThreadFactory} to
                         {@linkplain ForkJoinPool#ForkJoinPool(int, ForkJoinWorkerThreadFactory,
                         UncaughtExceptionHandler, boolean, int, int, int, Predicate, long, TimeUnit)
                         use it} in a {@code ForkJoinPool}.
                        
                         @since 1.7
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="ThreadLocalRandom" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.Random"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A random number generator isolated to the current thread.  Like the
                         global {@link java.util.Random} generator used by the {@link
                         java.lang.Math} class, a {@code ThreadLocalRandom} is initialized
                         with an internally generated seed that may not otherwise be
                         modified. When applicable, use of {@code ThreadLocalRandom} rather
                         than shared {@code Random} objects in concurrent programs will
                         typically encounter much less overhead and contention.  Use of
                         {@code ThreadLocalRandom} is particularly appropriate when multiple
                         tasks (for example, each a {@link ForkJoinTask}) use random numbers
                         in parallel in thread pools.
                        
                         &lt;p&gt;Usages of this class should typically be of the form:
                         {@code ThreadLocalRandom.current().nextX(...)} (where
                         {@code X} is {@code Int}, {@code Long}, etc).
                         When all usages are of this form, it is never possible to
                         accidentally share a {@code ThreadLocalRandom} across multiple threads.
                        
                         &lt;p&gt;This class also provides additional commonly used bounded random
                         generation methods.
                        
                         &lt;p&gt;Instances of {@code ThreadLocalRandom} are not cryptographically
                         secure.  Consider instead using {@link java.security.SecureRandom}
                         in security-sensitive applications. Additionally,
                         default-constructed instances do not use a cryptographically random
                         seed unless the {@linkplain System#getProperty system property}
                         {@code java.util.secureRandomSeed} is set to {@code true}.
                        
                         @since 1.7
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="Processor" access="PUBLIC" declaringClass="Flow" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.Flow$Subscriber"/>
                        <superType superType="java.util.concurrent.Flow$Publisher"/>
                    </superTypes>
                </acts>
                <acts name="ConcurrentHashMap" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.ConcurrentMap"/>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.util.AbstractMap"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A hash table supporting full concurrency of retrievals and
                         high expected concurrency for updates. This class obeys the
                         same functional specification as {@link java.util.Hashtable}, and
                         includes versions of methods corresponding to each method of
                         {@code Hashtable}. However, even though all operations are
                         thread-safe, retrieval operations do &lt;em&gt;not&lt;/em&gt; entail locking,
                         and there is &lt;em&gt;not&lt;/em&gt; any support for locking the entire table
                         in a way that prevents all access.  This class is fully
                         interoperable with {@code Hashtable} in programs that rely on its
                         thread safety but not on its synchronization details.
                        
                         &lt;p&gt;Retrieval operations (including {@code get}) generally do not
                         block, so may overlap with update operations (including {@code put}
                         and {@code remove}). Retrievals reflect the results of the most
                         recently &lt;em&gt;completed&lt;/em&gt; update operations holding upon their
                         onset. (More formally, an update operation for a given key bears a
                         &lt;em&gt;happens-before&lt;/em&gt; relation with any (non-null) retrieval for
                         that key reporting the updated value.)  For aggregate operations
                         such as {@code putAll} and {@code clear}, concurrent retrievals may
                         reflect insertion or removal of only some entries.  Similarly,
                         Iterators, Spliterators and Enumerations return elements reflecting the
                         state of the hash table at some point at or since the creation of the
                         iterator/enumeration.  They do &lt;em&gt;not&lt;/em&gt; throw {@link
                         java.util.ConcurrentModificationException ConcurrentModificationException}.
                         However, iterators are designed to be used by only one thread at a time.
                         Bear in mind that the results of aggregate status methods including
                         {@code size}, {@code isEmpty}, and {@code containsValue} are typically
                         useful only when a map is not undergoing concurrent updates in other threads.
                         Otherwise the results of these methods reflect transient states
                         that may be adequate for monitoring or estimation purposes, but not
                         for program control.
                        
                         &lt;p&gt;The table is dynamically expanded when there are too many
                         collisions (i.e., keys that have distinct hash codes but fall into
                         the same slot modulo the table size), with the expected average
                         effect of maintaining roughly two bins per mapping (corresponding
                         to a 0.75 load factor threshold for resizing). There may be much
                         variance around this average as mappings are added and removed, but
                         overall, this maintains a commonly accepted time/space tradeoff for
                         hash tables.  However, resizing this or any other kind of hash
                         table may be a relatively slow operation. When possible, it is a
                         good idea to provide a size estimate as an optional {@code
                         initialCapacity} constructor argument. An additional optional
                         {@code loadFactor} constructor argument provides a further means of
                         customizing initial table capacity by specifying the table density
                         to be used in calculating the amount of space to allocate for the
                         given number of elements.  Also, for compatibility with previous
                         versions of this class, constructors may optionally specify an
                         expected {@code concurrencyLevel} as an additional hint for
                         internal sizing.  Note that using many keys with exactly the same
                         {@code hashCode()} is a sure way to slow down performance of any
                         hash table. To ameliorate impact, when keys are {@link Comparable},
                         this class may use comparison order among keys to help break ties.
                        
                         &lt;p&gt;A {@link Set} projection of a ConcurrentHashMap may be created
                         (using {@link #newKeySet()} or {@link #newKeySet(int)}), or viewed
                         (using {@link #keySet(Object)} when only keys are of interest, and the
                         mapped values are (perhaps transiently) not used or all take the
                         same mapping value.
                        
                         &lt;p&gt;A ConcurrentHashMap can be used as a scalable frequency map (a
                         form of histogram or multiset) by using {@link
                         java.util.concurrent.atomic.LongAdder} values and initializing via
                         {@link #computeIfAbsent computeIfAbsent}. For example, to add a count
                         to a {@code ConcurrentHashMap&lt;String,LongAdder&gt; freqs}, you can use
                         {@code freqs.computeIfAbsent(key, k -&gt; new LongAdder()).increment();}
                        
                         &lt;p&gt;This class and its views and iterators implement all of the
                         &lt;em&gt;optional&lt;/em&gt; methods of the {@link Map} and {@link Iterator}
                         interfaces.
                        
                         &lt;p&gt;Like {@link Hashtable} but unlike {@link HashMap}, this class
                         does &lt;em&gt;not&lt;/em&gt; allow {@code null} to be used as a key or value.
                        
                         &lt;p&gt;ConcurrentHashMaps support a set of sequential and parallel bulk
                         operations that, unlike most {@link Stream} methods, are designed
                         to be safely, and often sensibly, applied even with maps that are
                         being concurrently updated by other threads; for example, when
                         computing a snapshot summary of the values in a shared registry.
                         There are three kinds of operation, each with four forms, accepting
                         functions with keys, values, entries, and (key, value) pairs as
                         arguments and/or return values. Because the elements of a
                         ConcurrentHashMap are not ordered in any particular way, and may be
                         processed in different orders in different parallel executions, the
                         correctness of supplied functions should not depend on any
                         ordering, or on any other objects or values that may transiently
                         change while computation is in progress; and except for forEach
                         actions, should ideally be side-effect-free. Bulk operations on
                         {@link Map.Entry} objects do not support method {@code setValue}.
                        
                         &lt;ul&gt;
                         &lt;li&gt;forEach: Performs a given action on each element.
                         A variant form applies a given transformation on each element
                         before performing the action.
                        
                         &lt;li&gt;search: Returns the first available non-null result of
                         applying a given function on each element; skipping further
                         search when a result is found.
                        
                         &lt;li&gt;reduce: Accumulates each element.  The supplied reduction
                         function cannot rely on ordering (more formally, it should be
                         both associative and commutative).  There are five variants:
                        
                         &lt;ul&gt;
                        
                         &lt;li&gt;Plain reductions. (There is not a form of this method for
                         (key, value) function arguments since there is no corresponding
                         return type.)
                        
                         &lt;li&gt;Mapped reductions that accumulate the results of a given
                         function applied to each element.
                        
                         &lt;li&gt;Reductions to scalar doubles, longs, and ints, using a
                         given basis value.
                        
                         &lt;/ul&gt;
                         &lt;/ul&gt;
                        
                         &lt;p&gt;These bulk operations accept a {@code parallelismThreshold}
                         argument. Methods proceed sequentially if the current map size is
                         estimated to be less than the given threshold. Using a value of
                         {@code Long.MAX_VALUE} suppresses all parallelism.  Using a value
                         of {@code 1} results in maximal parallelism by partitioning into
                         enough subtasks to fully utilize the {@link
                         ForkJoinPool#commonPool()} that is used for all parallel
                         computations. Normally, you would initially choose one of these
                         extreme values, and then measure performance of using in-between
                         values that trade off overhead versus throughput.
                        
                         &lt;p&gt;The concurrency properties of bulk operations follow
                         from those of ConcurrentHashMap: Any non-null result returned
                         from {@code get(key)} and related access methods bears a
                         happens-before relation with the associated insertion or
                         update.  The result of any bulk operation reflects the
                         composition of these per-element relations (but is not
                         necessarily atomic with respect to the map as a whole unless it
                         is somehow known to be quiescent).  Conversely, because keys
                         and values in the map are never null, null serves as a reliable
                         atomic indicator of the current lack of any result.  To
                         maintain this property, null serves as an implicit basis for
                         all non-scalar reduction operations. For the double, long, and
                         int versions, the basis should be one that, when combined with
                         any other value, returns that other value (more formally, it
                         should be the identity element for the reduction). Most common
                         reductions have these properties; for example, computing a sum
                         with basis 0 or a minimum with basis MAX_VALUE.
                        
                         &lt;p&gt;Search and transformation functions provided as arguments
                         should similarly return null to indicate the lack of any result
                         (in which case it is not used). In the case of mapped
                         reductions, this also enables transformations to serve as
                         filters, returning null (or, in the case of primitive
                         specializations, the identity basis) if the element should not
                         be combined. You can create compound transformations and
                         filterings by composing them yourself under this "null means
                         there is nothing there now" rule before using them in search or
                         reduce operations.
                        
                         &lt;p&gt;Methods accepting and/or returning Entry arguments maintain
                         key-value associations. They may be useful for example when
                         finding the key for the greatest value. Note that "plain" Entry
                         arguments can be supplied using {@code new
                         AbstractMap.SimpleEntry(k,v)}.
                        
                         &lt;p&gt;Bulk operations may complete abruptly, throwing an
                         exception encountered in the application of a supplied
                         function. Bear in mind when handling such exceptions that other
                         concurrently executing functions could also have thrown
                         exceptions, or would have done so if the first exception had
                         not occurred.
                        
                         &lt;p&gt;Speedups for parallel compared to sequential forms are common
                         but not guaranteed.  Parallel operations involving brief functions
                         on small maps may execute more slowly than sequential forms if the
                         underlying work to parallelize the computation is more expensive
                         than the computation itself.  Similarly, parallelization may not
                         lead to much actual parallelism if all processors are busy
                         performing unrelated tasks.
                        
                         &lt;p&gt;All arguments to all task methods must be non-null.
                        
                         &lt;p&gt;This class is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.5
                         @author Doug Lea
                         @param &lt;K&gt; the type of keys maintained by this map
                         @param &lt;V&gt; the type of mapped values
                        </javadoc>
                </acts>
                <acts name="ExecutionException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Exception thrown when attempting to retrieve the result of a task
                         that aborted by throwing an exception. This exception can be
                         inspected using the {@link #getCause()} method.
                        
                         @see Future
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="CompletionStage" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         A stage of a possibly asynchronous computation, that performs an
                         action or computes a value when another CompletionStage completes.
                         A stage completes upon termination of its computation, but this may
                         in turn trigger other dependent stages.  The functionality defined
                         in this interface takes only a few basic forms, which expand out to
                         a larger set of methods to capture a range of usage styles:
                        
                         &lt;ul&gt;
                        
                         &lt;li&gt;The computation performed by a stage may be expressed as a
                         Function, Consumer, or Runnable (using methods with names including
                         &lt;em&gt;apply&lt;/em&gt;, &lt;em&gt;accept&lt;/em&gt;, or &lt;em&gt;run&lt;/em&gt;, respectively)
                         depending on whether it requires arguments and/or produces results.
                         For example:
                         &lt;pre&gt; {@code
                         stage.thenApply(x -&gt; square(x))
                              .thenAccept(x -&gt; System.out.print(x))
                              .thenRun(() -&gt; System.out.println());}&lt;/pre&gt;
                        
                         An additional form (&lt;em&gt;compose&lt;/em&gt;) allows the construction of
                         computation pipelines from functions returning completion stages.
                        
                         &lt;p&gt;Any argument to a stage's computation is the outcome of a
                         triggering stage's computation.
                        
                         &lt;li&gt;One stage's execution may be triggered by completion of a
                         single stage, or both of two stages, or either of two stages.
                         Dependencies on a single stage are arranged using methods with
                         prefix &lt;em&gt;then&lt;/em&gt;. Those triggered by completion of
                         &lt;em&gt;both&lt;/em&gt; of two stages may &lt;em&gt;combine&lt;/em&gt; their results or
                         effects, using correspondingly named methods. Those triggered by
                         &lt;em&gt;either&lt;/em&gt; of two stages make no guarantees about which of the
                         results or effects are used for the dependent stage's computation.
                        
                         &lt;li&gt;Dependencies among stages control the triggering of
                         computations, but do not otherwise guarantee any particular
                         ordering. Additionally, execution of a new stage's computations may
                         be arranged in any of three ways: default execution, default
                         asynchronous execution (using methods with suffix &lt;em&gt;async&lt;/em&gt;
                         that employ the stage's default asynchronous execution facility),
                         or custom (via a supplied {@link Executor}).  The execution
                         properties of default and async modes are specified by
                         CompletionStage implementations, not this interface. Methods with
                         explicit Executor arguments may have arbitrary execution
                         properties, and might not even support concurrent execution, but
                         are arranged for processing in a way that accommodates asynchrony.
                        
                         &lt;li&gt;Two method forms ({@link #handle handle} and {@link
                         #whenComplete whenComplete}) support unconditional computation
                         whether the triggering stage completed normally or exceptionally.
                         Method {@link #exceptionally exceptionally} supports computation
                         only when the triggering stage completes exceptionally, computing a
                         replacement result, similarly to the java {@code catch} keyword.
                         In all other cases, if a stage's computation terminates abruptly
                         with an (unchecked) exception or error, then all dependent stages
                         requiring its completion complete exceptionally as well, with a
                         {@link CompletionException} holding the exception as its cause.  If
                         a stage is dependent on &lt;em&gt;both&lt;/em&gt; of two stages, and both
                         complete exceptionally, then the CompletionException may correspond
                         to either one of these exceptions.  If a stage is dependent on
                         &lt;em&gt;either&lt;/em&gt; of two others, and only one of them completes
                         exceptionally, no guarantees are made about whether the dependent
                         stage completes normally or exceptionally. In the case of method
                         {@code whenComplete}, when the supplied action itself encounters an
                         exception, then the stage completes exceptionally with this
                         exception unless the source stage also completed exceptionally, in
                         which case the exceptional completion from the source stage is
                         given preference and propagated to the dependent stage.
                        
                         &lt;/ul&gt;
                        
                         &lt;p&gt;All methods adhere to the above triggering, execution, and
                         exceptional completion specifications (which are not repeated in
                         individual method specifications). Additionally, while arguments
                         used to pass a completion result (that is, for parameters of type
                         {@code T}) for methods accepting them may be null, passing a null
                         value for any other parameter will result in a {@link
                         NullPointerException} being thrown.
                        
                         &lt;p&gt;Method form {@link #handle handle} is the most general way of
                         creating a continuation stage, unconditionally performing a
                         computation that is given both the result and exception (if any) of
                         the triggering CompletionStage, and computing an arbitrary result.
                         Method {@link #whenComplete whenComplete} is similar, but preserves
                         the result of the triggering stage instead of computing a new one.
                         Because a stage's normal result may be {@code null}, both methods
                         should have a computation structured thus:
                        
                         &lt;pre&gt;{@code (result, exception) -&gt; {
                           if (exception == null) {
                             // triggering stage completed normally
                           } else {
                             // triggering stage completed exceptionally
                           }
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;This interface does not define methods for initially creating,
                         forcibly completing normally or exceptionally, probing completion
                         status or results, or awaiting completion of a stage.
                         Implementations of CompletionStage may provide means of achieving
                         such effects, as appropriate.  Method {@link #toCompletableFuture}
                         enables interoperability among different implementations of this
                         interface by providing a common conversion type.
                        
                         @author Doug Lea
                         @since 1.8
                        </javadoc>
                </acts>
                <acts name="ConcurrentNavigableMap" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.ConcurrentMap"/>
                        <superType superType="java.util.NavigableMap"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@link ConcurrentMap} supporting {@link NavigableMap} operations,
                         and recursively so for its navigable sub-maps.
                        
                         &lt;p&gt;This interface is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @author Doug Lea
                         @param &lt;K&gt; the type of keys maintained by this map
                         @param &lt;V&gt; the type of mapped values
                         @since 1.6
                        </javadoc>
                </acts>
                <acts name="ConcurrentSkipListMap" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.ConcurrentNavigableMap"/>
                        <superType superType="java.lang.Cloneable"/>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.util.AbstractMap"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A scalable concurrent {@link ConcurrentNavigableMap} implementation.
                         The map is sorted according to the {@linkplain Comparable natural
                         ordering} of its keys, or by a {@link Comparator} provided at map
                         creation time, depending on which constructor is used.
                        
                         &lt;p&gt;This class implements a concurrent variant of &lt;a
                         href="http://en.wikipedia.org/wiki/Skip_list" target="_top"&gt;SkipLists&lt;/a&gt;
                         providing expected average &lt;i&gt;log(n)&lt;/i&gt; time cost for the
                         {@code containsKey}, {@code get}, {@code put} and
                         {@code remove} operations and their variants.  Insertion, removal,
                         update, and access operations safely execute concurrently by
                         multiple threads.
                        
                         &lt;p&gt;Iterators and spliterators are
                         &lt;a href="package-summary.html#Weakly"&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
                        
                         &lt;p&gt;Ascending key ordered views and their iterators are faster than
                         descending ones.
                        
                         &lt;p&gt;All {@code Map.Entry} pairs returned by methods in this class
                         and its views represent snapshots of mappings at the time they were
                         produced. They do &lt;em&gt;not&lt;/em&gt; support the {@code Entry.setValue}
                         method. (Note however that it is possible to change mappings in the
                         associated map using {@code put}, {@code putIfAbsent}, or
                         {@code replace}, depending on exactly which effect you need.)
                        
                         &lt;p&gt;Beware that bulk operations {@code putAll}, {@code equals},
                         {@code toArray}, {@code containsValue}, and {@code clear} are
                         &lt;em&gt;not&lt;/em&gt; guaranteed to be performed atomically. For example, an
                         iterator operating concurrently with a {@code putAll} operation
                         might view only some of the added elements.
                        
                         &lt;p&gt;This class and its views and iterators implement all of the
                         &lt;em&gt;optional&lt;/em&gt; methods of the {@link Map} and {@link Iterator}
                         interfaces. Like most other concurrent collections, this class does
                         &lt;em&gt;not&lt;/em&gt; permit the use of {@code null} keys or values because some
                         null return values cannot be reliably distinguished from the absence of
                         elements.
                        
                         &lt;p&gt;This class is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @author Doug Lea
                         @param &lt;K&gt; the type of keys maintained by this map
                         @param &lt;V&gt; the type of mapped values
                         @since 1.6
                        </javadoc>
                </acts>
                <acts name="Delayed" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.Comparable"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A mix-in style interface for marking objects that should be
                         acted upon after a given delay.
                        
                         &lt;p&gt;An implementation of this interface must define a
                         {@code compareTo} method that provides an ordering consistent with
                         its {@code getDelay} method.
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="ConcurrentSkipListSet" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.NavigableSet"/>
                        <superType superType="java.lang.Cloneable"/>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.util.AbstractSet"/>
                        <superType superType="java.util.AbstractCollection"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A scalable concurrent {@link NavigableSet} implementation based on
                         a {@link ConcurrentSkipListMap}.  The elements of the set are kept
                         sorted according to their {@linkplain Comparable natural ordering},
                         or by a {@link Comparator} provided at set creation time, depending
                         on which constructor is used.
                        
                         &lt;p&gt;This implementation provides expected average &lt;i&gt;log(n)&lt;/i&gt; time
                         cost for the {@code contains}, {@code add}, and {@code remove}
                         operations and their variants.  Insertion, removal, and access
                         operations safely execute concurrently by multiple threads.
                        
                         &lt;p&gt;Iterators and spliterators are
                         &lt;a href="package-summary.html#Weakly"&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
                        
                         &lt;p&gt;Ascending ordered views and their iterators are faster than
                         descending ones.
                        
                         &lt;p&gt;Beware that, unlike in most collections, the {@code size}
                         method is &lt;em&gt;not&lt;/em&gt; a constant-time operation. Because of the
                         asynchronous nature of these sets, determining the current number
                         of elements requires a traversal of the elements, and so may report
                         inaccurate results if this collection is modified during traversal.
                        
                         &lt;p&gt;Bulk operations that add, remove, or examine multiple elements,
                         such as {@link #addAll}, {@link #removeIf} or {@link #forEach},
                         are &lt;em&gt;not&lt;/em&gt; guaranteed to be performed atomically.
                         For example, a {@code forEach} traversal concurrent with an {@code
                         addAll} operation might observe only some of the added elements.
                        
                         &lt;p&gt;This class and its iterators implement all of the
                         &lt;em&gt;optional&lt;/em&gt; methods of the {@link Set} and {@link Iterator}
                         interfaces. Like most other concurrent collection implementations,
                         this class does not permit the use of {@code null} elements,
                         because {@code null} arguments and return values cannot be reliably
                         distinguished from the absence of elements.
                        
                         &lt;p&gt;This class is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @author Doug Lea
                         @param &lt;E&gt; the type of elements maintained by this set
                         @since 1.6
                        </javadoc>
                </acts>
                <acts name="RejectedExecutionHandler" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         A handler for tasks that cannot be executed by a {@link ThreadPoolExecutor}.
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="DiscardPolicy" access="PUBLIC" declaringClass="ThreadPoolExecutor" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.RejectedExecutionHandler"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                </acts>
                <acts name="AbortPolicy" access="PUBLIC" declaringClass="ThreadPoolExecutor" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.RejectedExecutionHandler"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                </acts>
                <acts name="CountDownLatch" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A synchronization aid that allows one or more threads to wait until
                         a set of operations being performed in other threads completes.
                        
                         &lt;p&gt;A {@code CountDownLatch} is initialized with a given &lt;em&gt;count&lt;/em&gt;.
                         The {@link #await await} methods block until the current count reaches
                         zero due to invocations of the {@link #countDown} method, after which
                         all waiting threads are released and any subsequent invocations of
                         {@link #await await} return immediately.  This is a one-shot phenomenon
                         -- the count cannot be reset.  If you need a version that resets the
                         count, consider using a {@link CyclicBarrier}.
                        
                         &lt;p&gt;A {@code CountDownLatch} is a versatile synchronization tool
                         and can be used for a number of purposes.  A
                         {@code CountDownLatch} initialized with a count of one serves as a
                         simple on/off latch, or gate: all threads invoking {@link #await await}
                         wait at the gate until it is opened by a thread invoking {@link
                         #countDown}.  A {@code CountDownLatch} initialized to &lt;em&gt;N&lt;/em&gt;
                         can be used to make one thread wait until &lt;em&gt;N&lt;/em&gt; threads have
                         completed some action, or some action has been completed N times.
                        
                         &lt;p&gt;A useful property of a {@code CountDownLatch} is that it
                         doesn't require that threads calling {@code countDown} wait for
                         the count to reach zero before proceeding, it simply prevents any
                         thread from proceeding past an {@link #await await} until all
                         threads could pass.
                        
                         &lt;p&gt;&lt;b&gt;Sample usage:&lt;/b&gt; Here is a pair of classes in which a group
                         of worker threads use two countdown latches:
                         &lt;ul&gt;
                         &lt;li&gt;The first is a start signal that prevents any worker from proceeding
                         until the driver is ready for them to proceed;
                         &lt;li&gt;The second is a completion signal that allows the driver to wait
                         until all workers have completed.
                         &lt;/ul&gt;
                        
                         &lt;pre&gt; {@code
                         class Driver { // ...
                           void main() throws InterruptedException {
                             CountDownLatch startSignal = new CountDownLatch(1);
                             CountDownLatch doneSignal = new CountDownLatch(N);
                        
                             for (int i = 0; i &lt; N; ++i) // create and start threads
                               new Thread(new Worker(startSignal, doneSignal)).start();
                        
                             doSomethingElse();            // don't let run yet
                             startSignal.countDown();      // let all threads proceed
                             doSomethingElse();
                             doneSignal.await();           // wait for all to finish
                           }
                         }
                        
                         class Worker implements Runnable {
                           private final CountDownLatch startSignal;
                           private final CountDownLatch doneSignal;
                           Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
                             this.startSignal = startSignal;
                             this.doneSignal = doneSignal;
                           }
                           public void run() {
                             try {
                               startSignal.await();
                               doWork();
                               doneSignal.countDown();
                             } catch (InterruptedException ex) {} // return;
                           }
                        
                           void doWork() { ... }
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;Another typical usage would be to divide a problem into N parts,
                         describe each part with a Runnable that executes that portion and
                         counts down on the latch, and queue all the Runnables to an
                         Executor.  When all sub-parts are complete, the coordinating thread
                         will be able to pass through await. (When threads must repeatedly
                         count down in this way, instead use a {@link CyclicBarrier}.)
                        
                         &lt;pre&gt; {@code
                         class Driver2 { // ...
                           void main() throws InterruptedException {
                             CountDownLatch doneSignal = new CountDownLatch(N);
                             Executor e = ...
                        
                             for (int i = 0; i &lt; N; ++i) // create and start threads
                               e.execute(new WorkerRunnable(doneSignal, i));
                        
                             doneSignal.await();           // wait for all to finish
                           }
                         }
                        
                         class WorkerRunnable implements Runnable {
                           private final CountDownLatch doneSignal;
                           private final int i;
                           WorkerRunnable(CountDownLatch doneSignal, int i) {
                             this.doneSignal = doneSignal;
                             this.i = i;
                           }
                           public void run() {
                             try {
                               doWork(i);
                               doneSignal.countDown();
                             } catch (InterruptedException ex) {} // return;
                           }
                        
                           void doWork() { ... }
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;Memory consistency effects: Until the count reaches
                         zero, actions in a thread prior to calling
                         {@code countDown()}
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         actions following a successful return from a corresponding
                         {@code await()} in another thread.
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="RejectedExecutionException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.RuntimeException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Exception thrown by an {@link Executor} when a task cannot be
                         accepted for execution.
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="ScheduledFuture" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.Delayed"/>
                        <superType superType="java.util.concurrent.Future"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A delayed result-bearing action that can be cancelled.
                         Usually a scheduled future is the result of scheduling
                         a task with a {@link ScheduledExecutorService}.
                        
                         @since 1.5
                         @author Doug Lea
                         @param &lt;V&gt; The result type returned by this Future
                        </javadoc>
                </acts>
                <acts name="ConcurrentLinkedDeque" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.Deque"/>
                        <superType superType="java.io.Serializable"/>
                        <superType superType="java.util.AbstractCollection"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An unbounded concurrent {@linkplain Deque deque} based on linked nodes.
                         Concurrent insertion, removal, and access operations execute safely
                         across multiple threads.
                         A {@code ConcurrentLinkedDeque} is an appropriate choice when
                         many threads will share access to a common collection.
                         Like most other concurrent collection implementations, this class
                         does not permit the use of {@code null} elements.
                        
                         &lt;p&gt;Iterators and spliterators are
                         &lt;a href="package-summary.html#Weakly"&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
                        
                         &lt;p&gt;Beware that, unlike in most collections, the {@code size} method
                         is &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the
                         asynchronous nature of these deques, determining the current number
                         of elements requires a traversal of the elements, and so may report
                         inaccurate results if this collection is modified during traversal.
                        
                         &lt;p&gt;Bulk operations that add, remove, or examine multiple elements,
                         such as {@link #addAll}, {@link #removeIf} or {@link #forEach},
                         are &lt;em&gt;not&lt;/em&gt; guaranteed to be performed atomically.
                         For example, a {@code forEach} traversal concurrent with an {@code
                         addAll} operation might observe only some of the added elements.
                        
                         &lt;p&gt;This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt;
                         methods of the {@link Deque} and {@link Iterator} interfaces.
                        
                         &lt;p&gt;Memory consistency effects: As with other concurrent collections,
                         actions in a thread prior to placing an object into a
                         {@code ConcurrentLinkedDeque}
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         actions subsequent to the access or removal of that element from
                         the {@code ConcurrentLinkedDeque} in another thread.
                        
                         &lt;p&gt;This class is a member of the
                         &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                         Java Collections Framework&lt;/a&gt;.
                        
                         @since 1.7
                         @author Doug Lea
                         @author Martin Buchholz
                         @param &lt;E&gt; the type of elements held in this deque
                        </javadoc>
                </acts>
                <acts name="Flow" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Interrelated interfaces and static methods for establishing
                         flow-controlled components in which {@link Publisher Publishers}
                         produce items consumed by one or more {@link Subscriber
                         Subscribers}, each managed by a {@link Subscription
                         Subscription}.
                        
                         &lt;p&gt;These interfaces correspond to the &lt;a
                         href="http://www.reactive-streams.org/"&gt; reactive-streams&lt;/a&gt;
                         specification.  They apply in both concurrent and distributed
                         asynchronous settings: All (seven) methods are defined in {@code
                         void} "one-way" message style. Communication relies on a simple form
                         of flow control (method {@link Subscription#request}) that can be
                         used to avoid resource management problems that may otherwise occur
                         in "push" based systems.
                        
                         &lt;p&gt;&lt;b&gt;Examples.&lt;/b&gt; A {@link Publisher} usually defines its own
                         {@link Subscription} implementation; constructing one in method
                         {@code subscribe} and issuing it to the calling {@link
                         Subscriber}. It publishes items to the subscriber asynchronously,
                         normally using an {@link Executor}.  For example, here is a very
                         simple publisher that only issues (when requested) a single {@code
                         TRUE} item to a single subscriber.  Because the subscriber receives
                         only a single item, this class does not use buffering and ordering
                         control required in most implementations (for example {@link
                         SubmissionPublisher}).
                        
                         &lt;pre&gt; {@code
                         class OneShotPublisher implements Publisher&lt;Boolean&gt; {
                           private final ExecutorService executor = ForkJoinPool.commonPool(); // daemon-based
                           private boolean subscribed; // true after first subscribe
                           public synchronized void subscribe(Subscriber&lt;? super Boolean&gt; subscriber) {
                             if (subscribed)
                               subscriber.onError(new IllegalStateException()); // only one allowed
                             else {
                               subscribed = true;
                               subscriber.onSubscribe(new OneShotSubscription(subscriber, executor));
                             }
                           }
                           static class OneShotSubscription implements Subscription {
                             private final Subscriber&lt;? super Boolean&gt; subscriber;
                             private final ExecutorService executor;
                             private Future&lt;?&gt; future; // to allow cancellation
                             private boolean completed;
                             OneShotSubscription(Subscriber&lt;? super Boolean&gt; subscriber,
                                                 ExecutorService executor) {
                               this.subscriber = subscriber;
                               this.executor = executor;
                             }
                             public synchronized void request(long n) {
                               if (!completed) {
                                 completed = true;
                                 if (n &lt;= 0) {
                                   IllegalArgumentException ex = new IllegalArgumentException();
                                   executor.execute(() -&gt; subscriber.onError(ex));
                                 } else {
                                   future = executor.submit(() -&gt; {
                                     subscriber.onNext(Boolean.TRUE);
                                     subscriber.onComplete();
                                   });
                                 }
                               }
                             }
                             public synchronized void cancel() {
                               completed = true;
                               if (future != null) future.cancel(false);
                             }
                           }
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;A {@link Subscriber} arranges that items be requested and
                         processed.  Items (invocations of {@link Subscriber#onNext}) are
                         not issued unless requested, but multiple items may be requested.
                         Many Subscriber implementations can arrange this in the style of
                         the following example, where a buffer size of 1 single-steps, and
                         larger sizes usually allow for more efficient overlapped processing
                         with less communication; for example with a value of 64, this keeps
                         total outstanding requests between 32 and 64.
                         Because Subscriber method invocations for a given {@link
                         Subscription} are strictly ordered, there is no need for these
                         methods to use locks or volatiles unless a Subscriber maintains
                         multiple Subscriptions (in which case it is better to instead
                         define multiple Subscribers, each with its own Subscription).
                        
                         &lt;pre&gt; {@code
                         class SampleSubscriber&lt;T&gt; implements Subscriber&lt;T&gt; {
                           final Consumer&lt;? super T&gt; consumer;
                           Subscription subscription;
                           final long bufferSize;
                           long count;
                           SampleSubscriber(long bufferSize, Consumer&lt;? super T&gt; consumer) {
                             this.bufferSize = bufferSize;
                             this.consumer = consumer;
                           }
                           public void onSubscribe(Subscription subscription) {
                             long initialRequestSize = bufferSize;
                             count = bufferSize - bufferSize / 2; // re-request when half consumed
                             (this.subscription = subscription).request(initialRequestSize);
                           }
                           public void onNext(T item) {
                             if (--count &lt;= 0)
                               subscription.request(count = bufferSize - bufferSize / 2);
                             consumer.accept(item);
                           }
                           public void onError(Throwable ex) { ex.printStackTrace(); }
                           public void onComplete() {}
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;The default value of {@link #defaultBufferSize} may provide a
                         useful starting point for choosing request sizes and capacities in
                         Flow components based on expected rates, resources, and usages.
                         Or, when flow control is never needed, a subscriber may initially
                         request an effectively unbounded number of items, as in:
                        
                         &lt;pre&gt; {@code
                         class UnboundedSubscriber&lt;T&gt; implements Subscriber&lt;T&gt; {
                           public void onSubscribe(Subscription subscription) {
                             subscription.request(Long.MAX_VALUE); // effectively unbounded
                           }
                           public void onNext(T item) { use(item); }
                           public void onError(Throwable ex) { ex.printStackTrace(); }
                           public void onComplete() {}
                           void use(T item) { ... }
                         }}&lt;/pre&gt;
                        
                         @author Doug Lea
                         @since 9
                        </javadoc>
                </acts>
                <acts name="CompletionException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.lang.RuntimeException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Exception thrown when an error or other exception is encountered
                         in the course of completing a result or task.
                        
                         @since 1.8
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="ExecutorService" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.Executor"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An {@link Executor} that provides methods to manage termination and
                         methods that can produce a {@link Future} for tracking progress of
                         one or more asynchronous tasks.
                        
                         &lt;p&gt;An {@code ExecutorService} can be shut down, which will cause
                         it to reject new tasks.  Two different methods are provided for
                         shutting down an {@code ExecutorService}. The {@link #shutdown}
                         method will allow previously submitted tasks to execute before
                         terminating, while the {@link #shutdownNow} method prevents waiting
                         tasks from starting and attempts to stop currently executing tasks.
                         Upon termination, an executor has no tasks actively executing, no
                         tasks awaiting execution, and no new tasks can be submitted.  An
                         unused {@code ExecutorService} should be shut down to allow
                         reclamation of its resources.
                        
                         &lt;p&gt;Method {@code submit} extends base method {@link
                         Executor#execute(Runnable)} by creating and returning a {@link Future}
                         that can be used to cancel execution and/or wait for completion.
                         Methods {@code invokeAny} and {@code invokeAll} perform the most
                         commonly useful forms of bulk execution, executing a collection of
                         tasks and then waiting for at least one, or all, to
                         complete. (Class {@link ExecutorCompletionService} can be used to
                         write customized variants of these methods.)
                        
                         &lt;p&gt;The {@link Executors} class provides factory methods for the
                         executor services provided in this package.
                        
                         &lt;h3&gt;Usage Examples&lt;/h3&gt;
                        
                         Here is a sketch of a network service in which threads in a thread
                         pool service incoming requests. It uses the preconfigured {@link
                         Executors#newFixedThreadPool} factory method:
                        
                         &lt;pre&gt; {@code
                         class NetworkService implements Runnable {
                           private final ServerSocket serverSocket;
                           private final ExecutorService pool;
                        
                           public NetworkService(int port, int poolSize)
                               throws IOException {
                             serverSocket = new ServerSocket(port);
                             pool = Executors.newFixedThreadPool(poolSize);
                           }
                        
                           public void run() { // run the service
                             try {
                               for (;;) {
                                 pool.execute(new Handler(serverSocket.accept()));
                               }
                             } catch (IOException ex) {
                               pool.shutdown();
                             }
                           }
                         }
                        
                         class Handler implements Runnable {
                           private final Socket socket;
                           Handler(Socket socket) { this.socket = socket; }
                           public void run() {
                             // read and service request on socket
                           }
                         }}&lt;/pre&gt;
                        
                         The following method shuts down an {@code ExecutorService} in two phases,
                         first by calling {@code shutdown} to reject incoming tasks, and then
                         calling {@code shutdownNow}, if necessary, to cancel any lingering tasks:
                        
                         &lt;pre&gt; {@code
                         void shutdownAndAwaitTermination(ExecutorService pool) {
                           pool.shutdown(); // Disable new tasks from being submitted
                           try {
                             // Wait a while for existing tasks to terminate
                             if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {
                               pool.shutdownNow(); // Cancel currently executing tasks
                               // Wait a while for tasks to respond to being cancelled
                               if (!pool.awaitTermination(60, TimeUnit.SECONDS))
                                   System.err.println("Pool did not terminate");
                             }
                           } catch (InterruptedException ie) {
                             // (Re-)Cancel if current thread also interrupted
                             pool.shutdownNow();
                             // Preserve interrupt status
                             Thread.currentThread().interrupt();
                           }
                         }}&lt;/pre&gt;
                        
                         &lt;p&gt;Memory consistency effects: Actions in a thread prior to the
                         submission of a {@code Runnable} or {@code Callable} task to an
                         {@code ExecutorService}
                         &lt;a href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         any actions taken by that task, which in turn &lt;i&gt;happen-before&lt;/i&gt; the
                         result is retrieved via {@code Future.get()}.
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <acts name="ForkJoinWorkerThreadFactory" access="PUBLIC" declaringClass="ForkJoinPool" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes/>
                </acts>
                <acts name="Future" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.util.concurrent">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         A {@code Future} represents the result of an asynchronous
                         computation.  Methods are provided to check if the computation is
                         complete, to wait for its completion, and to retrieve the result of
                         the computation.  The result can only be retrieved using method
                         {@code get} when the computation has completed, blocking if
                         necessary until it is ready.  Cancellation is performed by the
                         {@code cancel} method.  Additional methods are provided to
                         determine if the task completed normally or was cancelled. Once a
                         computation has completed, the computation cannot be cancelled.
                         If you would like to use a {@code Future} for the sake
                         of cancellability but not provide a usable result, you can
                         declare types of the form {@code Future&lt;?&gt;} and
                         return {@code null} as a result of the underlying task.
                        
                         &lt;p&gt;&lt;b&gt;Sample Usage&lt;/b&gt; (Note that the following classes are all
                         made-up.)
                        
                         &lt;pre&gt; {@code
                         interface ArchiveSearcher { String search(String target); }
                         class App {
                           ExecutorService executor = ...
                           ArchiveSearcher searcher = ...
                           void showSearch(String target) throws InterruptedException {
                             Callable&lt;String&gt; task = () -&gt; searcher.search(target);
                             Future&lt;String&gt; future = executor.submit(task);
                             displayOtherThings(); // do other things while searching
                             try {
                               displayText(future.get()); // use future
                             } catch (ExecutionException ex) { cleanup(); return; }
                           }
                         }}&lt;/pre&gt;
                        
                         The {@link FutureTask} class is an implementation of {@code Future} that
                         implements {@code Runnable}, and so may be executed by an {@code Executor}.
                         For example, the above construction with {@code submit} could be replaced by:
                         &lt;pre&gt; {@code
                         FutureTask&lt;String&gt; future = new FutureTask&lt;&gt;(task);
                         executor.execute(future);}&lt;/pre&gt;
                        
                         &lt;p&gt;Memory consistency effects: Actions taken by the asynchronous computation
                         &lt;a href="package-summary.html#MemoryVisibility"&gt; &lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                         actions following the corresponding {@code Future.get()} in another thread.
                        
                         @see FutureTask
                         @see Executor
                         @since 1.5
                         @author Doug Lea
                         @param &lt;V&gt; The result type returned by this Future's {@code get} method
                        </javadoc>
                </acts>
                <acts name="ThreadPoolExecutor" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.util.concurrent">
                    <superTypes>
                        <superType superType="java.util.concurrent.AbstractExecutorService"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An {@link ExecutorService} that executes each submitted task using
                         one of possibly several pooled threads, normally configured
                         using {@link Executors} factory methods.
                        
                         &lt;p&gt;Thread pools address two different problems: they usually
                         provide improved performance when executing large numbers of
                         asynchronous tasks, due to reduced per-task invocation overhead,
                         and they provide a means of bounding and managing the resources,
                         including threads, consumed when executing a collection of tasks.
                         Each {@code ThreadPoolExecutor} also maintains some basic
                         statistics, such as the number of completed tasks.
                        
                         &lt;p&gt;To be useful across a wide range of contexts, this class
                         provides many adjustable parameters and extensibility
                         hooks. However, programmers are urged to use the more convenient
                         {@link Executors} factory methods {@link
                         Executors#newCachedThreadPool} (unbounded thread pool, with
                         automatic thread reclamation), {@link Executors#newFixedThreadPool}
                         (fixed size thread pool) and {@link
                         Executors#newSingleThreadExecutor} (single background thread), that
                         preconfigure settings for the most common usage
                         scenarios. Otherwise, use the following guide when manually
                         configuring and tuning this class:
                        
                         &lt;dl&gt;
                        
                         &lt;dt&gt;Core and maximum pool sizes&lt;/dt&gt;
                        
                         &lt;dd&gt;A {@code ThreadPoolExecutor} will automatically adjust the
                         pool size (see {@link #getPoolSize})
                         according to the bounds set by
                         corePoolSize (see {@link #getCorePoolSize}) and
                         maximumPoolSize (see {@link #getMaximumPoolSize}).
                        
                         When a new task is submitted in method {@link #execute(Runnable)},
                         if fewer than corePoolSize threads are running, a new thread is
                         created to handle the request, even if other worker threads are
                         idle.  Else if fewer than maximumPoolSize threads are running, a
                         new thread will be created to handle the request only if the queue
                         is full.  By setting corePoolSize and maximumPoolSize the same, you
                         create a fixed-size thread pool. By setting maximumPoolSize to an
                         essentially unbounded value such as {@code Integer.MAX_VALUE}, you
                         allow the pool to accommodate an arbitrary number of concurrent
                         tasks. Most typically, core and maximum pool sizes are set only
                         upon construction, but they may also be changed dynamically using
                         {@link #setCorePoolSize} and {@link #setMaximumPoolSize}. &lt;/dd&gt;
                        
                         &lt;dt&gt;On-demand construction&lt;/dt&gt;
                        
                         &lt;dd&gt;By default, even core threads are initially created and
                         started only when new tasks arrive, but this can be overridden
                         dynamically using method {@link #prestartCoreThread} or {@link
                         #prestartAllCoreThreads}.  You probably want to prestart threads if
                         you construct the pool with a non-empty queue. &lt;/dd&gt;
                        
                         &lt;dt&gt;Creating new threads&lt;/dt&gt;
                        
                         &lt;dd&gt;New threads are created using a {@link ThreadFactory}.  If not
                         otherwise specified, a {@link Executors#defaultThreadFactory} is
                         used, that creates threads to all be in the same {@link
                         ThreadGroup} and with the same {@code NORM_PRIORITY} priority and
                         non-daemon status. By supplying a different ThreadFactory, you can
                         alter the thread's name, thread group, priority, daemon status,
                         etc. If a {@code ThreadFactory} fails to create a thread when asked
                         by returning null from {@code newThread}, the executor will
                         continue, but might not be able to execute any tasks. Threads
                         should possess the "modifyThread" {@code RuntimePermission}. If
                         worker threads or other threads using the pool do not possess this
                         permission, service may be degraded: configuration changes may not
                         take effect in a timely manner, and a shutdown pool may remain in a
                         state in which termination is possible but not completed.&lt;/dd&gt;
                        
                         &lt;dt&gt;Keep-alive times&lt;/dt&gt;
                        
                         &lt;dd&gt;If the pool currently has more than corePoolSize threads,
                         excess threads will be terminated if they have been idle for more
                         than the keepAliveTime (see {@link #getKeepAliveTime(TimeUnit)}).
                         This provides a means of reducing resource consumption when the
                         pool is not being actively used. If the pool becomes more active
                         later, new threads will be constructed. This parameter can also be
                         changed dynamically using method {@link #setKeepAliveTime(long,
                         TimeUnit)}.  Using a value of {@code Long.MAX_VALUE} {@link
                         TimeUnit#NANOSECONDS} effectively disables idle threads from ever
                         terminating prior to shut down. By default, the keep-alive policy
                         applies only when there are more than corePoolSize threads, but
                         method {@link #allowCoreThreadTimeOut(boolean)} can be used to
                         apply this time-out policy to core threads as well, so long as the
                         keepAliveTime value is non-zero. &lt;/dd&gt;
                        
                         &lt;dt&gt;Queuing&lt;/dt&gt;
                        
                         &lt;dd&gt;Any {@link BlockingQueue} may be used to transfer and hold
                         submitted tasks.  The use of this queue interacts with pool sizing:
                        
                         &lt;ul&gt;
                        
                         &lt;li&gt;If fewer than corePoolSize threads are running, the Executor
                         always prefers adding a new thread
                         rather than queuing.
                        
                         &lt;li&gt;If corePoolSize or more threads are running, the Executor
                         always prefers queuing a request rather than adding a new
                         thread.
                        
                         &lt;li&gt;If a request cannot be queued, a new thread is created unless
                         this would exceed maximumPoolSize, in which case, the task will be
                         rejected.
                        
                         &lt;/ul&gt;
                        
                         There are three general strategies for queuing:
                         &lt;ol&gt;
                        
                         &lt;li&gt;&lt;em&gt; Direct handoffs.&lt;/em&gt; A good default choice for a work
                         queue is a {@link SynchronousQueue} that hands off tasks to threads
                         without otherwise holding them. Here, an attempt to queue a task
                         will fail if no threads are immediately available to run it, so a
                         new thread will be constructed. This policy avoids lockups when
                         handling sets of requests that might have internal dependencies.
                         Direct handoffs generally require unbounded maximumPoolSizes to
                         avoid rejection of new submitted tasks. This in turn admits the
                         possibility of unbounded thread growth when commands continue to
                         arrive on average faster than they can be processed.
                        
                         &lt;li&gt;&lt;em&gt; Unbounded queues.&lt;/em&gt; Using an unbounded queue (for
                         example a {@link LinkedBlockingQueue} without a predefined
                         capacity) will cause new tasks to wait in the queue when all
                         corePoolSize threads are busy. Thus, no more than corePoolSize
                         threads will ever be created. (And the value of the maximumPoolSize
                         therefore doesn't have any effect.)  This may be appropriate when
                         each task is completely independent of others, so tasks cannot
                         affect each others execution; for example, in a web page server.
                         While this style of queuing can be useful in smoothing out
                         transient bursts of requests, it admits the possibility of
                         unbounded work queue growth when commands continue to arrive on
                         average faster than they can be processed.
                        
                         &lt;li&gt;&lt;em&gt;Bounded queues.&lt;/em&gt; A bounded queue (for example, an
                         {@link ArrayBlockingQueue}) helps prevent resource exhaustion when
                         used with finite maximumPoolSizes, but can be more difficult to
                         tune and control.  Queue sizes and maximum pool sizes may be traded
                         off for each other: Using large queues and small pools minimizes
                         CPU usage, OS resources, and context-switching overhead, but can
                         lead to artificially low throughput.  If tasks frequently block (for
                         example if they are I/O bound), a system may be able to schedule
                         time for more threads than you otherwise allow. Use of small queues
                         generally requires larger pool sizes, which keeps CPUs busier but
                         may encounter unacceptable scheduling overhead, which also
                         decreases throughput.
                        
                         &lt;/ol&gt;
                        
                         &lt;/dd&gt;
                        
                         &lt;dt&gt;Rejected tasks&lt;/dt&gt;
                        
                         &lt;dd&gt;New tasks submitted in method {@link #execute(Runnable)} will be
                         &lt;em&gt;rejected&lt;/em&gt; when the Executor has been shut down, and also when
                         the Executor uses finite bounds for both maximum threads and work queue
                         capacity, and is saturated.  In either case, the {@code execute} method
                         invokes the {@link
                         RejectedExecutionHandler#rejectedExecution(Runnable, ThreadPoolExecutor)}
                         method of its {@link RejectedExecutionHandler}.  Four predefined handler
                         policies are provided:
                        
                         &lt;ol&gt;
                        
                         &lt;li&gt;In the default {@link ThreadPoolExecutor.AbortPolicy}, the handler
                         throws a runtime {@link RejectedExecutionException} upon rejection.
                        
                         &lt;li&gt;In {@link ThreadPoolExecutor.CallerRunsPolicy}, the thread
                         that invokes {@code execute} itself runs the task. This provides a
                         simple feedback control mechanism that will slow down the rate that
                         new tasks are submitted.
                        
                         &lt;li&gt;In {@link ThreadPoolExecutor.DiscardPolicy}, a task that
                         cannot be executed is simply dropped.
                        
                         &lt;li&gt;In {@link ThreadPoolExecutor.DiscardOldestPolicy}, if the
                         executor is not shut down, the task at the head of the work queue
                         is dropped, and then execution is retried (which can fail again,
                         causing this to be repeated.)
                        
                         &lt;/ol&gt;
                        
                         It is possible to define and use other kinds of {@link
                         RejectedExecutionHandler} classes. Doing so requires some care
                         especially when policies are designed to work only under particular
                         capacity or queuing policies. &lt;/dd&gt;
                        
                         &lt;dt&gt;Hook methods&lt;/dt&gt;
                        
                         &lt;dd&gt;This class provides {@code protected} overridable
                         {@link #beforeExecute(Thread, Runnable)} and
                         {@link #afterExecute(Runnable, Throwable)} methods that are called
                         before and after execution of each task.  These can be used to
                         manipulate the execution environment; for example, reinitializing
                         ThreadLocals, gathering statistics, or adding log entries.
                         Additionally, method {@link #terminated} can be overridden to perform
                         any special processing that needs to be done once the Executor has
                         fully terminated.
                        
                         &lt;p&gt;If hook, callback, or BlockingQueue methods throw exceptions,
                         internal worker threads may in turn fail, abruptly terminate, and
                         possibly be replaced.&lt;/dd&gt;
                        
                         &lt;dt&gt;Queue maintenance&lt;/dt&gt;
                        
                         &lt;dd&gt;Method {@link #getQueue()} allows access to the work queue
                         for purposes of monitoring and debugging.  Use of this method for
                         any other purpose is strongly discouraged.  Two supplied methods,
                         {@link #remove(Runnable)} and {@link #purge} are available to
                         assist in storage reclamation when large numbers of queued tasks
                         become cancelled.&lt;/dd&gt;
                        
                         &lt;dt&gt;Reclamation&lt;/dt&gt;
                        
                         &lt;dd&gt;A pool that is no longer referenced in a program &lt;em&gt;AND&lt;/em&gt;
                         has no remaining threads may be reclaimed (garbage collected)
                         without being explicitly shutdown. You can configure a pool to
                         allow all unused threads to eventually die by setting appropriate
                         keep-alive times, using a lower bound of zero core threads and/or
                         setting {@link #allowCoreThreadTimeOut(boolean)}.  &lt;/dd&gt;
                        
                         &lt;/dl&gt;
                        
                         &lt;p&gt;&lt;b&gt;Extension example&lt;/b&gt;. Most extensions of this class
                         override one or more of the protected hook methods. For example,
                         here is a subclass that adds a simple pause/resume feature:
                        
                         &lt;pre&gt; {@code
                         class PausableThreadPoolExecutor extends ThreadPoolExecutor {
                           private boolean isPaused;
                           private ReentrantLock pauseLock = new ReentrantLock();
                           private Condition unpaused = pauseLock.newCondition();
                        
                           public PausableThreadPoolExecutor(...) { super(...); }
                        
                           protected void beforeExecute(Thread t, Runnable r) {
                             super.beforeExecute(t, r);
                             pauseLock.lock();
                             try {
                               while (isPaused) unpaused.await();
                             } catch (InterruptedException ie) {
                               t.interrupt();
                             } finally {
                               pauseLock.unlock();
                             }
                           }
                        
                           public void pause() {
                             pauseLock.lock();
                             try {
                               isPaused = true;
                             } finally {
                               pauseLock.unlock();
                             }
                           }
                        
                           public void resume() {
                             pauseLock.lock();
                             try {
                               isPaused = false;
                               unpaused.signalAll();
                             } finally {
                               pauseLock.unlock();
                             }
                           }
                         }}&lt;/pre&gt;
                        
                         @since 1.5
                         @author Doug Lea
                        </javadoc>
                </acts>
                <package name="atomic"/>
                <package name="locks"/>
            </package>
            <package name="logging"/>
            <package name="jar"/>
            <package name="spi"/>
            <package name="prefs"/>
        </package>
        <package name="nio">
            <package name="charset">
                <package name="spi"/>
            </package>
            <package name="file">
                <acts name="DirectoryIteratorException" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.util.ConcurrentModificationException"/>
                        <superType superType="java.lang.RuntimeException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Runtime exception thrown if an I/O error is encountered when iterating over
                         the entries in a directory. The I/O error is retrieved as an {@link
                         IOException} using the {@link #getCause() getCause()} method.
                        
                         @since 1.7
                         @see DirectoryStream
                        </javadoc>
                </acts>
                <acts name="SimpleFileVisitor" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.nio.file.FileVisitor"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A simple visitor of files with default behavior to visit all files and to
                         re-throw I/O errors.
                        
                         &lt;p&gt; Methods in this class may be overridden subject to their general contract.
                        
                         @param   &lt;T&gt;     The type of reference to the files
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="AccessDeniedException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.nio.file.FileSystemException"/>
                        <superType superType="java.io.IOException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Checked exception thrown when a file system operation is denied, typically
                         due to a file permission or other access check.
                        
                         &lt;p&gt; This exception is not related to the {@link
                         java.security.AccessControlException AccessControlException} or {@link
                         SecurityException} thrown by access controllers or security managers when
                         access to a file is denied.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="FileAlreadyExistsException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.nio.file.FileSystemException"/>
                        <superType superType="java.io.IOException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Checked exception thrown when an attempt is made to create a file or
                         directory and a file of that name already exists.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="CopyOption" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.nio.file">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         An object that configures how to copy or move a file.
                        
                         &lt;p&gt; Objects of this type may be used with the {@link
                         Files#copy(Path,Path,CopyOption[]) Files.copy(Path,Path,CopyOption...)},
                         {@link Files#copy(java.io.InputStream,Path,CopyOption[])
                         Files.copy(InputStream,Path,CopyOption...)} and {@link Files#move
                         Files.move(Path,Path,CopyOption...)} methods to configure how a file is
                         copied or moved.
                        
                         &lt;p&gt; The {@link StandardCopyOption} enumeration type defines the
                         &lt;i&gt;standard&lt;/i&gt; options.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="StandardOpenOption" access="PUBLIC" kind="TYPE" typeKind="ENUM" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.nio.file.OpenOption"/>
                        <superType superType="java.lang.Enum"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Defines the standard open options.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="FileVisitOption" access="PUBLIC" kind="TYPE" typeKind="ENUM" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.Enum"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Defines the file tree traversal options.
                        
                         @since 1.7
                        
                         @see Files#walkFileTree
                        </javadoc>
                </acts>
                <acts name="DirectoryStream" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.io.Closeable"/>
                        <superType superType="java.lang.Iterable"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An object to iterate over the entries in a directory. A directory stream
                         allows for the convenient use of the for-each construct to iterate over a
                         directory.
                        
                         &lt;p&gt; &lt;b&gt; While {@code DirectoryStream} extends {@code Iterable}, it is not a
                         general-purpose {@code Iterable} as it supports only a single {@code
                         Iterator}; invoking the {@link #iterator iterator} method to obtain a second
                         or subsequent iterator throws {@code IllegalStateException}. &lt;/b&gt;
                        
                         &lt;p&gt; An important property of the directory stream's {@code Iterator} is that
                         its {@link Iterator#hasNext() hasNext} method is guaranteed to read-ahead by
                         at least one element. If {@code hasNext} method returns {@code true}, and is
                         followed by a call to the {@code next} method, it is guaranteed that the
                         {@code next} method will not throw an exception due to an I/O error, or
                         because the stream has been {@link #close closed}. The {@code Iterator} does
                         not support the {@link Iterator#remove remove} operation.
                        
                         &lt;p&gt; A {@code DirectoryStream} is opened upon creation and is closed by
                         invoking the {@code close} method. Closing a directory stream releases any
                         resources associated with the stream. Failure to close the stream may result
                         in a resource leak. The try-with-resources statement provides a useful
                         construct to ensure that the stream is closed:
                         &lt;pre&gt;
                           Path dir = ...
                           try (DirectoryStream&amp;lt;Path&amp;gt; stream = Files.newDirectoryStream(dir)) {
                               for (Path entry: stream) {
                                   ...
                               }
                           }
                         &lt;/pre&gt;
                        
                         &lt;p&gt; Once a directory stream is closed, then further access to the directory,
                         using the {@code Iterator}, behaves as if the end of stream has been reached.
                         Due to read-ahead, the {@code Iterator} may return one or more elements
                         after the directory stream has been closed. Once these buffered elements
                         have been read, then subsequent calls to the {@code hasNext} method returns
                         {@code false}, and subsequent calls to the {@code next} method will throw
                         {@code NoSuchElementException}.
                        
                         &lt;p&gt; A directory stream is not required to be &lt;i&gt;asynchronously closeable&lt;/i&gt;.
                         If a thread is blocked on the directory stream's iterator reading from the
                         directory, and another thread invokes the {@code close} method, then the
                         second thread may block until the read operation is complete.
                        
                         &lt;p&gt; If an I/O error is encountered when accessing the directory then it
                         causes the {@code Iterator}'s {@code hasNext} or {@code next} methods to
                         throw {@link DirectoryIteratorException} with the {@link IOException} as the
                         cause. As stated above, the {@code hasNext} method is guaranteed to
                         read-ahead by at least one element. This means that if {@code hasNext} method
                         returns {@code true}, and is followed by a call to the {@code next} method,
                         then it is guaranteed that the {@code next} method will not fail with a
                         {@code DirectoryIteratorException}.
                        
                         &lt;p&gt; The elements returned by the iterator are in no specific order. Some file
                         systems maintain special links to the directory itself and the directory's
                         parent directory. Entries representing these links are not returned by the
                         iterator.
                        
                         &lt;p&gt; The iterator is &lt;i&gt;weakly consistent&lt;/i&gt;. It is thread safe but does not
                         freeze the directory while iterating, so it may (or may not) reflect updates
                         to the directory that occur after the {@code DirectoryStream} is created.
                        
                         &lt;p&gt; &lt;b&gt;Usage Examples:&lt;/b&gt;
                         Suppose we want a list of the source files in a directory. This example uses
                         both the for-each and try-with-resources constructs.
                         &lt;pre&gt;
                           List&amp;lt;Path&amp;gt; listSourceFiles(Path dir) throws IOException {
                               List&amp;lt;Path&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
                               try (DirectoryStream&amp;lt;Path&amp;gt; stream = Files.newDirectoryStream(dir, "*.{c,h,cpp,hpp,java}")) {
                                   for (Path entry: stream) {
                                       result.add(entry);
                                   }
                               } catch (DirectoryIteratorException ex) {
                                   // I/O error encounted during the iteration, the cause is an IOException
                                   throw ex.getCause();
                               }
                               return result;
                           }
                         &lt;/pre&gt;
                         @param   &lt;T&gt;     The type of element returned by the iterator
                        
                         @since 1.7
                        
                         @see Files#newDirectoryStream(Path)
                        </javadoc>
                </acts>
                <acts name="NoSuchFileException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.nio.file.FileSystemException"/>
                        <superType superType="java.io.IOException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Checked exception thrown when an attempt is made to access a file that does
                         not exist.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="DirectoryNotEmptyException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.nio.file.FileSystemException"/>
                        <superType superType="java.io.IOException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Checked exception thrown when a file system operation fails because a
                         directory is not empty.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="ClosedWatchServiceException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.IllegalStateException"/>
                        <superType superType="java.lang.RuntimeException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Unchecked exception thrown when an attempt is made to invoke an operation on
                         a watch service that is closed.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="NotLinkException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.nio.file.FileSystemException"/>
                        <superType superType="java.io.IOException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Checked exception thrown when a file system operation fails because a file
                         is not a symbolic link.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="Kind" access="PUBLIC" declaringClass="WatchEvent" kind="TYPE" typeKind="INTERFACE" packageName="java.nio.file">
                    <superTypes/>
                </acts>
                <acts name="InvalidPathException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.IllegalArgumentException"/>
                        <superType superType="java.lang.RuntimeException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Unchecked exception thrown when path string cannot be converted into a
                         {@link Path} because the path string contains invalid characters, or
                         the path string is invalid for other file system specific reasons.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="FileSystemException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.io.IOException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Thrown when a file system operation fails on one or two files. This class is
                         the general class for file system exceptions.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="NotDirectoryException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.nio.file.FileSystemException"/>
                        <superType superType="java.io.IOException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Checked exception thrown when a file system operation, intended for a
                         directory, fails because the file is not a directory.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="ProviderNotFoundException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.RuntimeException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Runtime exception thrown when a provider of the required type cannot be found.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="FileSystem" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.io.Closeable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Provides an interface to a file system and is the factory for objects to
                         access files and other objects in the file system.
                        
                         &lt;p&gt; The default file system, obtained by invoking the {@link FileSystems#getDefault
                         FileSystems.getDefault} method, provides access to the file system that is
                         accessible to the Java virtual machine. The {@link FileSystems} class defines
                         methods to create file systems that provide access to other types of (custom)
                         file systems.
                        
                         &lt;p&gt; A file system is the factory for several types of objects:
                        
                         &lt;ul&gt;
                           &lt;li&gt;&lt;p&gt; The {@link #getPath getPath} method converts a system dependent
                             &lt;em&gt;path string&lt;/em&gt;, returning a {@link Path} object that may be used
                             to locate and access a file. &lt;/p&gt;&lt;/li&gt;
                           &lt;li&gt;&lt;p&gt; The {@link #getPathMatcher  getPathMatcher} method is used
                             to create a {@link PathMatcher} that performs match operations on
                             paths. &lt;/p&gt;&lt;/li&gt;
                           &lt;li&gt;&lt;p&gt; The {@link #getFileStores getFileStores} method returns an iterator
                             over the underlying {@link FileStore file-stores}. &lt;/p&gt;&lt;/li&gt;
                           &lt;li&gt;&lt;p&gt; The {@link #getUserPrincipalLookupService getUserPrincipalLookupService}
                             method returns the {@link UserPrincipalLookupService} to lookup users or
                             groups by name. &lt;/p&gt;&lt;/li&gt;
                           &lt;li&gt;&lt;p&gt; The {@link #newWatchService newWatchService} method creates a
                             {@link WatchService} that may be used to watch objects for changes and
                             events. &lt;/p&gt;&lt;/li&gt;
                         &lt;/ul&gt;
                        
                         &lt;p&gt; File systems vary greatly. In some cases the file system is a single
                         hierarchy of files with one top-level root directory. In other cases it may
                         have several distinct file hierarchies, each with its own top-level root
                         directory. The {@link #getRootDirectories getRootDirectories} method may be
                         used to iterate over the root directories in the file system. A file system
                         is typically composed of one or more underlying {@link FileStore file-stores}
                         that provide the storage for the files. Theses file stores can also vary in
                         the features they support, and the file attributes or &lt;em&gt;meta-data&lt;/em&gt; that
                         they associate with files.
                        
                         &lt;p&gt; A file system is open upon creation and can be closed by invoking its
                         {@link #close() close} method. Once closed, any further attempt to access
                         objects in the file system cause {@link ClosedFileSystemException} to be
                         thrown. File systems created by the default {@link FileSystemProvider provider}
                         cannot be closed.
                        
                         &lt;p&gt; A {@code FileSystem} can provide read-only or read-write access to the
                         file system. Whether or not a file system provides read-only access is
                         established when the {@code FileSystem} is created and can be tested by invoking
                         its {@link #isReadOnly() isReadOnly} method. Attempts to write to file stores
                         by means of an object associated with a read-only file system throws {@link
                         ReadOnlyFileSystemException}.
                        
                         &lt;p&gt; File systems are safe for use by multiple concurrent threads. The {@link
                         #close close} method may be invoked at any time to close a file system but
                         whether a file system is &lt;i&gt;asynchronously closeable&lt;/i&gt; is provider specific
                         and therefore unspecified. In other words, if a thread is accessing an
                         object in a file system, and another thread invokes the {@code close} method
                         then it may require to block until the first operation is complete. Closing
                         a file system causes all open channels, watch services, and other {@link
                         Closeable closeable} objects associated with the file system to be closed.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="FileVisitor" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.nio.file">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         A visitor of files. An implementation of this interface is provided to the
                         {@link Files#walkFileTree Files.walkFileTree} methods to visit each file in
                         a file tree.
                        
                         &lt;p&gt; &lt;b&gt;Usage Examples:&lt;/b&gt;
                         Suppose we want to delete a file tree. In that case, each directory should
                         be deleted after the entries in the directory are deleted.
                         &lt;pre&gt;
                             Path start = ...
                             Files.walkFileTree(start, new SimpleFileVisitor&amp;lt;Path&amp;gt;() {
                                 &amp;#64;Override
                                 public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
                                     throws IOException
                                 {
                                     Files.delete(file);
                                     return FileVisitResult.CONTINUE;
                                 }
                                 &amp;#64;Override
                                 public FileVisitResult postVisitDirectory(Path dir, IOException e)
                                     throws IOException
                                 {
                                     if (e == null) {
                                         Files.delete(dir);
                                         return FileVisitResult.CONTINUE;
                                     } else {
                                         // directory iteration failed
                                         throw e;
                                     }
                                 }
                             });
                         &lt;/pre&gt;
                         &lt;p&gt; Furthermore, suppose we want to copy a file tree to a target location.
                         In that case, symbolic links should be followed and the target directory
                         should be created before the entries in the directory are copied.
                         &lt;pre&gt;
                             final Path source = ...
                             final Path target = ...
                        
                             Files.walkFileTree(source, EnumSet.of(FileVisitOption.FOLLOW_LINKS), Integer.MAX_VALUE,
                                 new SimpleFileVisitor&amp;lt;Path&amp;gt;() {
                                     &amp;#64;Override
                                     public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)
                                         throws IOException
                                     {
                                         Path targetdir = target.resolve(source.relativize(dir));
                                         try {
                                             Files.copy(dir, targetdir);
                                         } catch (FileAlreadyExistsException e) {
                                              if (!Files.isDirectory(targetdir))
                                                  throw e;
                                         }
                                         return CONTINUE;
                                     }
                                     &amp;#64;Override
                                     public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
                                         throws IOException
                                     {
                                         Files.copy(file, target.resolve(source.relativize(file)));
                                         return CONTINUE;
                                     }
                                 });
                         &lt;/pre&gt;
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="AtomicMoveNotSupportedException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.nio.file.FileSystemException"/>
                        <superType superType="java.io.IOException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Checked exception thrown when a file cannot be moved as an atomic file system
                         operation.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="FileSystemAlreadyExistsException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.RuntimeException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Runtime exception thrown when an attempt is made to create a file system that
                         already exists.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="Paths" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         This class consists exclusively of static methods that return a {@link Path}
                         by converting a path string or {@link URI}.
                        
                         @apiNote
                         It is recommended to obtain a {@code Path} via the {@code Path.of} methods
                         instead of via the {@code get} methods defined in this class as this class
                         may be deprecated in a future release.
                        
                         @since 1.7
                         @see Path
                        </javadoc>
                </acts>
                <acts name="WatchEvent" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.nio.file">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         An event or a repeated event for an object that is registered with a {@link
                         WatchService}.
                        
                         &lt;p&gt; An event is classified by its {@link #kind() kind} and has a {@link
                         #count() count} to indicate the number of times that the event has been
                         observed. This allows for efficient representation of repeated events. The
                         {@link #context() context} method returns any context associated with
                         the event. In the case of a repeated event then the context is the same for
                         all events.
                        
                         &lt;p&gt; Watch events are immutable and safe for use by multiple concurrent
                         threads.
                        
                         @param   &lt;T&gt;     The type of the context object associated with the event
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="Modifier" access="PUBLIC" declaringClass="WatchEvent" kind="TYPE" typeKind="INTERFACE" packageName="java.nio.file">
                    <superTypes/>
                </acts>
                <acts name="Files" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         This class consists exclusively of static methods that operate on files,
                         directories, or other types of files.
                        
                         &lt;p&gt; In most cases, the methods defined here will delegate to the associated
                         file system provider to perform the file operations.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="FileSystems" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Factory methods for file systems. This class defines the {@link #getDefault
                         getDefault} method to get the default file system and factory methods to
                         construct other types of file systems.
                        
                         &lt;p&gt; The first invocation of any of the methods defined by this class causes
                         the default {@link FileSystemProvider provider} to be loaded. The default
                         provider, identified by the URI scheme "file", creates the {@link FileSystem}
                         that provides access to the file systems accessible to the Java virtual
                         machine. If the process of loading or initializing the default provider fails
                         then an unspecified error is thrown.
                        
                         &lt;p&gt; The first invocation of the {@link FileSystemProvider#installedProviders()
                         installedProviders} method, by way of invoking any of the {@code
                         newFileSystem} methods defined by this class, locates and loads all
                         installed file system providers. Installed providers are loaded using the
                         service-provider loading facility defined by the {@link ServiceLoader} class.
                         Installed providers are loaded using the system class loader. If the
                         system class loader cannot be found then the platform class loader is used.
                         Providers are typically installed by placing them in a JAR file on the
                         application class path, the JAR file contains a
                         provider-configuration file named {@code java.nio.file.spi.FileSystemProvider}
                         in the resource directory {@code META-INF/services}, and the file lists one or
                         more fully-qualified names of concrete subclass of {@link FileSystemProvider}
                         that have a zero argument constructor.
                         The ordering that installed providers are located is implementation specific.
                         If a provider is instantiated and its {@link FileSystemProvider#getScheme()
                         getScheme} returns the same URI scheme of a provider that was previously
                         instantiated then the most recently instantiated duplicate is discarded. URI
                         schemes are compared without regard to case. During construction a provider
                         may safely access files associated with the default provider but care needs
                         to be taken to avoid circular loading of other installed providers. If
                         circular loading of installed providers is detected then an unspecified error
                         is thrown.
                        
                         &lt;p&gt; This class also defines factory methods that allow a {@link ClassLoader}
                         to be specified when locating a provider. As with installed providers, the
                         provider classes are identified by placing the provider configuration file
                         in the resource directory {@code META-INF/services}.
                        
                         &lt;p&gt; If a thread initiates the loading of the installed file system providers
                         and another thread invokes a method that also attempts to load the providers
                         then the method will block until the loading completes.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="Path" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.Comparable"/>
                        <superType superType="java.lang.Iterable"/>
                        <superType superType="java.nio.file.Watchable"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An object that may be used to locate a file in a file system. It will
                         typically represent a system dependent file path.
                        
                         &lt;p&gt; A {@code Path} represents a path that is hierarchical and composed of a
                         sequence of directory and file name elements separated by a special separator
                         or delimiter. A &lt;em&gt;root component&lt;/em&gt;, that identifies a file system
                         hierarchy, may also be present. The name element that is &lt;em&gt;farthest&lt;/em&gt;
                         from the root of the directory hierarchy is the name of a file or directory.
                         The other name elements are directory names. A {@code Path} can represent a
                         root, a root and a sequence of names, or simply one or more name elements.
                         A {@code Path} is considered to be an &lt;i&gt;empty path&lt;/i&gt; if it consists
                         solely of one name element that is empty. Accessing a file using an
                         &lt;i&gt;empty path&lt;/i&gt; is equivalent to accessing the default directory of the
                         file system. {@code Path} defines the {@link #getFileName() getFileName},
                         {@link #getParent getParent}, {@link #getRoot getRoot}, and {@link #subpath
                         subpath} methods to access the path components or a subsequence of its name
                         elements.
                        
                         &lt;p&gt; In addition to accessing the components of a path, a {@code Path} also
                         defines the {@link #resolve(Path) resolve} and {@link #resolveSibling(Path)
                         resolveSibling} methods to combine paths. The {@link #relativize relativize}
                         method that can be used to construct a relative path between two paths.
                         Paths can be {@link #compareTo compared}, and tested against each other using
                         the {@link #startsWith startsWith} and {@link #endsWith endsWith} methods.
                        
                         &lt;p&gt; This interface extends {@link Watchable} interface so that a directory
                         located by a path can be {@link #register registered} with a {@link
                         WatchService} and entries in the directory watched. &lt;/p&gt;
                        
                         &lt;p&gt; &lt;b&gt;WARNING:&lt;/b&gt; This interface is only intended to be implemented by
                         those developing custom file system implementations. Methods may be added to
                         this interface in future releases. &lt;/p&gt;
                        
                         &lt;h2&gt;Accessing Files&lt;/h2&gt;
                         &lt;p&gt; Paths may be used with the {@link Files} class to operate on files,
                         directories, and other types of files. For example, suppose we want a {@link
                         java.io.BufferedReader} to read text from a file "{@code access.log}". The
                         file is located in a directory "{@code logs}" relative to the current working
                         directory and is UTF-8 encoded.
                         &lt;pre&gt;
                             Path path = FileSystems.getDefault().getPath("logs", "access.log");
                             BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);
                         &lt;/pre&gt;
                        
                         &lt;a id="interop"&gt;&lt;/a&gt;&lt;h2&gt;Interoperability&lt;/h2&gt;
                         &lt;p&gt; Paths associated with the default {@link
                         java.nio.file.spi.FileSystemProvider provider} are generally interoperable
                         with the {@link java.io.File java.io.File} class. Paths created by other
                         providers are unlikely to be interoperable with the abstract path names
                         represented by {@code java.io.File}. The {@link java.io.File#toPath toPath}
                         method may be used to obtain a {@code Path} from the abstract path name
                         represented by a {@code java.io.File} object. The resulting {@code Path} can
                         be used to operate on the same file as the {@code java.io.File} object. In
                         addition, the {@link #toFile toFile} method is useful to construct a {@code
                         File} from the {@code String} representation of a {@code Path}.
                        
                         &lt;h2&gt;Concurrency&lt;/h2&gt;
                         &lt;p&gt; Implementations of this interface are immutable and safe for use by
                         multiple concurrent threads.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="StandardWatchEventKinds" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Defines the &lt;em&gt;standard&lt;/em&gt; event kinds.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="LinkOption" access="PUBLIC" kind="TYPE" typeKind="ENUM" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.nio.file.OpenOption"/>
                        <superType superType="java.nio.file.CopyOption"/>
                        <superType superType="java.lang.Enum"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Defines the options as to how symbolic links are handled.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="WatchKey" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.nio.file">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         A token representing the registration of a {@link Watchable watchable} object
                         with a {@link WatchService}.
                        
                         &lt;p&gt; A watch key is created when a watchable object is registered with a watch
                         service. The key remains {@link #isValid valid} until:
                         &lt;ol&gt;
                           &lt;li&gt; It is cancelled, explicitly, by invoking its {@link #cancel cancel}
                             method, or&lt;/li&gt;
                           &lt;li&gt; Cancelled implicitly, because the object is no longer accessible,
                             or &lt;/li&gt;
                           &lt;li&gt; By {@link WatchService#close closing} the watch service. &lt;/li&gt;
                         &lt;/ol&gt;
                        
                         &lt;p&gt; A watch key has a state. When initially created the key is said to be
                         &lt;em&gt;ready&lt;/em&gt;. When an event is detected then the key is &lt;em&gt;signalled&lt;/em&gt;
                         and queued so that it can be retrieved by invoking the watch service's {@link
                         WatchService#poll() poll} or {@link WatchService#take() take} methods. Once
                         signalled, a key remains in this state until its {@link #reset reset} method
                         is invoked to return the key to the ready state. Events detected while the
                         key is in the signalled state are queued but do not cause the key to be
                         re-queued for retrieval from the watch service. Events are retrieved by
                         invoking the key's {@link #pollEvents pollEvents} method. This method
                         retrieves and removes all events accumulated for the object. When initially
                         created, a watch key has no pending events. Typically events are retrieved
                         when the key is in the signalled state leading to the following idiom:
                        
                         &lt;pre&gt;
                             for (;;) {
                                 // retrieve key
                                 WatchKey key = watcher.take();
                        
                                 // process events
                                 for (WatchEvent&amp;lt;?&amp;gt; event: key.pollEvents()) {
                                     :
                                 }
                        
                                 // reset the key
                                 boolean valid = key.reset();
                                 if (!valid) {
                                     // object no longer registered
                                 }
                             }
                         &lt;/pre&gt;
                        
                         &lt;p&gt; Watch keys are safe for use by multiple concurrent threads. Where there
                         are several threads retrieving signalled keys from a watch service then care
                         should be taken to ensure that the {@code reset} method is only invoked after
                         the events for the object have been processed. This ensures that one thread
                         is processing the events for an object at any time.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="FileVisitResult" access="PUBLIC" kind="TYPE" typeKind="ENUM" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.Enum"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The result type of a {@link FileVisitor FileVisitor}.
                        
                         @since 1.7
                        
                         @see Files#walkFileTree
                        </javadoc>
                </acts>
                <acts name="SecureDirectoryStream" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.nio.file.DirectoryStream"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A {@code DirectoryStream} that defines operations on files that are located
                         relative to an open directory. A {@code SecureDirectoryStream} is intended
                         for use by sophisticated or security sensitive applications requiring to
                         traverse file trees or otherwise operate on directories in a race-free manner.
                         Race conditions can arise when a sequence of file operations cannot be
                         carried out in isolation. Each of the file operations defined by this
                         interface specify a relative path. All access to the file is relative
                         to the open directory irrespective of if the directory is moved or replaced
                         by an attacker while the directory is open. A {@code SecureDirectoryStream}
                         may also be used as a virtual &lt;em&gt;working directory&lt;/em&gt;.
                        
                         &lt;p&gt; A {@code SecureDirectoryStream} requires corresponding support from the
                         underlying operating system. Where an implementation supports this features
                         then the {@code DirectoryStream} returned by the {@link Files#newDirectoryStream
                         newDirectoryStream} method will be a {@code SecureDirectoryStream} and must
                         be cast to that type in order to invoke the methods defined by this interface.
                        
                         &lt;p&gt; In the case of the default {@link java.nio.file.spi.FileSystemProvider
                         provider}, and a security manager is set, then the permission checks are
                         performed using the path obtained by resolving the given relative path
                         against the &lt;i&gt;original path&lt;/i&gt; of the directory (irrespective of if the
                         directory is moved since it was opened).
                        
                         @since   1.7
                        </javadoc>
                </acts>
                <acts name="ClosedFileSystemException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.IllegalStateException"/>
                        <superType superType="java.lang.RuntimeException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Unchecked exception thrown when an attempt is made to invoke an operation on
                         a file and the file system is closed.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="Filter" access="PUBLIC" declaringClass="DirectoryStream" kind="TYPE" typeKind="INTERFACE" packageName="java.nio.file">
                    <superTypes/>
                </acts>
                <acts name="FileStore" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Storage for files. A {@code FileStore} represents a storage pool, device,
                         partition, volume, concrete file system or other implementation specific means
                         of file storage. The {@code FileStore} for where a file is stored is obtained
                         by invoking the {@link Files#getFileStore getFileStore} method, or all file
                         stores can be enumerated by invoking the {@link FileSystem#getFileStores
                         getFileStores} method.
                        
                         &lt;p&gt; In addition to the methods defined by this class, a file store may support
                         one or more {@link FileStoreAttributeView FileStoreAttributeView} classes
                         that provide a read-only or updatable view of a set of file store attributes.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="LinkPermission" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.security.BasicPermission"/>
                        <superType superType="java.security.Permission"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The {@code Permission} class for link creation operations.
                        
                         &lt;p&gt; The following table provides a summary description of what the permission
                         allows, and discusses the risks of granting code the permission.
                        
                         &lt;table class="striped"&gt;
                         &lt;caption style="display:none"&gt;Table shows permission target name, what the permission allows, and associated risks&lt;/caption&gt;
                         &lt;thead&gt;
                         &lt;tr&gt;
                         &lt;th scope="col"&gt;Permission Target Name&lt;/th&gt;
                         &lt;th scope="col"&gt;What the Permission Allows&lt;/th&gt;
                         &lt;th scope="col"&gt;Risks of Allowing this Permission&lt;/th&gt;
                         &lt;/tr&gt;
                         &lt;/thead&gt;
                         &lt;tbody&gt;
                         &lt;tr&gt;
                           &lt;th scope="row"&gt;hard&lt;/th&gt;
                           &lt;td&gt; Ability to add an existing file to a directory. This is sometimes
                           known as creating a link, or hard link. &lt;/td&gt;
                           &lt;td&gt; Extreme care should be taken when granting this permission. It allows
                           linking to any file or directory in the file system thus allowing the
                           attacker access to all files. &lt;/td&gt;
                         &lt;/tr&gt;
                         &lt;tr&gt;
                           &lt;th scope="row"&gt;symbolic&lt;/th&gt;
                           &lt;td&gt; Ability to create symbolic links. &lt;/td&gt;
                           &lt;td&gt; Extreme care should be taken when granting this permission. It allows
                           linking to any file or directory in the file system thus allowing the
                           attacker to access to all files. &lt;/td&gt;
                         &lt;/tr&gt;
                         &lt;/tbody&gt;
                         &lt;/table&gt;
                        
                         @since 1.7
                        
                         @see Files#createLink
                         @see Files#createSymbolicLink
                        </javadoc>
                </acts>
                <acts name="OpenOption" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.nio.file">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         An object that configures how to open or create a file.
                        
                         &lt;p&gt; Objects of this type are used by methods such as {@link
                         Files#newOutputStream(Path,OpenOption[]) newOutputStream}, {@link
                         Files#newByteChannel newByteChannel}, {@link
                         java.nio.channels.FileChannel#open FileChannel.open}, and {@link
                         java.nio.channels.AsynchronousFileChannel#open AsynchronousFileChannel.open}
                         when opening or creating a file.
                        
                         &lt;p&gt; The {@link StandardOpenOption} enumeration type defines the
                         &lt;i&gt;standard&lt;/i&gt; options.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="PathMatcher" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.nio.file">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         An interface that is implemented by objects that perform match operations on
                         paths.
                        
                         @since 1.7
                        
                         @see FileSystem#getPathMatcher
                         @see Files#newDirectoryStream(Path,String)
                        </javadoc>
                </acts>
                <acts name="StandardCopyOption" access="PUBLIC" kind="TYPE" typeKind="ENUM" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.nio.file.CopyOption"/>
                        <superType superType="java.lang.Enum"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Defines the standard copy options.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="Watchable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.nio.file">
                    <superTypes/>
                    <javadoc xml:space="preserve">
                         An object that may be registered with a watch service so that it can be
                         &lt;em&gt;watched&lt;/em&gt; for changes and events.
                        
                         &lt;p&gt; This interface defines the {@link #register register} method to register
                         the object with a {@link WatchService} returning a {@link WatchKey} to
                         represent the registration. An object may be registered with more than one
                         watch service. Registration with a watch service is cancelled by invoking the
                         key's {@link WatchKey#cancel cancel} method.
                        
                         @since 1.7
                        
                         @see Path#register
                        </javadoc>
                </acts>
                <acts name="FileSystemNotFoundException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.RuntimeException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Runtime exception thrown when a file system cannot be found.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="ClosedDirectoryStreamException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.IllegalStateException"/>
                        <superType superType="java.lang.RuntimeException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Unchecked exception thrown when an attempt is made to invoke an operation on
                         a directory stream that is closed.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="AccessMode" access="PUBLIC" kind="TYPE" typeKind="ENUM" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.Enum"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Defines access modes used to test the accessibility of a file.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="ProviderMismatchException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.IllegalArgumentException"/>
                        <superType superType="java.lang.RuntimeException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Unchecked exception thrown when an attempt is made to invoke a method on an
                         object created by one file system provider with a parameter created by a
                         different file system provider.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="FileSystemLoopException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.nio.file.FileSystemException"/>
                        <superType superType="java.io.IOException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Checked exception thrown when a file system loop, or cycle, is encountered.
                        
                         @since 1.7
                         @see Files#walkFileTree
                        </javadoc>
                </acts>
                <acts name="ReadOnlyFileSystemException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.lang.UnsupportedOperationException"/>
                        <superType superType="java.lang.RuntimeException"/>
                        <superType superType="java.lang.Exception"/>
                        <superType superType="java.lang.Throwable"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Unchecked exception thrown when an attempt is made to update an object
                         associated with a {@link FileSystem#isReadOnly() read-only} {@code FileSystem}.
                        
                         @since 1.7
                        </javadoc>
                </acts>
                <acts name="WatchService" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.nio.file">
                    <superTypes>
                        <superType superType="java.io.Closeable"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A watch service that &lt;em&gt;watches&lt;/em&gt; registered objects for changes and
                         events. For example a file manager may use a watch service to monitor a
                         directory for changes so that it can update its display of the list of files
                         when files are created or deleted.
                        
                         &lt;p&gt; A {@link Watchable} object is registered with a watch service by invoking
                         its {@link Watchable#register register} method, returning a {@link WatchKey}
                         to represent the registration. When an event for an object is detected the
                         key is &lt;em&gt;signalled&lt;/em&gt;, and if not currently signalled, it is queued to
                         the watch service so that it can be retrieved by consumers that invoke the
                         {@link #poll() poll} or {@link #take() take} methods to retrieve keys
                         and process events. Once the events have been processed the consumer
                         invokes the key's {@link WatchKey#reset reset} method to reset the key which
                         allows the key to be signalled and re-queued with further events.
                        
                         &lt;p&gt; Registration with a watch service is cancelled by invoking the key's
                         {@link WatchKey#cancel cancel} method. A key that is queued at the time that
                         it is cancelled remains in the queue until it is retrieved. Depending on the
                         object, a key may be cancelled automatically. For example, suppose a
                         directory is watched and the watch service detects that it has been deleted
                         or its file system is no longer accessible. When a key is cancelled in this
                         manner it is signalled and queued, if not currently signalled. To ensure
                         that the consumer is notified the return value from the {@code reset}
                         method indicates if the key is valid.
                        
                         &lt;p&gt; A watch service is safe for use by multiple concurrent consumers. To
                         ensure that only one consumer processes the events for a particular object at
                         any time then care should be taken to ensure that the key's {@code reset}
                         method is only invoked after its events have been processed. The {@link
                         #close close} method may be invoked at any time to close the service causing
                         any threads waiting to retrieve keys, to throw {@code
                         ClosedWatchServiceException}.
                        
                         &lt;p&gt; File systems may report events faster than they can be retrieved or
                         processed and an implementation may impose an unspecified limit on the number
                         of events that it may accumulate. Where an implementation &lt;em&gt;knowingly&lt;/em&gt;
                         discards events then it arranges for the key's {@link WatchKey#pollEvents
                         pollEvents} method to return an element with an event type of {@link
                         StandardWatchEventKinds#OVERFLOW OVERFLOW}. This event can be used by the
                         consumer as a trigger to re-examine the state of the object.
                        
                         &lt;p&gt; When an event is reported to indicate that a file in a watched directory
                         has been modified then there is no guarantee that the program (or programs)
                         that have modified the file have completed. Care should be taken to coordinate
                         access with other programs that may be updating the file.
                         The {@link java.nio.channels.FileChannel FileChannel} class defines methods
                         to lock regions of a file against access by other programs.
                        
                         &lt;h2&gt;Platform dependencies&lt;/h2&gt;
                        
                         &lt;p&gt; The implementation that observes events from the file system is intended
                         to map directly on to the native file event notification facility where
                         available, or to use a primitive mechanism, such as polling, when a native
                         facility is not available. Consequently, many of the details on how events
                         are detected, their timeliness, and whether their ordering is preserved are
                         highly implementation specific. For example, when a file in a watched
                         directory is modified then it may result in a single {@link
                         StandardWatchEventKinds#ENTRY_MODIFY ENTRY_MODIFY} event in some
                         implementations but several events in other implementations. Short-lived
                         files (meaning files that are deleted very quickly after they are created)
                         may not be detected by primitive implementations that periodically poll the
                         file system to detect changes.
                        
                         &lt;p&gt; If a watched file is not located on a local storage device then it is
                         implementation specific if changes to the file can be detected. In particular,
                         it is not required that changes to files carried out on remote systems be
                         detected.
                        
                         @since 1.7
                        
                         @see FileSystem#newWatchService
                        </javadoc>
                </acts>
                <package name="attribute"/>
                <package name="spi"/>
            </package>
            <package name="channels">
                <package name="spi"/>
            </package>
        </package>
        <package name="beans">
            <package name="beancontext"/>
        </package>
        <package name="math">
            <acts name="RoundingMode" access="PUBLIC" kind="TYPE" typeKind="ENUM" packageName="java.math">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Specifies a &lt;i&gt;rounding behavior&lt;/i&gt; for numerical operations
                     capable of discarding precision. Each rounding mode indicates how
                     the least significant returned digit of a rounded result is to be
                     calculated.  If fewer digits are returned than the digits needed to
                     represent the exact numerical result, the discarded digits will be
                     referred to as the &lt;i&gt;discarded fraction&lt;/i&gt; regardless the digits'
                     contribution to the value of the number.  In other words,
                     considered as a numerical value, the discarded fraction could have
                     an absolute value greater than one.
                    
                     &lt;p&gt;Each rounding mode description includes a table listing how
                     different two-digit decimal values would round to a one digit
                     decimal value under the rounding mode in question.  The result
                     column in the tables could be gotten by creating a
                     {@code BigDecimal} number with the specified value, forming a
                     {@link MathContext} object with the proper settings
                     ({@code precision} set to {@code 1}, and the
                     {@code roundingMode} set to the rounding mode in question), and
                     calling {@link BigDecimal#round round} on this number with the
                     proper {@code MathContext}.  A summary table showing the results
                     of these rounding operations for all rounding modes appears below.
                    
                    &lt;table class="striped"&gt;
                     &lt;caption&gt;&lt;b&gt;Summary of Rounding Operations Under Different Rounding Modes&lt;/b&gt;&lt;/caption&gt;
                     &lt;thead&gt;
                     &lt;tr&gt;&lt;th scope="col" rowspan="2"&gt;Input Number&lt;/th&gt;&lt;th scope="col"colspan=8&gt;Result of rounding input to one digit with the given
                                               rounding mode&lt;/th&gt;
                     &lt;tr style="vertical-align:top"&gt;
                                                   &lt;th&gt;{@code UP}&lt;/th&gt;
                                                               &lt;th&gt;{@code DOWN}&lt;/th&gt;
                                                                            &lt;th&gt;{@code CEILING}&lt;/th&gt;
                                                                                           &lt;th&gt;{@code FLOOR}&lt;/th&gt;
                                                                                                        &lt;th&gt;{@code HALF_UP}&lt;/th&gt;
                                                                                                                       &lt;th&gt;{@code HALF_DOWN}&lt;/th&gt;
                                                                                                                                        &lt;th&gt;{@code HALF_EVEN}&lt;/th&gt;
                                                                                                                                                         &lt;th&gt;{@code UNNECESSARY}&lt;/th&gt;
                     &lt;/thead&gt;
                     &lt;tbody style="text-align:right"&gt;
                    
                     &lt;tr&gt;&lt;th scope="row"&gt;5.5&lt;/th&gt;  &lt;td&gt;6&lt;/td&gt;  &lt;td&gt;5&lt;/td&gt;    &lt;td&gt;6&lt;/td&gt;    &lt;td&gt;5&lt;/td&gt;  &lt;td&gt;6&lt;/td&gt;      &lt;td&gt;5&lt;/td&gt;       &lt;td&gt;6&lt;/td&gt;       &lt;td&gt;throw {@code ArithmeticException}&lt;/td&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;2.5&lt;/th&gt;  &lt;td&gt;3&lt;/td&gt;  &lt;td&gt;2&lt;/td&gt;    &lt;td&gt;3&lt;/td&gt;    &lt;td&gt;2&lt;/td&gt;  &lt;td&gt;3&lt;/td&gt;      &lt;td&gt;2&lt;/td&gt;       &lt;td&gt;2&lt;/td&gt;       &lt;td&gt;throw {@code ArithmeticException}&lt;/td&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;1.6&lt;/th&gt;  &lt;td&gt;2&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;    &lt;td&gt;2&lt;/td&gt;    &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;2&lt;/td&gt;      &lt;td&gt;2&lt;/td&gt;       &lt;td&gt;2&lt;/td&gt;       &lt;td&gt;throw {@code ArithmeticException}&lt;/td&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;1.1&lt;/th&gt;  &lt;td&gt;2&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;    &lt;td&gt;2&lt;/td&gt;    &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;      &lt;td&gt;1&lt;/td&gt;       &lt;td&gt;1&lt;/td&gt;       &lt;td&gt;throw {@code ArithmeticException}&lt;/td&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;1.0&lt;/th&gt;  &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;    &lt;td&gt;1&lt;/td&gt;    &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;      &lt;td&gt;1&lt;/td&gt;       &lt;td&gt;1&lt;/td&gt;       &lt;td&gt;1&lt;/td&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;-1.0&lt;/th&gt; &lt;td&gt;-1&lt;/td&gt; &lt;td&gt;-1&lt;/td&gt;   &lt;td&gt;-1&lt;/td&gt;   &lt;td&gt;-1&lt;/td&gt; &lt;td&gt;-1&lt;/td&gt;     &lt;td&gt;-1&lt;/td&gt;      &lt;td&gt;-1&lt;/td&gt;      &lt;td&gt;-1&lt;/td&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;-1.1&lt;/th&gt; &lt;td&gt;-2&lt;/td&gt; &lt;td&gt;-1&lt;/td&gt;   &lt;td&gt;-1&lt;/td&gt;   &lt;td&gt;-2&lt;/td&gt; &lt;td&gt;-1&lt;/td&gt;     &lt;td&gt;-1&lt;/td&gt;      &lt;td&gt;-1&lt;/td&gt;      &lt;td&gt;throw {@code ArithmeticException}&lt;/td&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;-1.6&lt;/th&gt; &lt;td&gt;-2&lt;/td&gt; &lt;td&gt;-1&lt;/td&gt;   &lt;td&gt;-1&lt;/td&gt;   &lt;td&gt;-2&lt;/td&gt; &lt;td&gt;-2&lt;/td&gt;     &lt;td&gt;-2&lt;/td&gt;      &lt;td&gt;-2&lt;/td&gt;      &lt;td&gt;throw {@code ArithmeticException}&lt;/td&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;-2.5&lt;/th&gt; &lt;td&gt;-3&lt;/td&gt; &lt;td&gt;-2&lt;/td&gt;   &lt;td&gt;-2&lt;/td&gt;   &lt;td&gt;-3&lt;/td&gt; &lt;td&gt;-3&lt;/td&gt;     &lt;td&gt;-2&lt;/td&gt;      &lt;td&gt;-2&lt;/td&gt;      &lt;td&gt;throw {@code ArithmeticException}&lt;/td&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;-5.5&lt;/th&gt; &lt;td&gt;-6&lt;/td&gt; &lt;td&gt;-5&lt;/td&gt;   &lt;td&gt;-5&lt;/td&gt;   &lt;td&gt;-6&lt;/td&gt; &lt;td&gt;-6&lt;/td&gt;     &lt;td&gt;-5&lt;/td&gt;      &lt;td&gt;-6&lt;/td&gt;      &lt;td&gt;throw {@code ArithmeticException}&lt;/td&gt;
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                    
                     &lt;p&gt;This {@code enum} is intended to replace the integer-based
                     enumeration of rounding mode constants in {@link BigDecimal}
                     ({@link BigDecimal#ROUND_UP}, {@link BigDecimal#ROUND_DOWN},
                     etc. ).
                    
                     @see     BigDecimal
                     @see     MathContext
                     @author  Josh Bloch
                     @author  Mike Cowlishaw
                     @author  Joseph D. Darcy
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="BigInteger" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.math">
                <superTypes>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Number"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Immutable arbitrary-precision integers.  All operations behave as if
                     BigIntegers were represented in two's-complement notation (like Java's
                     primitive integer types).  BigInteger provides analogues to all of Java's
                     primitive integer operators, and all relevant methods from java.lang.Math.
                     Additionally, BigInteger provides operations for modular arithmetic, GCD
                     calculation, primality testing, prime generation, bit manipulation,
                     and a few other miscellaneous operations.
                    
                     &lt;p&gt;Semantics of arithmetic operations exactly mimic those of Java's integer
                     arithmetic operators, as defined in &lt;i&gt;The Java&amp;trade; Language Specification&lt;/i&gt;.
                     For example, division by zero throws an {@code ArithmeticException}, and
                     division of a negative by a positive yields a negative (or zero) remainder.
                    
                     &lt;p&gt;Semantics of shift operations extend those of Java's shift operators
                     to allow for negative shift distances.  A right-shift with a negative
                     shift distance results in a left shift, and vice-versa.  The unsigned
                     right shift operator ({@code &gt;&gt;&gt;}) is omitted since this operation
                     only makes sense for a fixed sized word and not for a
                     representation conceptually having an infinite number of leading
                     virtual sign bits.
                    
                     &lt;p&gt;Semantics of bitwise logical operations exactly mimic those of Java's
                     bitwise integer operators.  The binary operators ({@code and},
                     {@code or}, {@code xor}) implicitly perform sign extension on the shorter
                     of the two operands prior to performing the operation.
                    
                     &lt;p&gt;Comparison operations perform signed integer comparisons, analogous to
                     those performed by Java's relational and equality operators.
                    
                     &lt;p&gt;Modular arithmetic operations are provided to compute residues, perform
                     exponentiation, and compute multiplicative inverses.  These methods always
                     return a non-negative result, between {@code 0} and {@code (modulus - 1)},
                     inclusive.
                    
                     &lt;p&gt;Bit operations operate on a single bit of the two's-complement
                     representation of their operand.  If necessary, the operand is sign-
                     extended so that it contains the designated bit.  None of the single-bit
                     operations can produce a BigInteger with a different sign from the
                     BigInteger being operated on, as they affect only a single bit, and the
                     arbitrarily large abstraction provided by this class ensures that conceptually
                     there are infinitely many "virtual sign bits" preceding each BigInteger.
                    
                     &lt;p&gt;For the sake of brevity and clarity, pseudo-code is used throughout the
                     descriptions of BigInteger methods.  The pseudo-code expression
                     {@code (i + j)} is shorthand for "a BigInteger whose value is
                     that of the BigInteger {@code i} plus that of the BigInteger {@code j}."
                     The pseudo-code expression {@code (i == j)} is shorthand for
                     "{@code true} if and only if the BigInteger {@code i} represents the same
                     value as the BigInteger {@code j}."  Other pseudo-code expressions are
                     interpreted similarly.
                    
                     &lt;p&gt;All methods and constructors in this class throw
                     {@code NullPointerException} when passed
                     a null object reference for any input parameter.
                    
                     BigInteger must support values in the range
                     -2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive) to
                     +2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive)
                     and may support values outside of that range.
                    
                     An {@code ArithmeticException} is thrown when a BigInteger
                     constructor or method would generate a value outside of the
                     supported range.
                    
                     The range of probable prime values is limited and may be less than
                     the full supported positive range of {@code BigInteger}.
                     The range must be at least 1 to 2&lt;sup&gt;500000000&lt;/sup&gt;.
                    
                     @implNote
                     In the reference implementation, BigInteger constructors and
                     operations throw {@code ArithmeticException} when the result is out
                     of the supported range of
                     -2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive) to
                     +2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive).
                    
                     @see     BigDecimal
                     @jls     4.2.2 Integer Operations
                     @author  Josh Bloch
                     @author  Michael McCloskey
                     @author  Alan Eliasen
                     @author  Timothy Buktu
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="BigDecimal" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.math">
                <superTypes>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Number"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Immutable, arbitrary-precision signed decimal numbers.  A
                     {@code BigDecimal} consists of an arbitrary precision integer
                     &lt;i&gt;unscaled value&lt;/i&gt; and a 32-bit integer &lt;i&gt;scale&lt;/i&gt;.  If zero
                     or positive, the scale is the number of digits to the right of the
                     decimal point.  If negative, the unscaled value of the number is
                     multiplied by ten to the power of the negation of the scale.  The
                     value of the number represented by the {@code BigDecimal} is
                     therefore &lt;code&gt;(unscaledValue &amp;times; 10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/code&gt;.
                    
                     &lt;p&gt;The {@code BigDecimal} class provides operations for
                     arithmetic, scale manipulation, rounding, comparison, hashing, and
                     format conversion.  The {@link #toString} method provides a
                     canonical representation of a {@code BigDecimal}.
                    
                     &lt;p&gt;The {@code BigDecimal} class gives its user complete control
                     over rounding behavior.  If no rounding mode is specified and the
                     exact result cannot be represented, an exception is thrown;
                     otherwise, calculations can be carried out to a chosen precision
                     and rounding mode by supplying an appropriate {@link MathContext}
                     object to the operation.  In either case, eight &lt;em&gt;rounding
                     modes&lt;/em&gt; are provided for the control of rounding.  Using the
                     integer fields in this class (such as {@link #ROUND_HALF_UP}) to
                     represent rounding mode is deprecated; the enumeration values
                     of the {@code RoundingMode} {@code enum}, (such as {@link
                     RoundingMode#HALF_UP}) should be used instead.
                    
                     &lt;p&gt;When a {@code MathContext} object is supplied with a precision
                     setting of 0 (for example, {@link MathContext#UNLIMITED}),
                     arithmetic operations are exact, as are the arithmetic methods
                     which take no {@code MathContext} object.  (This is the only
                     behavior that was supported in releases prior to 5.)  As a
                     corollary of computing the exact result, the rounding mode setting
                     of a {@code MathContext} object with a precision setting of 0 is
                     not used and thus irrelevant.  In the case of divide, the exact
                     quotient could have an infinitely long decimal expansion; for
                     example, 1 divided by 3.  If the quotient has a nonterminating
                     decimal expansion and the operation is specified to return an exact
                     result, an {@code ArithmeticException} is thrown.  Otherwise, the
                     exact result of the division is returned, as done for other
                     operations.
                    
                     &lt;p&gt;When the precision setting is not 0, the rules of
                     {@code BigDecimal} arithmetic are broadly compatible with selected
                     modes of operation of the arithmetic defined in ANSI X3.274-1996
                     and ANSI X3.274-1996/AM 1-2000 (section 7.4).  Unlike those
                     standards, {@code BigDecimal} includes many rounding modes, which
                     were mandatory for division in {@code BigDecimal} releases prior
                     to 5.  Any conflicts between these ANSI standards and the
                     {@code BigDecimal} specification are resolved in favor of
                     {@code BigDecimal}.
                    
                     &lt;p&gt;Since the same numerical value can have different
                     representations (with different scales), the rules of arithmetic
                     and rounding must specify both the numerical result and the scale
                     used in the result's representation.
                    
                    
                     &lt;p&gt;In general the rounding modes and precision setting determine
                     how operations return results with a limited number of digits when
                     the exact result has more digits (perhaps infinitely many in the
                     case of division and square root) than the number of digits returned.
                    
                     First, the
                     total number of digits to return is specified by the
                     {@code MathContext}'s {@code precision} setting; this determines
                     the result's &lt;i&gt;precision&lt;/i&gt;.  The digit count starts from the
                     leftmost nonzero digit of the exact result.  The rounding mode
                     determines how any discarded trailing digits affect the returned
                     result.
                    
                     &lt;p&gt;For all arithmetic operators , the operation is carried out as
                     though an exact intermediate result were first calculated and then
                     rounded to the number of digits specified by the precision setting
                     (if necessary), using the selected rounding mode.  If the exact
                     result is not returned, some digit positions of the exact result
                     are discarded.  When rounding increases the magnitude of the
                     returned result, it is possible for a new digit position to be
                     created by a carry propagating to a leading {@literal "9"} digit.
                     For example, rounding the value 999.9 to three digits rounding up
                     would be numerically equal to one thousand, represented as
                     100&amp;times;10&lt;sup&gt;1&lt;/sup&gt;.  In such cases, the new {@literal "1"} is
                     the leading digit position of the returned result.
                    
                     &lt;p&gt;Besides a logical exact result, each arithmetic operation has a
                     preferred scale for representing a result.  The preferred
                     scale for each operation is listed in the table below.
                    
                     &lt;table class="striped" style="text-align:left"&gt;
                     &lt;caption&gt;Preferred Scales for Results of Arithmetic Operations
                     &lt;/caption&gt;
                     &lt;thead&gt;
                     &lt;tr&gt;&lt;th scope="col"&gt;Operation&lt;/th&gt;&lt;th scope="col"&gt;Preferred Scale of Result&lt;/th&gt;&lt;/tr&gt;
                     &lt;/thead&gt;
                     &lt;tbody&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;Add&lt;/th&gt;&lt;td&gt;max(addend.scale(), augend.scale())&lt;/td&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;Subtract&lt;/th&gt;&lt;td&gt;max(minuend.scale(), subtrahend.scale())&lt;/td&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;Multiply&lt;/th&gt;&lt;td&gt;multiplier.scale() + multiplicand.scale()&lt;/td&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;Divide&lt;/th&gt;&lt;td&gt;dividend.scale() - divisor.scale()&lt;/td&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;Square root&lt;/th&gt;&lt;td&gt;radicand.scale()/2&lt;/td&gt;
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     These scales are the ones used by the methods which return exact
                     arithmetic results; except that an exact divide may have to use a
                     larger scale since the exact result may have more digits.  For
                     example, {@code 1/32} is {@code 0.03125}.
                    
                     &lt;p&gt;Before rounding, the scale of the logical exact intermediate
                     result is the preferred scale for that operation.  If the exact
                     numerical result cannot be represented in {@code precision}
                     digits, rounding selects the set of digits to return and the scale
                     of the result is reduced from the scale of the intermediate result
                     to the least scale which can represent the {@code precision}
                     digits actually returned.  If the exact result can be represented
                     with at most {@code precision} digits, the representation
                     of the result with the scale closest to the preferred scale is
                     returned.  In particular, an exactly representable quotient may be
                     represented in fewer than {@code precision} digits by removing
                     trailing zeros and decreasing the scale.  For example, rounding to
                     three digits using the {@linkplain RoundingMode#FLOOR floor}
                     rounding mode, &lt;br&gt;
                    
                     {@code 19/100 = 0.19   // integer=19,  scale=2} &lt;br&gt;
                    
                     but&lt;br&gt;
                    
                     {@code 21/110 = 0.190  // integer=190, scale=3} &lt;br&gt;
                    
                     &lt;p&gt;Note that for add, subtract, and multiply, the reduction in
                     scale will equal the number of digit positions of the exact result
                     which are discarded. If the rounding causes a carry propagation to
                     create a new high-order digit position, an additional digit of the
                     result is discarded than when no new digit position is created.
                    
                     &lt;p&gt;Other methods may have slightly different rounding semantics.
                     For example, the result of the {@code pow} method using the
                     {@linkplain #pow(int, MathContext) specified algorithm} can
                     occasionally differ from the rounded mathematical result by more
                     than one unit in the last place, one &lt;i&gt;{@linkplain #ulp() ulp}&lt;/i&gt;.
                    
                     &lt;p&gt;Two types of operations are provided for manipulating the scale
                     of a {@code BigDecimal}: scaling/rounding operations and decimal
                     point motion operations.  Scaling/rounding operations ({@link
                     #setScale setScale} and {@link #round round}) return a
                     {@code BigDecimal} whose value is approximately (or exactly) equal
                     to that of the operand, but whose scale or precision is the
                     specified value; that is, they increase or decrease the precision
                     of the stored number with minimal effect on its value.  Decimal
                     point motion operations ({@link #movePointLeft movePointLeft} and
                     {@link #movePointRight movePointRight}) return a
                     {@code BigDecimal} created from the operand by moving the decimal
                     point a specified distance in the specified direction.
                    
                     &lt;p&gt;For the sake of brevity and clarity, pseudo-code is used
                     throughout the descriptions of {@code BigDecimal} methods.  The
                     pseudo-code expression {@code (i + j)} is shorthand for "a
                     {@code BigDecimal} whose value is that of the {@code BigDecimal}
                     {@code i} added to that of the {@code BigDecimal}
                     {@code j}." The pseudo-code expression {@code (i == j)} is
                     shorthand for "{@code true} if and only if the
                     {@code BigDecimal} {@code i} represents the same value as the
                     {@code BigDecimal} {@code j}." Other pseudo-code expressions
                     are interpreted similarly.  Square brackets are used to represent
                     the particular {@code BigInteger} and scale pair defining a
                     {@code BigDecimal} value; for example [19, 2] is the
                     {@code BigDecimal} numerically equal to 0.19 having a scale of 2.
                    
                    
                     &lt;p&gt;All methods and constructors for this class throw
                     {@code NullPointerException} when passed a {@code null} object
                     reference for any input parameter.
                    
                     @apiNote Care should be exercised if {@code BigDecimal} objects
                     are used as keys in a {@link java.util.SortedMap SortedMap} or
                     elements in a {@link java.util.SortedSet SortedSet} since
                     {@code BigDecimal}'s &lt;i&gt;natural ordering&lt;/i&gt; is &lt;em&gt;inconsistent
                     with equals&lt;/em&gt;.  See {@link Comparable}, {@link
                     java.util.SortedMap} or {@link java.util.SortedSet} for more
                     information.
                    
                     @see     BigInteger
                     @see     MathContext
                     @see     RoundingMode
                     @see     java.util.SortedMap
                     @see     java.util.SortedSet
                     @author  Josh Bloch
                     @author  Mike Cowlishaw
                     @author  Joseph D. Darcy
                     @author  Sergey V. Kuksenko
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="MathContext" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.math">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Immutable objects which encapsulate the context settings which
                     describe certain rules for numerical operators, such as those
                     implemented by the {@link BigDecimal} class.
                    
                     &lt;p&gt;The base-independent settings are:
                     &lt;ol&gt;
                     &lt;li&gt;{@code precision}:
                     the number of digits to be used for an operation; results are
                     rounded to this precision
                    
                     &lt;li&gt;{@code roundingMode}:
                     a {@link RoundingMode} object which specifies the algorithm to be
                     used for rounding.
                     &lt;/ol&gt;
                    
                     @see     BigDecimal
                     @see     RoundingMode
                     @author  Mike Cowlishaw
                     @author  Joseph D. Darcy
                     @since 1.5
                    </javadoc>
            </acts>
        </package>
        <package name="text">
            <acts name="RuleBasedCollator" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.text.Collator"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The &lt;code&gt;RuleBasedCollator&lt;/code&gt; class is a concrete subclass of
                     &lt;code&gt;Collator&lt;/code&gt; that provides a simple, data-driven, table
                     collator.  With this class you can create a customized table-based
                     &lt;code&gt;Collator&lt;/code&gt;.  &lt;code&gt;RuleBasedCollator&lt;/code&gt; maps
                     characters to sort keys.
                    
                     &lt;p&gt;
                     &lt;code&gt;RuleBasedCollator&lt;/code&gt; has the following restrictions
                     for efficiency (other subclasses may be used for more complex languages) :
                     &lt;ol&gt;
                     &lt;li&gt;If a special collation rule controlled by a &amp;lt;modifier&amp;gt; is
                          specified it applies to the whole collator object.
                     &lt;li&gt;All non-mentioned characters are at the end of the
                         collation order.
                     &lt;/ol&gt;
                    
                     &lt;p&gt;
                     The collation table is composed of a list of collation rules, where each
                     rule is of one of three forms:
                     &lt;pre&gt;
                        &amp;lt;modifier&amp;gt;
                        &amp;lt;relation&amp;gt; &amp;lt;text-argument&amp;gt;
                        &amp;lt;reset&amp;gt; &amp;lt;text-argument&amp;gt;
                     &lt;/pre&gt;
                     The definitions of the rule elements is as follows:
                     &lt;UL&gt;
                        &lt;LI&gt;&lt;strong&gt;Text-Argument&lt;/strong&gt;: A text-argument is any sequence of
                            characters, excluding special characters (that is, common
                            whitespace characters [0009-000D, 0020] and rule syntax characters
                            [0021-002F, 003A-0040, 005B-0060, 007B-007E]). If those
                            characters are desired, you can put them in single quotes
                            (e.g. ampersand =&amp;gt; '&amp;amp;'). Note that unquoted white space characters
                            are ignored; e.g. &lt;code&gt;b c&lt;/code&gt; is treated as &lt;code&gt;bc&lt;/code&gt;.
                        &lt;LI&gt;&lt;strong&gt;Modifier&lt;/strong&gt;: There are currently two modifiers that
                            turn on special collation rules.
                            &lt;UL&gt;
                                &lt;LI&gt;'@' : Turns on backwards sorting of accents (secondary
                                          differences), as in French.
                                &lt;LI&gt;'!' : Turns on Thai/Lao vowel-consonant swapping.  If this
                                          rule is in force when a Thai vowel of the range
                                          &amp;#92;U0E40-&amp;#92;U0E44 precedes a Thai consonant of the range
                                          &amp;#92;U0E01-&amp;#92;U0E2E OR a Lao vowel of the range &amp;#92;U0EC0-&amp;#92;U0EC4
                                          precedes a Lao consonant of the range &amp;#92;U0E81-&amp;#92;U0EAE then
                                          the vowel is placed after the consonant for collation
                                          purposes.
                            &lt;/UL&gt;
                            &lt;p&gt;'@' : Indicates that accents are sorted backwards, as in French.
                        &lt;LI&gt;&lt;strong&gt;Relation&lt;/strong&gt;: The relations are the following:
                            &lt;UL&gt;
                                &lt;LI&gt;'&amp;lt;' : Greater, as a letter difference (primary)
                                &lt;LI&gt;';' : Greater, as an accent difference (secondary)
                                &lt;LI&gt;',' : Greater, as a case difference (tertiary)
                                &lt;LI&gt;'=' : Equal
                            &lt;/UL&gt;
                        &lt;LI&gt;&lt;strong&gt;Reset&lt;/strong&gt;: There is a single reset
                            which is used primarily for contractions and expansions, but which
                            can also be used to add a modification at the end of a set of rules.
                            &lt;p&gt;'&amp;amp;' : Indicates that the next rule follows the position to where
                                the reset text-argument would be sorted.
                     &lt;/UL&gt;
                    
                     &lt;p&gt;
                     This sounds more complicated than it is in practice. For example, the
                     following are equivalent ways of expressing the same thing:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     a &amp;lt; b &amp;lt; c
                     a &amp;lt; b &amp;amp; b &amp;lt; c
                     a &amp;lt; c &amp;amp; a &amp;lt; b
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                     Notice that the order is important, as the subsequent item goes immediately
                     after the text-argument. The following are not equivalent:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     a &amp;lt; b &amp;amp; a &amp;lt; c
                     a &amp;lt; c &amp;amp; a &amp;lt; b
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                     Either the text-argument must already be present in the sequence, or some
                     initial substring of the text-argument must be present. (e.g. "a &amp;lt; b &amp;amp; ae &amp;lt;
                     e" is valid since "a" is present in the sequence before "ae" is reset). In
                     this latter case, "ae" is not entered and treated as a single character;
                     instead, "e" is sorted as if it were expanded to two characters: "a"
                     followed by an "e". This difference appears in natural languages: in
                     traditional Spanish "ch" is treated as though it contracts to a single
                     character (expressed as "c &amp;lt; ch &amp;lt; d"), while in traditional German
                     a-umlaut is treated as though it expanded to two characters
                     (expressed as "a,A &amp;lt; b,B ... &amp;amp;ae;&amp;#92;u00e3&amp;amp;AE;&amp;#92;u00c3").
                     [&amp;#92;u00e3 and &amp;#92;u00c3 are, of course, the escape sequences for a-umlaut.]
                     &lt;p&gt;
                     &lt;strong&gt;Ignorable Characters&lt;/strong&gt;
                     &lt;p&gt;
                     For ignorable characters, the first rule must start with a relation (the
                     examples we have used above are really fragments; "a &amp;lt; b" really should be
                     "&amp;lt; a &amp;lt; b"). If, however, the first relation is not "&amp;lt;", then all the all
                     text-arguments up to the first "&amp;lt;" are ignorable. For example, ", - &amp;lt; a &amp;lt; b"
                     makes "-" an ignorable character, as we saw earlier in the word
                     "black-birds". In the samples for different languages, you see that most
                     accents are ignorable.
                    
                     &lt;p&gt;&lt;strong&gt;Normalization and Accents&lt;/strong&gt;
                     &lt;p&gt;
                     &lt;code&gt;RuleBasedCollator&lt;/code&gt; automatically processes its rule table to
                     include both pre-composed and combining-character versions of
                     accented characters.  Even if the provided rule string contains only
                     base characters and separate combining accent characters, the pre-composed
                     accented characters matching all canonical combinations of characters from
                     the rule string will be entered in the table.
                     &lt;p&gt;
                     This allows you to use a RuleBasedCollator to compare accented strings
                     even when the collator is set to NO_DECOMPOSITION.  There are two caveats,
                     however.  First, if the strings to be collated contain combining
                     sequences that may not be in canonical order, you should set the collator to
                     CANONICAL_DECOMPOSITION or FULL_DECOMPOSITION to enable sorting of
                     combining sequences.  Second, if the strings contain characters with
                     compatibility decompositions (such as full-width and half-width forms),
                     you must use FULL_DECOMPOSITION, since the rule tables only include
                     canonical mappings.
                    
                     &lt;p&gt;&lt;strong&gt;Errors&lt;/strong&gt;
                     &lt;p&gt;
                     The following are errors:
                     &lt;UL&gt;
                         &lt;LI&gt;A text-argument contains unquoted punctuation symbols
                            (e.g. "a &amp;lt; b-c &amp;lt; d").
                         &lt;LI&gt;A relation or reset character not followed by a text-argument
                            (e.g. "a &amp;lt; ,b").
                         &lt;LI&gt;A reset where the text-argument (or an initial substring of the
                             text-argument) is not already in the sequence.
                             (e.g. "a &amp;lt; b &amp;amp; e &amp;lt; f")
                     &lt;/UL&gt;
                     If you produce one of these errors, a &lt;code&gt;RuleBasedCollator&lt;/code&gt; throws
                     a &lt;code&gt;ParseException&lt;/code&gt;.
                    
                     &lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;
                     &lt;p&gt;Simple:     "&amp;lt; a &amp;lt; b &amp;lt; c &amp;lt; d"
                     &lt;p&gt;Norwegian:  "&amp;lt; a, A &amp;lt; b, B &amp;lt; c, C &amp;lt; d, D &amp;lt; e, E &amp;lt; f, F
                                     &amp;lt; g, G &amp;lt; h, H &amp;lt; i, I &amp;lt; j, J &amp;lt; k, K &amp;lt; l, L
                                     &amp;lt; m, M &amp;lt; n, N &amp;lt; o, O &amp;lt; p, P &amp;lt; q, Q &amp;lt; r, R
                                     &amp;lt; s, S &amp;lt; t, T &amp;lt; u, U &amp;lt; v, V &amp;lt; w, W &amp;lt; x, X
                                     &amp;lt; y, Y &amp;lt; z, Z
                                     &amp;lt; &amp;#92;u00E6, &amp;#92;u00C6
                                     &amp;lt; &amp;#92;u00F8, &amp;#92;u00D8
                                     &amp;lt; &amp;#92;u00E5 = a&amp;#92;u030A, &amp;#92;u00C5 = A&amp;#92;u030A;
                                          aa, AA"
                    
                     &lt;p&gt;
                     To create a &lt;code&gt;RuleBasedCollator&lt;/code&gt; object with specialized
                     rules tailored to your needs, you construct the &lt;code&gt;RuleBasedCollator&lt;/code&gt;
                     with the rules contained in a &lt;code&gt;String&lt;/code&gt; object. For example:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     String simple = "&amp;lt; a&amp;lt; b&amp;lt; c&amp;lt; d";
                     RuleBasedCollator mySimple = new RuleBasedCollator(simple);
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                     Or:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     String Norwegian = "&amp;lt; a, A &amp;lt; b, B &amp;lt; c, C &amp;lt; d, D &amp;lt; e, E &amp;lt; f, F &amp;lt; g, G &amp;lt; h, H &amp;lt; i, I" +
                                        "&amp;lt; j, J &amp;lt; k, K &amp;lt; l, L &amp;lt; m, M &amp;lt; n, N &amp;lt; o, O &amp;lt; p, P &amp;lt; q, Q &amp;lt; r, R" +
                                        "&amp;lt; s, S &amp;lt; t, T &amp;lt; u, U &amp;lt; v, V &amp;lt; w, W &amp;lt; x, X &amp;lt; y, Y &amp;lt; z, Z" +
                                        "&amp;lt; &amp;#92;u00E6, &amp;#92;u00C6" +     // Latin letter ae &amp;amp; AE
                                        "&amp;lt; &amp;#92;u00F8, &amp;#92;u00D8" +     // Latin letter o &amp;amp; O with stroke
                                        "&amp;lt; &amp;#92;u00E5 = a&amp;#92;u030A," +  // Latin letter a with ring above
                                        "  &amp;#92;u00C5 = A&amp;#92;u030A;" +  // Latin letter A with ring above
                                        "  aa, AA";
                     RuleBasedCollator myNorwegian = new RuleBasedCollator(Norwegian);
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt;
                     A new collation rules string can be created by concatenating rules
                     strings. For example, the rules returned by {@link #getRules()} could
                     be concatenated to combine multiple &lt;code&gt;RuleBasedCollator&lt;/code&gt;s.
                    
                     &lt;p&gt;
                     The following example demonstrates how to change the order of
                     non-spacing accents,
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     // old rule
                     String oldRules = "=&amp;#92;u0301;&amp;#92;u0300;&amp;#92;u0302;&amp;#92;u0308"    // main accents
                                     + ";&amp;#92;u0327;&amp;#92;u0303;&amp;#92;u0304;&amp;#92;u0305"    // main accents
                                     + ";&amp;#92;u0306;&amp;#92;u0307;&amp;#92;u0309;&amp;#92;u030A"    // main accents
                                     + ";&amp;#92;u030B;&amp;#92;u030C;&amp;#92;u030D;&amp;#92;u030E"    // main accents
                                     + ";&amp;#92;u030F;&amp;#92;u0310;&amp;#92;u0311;&amp;#92;u0312"    // main accents
                                     + "&amp;lt; a , A ; ae, AE ; &amp;#92;u00e6 , &amp;#92;u00c6"
                                     + "&amp;lt; b , B &amp;lt; c, C &amp;lt; e, E &amp;amp; C &amp;lt; d, D";
                     // change the order of accent characters
                     String addOn = "&amp;amp; &amp;#92;u0300 ; &amp;#92;u0308 ; &amp;#92;u0302";
                     RuleBasedCollator myCollator = new RuleBasedCollator(oldRules + addOn);
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     @see        Collator
                     @see        CollationElementIterator
                     @author     Helena Shih, Laura Werner, Richard Gillam
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="Form" access="PUBLIC" declaringClass="Normalizer" kind="TYPE" typeKind="ENUM" packageName="java.text">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="DecimalFormat" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.text.NumberFormat"/>
                    <superType superType="java.text.Format"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;code&gt;DecimalFormat&lt;/code&gt; is a concrete subclass of
                     &lt;code&gt;NumberFormat&lt;/code&gt; that formats decimal numbers. It has a variety of
                     features designed to make it possible to parse and format numbers in any
                     locale, including support for Western, Arabic, and Indic digits.  It also
                     supports different kinds of numbers, including integers (123), fixed-point
                     numbers (123.4), scientific notation (1.23E4), percentages (12%), and
                     currency amounts ($123).  All of these can be localized.
                    
                     &lt;p&gt;To obtain a &lt;code&gt;NumberFormat&lt;/code&gt; for a specific locale, including the
                     default locale, call one of &lt;code&gt;NumberFormat&lt;/code&gt;'s factory methods, such
                     as &lt;code&gt;getInstance()&lt;/code&gt;.  In general, do not call the
                     &lt;code&gt;DecimalFormat&lt;/code&gt; constructors directly, since the
                     &lt;code&gt;NumberFormat&lt;/code&gt; factory methods may return subclasses other than
                     &lt;code&gt;DecimalFormat&lt;/code&gt;. If you need to customize the format object, do
                     something like this:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                     NumberFormat f = NumberFormat.getInstance(loc);
                     if (f instanceof DecimalFormat) {
                         ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);
                     }
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt;A &lt;code&gt;DecimalFormat&lt;/code&gt; comprises a &lt;em&gt;pattern&lt;/em&gt; and a set of
                     &lt;em&gt;symbols&lt;/em&gt;.  The pattern may be set directly using
                     &lt;code&gt;applyPattern()&lt;/code&gt;, or indirectly using the API methods.  The
                     symbols are stored in a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.  When using
                     the &lt;code&gt;NumberFormat&lt;/code&gt; factory methods, the pattern and symbols are
                     read from localized &lt;code&gt;ResourceBundle&lt;/code&gt;s.
                    
                     &lt;h3&gt;Patterns&lt;/h3&gt;
                    
                     &lt;code&gt;DecimalFormat&lt;/code&gt; patterns have the following syntax:
                     &lt;blockquote&gt;&lt;pre&gt;
                     &lt;i&gt;Pattern:&lt;/i&gt;
                             &lt;i&gt;PositivePattern&lt;/i&gt;
                             &lt;i&gt;PositivePattern&lt;/i&gt; ; &lt;i&gt;NegativePattern&lt;/i&gt;
                     &lt;i&gt;PositivePattern:&lt;/i&gt;
                             &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                     &lt;i&gt;NegativePattern:&lt;/i&gt;
                             &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                     &lt;i&gt;Prefix:&lt;/i&gt;
                             any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
                     &lt;i&gt;Suffix:&lt;/i&gt;
                             any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
                     &lt;i&gt;Number:&lt;/i&gt;
                             &lt;i&gt;Integer&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                             &lt;i&gt;Integer&lt;/i&gt; . &lt;i&gt;Fraction&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                     &lt;i&gt;Integer:&lt;/i&gt;
                             &lt;i&gt;MinimumInteger&lt;/i&gt;
                             #
                             # &lt;i&gt;Integer&lt;/i&gt;
                             # , &lt;i&gt;Integer&lt;/i&gt;
                     &lt;i&gt;MinimumInteger:&lt;/i&gt;
                             0
                             0 &lt;i&gt;MinimumInteger&lt;/i&gt;
                             0 , &lt;i&gt;MinimumInteger&lt;/i&gt;
                     &lt;i&gt;Fraction:&lt;/i&gt;
                             &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                     &lt;i&gt;MinimumFraction:&lt;/i&gt;
                             0 &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                     &lt;i&gt;OptionalFraction:&lt;/i&gt;
                             # &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                     &lt;i&gt;Exponent:&lt;/i&gt;
                             E &lt;i&gt;MinimumExponent&lt;/i&gt;
                     &lt;i&gt;MinimumExponent:&lt;/i&gt;
                             0 &lt;i&gt;MinimumExponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt;A &lt;code&gt;DecimalFormat&lt;/code&gt; pattern contains a positive and negative
                     subpattern, for example, &lt;code&gt;"#,##0.00;(#,##0.00)"&lt;/code&gt;.  Each
                     subpattern has a prefix, numeric part, and suffix. The negative subpattern
                     is optional; if absent, then the positive subpattern prefixed with the
                     localized minus sign (&lt;code&gt;'-'&lt;/code&gt; in most locales) is used as the
                     negative subpattern. That is, &lt;code&gt;"0.00"&lt;/code&gt; alone is equivalent to
                     &lt;code&gt;"0.00;-0.00"&lt;/code&gt;.  If there is an explicit negative subpattern, it
                     serves only to specify the negative prefix and suffix; the number of digits,
                     minimal digits, and other characteristics are all the same as the positive
                     pattern. That means that &lt;code&gt;"#,##0.0#;(#)"&lt;/code&gt; produces precisely
                     the same behavior as &lt;code&gt;"#,##0.0#;(#,##0.0#)"&lt;/code&gt;.
                    
                     &lt;p&gt;The prefixes, suffixes, and various symbols used for infinity, digits,
                     thousands separators, decimal separators, etc. may be set to arbitrary
                     values, and they will appear properly during formatting.  However, care must
                     be taken that the symbols and strings do not conflict, or parsing will be
                     unreliable.  For example, either the positive and negative prefixes or the
                     suffixes must be distinct for &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; to be able
                     to distinguish positive from negative values.  (If they are identical, then
                     &lt;code&gt;DecimalFormat&lt;/code&gt; will behave as if no negative subpattern was
                     specified.)  Another example is that the decimal separator and thousands
                     separator should be distinct characters, or parsing will be impossible.
                    
                     &lt;p&gt;The grouping separator is commonly used for thousands, but in some
                     countries it separates ten-thousands. The grouping size is a constant number
                     of digits between the grouping characters, such as 3 for 100,000,000 or 4 for
                     1,0000,0000.  If you supply a pattern with multiple grouping characters, the
                     interval between the last one and the end of the integer is the one that is
                     used. So &lt;code&gt;"#,##,###,####"&lt;/code&gt; == &lt;code&gt;"######,####"&lt;/code&gt; ==
                     &lt;code&gt;"##,####,####"&lt;/code&gt;.
                    
                     &lt;h4&gt;Special Pattern Characters&lt;/h4&gt;
                    
                     &lt;p&gt;Many characters in a pattern are taken literally; they are matched during
                     parsing and output unchanged during formatting.  Special characters, on the
                     other hand, stand for other characters, strings, or classes of characters.
                     They must be quoted, unless noted otherwise, if they are to appear in the
                     prefix or suffix as literals.
                    
                     &lt;p&gt;The characters listed here are used in non-localized patterns.  Localized
                     patterns use the corresponding characters taken from this formatter's
                     &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object instead, and these characters lose
                     their special status.  Two exceptions are the currency sign and quote, which
                     are not localized.
                    
                     &lt;blockquote&gt;
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;Chart showing symbol, location, localized, and meaning.&lt;/caption&gt;
                     &lt;thead&gt;
                         &lt;tr&gt;
                              &lt;th scope="col" style="text-align:left"&gt;Symbol
                              &lt;th scope="col" style="text-align:left"&gt;Location
                              &lt;th scope="col" style="text-align:left"&gt;Localized?
                              &lt;th scope="col" style="text-align:left"&gt;Meaning
                     &lt;/thead&gt;
                     &lt;tbody&gt;
                         &lt;tr style="vertical-align:top"&gt;
                              &lt;th scope="row"&gt;&lt;code&gt;0&lt;/code&gt;
                              &lt;td&gt;Number
                              &lt;td&gt;Yes
                              &lt;td&gt;Digit
                         &lt;tr style="vertical-align: top"&gt;
                              &lt;th scope="row"&gt;&lt;code&gt;#&lt;/code&gt;
                              &lt;td&gt;Number
                              &lt;td&gt;Yes
                              &lt;td&gt;Digit, zero shows as absent
                         &lt;tr style="vertical-align:top"&gt;
                              &lt;th scope="row"&gt;&lt;code&gt;.&lt;/code&gt;
                              &lt;td&gt;Number
                              &lt;td&gt;Yes
                              &lt;td&gt;Decimal separator or monetary decimal separator
                         &lt;tr style="vertical-align: top"&gt;
                              &lt;th scope="row"&gt;&lt;code&gt;-&lt;/code&gt;
                              &lt;td&gt;Number
                              &lt;td&gt;Yes
                              &lt;td&gt;Minus sign
                         &lt;tr style="vertical-align:top"&gt;
                              &lt;th scope="row"&gt;&lt;code&gt;,&lt;/code&gt;
                              &lt;td&gt;Number
                              &lt;td&gt;Yes
                              &lt;td&gt;Grouping separator
                         &lt;tr style="vertical-align: top"&gt;
                              &lt;th scope="row"&gt;&lt;code&gt;E&lt;/code&gt;
                              &lt;td&gt;Number
                              &lt;td&gt;Yes
                              &lt;td&gt;Separates mantissa and exponent in scientific notation.
                                  &lt;em&gt;Need not be quoted in prefix or suffix.&lt;/em&gt;
                         &lt;tr style="vertical-align:top"&gt;
                              &lt;th scope="row"&gt;&lt;code&gt;;&lt;/code&gt;
                              &lt;td&gt;Subpattern boundary
                              &lt;td&gt;Yes
                              &lt;td&gt;Separates positive and negative subpatterns
                         &lt;tr style="vertical-align: top"&gt;
                              &lt;th scope="row"&gt;&lt;code&gt;%&lt;/code&gt;
                              &lt;td&gt;Prefix or suffix
                              &lt;td&gt;Yes
                              &lt;td&gt;Multiply by 100 and show as percentage
                         &lt;tr style="vertical-align:top"&gt;
                              &lt;th scope="row"&gt;&lt;code&gt;&amp;#92;u2030&lt;/code&gt;
                              &lt;td&gt;Prefix or suffix
                              &lt;td&gt;Yes
                              &lt;td&gt;Multiply by 1000 and show as per mille value
                         &lt;tr style="vertical-align: top"&gt;
                              &lt;th scope="row"&gt;&lt;code&gt;&amp;#164;&lt;/code&gt; (&lt;code&gt;&amp;#92;u00A4&lt;/code&gt;)
                              &lt;td&gt;Prefix or suffix
                              &lt;td&gt;No
                              &lt;td&gt;Currency sign, replaced by currency symbol.  If
                                  doubled, replaced by international currency symbol.
                                  If present in a pattern, the monetary decimal separator
                                  is used instead of the decimal separator.
                         &lt;tr style="vertical-align:top"&gt;
                              &lt;th scope="row"&gt;&lt;code&gt;'&lt;/code&gt;
                              &lt;td&gt;Prefix or suffix
                              &lt;td&gt;No
                              &lt;td&gt;Used to quote special characters in a prefix or suffix,
                                  for example, &lt;code&gt;"'#'#"&lt;/code&gt; formats 123 to
                                  &lt;code&gt;"#123"&lt;/code&gt;.  To create a single quote
                                  itself, use two in a row: &lt;code&gt;"# o''clock"&lt;/code&gt;.
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;h4&gt;Scientific Notation&lt;/h4&gt;
                    
                     &lt;p&gt;Numbers in scientific notation are expressed as the product of a mantissa
                     and a power of ten, for example, 1234 can be expressed as 1.234 x 10^3.  The
                     mantissa is often in the range 1.0 &amp;le; x {@literal &lt;} 10.0, but it need not
                     be.
                     &lt;code&gt;DecimalFormat&lt;/code&gt; can be instructed to format and parse scientific
                     notation &lt;em&gt;only via a pattern&lt;/em&gt;; there is currently no factory method
                     that creates a scientific notation format.  In a pattern, the exponent
                     character immediately followed by one or more digit characters indicates
                     scientific notation.  Example: &lt;code&gt;"0.###E0"&lt;/code&gt; formats the number
                     1234 as &lt;code&gt;"1.234E3"&lt;/code&gt;.
                    
                     &lt;ul&gt;
                     &lt;li&gt;The number of digit characters after the exponent character gives the
                     minimum exponent digit count.  There is no maximum.  Negative exponents are
                     formatted using the localized minus sign, &lt;em&gt;not&lt;/em&gt; the prefix and suffix
                     from the pattern.  This allows patterns such as &lt;code&gt;"0.###E0 m/s"&lt;/code&gt;.
                    
                     &lt;li&gt;The minimum and maximum number of integer digits are interpreted
                     together:
                    
                     &lt;ul&gt;
                     &lt;li&gt;If the maximum number of integer digits is greater than their minimum number
                     and greater than 1, it forces the exponent to be a multiple of the maximum
                     number of integer digits, and the minimum number of integer digits to be
                     interpreted as 1.  The most common use of this is to generate
                     &lt;em&gt;engineering notation&lt;/em&gt;, in which the exponent is a multiple of three,
                     e.g., &lt;code&gt;"##0.#####E0"&lt;/code&gt;. Using this pattern, the number 12345
                     formats to &lt;code&gt;"12.345E3"&lt;/code&gt;, and 123456 formats to
                     &lt;code&gt;"123.456E3"&lt;/code&gt;.
                    
                     &lt;li&gt;Otherwise, the minimum number of integer digits is achieved by adjusting the
                     exponent.  Example: 0.00123 formatted with &lt;code&gt;"00.###E0"&lt;/code&gt; yields
                     &lt;code&gt;"12.3E-4"&lt;/code&gt;.
                     &lt;/ul&gt;
                    
                     &lt;li&gt;The number of significant digits in the mantissa is the sum of the
                     &lt;em&gt;minimum integer&lt;/em&gt; and &lt;em&gt;maximum fraction&lt;/em&gt; digits, and is
                     unaffected by the maximum integer digits.  For example, 12345 formatted with
                     &lt;code&gt;"##0.##E0"&lt;/code&gt; is &lt;code&gt;"12.3E3"&lt;/code&gt;. To show all digits, set
                     the significant digits count to zero.  The number of significant digits
                     does not affect parsing.
                    
                     &lt;li&gt;Exponential patterns may not contain grouping separators.
                     &lt;/ul&gt;
                    
                     &lt;h4&gt;Rounding&lt;/h4&gt;
                    
                     &lt;code&gt;DecimalFormat&lt;/code&gt; provides rounding modes defined in
                     {@link java.math.RoundingMode} for formatting.  By default, it uses
                     {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.
                    
                     &lt;h4&gt;Digits&lt;/h4&gt;
                    
                     For formatting, &lt;code&gt;DecimalFormat&lt;/code&gt; uses the ten consecutive
                     characters starting with the localized zero digit defined in the
                     &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object as digits. For parsing, these
                     digits as well as all Unicode decimal digits, as defined by
                     {@link Character#digit Character.digit}, are recognized.
                    
                     &lt;h4&gt;Special Values&lt;/h4&gt;
                    
                     &lt;p&gt;&lt;code&gt;NaN&lt;/code&gt; is formatted as a string, which typically has a single character
                     &lt;code&gt;&amp;#92;uFFFD&lt;/code&gt;.  This string is determined by the
                     &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.  This is the only value for which
                     the prefixes and suffixes are not used.
                    
                     &lt;p&gt;Infinity is formatted as a string, which typically has a single character
                     &lt;code&gt;&amp;#92;u221E&lt;/code&gt;, with the positive or negative prefixes and suffixes
                     applied.  The infinity string is determined by the
                     &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.
                    
                     &lt;p&gt;Negative zero (&lt;code&gt;"-0"&lt;/code&gt;) parses to
                     &lt;ul&gt;
                     &lt;li&gt;&lt;code&gt;BigDecimal(0)&lt;/code&gt; if &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is
                     true,
                     &lt;li&gt;&lt;code&gt;Long(0)&lt;/code&gt; if &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is false
                         and &lt;code&gt;isParseIntegerOnly()&lt;/code&gt; is true,
                     &lt;li&gt;&lt;code&gt;Double(-0.0)&lt;/code&gt; if both &lt;code&gt;isParseBigDecimal()&lt;/code&gt;
                     and &lt;code&gt;isParseIntegerOnly()&lt;/code&gt; are false.
                     &lt;/ul&gt;
                    
                     &lt;h4&gt;&lt;a id="synchronization"&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;p&gt;
                     Decimal formats are generally not synchronized.
                     It is recommended to create separate format instances for each thread.
                     If multiple threads access a format concurrently, it must be synchronized
                     externally.
                    
                     &lt;h4&gt;Example&lt;/h4&gt;
                    
                     &lt;blockquote&gt;&lt;pre&gt;{@code
                     &lt;strong&gt;// Print out a number using the localized number, integer, currency,
                     // and percent format for each locale&lt;/strong&gt;
                     Locale[] locales = NumberFormat.getAvailableLocales();
                     double myNumber = -1234.56;
                     NumberFormat form;
                     for (int j = 0; j &lt; 4; ++j) {
                         System.out.println("FORMAT");
                         for (int i = 0; i &lt; locales.length; ++i) {
                             if (locales[i].getCountry().length() == 0) {
                                continue; // Skip language-only locales
                             }
                             System.out.print(locales[i].getDisplayName());
                             switch (j) {
                             case 0:
                                 form = NumberFormat.getInstance(locales[i]); break;
                             case 1:
                                 form = NumberFormat.getIntegerInstance(locales[i]); break;
                             case 2:
                                 form = NumberFormat.getCurrencyInstance(locales[i]); break;
                             default:
                                 form = NumberFormat.getPercentInstance(locales[i]); break;
                             }
                             if (form instanceof DecimalFormat) {
                                 System.out.print(": " + ((DecimalFormat) form).toPattern());
                             }
                             System.out.print(" -&gt; " + form.format(myNumber));
                             try {
                                 System.out.println(" -&gt; " + form.parse(form.format(myNumber)));
                             } catch (ParseException e) {}
                         }
                     }
                     }&lt;/pre&gt;&lt;/blockquote&gt;
                    
                     @see          &lt;a href="http://docs.oracle.com/javase/tutorial/i18n/format/decimalFormat.html"&gt;Java Tutorial&lt;/a&gt;
                     @see          NumberFormat
                     @see          DecimalFormatSymbols
                     @see          ParsePosition
                     @author       Mark Davis
                     @author       Alan Liu
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="Field" access="PUBLIC" declaringClass="NumberFormat" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.text.Format$Field"/>
                    <superType superType="java.text.AttributedCharacterIterator$Attribute"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="BreakIterator" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The &lt;code&gt;BreakIterator&lt;/code&gt; class implements methods for finding
                     the location of boundaries in text. Instances of &lt;code&gt;BreakIterator&lt;/code&gt;
                     maintain a current position and scan over text
                     returning the index of characters where boundaries occur.
                     Internally, &lt;code&gt;BreakIterator&lt;/code&gt; scans text using a
                     &lt;code&gt;CharacterIterator&lt;/code&gt;, and is thus able to scan text held
                     by any object implementing that protocol. A &lt;code&gt;StringCharacterIterator&lt;/code&gt;
                     is used to scan &lt;code&gt;String&lt;/code&gt; objects passed to &lt;code&gt;setText&lt;/code&gt;.
                    
                     &lt;p&gt;
                     You use the factory methods provided by this class to create
                     instances of various types of break iterators. In particular,
                     use &lt;code&gt;getWordInstance&lt;/code&gt;, &lt;code&gt;getLineInstance&lt;/code&gt;,
                     &lt;code&gt;getSentenceInstance&lt;/code&gt;, and &lt;code&gt;getCharacterInstance&lt;/code&gt;
                     to create &lt;code&gt;BreakIterator&lt;/code&gt;s that perform
                     word, line, sentence, and character boundary analysis respectively.
                     A single &lt;code&gt;BreakIterator&lt;/code&gt; can work only on one unit
                     (word, line, sentence, and so on). You must use a different iterator
                     for each unit boundary analysis you wish to perform.
                    
                     &lt;p&gt;&lt;a id="line"&gt;&lt;/a&gt;
                     Line boundary analysis determines where a text string can be
                     broken when line-wrapping. The mechanism correctly handles
                     punctuation and hyphenated words. Actual line breaking needs
                     to also consider the available line width and is handled by
                     higher-level software.
                    
                     &lt;p&gt;&lt;a id="sentence"&gt;&lt;/a&gt;
                     Sentence boundary analysis allows selection with correct interpretation
                     of periods within numbers and abbreviations, and trailing punctuation
                     marks such as quotation marks and parentheses.
                    
                     &lt;p&gt;&lt;a id="word"&gt;&lt;/a&gt;
                     Word boundary analysis is used by search and replace functions, as
                     well as within text editing applications that allow the user to
                     select words with a double click. Word selection provides correct
                     interpretation of punctuation marks within and following
                     words. Characters that are not part of a word, such as symbols
                     or punctuation marks, have word-breaks on both sides.
                    
                     &lt;p&gt;&lt;a id="character"&gt;&lt;/a&gt;
                     Character boundary analysis allows users to interact with characters
                     as they expect to, for example, when moving the cursor through a text
                     string. Character boundary analysis provides correct navigation
                     through character strings, regardless of how the character is stored.
                     The boundaries returned may be those of supplementary characters,
                     combining character sequences, or ligature clusters.
                     For example, an accented character might be stored as a base character
                     and a diacritical mark. What users consider to be a character can
                     differ between languages.
                    
                     &lt;p&gt;
                     The &lt;code&gt;BreakIterator&lt;/code&gt; instances returned by the factory methods
                     of this class are intended for use with natural languages only, not for
                     programming language text. It is however possible to define subclasses
                     that tokenize a programming language.
                    
                     &lt;P&gt;
                     &lt;strong&gt;Examples&lt;/strong&gt;:&lt;P&gt;
                     Creating and using text boundaries:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     public static void main(String args[]) {
                          if (args.length == 1) {
                              String stringToExamine = args[0];
                              //print each word in order
                              BreakIterator boundary = BreakIterator.getWordInstance();
                              boundary.setText(stringToExamine);
                              printEachForward(boundary, stringToExamine);
                              //print each sentence in reverse order
                              boundary = BreakIterator.getSentenceInstance(Locale.US);
                              boundary.setText(stringToExamine);
                              printEachBackward(boundary, stringToExamine);
                              printFirst(boundary, stringToExamine);
                              printLast(boundary, stringToExamine);
                          }
                     }
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     Print each element in order:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     public static void printEachForward(BreakIterator boundary, String source) {
                         int start = boundary.first();
                         for (int end = boundary.next();
                              end != BreakIterator.DONE;
                              start = end, end = boundary.next()) {
                              System.out.println(source.substring(start,end));
                         }
                     }
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     Print each element in reverse order:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     public static void printEachBackward(BreakIterator boundary, String source) {
                         int end = boundary.last();
                         for (int start = boundary.previous();
                              start != BreakIterator.DONE;
                              end = start, start = boundary.previous()) {
                             System.out.println(source.substring(start,end));
                         }
                     }
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     Print first element:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     public static void printFirst(BreakIterator boundary, String source) {
                         int start = boundary.first();
                         int end = boundary.next();
                         System.out.println(source.substring(start,end));
                     }
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     Print last element:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     public static void printLast(BreakIterator boundary, String source) {
                         int end = boundary.last();
                         int start = boundary.previous();
                         System.out.println(source.substring(start,end));
                     }
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     Print the element at a specified position:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     public static void printAt(BreakIterator boundary, int pos, String source) {
                         int end = boundary.following(pos);
                         int start = boundary.previous();
                         System.out.println(source.substring(start,end));
                     }
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     Find the next word:
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     public static int nextWordStartAfter(int pos, String text) {
                         BreakIterator wb = BreakIterator.getWordInstance();
                         wb.setText(text);
                         int last = wb.following(pos);
                         int current = wb.next();
                         while (current != BreakIterator.DONE) {
                             for (int p = last; p &lt; current; p++) {
                                 if (Character.isLetter(text.codePointAt(p)))
                                     return last;
                             }
                             last = current;
                             current = wb.next();
                         }
                         return BreakIterator.DONE;
                     }
                     }&lt;/pre&gt;
                     (The iterator returned by BreakIterator.getWordInstance() is unique in that
                     the break positions it returns don't represent both the start and end of the
                     thing being iterated over.  That is, a sentence-break iterator returns breaks
                     that each represent the end of one sentence and the beginning of the next.
                     With the word-break iterator, the characters between two boundaries might be a
                     word, or they might be the punctuation or whitespace between two words.  The
                     above code uses a simple heuristic to determine which boundary is the beginning
                     of a word: If the characters between this boundary and the next boundary
                     include at least one letter (this can be an alphabetical letter, a CJK ideograph,
                     a Hangul syllable, a Kana character, etc.), then the text between this boundary
                     and the next is a word; otherwise, it's the material between words.)
                     &lt;/blockquote&gt;
                    
                     @since 1.1
                     @see CharacterIterator
                    
                    </javadoc>
            </acts>
            <acts name="Collator" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.util.Comparator"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The &lt;code&gt;Collator&lt;/code&gt; class performs locale-sensitive
                     &lt;code&gt;String&lt;/code&gt; comparison. You use this class to build
                     searching and sorting routines for natural language text.
                    
                     &lt;p&gt;
                     &lt;code&gt;Collator&lt;/code&gt; is an abstract base class. Subclasses
                     implement specific collation strategies. One subclass,
                     &lt;code&gt;RuleBasedCollator&lt;/code&gt;, is currently provided with
                     the Java Platform and is applicable to a wide set of languages. Other
                     subclasses may be created to handle more specialized needs.
                    
                     &lt;p&gt;
                     Like other locale-sensitive classes, you can use the static
                     factory method, &lt;code&gt;getInstance&lt;/code&gt;, to obtain the appropriate
                     &lt;code&gt;Collator&lt;/code&gt; object for a given locale. You will only need
                     to look at the subclasses of &lt;code&gt;Collator&lt;/code&gt; if you need
                     to understand the details of a particular collation strategy or
                     if you need to modify that strategy.
                    
                     &lt;p&gt;
                     The following example shows how to compare two strings using
                     the &lt;code&gt;Collator&lt;/code&gt; for the default locale.
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     // Compare two strings in the default locale
                     Collator myCollator = Collator.getInstance();
                     if( myCollator.compare("abc", "ABC") &lt; 0 )
                         System.out.println("abc is less than ABC");
                     else
                         System.out.println("abc is greater than or equal to ABC");
                     }&lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt;
                     You can set a &lt;code&gt;Collator&lt;/code&gt;'s &lt;em&gt;strength&lt;/em&gt; property
                     to determine the level of difference considered significant in
                     comparisons. Four strengths are provided: &lt;code&gt;PRIMARY&lt;/code&gt;,
                     &lt;code&gt;SECONDARY&lt;/code&gt;, &lt;code&gt;TERTIARY&lt;/code&gt;, and &lt;code&gt;IDENTICAL&lt;/code&gt;.
                     The exact assignment of strengths to language features is
                     locale dependent.  For example, in Czech, "e" and "f" are considered
                     primary differences, while "e" and "&amp;#283;" are secondary differences,
                     "e" and "E" are tertiary differences and "e" and "e" are identical.
                     The following shows how both case and accents could be ignored for
                     US English.
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     //Get the Collator for US English and set its strength to PRIMARY
                     Collator usCollator = Collator.getInstance(Locale.US);
                     usCollator.setStrength(Collator.PRIMARY);
                     if( usCollator.compare("abc", "ABC") == 0 ) {
                         System.out.println("Strings are equivalent");
                     }
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                     &lt;p&gt;
                     For comparing &lt;code&gt;String&lt;/code&gt;s exactly once, the &lt;code&gt;compare&lt;/code&gt;
                     method provides the best performance. When sorting a list of
                     &lt;code&gt;String&lt;/code&gt;s however, it is generally necessary to compare each
                     &lt;code&gt;String&lt;/code&gt; multiple times. In this case, &lt;code&gt;CollationKey&lt;/code&gt;s
                     provide better performance. The &lt;code&gt;CollationKey&lt;/code&gt; class converts
                     a &lt;code&gt;String&lt;/code&gt; to a series of bits that can be compared bitwise
                     against other &lt;code&gt;CollationKey&lt;/code&gt;s. A &lt;code&gt;CollationKey&lt;/code&gt; is
                     created by a &lt;code&gt;Collator&lt;/code&gt; object for a given &lt;code&gt;String&lt;/code&gt;.
                     &lt;br&gt;
                     &lt;strong&gt;Note:&lt;/strong&gt; &lt;code&gt;CollationKey&lt;/code&gt;s from different
                     &lt;code&gt;Collator&lt;/code&gt;s can not be compared. See the class description
                     for {@link CollationKey}
                     for an example using &lt;code&gt;CollationKey&lt;/code&gt;s.
                    
                     @see         RuleBasedCollator
                     @see         CollationKey
                     @see         CollationElementIterator
                     @see         Locale
                     @author      Helena Shih, Laura Werner, Richard Gillam
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="AttributedString" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An AttributedString holds text and related attribute information. It
                     may be used as the actual data storage in some cases where a text
                     reader wants to access attributed text through the AttributedCharacterIterator
                     interface.
                    
                     &lt;p&gt;
                     An attribute is a key/value pair, identified by the key.  No two
                     attributes on a given character can have the same key.
                    
                     &lt;p&gt;The values for an attribute are immutable, or must not be mutated
                     by clients or storage.  They are always passed by reference, and not
                     cloned.
                    
                     @see AttributedCharacterIterator
                     @see Annotation
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="Format" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;code&gt;Format&lt;/code&gt; is an abstract base class for formatting locale-sensitive
                     information such as dates, messages, and numbers.
                    
                     &lt;p&gt;
                     &lt;code&gt;Format&lt;/code&gt; defines the programming interface for formatting
                     locale-sensitive objects into &lt;code&gt;String&lt;/code&gt;s (the
                     &lt;code&gt;format&lt;/code&gt; method) and for parsing &lt;code&gt;String&lt;/code&gt;s back
                     into objects (the &lt;code&gt;parseObject&lt;/code&gt; method).
                    
                     &lt;p&gt;
                     Generally, a format's &lt;code&gt;parseObject&lt;/code&gt; method must be able to parse
                     any string formatted by its &lt;code&gt;format&lt;/code&gt; method. However, there may
                     be exceptional cases where this is not possible. For example, a
                     &lt;code&gt;format&lt;/code&gt; method might create two adjacent integer numbers with
                     no separator in between, and in this case the &lt;code&gt;parseObject&lt;/code&gt; could
                     not tell which digits belong to which number.
                    
                     &lt;h3&gt;Subclassing&lt;/h3&gt;
                    
                     &lt;p&gt;
                     The Java Platform provides three specialized subclasses of &lt;code&gt;Format&lt;/code&gt;--
                     &lt;code&gt;DateFormat&lt;/code&gt;, &lt;code&gt;MessageFormat&lt;/code&gt;, and
                     &lt;code&gt;NumberFormat&lt;/code&gt;--for formatting dates, messages, and numbers,
                     respectively.
                     &lt;p&gt;
                     Concrete subclasses must implement three methods:
                     &lt;ol&gt;
                     &lt;li&gt; &lt;code&gt;format(Object obj, StringBuffer toAppendTo, FieldPosition pos)&lt;/code&gt;
                     &lt;li&gt; &lt;code&gt;formatToCharacterIterator(Object obj)&lt;/code&gt;
                     &lt;li&gt; &lt;code&gt;parseObject(String source, ParsePosition pos)&lt;/code&gt;
                     &lt;/ol&gt;
                     These general methods allow polymorphic parsing and formatting of objects
                     and are used, for example, by &lt;code&gt;MessageFormat&lt;/code&gt;.
                     Subclasses often also provide additional &lt;code&gt;format&lt;/code&gt; methods for
                     specific input types as well as &lt;code&gt;parse&lt;/code&gt; methods for specific
                     result types. Any &lt;code&gt;parse&lt;/code&gt; method that does not take a
                     &lt;code&gt;ParsePosition&lt;/code&gt; argument should throw &lt;code&gt;ParseException&lt;/code&gt;
                     when no text in the required format is at the beginning of the input text.
                    
                     &lt;p&gt;
                     Most subclasses will also implement the following factory methods:
                     &lt;ol&gt;
                     &lt;li&gt;
                     &lt;code&gt;getInstance&lt;/code&gt; for getting a useful format object appropriate
                     for the current locale
                     &lt;li&gt;
                     &lt;code&gt;getInstance(Locale)&lt;/code&gt; for getting a useful format
                     object appropriate for the specified locale
                     &lt;/ol&gt;
                     In addition, some subclasses may also implement other
                     &lt;code&gt;getXxxxInstance&lt;/code&gt; methods for more specialized control. For
                     example, the &lt;code&gt;NumberFormat&lt;/code&gt; class provides
                     &lt;code&gt;getPercentInstance&lt;/code&gt; and &lt;code&gt;getCurrencyInstance&lt;/code&gt;
                     methods for getting specialized number formatters.
                    
                     &lt;p&gt;
                     Subclasses of &lt;code&gt;Format&lt;/code&gt; that allow programmers to create objects
                     for locales (with &lt;code&gt;getInstance(Locale)&lt;/code&gt; for example)
                     must also implement the following class method:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     public static Locale[] getAvailableLocales()
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt;
                     And finally subclasses may define a set of constants to identify the various
                     fields in the formatted output. These constants are used to create a FieldPosition
                     object which identifies what information is contained in the field and its
                     position in the formatted result. These constants should be named
                     &lt;code&gt;&lt;em&gt;item&lt;/em&gt;_FIELD&lt;/code&gt; where &lt;code&gt;&lt;em&gt;item&lt;/em&gt;&lt;/code&gt; identifies
                     the field. For examples of these constants, see &lt;code&gt;ERA_FIELD&lt;/code&gt; and its
                     friends in {@link DateFormat}.
                    
                     &lt;h4&gt;&lt;a id="synchronization"&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;p&gt;
                     Formats are generally not synchronized.
                     It is recommended to create separate format instances for each thread.
                     If multiple threads access a format concurrently, it must be synchronized
                     externally.
                    
                     @see          java.text.ParsePosition
                     @see          java.text.FieldPosition
                     @see          java.text.NumberFormat
                     @see          java.text.DateFormat
                     @see          java.text.MessageFormat
                     @author       Mark Davis
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="Field" access="PUBLIC" declaringClass="MessageFormat" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.text.Format$Field"/>
                    <superType superType="java.text.AttributedCharacterIterator$Attribute"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Attribute" access="PUBLIC" declaringClass="AttributedCharacterIterator" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="CollationKey" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A &lt;code&gt;CollationKey&lt;/code&gt; represents a &lt;code&gt;String&lt;/code&gt; under the
                     rules of a specific &lt;code&gt;Collator&lt;/code&gt; object. Comparing two
                     &lt;code&gt;CollationKey&lt;/code&gt;s returns the relative order of the
                     &lt;code&gt;String&lt;/code&gt;s they represent. Using &lt;code&gt;CollationKey&lt;/code&gt;s
                     to compare &lt;code&gt;String&lt;/code&gt;s is generally faster than using
                     &lt;code&gt;Collator.compare&lt;/code&gt;. Thus, when the &lt;code&gt;String&lt;/code&gt;s
                     must be compared multiple times, for example when sorting a list
                     of &lt;code&gt;String&lt;/code&gt;s. It's more efficient to use &lt;code&gt;CollationKey&lt;/code&gt;s.
                    
                     &lt;p&gt;
                     You can not create &lt;code&gt;CollationKey&lt;/code&gt;s directly. Rather,
                     generate them by calling &lt;code&gt;Collator.getCollationKey&lt;/code&gt;.
                     You can only compare &lt;code&gt;CollationKey&lt;/code&gt;s generated from
                     the same &lt;code&gt;Collator&lt;/code&gt; object.
                    
                     &lt;p&gt;
                     Generating a &lt;code&gt;CollationKey&lt;/code&gt; for a &lt;code&gt;String&lt;/code&gt;
                     involves examining the entire &lt;code&gt;String&lt;/code&gt;
                     and converting it to series of bits that can be compared bitwise. This
                     allows fast comparisons once the keys are generated. The cost of generating
                     keys is recouped in faster comparisons when &lt;code&gt;String&lt;/code&gt;s need
                     to be compared many times. On the other hand, the result of a comparison
                     is often determined by the first couple of characters of each &lt;code&gt;String&lt;/code&gt;.
                     &lt;code&gt;Collator.compare&lt;/code&gt; examines only as many characters as it needs which
                     allows it to be faster when doing single comparisons.
                     &lt;p&gt;
                     The following example shows how &lt;code&gt;CollationKey&lt;/code&gt;s might be used
                     to sort a list of &lt;code&gt;String&lt;/code&gt;s.
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     // Create an array of CollationKeys for the Strings to be sorted.
                     Collator myCollator = Collator.getInstance();
                     CollationKey[] keys = new CollationKey[3];
                     keys[0] = myCollator.getCollationKey("Tom");
                     keys[1] = myCollator.getCollationKey("Dick");
                     keys[2] = myCollator.getCollationKey("Harry");
                     sort(keys);
                    
                     //...
                    
                     // Inside body of sort routine, compare keys this way
                     if (keys[i].compareTo(keys[j]) &gt; 0)
                        // swap keys[i] and keys[j]
                    
                     //...
                    
                     // Finally, when we've returned from sort.
                     System.out.println(keys[0].getSourceString());
                     System.out.println(keys[1].getSourceString());
                     System.out.println(keys[2].getSourceString());
                     }&lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     @see          Collator
                     @see          RuleBasedCollator
                     @author       Helena Shih
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="CollationElementIterator" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The &lt;code&gt;CollationElementIterator&lt;/code&gt; class is used as an iterator
                     to walk through each character of an international string. Use the iterator
                     to return the ordering priority of the positioned character. The ordering
                     priority of a character, which we refer to as a key, defines how a character
                     is collated in the given collation object.
                    
                     &lt;p&gt;
                     For example, consider the following in Spanish:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     "ca" &amp;rarr; the first key is key('c') and second key is key('a').
                     "cha" &amp;rarr; the first key is key('ch') and second key is key('a').
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                     And in German,
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     "äb" &amp;rarr; the first key is key('a'), the second key is key('e'), and
                     the third key is key('b').
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                     The key of a character is an integer composed of primary order(short),
                     secondary order(byte), and tertiary order(byte). Java strictly defines
                     the size and signedness of its primitive data types. Therefore, the static
                     functions &lt;code&gt;primaryOrder&lt;/code&gt;, &lt;code&gt;secondaryOrder&lt;/code&gt;, and
                     &lt;code&gt;tertiaryOrder&lt;/code&gt; return &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;,
                     and &lt;code&gt;short&lt;/code&gt; respectively to ensure the correctness of the key
                     value.
                    
                     &lt;p&gt;
                     Example of the iterator usage,
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                    
                      String testString = "This is a test";
                      Collator col = Collator.getInstance();
                      if (col instanceof RuleBasedCollator) {
                          RuleBasedCollator ruleBasedCollator = (RuleBasedCollator)col;
                          CollationElementIterator collationElementIterator = ruleBasedCollator.getCollationElementIterator(testString);
                          int primaryOrder = CollationElementIterator.primaryOrder(collationElementIterator.next());
                              :
                      }
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt;
                     &lt;code&gt;CollationElementIterator.next&lt;/code&gt; returns the collation order
                     of the next character. A collation order consists of primary order,
                     secondary order and tertiary order. The data type of the collation
                     order is &lt;strong&gt;int&lt;/strong&gt;. The first 16 bits of a collation order
                     is its primary order; the next 8 bits is the secondary order and the
                     last 8 bits is the tertiary order.
                    
                     &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; &lt;code&gt;CollationElementIterator&lt;/code&gt; is a part of
                     &lt;code&gt;RuleBasedCollator&lt;/code&gt; implementation. It is only usable
                     with &lt;code&gt;RuleBasedCollator&lt;/code&gt; instances.
                    
                     @see                Collator
                     @see                RuleBasedCollator
                     @author             Helena Shih, Laura Werner, Richard Gillam
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="Field" access="PUBLIC" declaringClass="DateFormat" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.text.Format$Field"/>
                    <superType superType="java.text.AttributedCharacterIterator$Attribute"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="ParsePosition" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;code&gt;ParsePosition&lt;/code&gt; is a simple class used by &lt;code&gt;Format&lt;/code&gt;
                     and its subclasses to keep track of the current position during parsing.
                     The &lt;code&gt;parseObject&lt;/code&gt; method in the various &lt;code&gt;Format&lt;/code&gt;
                     classes requires a &lt;code&gt;ParsePosition&lt;/code&gt; object as an argument.
                    
                     &lt;p&gt;
                     By design, as you parse through a string with different formats,
                     you can use the same &lt;code&gt;ParsePosition&lt;/code&gt;, since the index parameter
                     records the current position.
                    
                     @author      Mark Davis
                     @since 1.1
                     @see         java.text.Format
                    </javadoc>
            </acts>
            <acts name="DecimalFormatSymbols" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class represents the set of symbols (such as the decimal separator,
                     the grouping separator, and so on) needed by &lt;code&gt;DecimalFormat&lt;/code&gt;
                     to format numbers. &lt;code&gt;DecimalFormat&lt;/code&gt; creates for itself an instance of
                     &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; from its locale data.  If you need to change any
                     of these symbols, you can get the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object from
                     your &lt;code&gt;DecimalFormat&lt;/code&gt; and modify it.
                    
                     &lt;p&gt;If the locale contains "rg" (region override)
                     &lt;a href="../util/Locale.html#def_locale_extension"&gt;Unicode extension&lt;/a&gt;,
                     the symbols are overridden for the designated region.
                    
                     @see          java.util.Locale
                     @see          DecimalFormat
                     @author       Mark Davis
                     @author       Alan Liu
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="MessageFormat" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.text.Format"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;code&gt;MessageFormat&lt;/code&gt; provides a means to produce concatenated
                     messages in a language-neutral way. Use this to construct messages
                     displayed for end users.
                    
                     &lt;p&gt;
                     &lt;code&gt;MessageFormat&lt;/code&gt; takes a set of objects, formats them, then
                     inserts the formatted strings into the pattern at the appropriate places.
                    
                     &lt;p&gt;
                     &lt;strong&gt;Note:&lt;/strong&gt;
                     &lt;code&gt;MessageFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;
                     classes in that you create a &lt;code&gt;MessageFormat&lt;/code&gt; object with one
                     of its constructors (not with a &lt;code&gt;getInstance&lt;/code&gt; style factory
                     method). The factory methods aren't necessary because &lt;code&gt;MessageFormat&lt;/code&gt;
                     itself doesn't implement locale specific behavior. Any locale specific
                     behavior is defined by the pattern that you provide as well as the
                     subformats used for inserted arguments.
                    
                     &lt;h3&gt;&lt;a id="patterns"&gt;Patterns and Their Interpretation&lt;/a&gt;&lt;/h3&gt;
                    
                     &lt;code&gt;MessageFormat&lt;/code&gt; uses patterns of the following form:
                     &lt;blockquote&gt;&lt;pre&gt;
                     &lt;i&gt;MessageFormatPattern:&lt;/i&gt;
                             &lt;i&gt;String&lt;/i&gt;
                             &lt;i&gt;MessageFormatPattern&lt;/i&gt; &lt;i&gt;FormatElement&lt;/i&gt; &lt;i&gt;String&lt;/i&gt;
                    
                     &lt;i&gt;FormatElement:&lt;/i&gt;
                             { &lt;i&gt;ArgumentIndex&lt;/i&gt; }
                             { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; }
                             { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; , &lt;i&gt;FormatStyle&lt;/i&gt; }
                    
                     &lt;i&gt;FormatType: one of &lt;/i&gt;
                             number date time choice
                    
                     &lt;i&gt;FormatStyle:&lt;/i&gt;
                             short
                             medium
                             long
                             full
                             integer
                             currency
                             percent
                             &lt;i&gt;SubformatPattern&lt;/i&gt;
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt;Within a &lt;i&gt;String&lt;/i&gt;, a pair of single quotes can be used to
                     quote any arbitrary characters except single quotes. For example,
                     pattern string &lt;code&gt;"'{0}'"&lt;/code&gt; represents string
                     &lt;code&gt;"{0}"&lt;/code&gt;, not a &lt;i&gt;FormatElement&lt;/i&gt;. A single quote itself
                     must be represented by doubled single quotes {@code ''} throughout a
                     &lt;i&gt;String&lt;/i&gt;.  For example, pattern string &lt;code&gt;"'{''}'"&lt;/code&gt; is
                     interpreted as a sequence of &lt;code&gt;'{&lt;/code&gt; (start of quoting and a
                     left curly brace), &lt;code&gt;''&lt;/code&gt; (a single quote), and
                     &lt;code&gt;}'&lt;/code&gt; (a right curly brace and end of quoting),
                     &lt;em&gt;not&lt;/em&gt; &lt;code&gt;'{'&lt;/code&gt; and &lt;code&gt;'}'&lt;/code&gt; (quoted left and
                     right curly braces): representing string &lt;code&gt;"{'}"&lt;/code&gt;,
                     &lt;em&gt;not&lt;/em&gt; &lt;code&gt;"{}"&lt;/code&gt;.
                    
                     &lt;p&gt;A &lt;i&gt;SubformatPattern&lt;/i&gt; is interpreted by its corresponding
                     subformat, and subformat-dependent pattern rules apply. For example,
                     pattern string &lt;code&gt;"{1,number,&lt;u&gt;$'#',##&lt;/u&gt;}"&lt;/code&gt;
                     (&lt;i&gt;SubformatPattern&lt;/i&gt; with underline) will produce a number format
                     with the pound-sign quoted, with a result such as: {@code
                     "$#31,45"}. Refer to each {@code Format} subclass documentation for
                     details.
                    
                     &lt;p&gt;Any unmatched quote is treated as closed at the end of the given
                     pattern. For example, pattern string {@code "'{0}"} is treated as
                     pattern {@code "'{0}'"}.
                    
                     &lt;p&gt;Any curly braces within an unquoted pattern must be balanced. For
                     example, &lt;code&gt;"ab {0} de"&lt;/code&gt; and &lt;code&gt;"ab '}' de"&lt;/code&gt; are
                     valid patterns, but &lt;code&gt;"ab {0'}' de"&lt;/code&gt;, &lt;code&gt;"ab } de"&lt;/code&gt;
                     and &lt;code&gt;"''{''"&lt;/code&gt; are not.
                    
                     &lt;dl&gt;&lt;dt&gt;&lt;b&gt;Warning:&lt;/b&gt;&lt;dd&gt;The rules for using quotes within message
                     format patterns unfortunately have shown to be somewhat confusing.
                     In particular, it isn't always obvious to localizers whether single
                     quotes need to be doubled or not. Make sure to inform localizers about
                     the rules, and tell them (for example, by using comments in resource
                     bundle source files) which strings will be processed by {@code MessageFormat}.
                     Note that localizers may need to use single quotes in translated
                     strings where the original version doesn't have them.
                     &lt;/dl&gt;
                     &lt;p&gt;
                     The &lt;i&gt;ArgumentIndex&lt;/i&gt; value is a non-negative integer written
                     using the digits {@code '0'} through {@code '9'}, and represents an index into the
                     {@code arguments} array passed to the {@code format} methods
                     or the result array returned by the {@code parse} methods.
                     &lt;p&gt;
                     The &lt;i&gt;FormatType&lt;/i&gt; and &lt;i&gt;FormatStyle&lt;/i&gt; values are used to create
                     a {@code Format} instance for the format element. The following
                     table shows how the values map to {@code Format} instances. Combinations not
                     shown in the table are illegal. A &lt;i&gt;SubformatPattern&lt;/i&gt; must
                     be a valid pattern string for the {@code Format} subclass used.
                    
                     &lt;table class="plain"&gt;
                     &lt;caption style="display:none"&gt;Shows how FormatType and FormatStyle values map to Format instances&lt;/caption&gt;
                     &lt;thead&gt;
                        &lt;tr&gt;
                           &lt;th scope="col" class="TableHeadingColor"&gt;FormatType
                           &lt;th scope="col" class="TableHeadingColor"&gt;FormatStyle
                           &lt;th scope="col" class="TableHeadingColor"&gt;Subformat Created
                     &lt;/thead&gt;
                     &lt;tbody&gt;
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;&lt;i&gt;(none)&lt;/i&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;&lt;i&gt;(none)&lt;/i&gt;
                           &lt;td&gt;{@code null}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal" rowspan=5&gt;{@code number}
                           &lt;th scope="row" style="text-weight: normal"&gt;&lt;i&gt;(none)&lt;/i&gt;
                           &lt;td&gt;{@link NumberFormat#getInstance(Locale) NumberFormat.getInstance}{@code (getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;{@code integer}
                           &lt;td&gt;{@link NumberFormat#getIntegerInstance(Locale) NumberFormat.getIntegerInstance}{@code (getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;{@code currency}
                           &lt;td&gt;{@link NumberFormat#getCurrencyInstance(Locale) NumberFormat.getCurrencyInstance}{@code (getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;{@code percent}
                           &lt;td&gt;{@link NumberFormat#getPercentInstance(Locale) NumberFormat.getPercentInstance}{@code (getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
                           &lt;td&gt;{@code new} {@link DecimalFormat#DecimalFormat(String,DecimalFormatSymbols) DecimalFormat}{@code (subformatPattern,} {@link DecimalFormatSymbols#getInstance(Locale) DecimalFormatSymbols.getInstance}{@code (getLocale()))}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal" rowspan=6&gt;{@code date}
                           &lt;th scope="row" style="text-weight: normal"&gt;&lt;i&gt;(none)&lt;/i&gt;
                           &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;{@code short}
                           &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;{@code medium}
                           &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;{@code long}
                           &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;{@code full}
                           &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
                           &lt;td&gt;{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal" rowspan=6&gt;{@code time}
                           &lt;th scope="row" style="text-weight: normal"&gt;&lt;i&gt;(none)&lt;/i&gt;
                           &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;{@code short}
                           &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;{@code medium}
                           &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;{@code long}
                           &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;{@code full}
                           &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
                           &lt;td&gt;{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
                        &lt;tr&gt;
                           &lt;th scope="row" style="text-weight: normal"&gt;{@code choice}
                           &lt;th scope="row" style="text-weight: normal"&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
                           &lt;td&gt;{@code new} {@link ChoiceFormat#ChoiceFormat(String) ChoiceFormat}{@code (subformatPattern)}
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;h4&gt;Usage Information&lt;/h4&gt;
                    
                     &lt;p&gt;
                     Here are some examples of usage.
                     In real internationalized programs, the message format pattern and other
                     static strings will, of course, be obtained from resource bundles.
                     Other parameters will be dynamically determined at runtime.
                     &lt;p&gt;
                     The first example uses the static method &lt;code&gt;MessageFormat.format&lt;/code&gt;,
                     which internally creates a &lt;code&gt;MessageFormat&lt;/code&gt; for one-time use:
                     &lt;blockquote&gt;&lt;pre&gt;
                     int planet = 7;
                     String event = "a disturbance in the Force";
                    
                     String result = MessageFormat.format(
                         "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.",
                         planet, new Date(), event);
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     The output is:
                     &lt;blockquote&gt;&lt;pre&gt;
                     At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt;
                     The following example creates a &lt;code&gt;MessageFormat&lt;/code&gt; instance that
                     can be used repeatedly:
                     &lt;blockquote&gt;&lt;pre&gt;
                     int fileCount = 1273;
                     String diskName = "MyDisk";
                     Object[] testArgs = {new Long(fileCount), diskName};
                    
                     MessageFormat form = new MessageFormat(
                         "The disk \"{1}\" contains {0} file(s).");
                    
                     System.out.println(form.format(testArgs));
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:
                     &lt;blockquote&gt;&lt;pre&gt;
                     The disk "MyDisk" contains 0 file(s).
                     The disk "MyDisk" contains 1 file(s).
                     The disk "MyDisk" contains 1,273 file(s).
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt;
                     For more sophisticated patterns, you can use a &lt;code&gt;ChoiceFormat&lt;/code&gt;
                     to produce correct forms for singular and plural:
                     &lt;blockquote&gt;&lt;pre&gt;
                     MessageFormat form = new MessageFormat("The disk \"{1}\" contains {0}.");
                     double[] filelimits = {0,1,2};
                     String[] filepart = {"no files","one file","{0,number} files"};
                     ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
                     form.setFormatByArgumentIndex(0, fileform);
                    
                     int fileCount = 1273;
                     String diskName = "MyDisk";
                     Object[] testArgs = {new Long(fileCount), diskName};
                    
                     System.out.println(form.format(testArgs));
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:
                     &lt;blockquote&gt;&lt;pre&gt;
                     The disk "MyDisk" contains no files.
                     The disk "MyDisk" contains one file.
                     The disk "MyDisk" contains 1,273 files.
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt;
                     You can create the &lt;code&gt;ChoiceFormat&lt;/code&gt; programmatically, as in the
                     above example, or by using a pattern. See {@link ChoiceFormat}
                     for more information.
                     &lt;blockquote&gt;&lt;pre&gt;{@code
                     form.applyPattern(
                        "There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}.");
                     }&lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt;
                     &lt;strong&gt;Note:&lt;/strong&gt; As we see above, the string produced
                     by a &lt;code&gt;ChoiceFormat&lt;/code&gt; in &lt;code&gt;MessageFormat&lt;/code&gt; is treated as special;
                     occurrences of '{' are used to indicate subformats, and cause recursion.
                     If you create both a &lt;code&gt;MessageFormat&lt;/code&gt; and &lt;code&gt;ChoiceFormat&lt;/code&gt;
                     programmatically (instead of using the string patterns), then be careful not to
                     produce a format that recurses on itself, which will cause an infinite loop.
                     &lt;p&gt;
                     When a single argument is parsed more than once in the string, the last match
                     will be the final result of the parsing.  For example,
                     &lt;blockquote&gt;&lt;pre&gt;
                     MessageFormat mf = new MessageFormat("{0,number,#.##}, {0,number,#.#}");
                     Object[] objs = {new Double(3.1415)};
                     String result = mf.format( objs );
                     // result now equals "3.14, 3.1"
                     objs = null;
                     objs = mf.parse(result, new ParsePosition(0));
                     // objs now equals {new Double(3.1)}
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt;
                     Likewise, parsing with a {@code MessageFormat} object using patterns containing
                     multiple occurrences of the same argument would return the last match.  For
                     example,
                     &lt;blockquote&gt;&lt;pre&gt;
                     MessageFormat mf = new MessageFormat("{0}, {0}, {0}");
                     String forParsing = "x, y, z";
                     Object[] objs = mf.parse(forParsing, new ParsePosition(0));
                     // result now equals {new String("z")}
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;h4&gt;&lt;a id="synchronization"&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;p&gt;
                     Message formats are not synchronized.
                     It is recommended to create separate format instances for each thread.
                     If multiple threads access a format concurrently, it must be synchronized
                     externally.
                    
                     @see          java.util.Locale
                     @see          Format
                     @see          NumberFormat
                     @see          DecimalFormat
                     @see          DecimalFormatSymbols
                     @see          ChoiceFormat
                     @see          DateFormat
                     @see          SimpleDateFormat
                    
                     @author       Mark Davis
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="Normalizer" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class provides the method &lt;code&gt;normalize&lt;/code&gt; which transforms Unicode
                     text into an equivalent composed or decomposed form, allowing for easier
                     sorting and searching of text.
                     The &lt;code&gt;normalize&lt;/code&gt; method supports the standard normalization forms
                     described in
                     &lt;a href="http://www.unicode.org/unicode/reports/tr15/tr15-23.html"&gt;
                     Unicode Standard Annex #15 &amp;mdash; Unicode Normalization Forms&lt;/a&gt;.
                     &lt;p&gt;
                     Characters with accents or other adornments can be encoded in
                     several different ways in Unicode.  For example, take the character A-acute.
                     In Unicode, this can be encoded as a single character (the "composed" form):
                    
                     &lt;pre&gt;
                          U+00C1    LATIN CAPITAL LETTER A WITH ACUTE&lt;/pre&gt;
                    
                     or as two separate characters (the "decomposed" form):
                    
                     &lt;pre&gt;
                          U+0041    LATIN CAPITAL LETTER A
                          U+0301    COMBINING ACUTE ACCENT&lt;/pre&gt;
                    
                     To a user of your program, however, both of these sequences should be
                     treated as the same "user-level" character "A with acute accent".  When you
                     are searching or comparing text, you must ensure that these two sequences are
                     treated as equivalent.  In addition, you must handle characters with more than
                     one accent. Sometimes the order of a character's combining accents is
                     significant, while in other cases accent sequences in different orders are
                     really equivalent.
                     &lt;p&gt;
                     Similarly, the string "ffi" can be encoded as three separate letters:
                    
                     &lt;pre&gt;
                          U+0066    LATIN SMALL LETTER F
                          U+0066    LATIN SMALL LETTER F
                          U+0069    LATIN SMALL LETTER I&lt;/pre&gt;
                    
                     or as the single character
                    
                     &lt;pre&gt;
                          U+FB03    LATIN SMALL LIGATURE FFI&lt;/pre&gt;
                    
                     The ffi ligature is not a distinct semantic character, and strictly speaking
                     it shouldn't be in Unicode at all, but it was included for compatibility
                     with existing character sets that already provided it.  The Unicode standard
                     identifies such characters by giving them "compatibility" decompositions
                     into the corresponding semantic characters.  When sorting and searching, you
                     will often want to use these mappings.
                     &lt;p&gt;
                     The &lt;code&gt;normalize&lt;/code&gt; method helps solve these problems by transforming
                     text into the canonical composed and decomposed forms as shown in the first
                     example above. In addition, you can have it perform compatibility
                     decompositions so that you can treat compatibility characters the same as
                     their equivalents.
                     Finally, the &lt;code&gt;normalize&lt;/code&gt; method rearranges accents into the
                     proper canonical order, so that you do not have to worry about accent
                     rearrangement on your own.
                     &lt;p&gt;
                     The W3C generally recommends to exchange texts in NFC.
                     Note also that most legacy character encodings use only precomposed forms and
                     often do not encode any combining marks by themselves. For conversion to such
                     character encodings the Unicode text needs to be normalized to NFC.
                     For more usage examples, see the Unicode Standard Annex.
                    
                     @since 1.6
                    </javadoc>
            </acts>
            <acts name="ChoiceFormat" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.text.NumberFormat"/>
                    <superType superType="java.text.Format"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A &lt;code&gt;ChoiceFormat&lt;/code&gt; allows you to attach a format to a range of numbers.
                     It is generally used in a &lt;code&gt;MessageFormat&lt;/code&gt; for handling plurals.
                     The choice is specified with an ascending list of doubles, where each item
                     specifies a half-open interval up to the next item:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     X matches j if and only if limit[j] &amp;le; X &amp;lt; limit[j+1]
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                     If there is no match, then either the first or last index is used, depending
                     on whether the number (X) is too low or too high.  If the limit array is not
                     in ascending order, the results of formatting will be incorrect.  ChoiceFormat
                     also accepts &lt;code&gt;&amp;#92;u221E&lt;/code&gt; as equivalent to infinity(INF).
                    
                     &lt;p&gt;
                     &lt;strong&gt;Note:&lt;/strong&gt;
                     &lt;code&gt;ChoiceFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;
                     classes in that you create a &lt;code&gt;ChoiceFormat&lt;/code&gt; object with a
                     constructor (not with a &lt;code&gt;getInstance&lt;/code&gt; style factory
                     method). The factory methods aren't necessary because &lt;code&gt;ChoiceFormat&lt;/code&gt;
                     doesn't require any complex setup for a given locale. In fact,
                     &lt;code&gt;ChoiceFormat&lt;/code&gt; doesn't implement any locale specific behavior.
                    
                     &lt;p&gt;
                     When creating a &lt;code&gt;ChoiceFormat&lt;/code&gt;, you must specify an array of formats
                     and an array of limits. The length of these arrays must be the same.
                     For example,
                     &lt;ul&gt;
                     &lt;li&gt;
                         &lt;em&gt;limits&lt;/em&gt; = {1,2,3,4,5,6,7}&lt;br&gt;
                         &lt;em&gt;formats&lt;/em&gt; = {"Sun","Mon","Tue","Wed","Thur","Fri","Sat"}
                     &lt;li&gt;
                         &lt;em&gt;limits&lt;/em&gt; = {0, 1, ChoiceFormat.nextDouble(1)}&lt;br&gt;
                         &lt;em&gt;formats&lt;/em&gt; = {"no files", "one file", "many files"}&lt;br&gt;
                         (&lt;code&gt;nextDouble&lt;/code&gt; can be used to get the next higher double, to
                         make the half-open interval.)
                     &lt;/ul&gt;
                    
                     &lt;p&gt;
                     Here is a simple example that shows formatting and parsing:
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     double[] limits = {1,2,3,4,5,6,7};
                     String[] dayOfWeekNames = {"Sun","Mon","Tue","Wed","Thur","Fri","Sat"};
                     ChoiceFormat form = new ChoiceFormat(limits, dayOfWeekNames);
                     ParsePosition status = new ParsePosition(0);
                     for (double i = 0.0; i &lt;= 8.0; ++i) {
                         status.setIndex(0);
                         System.out.println(i + " -&gt; " + form.format(i) + " -&gt; "
                                                  + form.parse(form.format(i),status));
                     }
                     }&lt;/pre&gt;
                     &lt;/blockquote&gt;
                     Here is a more complex example, with a pattern format:
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     double[] filelimits = {0,1,2};
                     String[] filepart = {"are no files","is one file","are {2} files"};
                     ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
                     Format[] testFormats = {fileform, null, NumberFormat.getInstance()};
                     MessageFormat pattform = new MessageFormat("There {0} on {1}");
                     pattform.setFormats(testFormats);
                     Object[] testArgs = {null, "ADisk", null};
                     for (int i = 0; i &lt; 4; ++i) {
                         testArgs[0] = new Integer(i);
                         testArgs[2] = testArgs[0];
                         System.out.println(pattform.format(testArgs));
                     }
                     }&lt;/pre&gt;
                     &lt;/blockquote&gt;
                     &lt;p&gt;
                     Specifying a pattern for ChoiceFormat objects is fairly straightforward.
                     For example:
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     ChoiceFormat fmt = new ChoiceFormat(
                          "-1#is negative| 0#is zero or fraction | 1#is one |1.0&lt;is 1+ |2#is two |2&lt;is more than 2.");
                     System.out.println("Formatter Pattern : " + fmt.toPattern());
                    
                     System.out.println("Format with -INF : " + fmt.format(Double.NEGATIVE_INFINITY));
                     System.out.println("Format with -1.0 : " + fmt.format(-1.0));
                     System.out.println("Format with 0 : " + fmt.format(0));
                     System.out.println("Format with 0.9 : " + fmt.format(0.9));
                     System.out.println("Format with 1.0 : " + fmt.format(1));
                     System.out.println("Format with 1.5 : " + fmt.format(1.5));
                     System.out.println("Format with 2 : " + fmt.format(2));
                     System.out.println("Format with 2.1 : " + fmt.format(2.1));
                     System.out.println("Format with NaN : " + fmt.format(Double.NaN));
                     System.out.println("Format with +INF : " + fmt.format(Double.POSITIVE_INFINITY));
                     }&lt;/pre&gt;
                     &lt;/blockquote&gt;
                     And the output result would be like the following:
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     Format with -INF : is negative
                     Format with -1.0 : is negative
                     Format with 0 : is zero or fraction
                     Format with 0.9 : is zero or fraction
                     Format with 1.0 : is one
                     Format with 1.5 : is 1+
                     Format with 2 : is two
                     Format with 2.1 : is more than 2.
                     Format with NaN : is negative
                     Format with +INF : is more than 2.
                     }&lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;h3&gt;&lt;a id="synchronization"&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;
                    
                     &lt;p&gt;
                     Choice formats are not synchronized.
                     It is recommended to create separate format instances for each thread.
                     If multiple threads access a format concurrently, it must be synchronized
                     externally.
                    
                    
                     @see          DecimalFormat
                     @see          MessageFormat
                     @author       Mark Davis
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="FieldPosition" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;code&gt;FieldPosition&lt;/code&gt; is a simple class used by &lt;code&gt;Format&lt;/code&gt;
                     and its subclasses to identify fields in formatted output. Fields can
                     be identified in two ways:
                     &lt;ul&gt;
                      &lt;li&gt;By an integer constant, whose names typically end with
                          &lt;code&gt;_FIELD&lt;/code&gt;. The constants are defined in the various
                          subclasses of &lt;code&gt;Format&lt;/code&gt;.
                      &lt;li&gt;By a &lt;code&gt;Format.Field&lt;/code&gt; constant, see &lt;code&gt;ERA_FIELD&lt;/code&gt;
                          and its friends in &lt;code&gt;DateFormat&lt;/code&gt; for an example.
                     &lt;/ul&gt;
                     &lt;p&gt;
                     &lt;code&gt;FieldPosition&lt;/code&gt; keeps track of the position of the
                     field within the formatted output with two indices: the index
                     of the first character of the field and the index of the last
                     character of the field.
                    
                     &lt;p&gt;
                     One version of the &lt;code&gt;format&lt;/code&gt; method in the various
                     &lt;code&gt;Format&lt;/code&gt; classes requires a &lt;code&gt;FieldPosition&lt;/code&gt;
                     object as an argument. You use this &lt;code&gt;format&lt;/code&gt; method
                     to perform partial formatting or to get information about the
                     formatted output (such as the position of a field).
                    
                     &lt;p&gt;
                     If you are interested in the positions of all attributes in the
                     formatted string use the &lt;code&gt;Format&lt;/code&gt; method
                     &lt;code&gt;formatToCharacterIterator&lt;/code&gt;.
                    
                     @author      Mark Davis
                     @since 1.1
                     @see         java.text.Format
                    </javadoc>
            </acts>
            <acts name="Annotation" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An Annotation object is used as a wrapper for a text attribute value if
                     the attribute has annotation characteristics. These characteristics are:
                     &lt;ul&gt;
                     &lt;li&gt;The text range that the attribute is applied to is critical to the
                     semantics of the range. That means, the attribute cannot be applied to subranges
                     of the text range that it applies to, and, if two adjacent text ranges have
                     the same value for this attribute, the attribute still cannot be applied to
                     the combined range as a whole with this value.
                     &lt;li&gt;The attribute or its value usually do no longer apply if the underlying text is
                     changed.
                     &lt;/ul&gt;
                    
                     An example is grammatical information attached to a sentence:
                     For the previous sentence, you can say that "an example"
                     is the subject, but you cannot say the same about "an", "example", or "exam".
                     When the text is changed, the grammatical information typically becomes invalid.
                     Another example is Japanese reading information (yomi).
                    
                     &lt;p&gt;
                     Wrapping the attribute value into an Annotation object guarantees that
                     adjacent text runs don't get merged even if the attribute values are equal,
                     and indicates to text containers that the attribute should be discarded if
                     the underlying text is modified.
                    
                     @see AttributedCharacterIterator
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="AttributedCharacterIterator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.text">
                <superTypes>
                    <superType superType="java.text.CharacterIterator"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An {@code AttributedCharacterIterator} allows iteration through both text and
                     related attribute information.
                    
                     &lt;p&gt;
                     An attribute is a key/value pair, identified by the key.  No two
                     attributes on a given character can have the same key.
                    
                     &lt;p&gt;The values for an attribute are immutable, or must not be mutated
                     by clients or storage.  They are always passed by reference, and not
                     cloned.
                    
                     &lt;p&gt;A &lt;em&gt;run with respect to an attribute&lt;/em&gt; is a maximum text range for
                     which:
                     &lt;ul&gt;
                     &lt;li&gt;the attribute is undefined or {@code null} for the entire range, or
                     &lt;li&gt;the attribute value is defined and has the same non-{@code null} value for the
                         entire range.
                     &lt;/ul&gt;
                    
                     &lt;p&gt;A &lt;em&gt;run with respect to a set of attributes&lt;/em&gt; is a maximum text range for
                     which this condition is met for each member attribute.
                    
                     &lt;p&gt;When getting a run with no explicit attributes specified (i.e.,
                     calling {@link #getRunStart()} and {@link #getRunLimit()}), any
                     contiguous text segments having the same attributes (the same set
                     of attribute/value pairs) are treated as separate runs if the
                     attributes have been given to those text segments separately.
                    
                     &lt;p&gt;The returned indexes are limited to the range of the iterator.
                    
                     &lt;p&gt;The returned attribute information is limited to runs that contain
                     the current character.
                    
                     &lt;p&gt;
                     Attribute keys are instances of {@link AttributedCharacterIterator.Attribute} and its
                     subclasses, such as {@link java.awt.font.TextAttribute}.
                    
                     @see AttributedCharacterIterator.Attribute
                     @see java.awt.font.TextAttribute
                     @see AttributedString
                     @see Annotation
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="StringCharacterIterator" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.text.CharacterIterator"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;code&gt;StringCharacterIterator&lt;/code&gt; implements the
                     &lt;code&gt;CharacterIterator&lt;/code&gt; protocol for a &lt;code&gt;String&lt;/code&gt;.
                     The &lt;code&gt;StringCharacterIterator&lt;/code&gt; class iterates over the
                     entire &lt;code&gt;String&lt;/code&gt;.
                    
                     @see CharacterIterator
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="Bidi" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class implements the Unicode Bidirectional Algorithm.
                     &lt;p&gt;
                     A Bidi object provides information on the bidirectional reordering of the text
                     used to create it.  This is required, for example, to properly display Arabic
                     or Hebrew text.  These languages are inherently mixed directional, as they order
                     numbers from left-to-right while ordering most other text from right-to-left.
                     &lt;p&gt;
                     Once created, a Bidi object can be queried to see if the text it represents is
                     all left-to-right or all right-to-left.  Such objects are very lightweight and
                     this text is relatively easy to process.
                     &lt;p&gt;
                     If there are multiple runs of text, information about the runs can be accessed
                     by indexing to get the start, limit, and level of a run.  The level represents
                     both the direction and the 'nesting level' of a directional run.  Odd levels
                     are right-to-left, while even levels are left-to-right.  So for example level
                     0 represents left-to-right text, while level 1 represents right-to-left text, and
                     level 2 represents left-to-right text embedded in a right-to-left run.
                    
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="CharacterIterator" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.text">
                <superTypes>
                    <superType superType="java.lang.Cloneable"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This interface defines a protocol for bidirectional iteration over text.
                     The iterator iterates over a bounded sequence of characters.  Characters
                     are indexed with values beginning with the value returned by getBeginIndex() and
                     continuing through the value returned by getEndIndex()-1.
                     &lt;p&gt;
                     Iterators maintain a current character index, whose valid range is from
                     getBeginIndex() to getEndIndex(); the value getEndIndex() is included to allow
                     handling of zero-length text ranges and for historical reasons.
                     The current index can be retrieved by calling getIndex() and set directly
                     by calling setIndex(), first(), and last().
                     &lt;p&gt;
                     The methods previous() and next() are used for iteration. They return DONE if
                     they would move outside the range from getBeginIndex() to getEndIndex() -1,
                     signaling that the iterator has reached the end of the sequence. DONE is
                     also returned by other methods to indicate that the current index is
                     outside this range.
                    
                     &lt;P&gt;Examples:&lt;P&gt;
                    
                     Traverse the text from start to finish
                     &lt;pre&gt;{@code
                     public void traverseForward(CharacterIterator iter) {
                         for(char c = iter.first(); c != CharacterIterator.DONE; c = iter.next()) {
                             processChar(c);
                         }
                     }
                     }&lt;/pre&gt;
                    
                     Traverse the text backwards, from end to start
                     &lt;pre&gt;{@code
                     public void traverseBackward(CharacterIterator iter) {
                         for(char c = iter.last(); c != CharacterIterator.DONE; c = iter.previous()) {
                             processChar(c);
                         }
                     }
                     }&lt;/pre&gt;
                    
                     Traverse both forward and backward from a given position in the text.
                     Calls to notBoundary() in this example represents some
                     additional stopping criteria.
                     &lt;pre&gt;{@code
                     public void traverseOut(CharacterIterator iter, int pos) {
                         for (char c = iter.setIndex(pos);
                                  c != CharacterIterator.DONE &amp;&amp; notBoundary(c);
                                  c = iter.next()) {
                         }
                         int end = iter.getIndex();
                         for (char c = iter.setIndex(pos);
                                 c != CharacterIterator.DONE &amp;&amp; notBoundary(c);
                                 c = iter.previous()) {
                         }
                         int start = iter.getIndex();
                         processSection(start, end);
                     }
                     }&lt;/pre&gt;
                    
                     @since 1.1
                     @see StringCharacterIterator
                     @see AttributedCharacterIterator
                    </javadoc>
            </acts>
            <acts name="DateFormat" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.text.Format"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     {@code DateFormat} is an abstract class for date/time formatting subclasses which
                     formats and parses dates or time in a language-independent manner.
                     The date/time formatting subclass, such as {@link SimpleDateFormat}, allows for
                     formatting (i.e., date &amp;rarr; text), parsing (text &amp;rarr; date), and
                     normalization.  The date is represented as a &lt;code&gt;Date&lt;/code&gt; object or
                     as the milliseconds since January 1, 1970, 00:00:00 GMT.
                    
                     &lt;p&gt;{@code DateFormat} provides many class methods for obtaining default date/time
                     formatters based on the default or a given locale and a number of formatting
                     styles. The formatting styles include {@link #FULL}, {@link #LONG}, {@link #MEDIUM}, and {@link #SHORT}. More
                     detail and examples of using these styles are provided in the method
                     descriptions.
                    
                     &lt;p&gt;{@code DateFormat} helps you to format and parse dates for any locale.
                     Your code can be completely independent of the locale conventions for
                     months, days of the week, or even the calendar format: lunar vs. solar.
                    
                     &lt;p&gt;To format a date for the current Locale, use one of the
                     static factory methods:
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     myString = DateFormat.getDateInstance().format(myDate);
                     }&lt;/pre&gt;
                     &lt;/blockquote&gt;
                     &lt;p&gt;If you are formatting multiple dates, it is
                     more efficient to get the format and use it multiple times so that
                     the system doesn't have to fetch the information about the local
                     language and country conventions multiple times.
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     DateFormat df = DateFormat.getDateInstance();
                     for (int i = 0; i &lt; myDate.length; ++i) {
                         output.println(df.format(myDate[i]) + "; ");
                     }
                     }&lt;/pre&gt;
                     &lt;/blockquote&gt;
                     &lt;p&gt;To format a date for a different Locale, specify it in the
                     call to {@link #getDateInstance(int, Locale) getDateInstance()}.
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     DateFormat df = DateFormat.getDateInstance(DateFormat.LONG, Locale.FRANCE);
                     }&lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt;If the specified locale contains "ca" (calendar), "rg" (region override),
                     and/or "tz" (timezone) &lt;a href="../util/Locale.html#def_locale_extension"&gt;Unicode
                     extensions&lt;/a&gt;, the calendar, the country and/or the time zone for formatting
                     are overridden. If both "ca" and "rg" are specified, the calendar from the "ca"
                     extension supersedes the implicit one from the "rg" extension.
                    
                     &lt;p&gt;You can use a DateFormat to parse also.
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     myDate = df.parse(myString);
                     }&lt;/pre&gt;
                     &lt;/blockquote&gt;
                     &lt;p&gt;Use {@code getDateInstance} to get the normal date format for that country.
                     There are other static factory methods available.
                     Use {@code getTimeInstance} to get the time format for that country.
                     Use {@code getDateTimeInstance} to get a date and time format. You can pass in
                     different options to these factory methods to control the length of the
                     result; from {@link #SHORT} to {@link #MEDIUM} to {@link #LONG} to {@link #FULL}. The exact result depends
                     on the locale, but generally:
                     &lt;ul&gt;&lt;li&gt;{@link #SHORT} is completely numeric, such as {@code 12.13.52} or {@code 3:30pm}
                     &lt;li&gt;{@link #MEDIUM} is longer, such as {@code Jan 12, 1952}
                     &lt;li&gt;{@link #LONG} is longer, such as {@code January 12, 1952} or {@code 3:30:32pm}
                     &lt;li&gt;{@link #FULL} is pretty completely specified, such as
                     {@code Tuesday, April 12, 1952 AD or 3:30:42pm PST}.
                     &lt;/ul&gt;
                    
                     &lt;p&gt;You can also set the time zone on the format if you wish.
                     If you want even more control over the format or parsing,
                     (or want to give your users more control),
                     you can try casting the {@code DateFormat} you get from the factory methods
                     to a {@link SimpleDateFormat}. This will work for the majority
                     of countries; just remember to put it in a {@code try} block in case you
                     encounter an unusual one.
                    
                     &lt;p&gt;You can also use forms of the parse and format methods with
                     {@link ParsePosition} and {@link FieldPosition} to
                     allow you to
                     &lt;ul&gt;&lt;li&gt;progressively parse through pieces of a string.
                     &lt;li&gt;align any particular field, or find out where it is for selection
                     on the screen.
                     &lt;/ul&gt;
                    
                     &lt;h3&gt;&lt;a id="synchronization"&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;
                    
                     &lt;p&gt;
                     Date formats are not synchronized.
                     It is recommended to create separate format instances for each thread.
                     If multiple threads access a format concurrently, it must be synchronized
                     externally.
                    
                     @implSpec
                     &lt;ul&gt;&lt;li&gt;The {@link #format(Date, StringBuffer, FieldPosition)} and
                     {@link #parse(String, ParsePosition)} methods may throw
                     {@code NullPointerException}, if any of their parameter is {@code null}.
                     The subclass may provide its own implementation and specification about
                     {@code NullPointerException}.&lt;/li&gt;
                     &lt;li&gt;The {@link #setCalendar(Calendar)}, {@link
                     #setNumberFormat(NumberFormat)} and {@link #setTimeZone(TimeZone)} methods
                     do not throw {@code NullPointerException} when their parameter is
                     {@code null}, but any subsequent operations on the same instance may throw
                     {@code NullPointerException}.&lt;/li&gt;
                     &lt;li&gt;The {@link #getCalendar()}, {@link #getNumberFormat()} and
                     {@link getTimeZone()} methods may return {@code null}, if the respective
                     values of this instance is set to {@code null} through the corresponding
                     setter methods. For Example: {@link #getTimeZone()} may return {@code null},
                     if the {@code TimeZone} value of this instance is set as
                     {@link #setTimeZone(java.util.TimeZone) setTimeZone(null)}.&lt;/li&gt;
                     &lt;/ul&gt;
                    
                     @see          Format
                     @see          NumberFormat
                     @see          SimpleDateFormat
                     @see          java.util.Calendar
                     @see          java.util.GregorianCalendar
                     @see          java.util.TimeZone
                     @author       Mark Davis, Chen-Lieh Huang, Alan Liu
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="DateFormatSymbols" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;code&gt;DateFormatSymbols&lt;/code&gt; is a public class for encapsulating
                     localizable date-time formatting data, such as the names of the
                     months, the names of the days of the week, and the time zone data.
                     &lt;code&gt;SimpleDateFormat&lt;/code&gt; uses
                     &lt;code&gt;DateFormatSymbols&lt;/code&gt; to encapsulate this information.
                    
                     &lt;p&gt;
                     Typically you shouldn't use &lt;code&gt;DateFormatSymbols&lt;/code&gt; directly.
                     Rather, you are encouraged to create a date-time formatter with the
                     &lt;code&gt;DateFormat&lt;/code&gt; class's factory methods: &lt;code&gt;getTimeInstance&lt;/code&gt;,
                     &lt;code&gt;getDateInstance&lt;/code&gt;, or &lt;code&gt;getDateTimeInstance&lt;/code&gt;.
                     These methods automatically create a &lt;code&gt;DateFormatSymbols&lt;/code&gt; for
                     the formatter so that you don't have to. After the
                     formatter is created, you may modify its format pattern using the
                     &lt;code&gt;setPattern&lt;/code&gt; method. For more information about
                     creating formatters using &lt;code&gt;DateFormat&lt;/code&gt;'s factory methods,
                     see {@link DateFormat}.
                    
                     &lt;p&gt;
                     If you decide to create a date-time formatter with a specific
                     format pattern for a specific locale, you can do so with:
                     &lt;blockquote&gt;
                     &lt;pre&gt;
                     new SimpleDateFormat(aPattern, DateFormatSymbols.getInstance(aLocale)).
                     &lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt;If the locale contains "rg" (region override)
                     &lt;a href="../util/Locale.html#def_locale_extension"&gt;Unicode extension&lt;/a&gt;,
                     the symbols are overridden for the designated region.
                    
                     &lt;p&gt;
                     &lt;code&gt;DateFormatSymbols&lt;/code&gt; objects are cloneable. When you obtain
                     a &lt;code&gt;DateFormatSymbols&lt;/code&gt; object, feel free to modify the
                     date-time formatting data. For instance, you can replace the localized
                     date-time format pattern characters with the ones that you feel easy
                     to remember. Or you can change the representative cities
                     to your favorite ones.
                    
                     &lt;p&gt;
                     New &lt;code&gt;DateFormatSymbols&lt;/code&gt; subclasses may be added to support
                     &lt;code&gt;SimpleDateFormat&lt;/code&gt; for date-time formatting for additional locales.
                    
                     @see          DateFormat
                     @see          SimpleDateFormat
                     @see          java.util.SimpleTimeZone
                     @author       Chen-Lieh Huang
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="ParseException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that an error has been reached unexpectedly
                     while parsing.
                     @see java.lang.Exception
                     @see java.text.Format
                     @see java.text.FieldPosition
                     @author      Mark Davis
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="SimpleDateFormat" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.text.DateFormat"/>
                    <superType superType="java.text.Format"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;code&gt;SimpleDateFormat&lt;/code&gt; is a concrete class for formatting and
                     parsing dates in a locale-sensitive manner. It allows for formatting
                     (date &amp;rarr; text), parsing (text &amp;rarr; date), and normalization.
                    
                     &lt;p&gt;
                     &lt;code&gt;SimpleDateFormat&lt;/code&gt; allows you to start by choosing
                     any user-defined patterns for date-time formatting. However, you
                     are encouraged to create a date-time formatter with either
                     &lt;code&gt;getTimeInstance&lt;/code&gt;, &lt;code&gt;getDateInstance&lt;/code&gt;, or
                     &lt;code&gt;getDateTimeInstance&lt;/code&gt; in &lt;code&gt;DateFormat&lt;/code&gt;. Each
                     of these class methods can return a date/time formatter initialized
                     with a default format pattern. You may modify the format pattern
                     using the &lt;code&gt;applyPattern&lt;/code&gt; methods as desired.
                     For more information on using these methods, see
                     {@link DateFormat}.
                    
                     &lt;h3&gt;Date and Time Patterns&lt;/h3&gt;
                     &lt;p&gt;
                     Date and time formats are specified by &lt;em&gt;date and time pattern&lt;/em&gt;
                     strings.
                     Within date and time pattern strings, unquoted letters from
                     &lt;code&gt;'A'&lt;/code&gt; to &lt;code&gt;'Z'&lt;/code&gt; and from &lt;code&gt;'a'&lt;/code&gt; to
                     &lt;code&gt;'z'&lt;/code&gt; are interpreted as pattern letters representing the
                     components of a date or time string.
                     Text can be quoted using single quotes (&lt;code&gt;'&lt;/code&gt;) to avoid
                     interpretation.
                     &lt;code&gt;"''"&lt;/code&gt; represents a single quote.
                     All other characters are not interpreted; they're simply copied into the
                     output string during formatting or matched against the input string
                     during parsing.
                     &lt;p&gt;
                     The following pattern letters are defined (all other characters from
                     &lt;code&gt;'A'&lt;/code&gt; to &lt;code&gt;'Z'&lt;/code&gt; and from &lt;code&gt;'a'&lt;/code&gt; to
                     &lt;code&gt;'z'&lt;/code&gt; are reserved):
                     &lt;blockquote&gt;
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;Chart shows pattern letters, date/time component, presentation, and examples.&lt;/caption&gt;
                     &lt;thead&gt;
                         &lt;tr&gt;
                             &lt;th scope="col" style="text-align:left"&gt;Letter
                             &lt;th scope="col" style="text-align:left"&gt;Date or Time Component
                             &lt;th scope="col" style="text-align:left"&gt;Presentation
                             &lt;th scope="col" style="text-align:left"&gt;Examples
                     &lt;/thead&gt;
                     &lt;tbody&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;G&lt;/code&gt;
                             &lt;td&gt;Era designator
                             &lt;td&gt;&lt;a href="#text"&gt;Text&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;AD&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;y&lt;/code&gt;
                             &lt;td&gt;Year
                             &lt;td&gt;&lt;a href="#year"&gt;Year&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;1996&lt;/code&gt;; &lt;code&gt;96&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;Y&lt;/code&gt;
                             &lt;td&gt;Week year
                             &lt;td&gt;&lt;a href="#year"&gt;Year&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;2009&lt;/code&gt;; &lt;code&gt;09&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;M&lt;/code&gt;
                             &lt;td&gt;Month in year (context sensitive)
                             &lt;td&gt;&lt;a href="#month"&gt;Month&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;July&lt;/code&gt;; &lt;code&gt;Jul&lt;/code&gt;; &lt;code&gt;07&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;L&lt;/code&gt;
                             &lt;td&gt;Month in year (standalone form)
                             &lt;td&gt;&lt;a href="#month"&gt;Month&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;July&lt;/code&gt;; &lt;code&gt;Jul&lt;/code&gt;; &lt;code&gt;07&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;w&lt;/code&gt;
                             &lt;td&gt;Week in year
                             &lt;td&gt;&lt;a href="#number"&gt;Number&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;27&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;W&lt;/code&gt;
                             &lt;td&gt;Week in month
                             &lt;td&gt;&lt;a href="#number"&gt;Number&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;2&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;D&lt;/code&gt;
                             &lt;td&gt;Day in year
                             &lt;td&gt;&lt;a href="#number"&gt;Number&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;189&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;d&lt;/code&gt;
                             &lt;td&gt;Day in month
                             &lt;td&gt;&lt;a href="#number"&gt;Number&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;10&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;F&lt;/code&gt;
                             &lt;td&gt;Day of week in month
                             &lt;td&gt;&lt;a href="#number"&gt;Number&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;2&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;E&lt;/code&gt;
                             &lt;td&gt;Day name in week
                             &lt;td&gt;&lt;a href="#text"&gt;Text&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;Tuesday&lt;/code&gt;; &lt;code&gt;Tue&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;u&lt;/code&gt;
                             &lt;td&gt;Day number of week (1 = Monday, ..., 7 = Sunday)
                             &lt;td&gt;&lt;a href="#number"&gt;Number&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;1&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;a&lt;/code&gt;
                             &lt;td&gt;Am/pm marker
                             &lt;td&gt;&lt;a href="#text"&gt;Text&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;PM&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;H&lt;/code&gt;
                             &lt;td&gt;Hour in day (0-23)
                             &lt;td&gt;&lt;a href="#number"&gt;Number&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;k&lt;/code&gt;
                             &lt;td&gt;Hour in day (1-24)
                             &lt;td&gt;&lt;a href="#number"&gt;Number&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;24&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;K&lt;/code&gt;
                             &lt;td&gt;Hour in am/pm (0-11)
                             &lt;td&gt;&lt;a href="#number"&gt;Number&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;h&lt;/code&gt;
                             &lt;td&gt;Hour in am/pm (1-12)
                             &lt;td&gt;&lt;a href="#number"&gt;Number&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;12&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;m&lt;/code&gt;
                             &lt;td&gt;Minute in hour
                             &lt;td&gt;&lt;a href="#number"&gt;Number&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;30&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;s&lt;/code&gt;
                             &lt;td&gt;Second in minute
                             &lt;td&gt;&lt;a href="#number"&gt;Number&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;55&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;S&lt;/code&gt;
                             &lt;td&gt;Millisecond
                             &lt;td&gt;&lt;a href="#number"&gt;Number&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;978&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;z&lt;/code&gt;
                             &lt;td&gt;Time zone
                             &lt;td&gt;&lt;a href="#timezone"&gt;General time zone&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;Pacific Standard Time&lt;/code&gt;; &lt;code&gt;PST&lt;/code&gt;; &lt;code&gt;GMT-08:00&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;Z&lt;/code&gt;
                             &lt;td&gt;Time zone
                             &lt;td&gt;&lt;a href="#rfc822timezone"&gt;RFC 822 time zone&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;-0800&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;X&lt;/code&gt;
                             &lt;td&gt;Time zone
                             &lt;td&gt;&lt;a href="#iso8601timezone"&gt;ISO 8601 time zone&lt;/a&gt;
                             &lt;td&gt;&lt;code&gt;-08&lt;/code&gt;; &lt;code&gt;-0800&lt;/code&gt;;  &lt;code&gt;-08:00&lt;/code&gt;
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                     &lt;/blockquote&gt;
                     Pattern letters are usually repeated, as their number determines the
                     exact presentation:
                     &lt;ul&gt;
                     &lt;li&gt;&lt;strong&gt;&lt;a id="text"&gt;Text:&lt;/a&gt;&lt;/strong&gt;
                         For formatting, if the number of pattern letters is 4 or more,
                         the full form is used; otherwise a short or abbreviated form
                         is used if available.
                         For parsing, both forms are accepted, independent of the number
                         of pattern letters.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;strong&gt;&lt;a id="number"&gt;Number:&lt;/a&gt;&lt;/strong&gt;
                         For formatting, the number of pattern letters is the minimum
                         number of digits, and shorter numbers are zero-padded to this amount.
                         For parsing, the number of pattern letters is ignored unless
                         it's needed to separate two adjacent fields.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;strong&gt;&lt;a id="year"&gt;Year:&lt;/a&gt;&lt;/strong&gt;
                         If the formatter's {@link #getCalendar() Calendar} is the Gregorian
                         calendar, the following rules are applied.&lt;br&gt;
                         &lt;ul&gt;
                         &lt;li&gt;For formatting, if the number of pattern letters is 2, the year
                             is truncated to 2 digits; otherwise it is interpreted as a
                             &lt;a href="#number"&gt;number&lt;/a&gt;.
                         &lt;li&gt;For parsing, if the number of pattern letters is more than 2,
                             the year is interpreted literally, regardless of the number of
                             digits. So using the pattern "MM/dd/yyyy", "01/11/12" parses to
                             Jan 11, 12 A.D.
                         &lt;li&gt;For parsing with the abbreviated year pattern ("y" or "yy"),
                             &lt;code&gt;SimpleDateFormat&lt;/code&gt; must interpret the abbreviated year
                             relative to some century.  It does this by adjusting dates to be
                             within 80 years before and 20 years after the time the &lt;code&gt;SimpleDateFormat&lt;/code&gt;
                             instance is created. For example, using a pattern of "MM/dd/yy" and a
                             &lt;code&gt;SimpleDateFormat&lt;/code&gt; instance created on Jan 1, 1997,  the string
                             "01/11/12" would be interpreted as Jan 11, 2012 while the string "05/04/64"
                             would be interpreted as May 4, 1964.
                             During parsing, only strings consisting of exactly two digits, as defined by
                             {@link Character#isDigit(char)}, will be parsed into the default century.
                             Any other numeric string, such as a one digit string, a three or more digit
                             string, or a two digit string that isn't all digits (for example, "-1"), is
                             interpreted literally.  So "01/02/3" or "01/02/003" are parsed, using the
                             same pattern, as Jan 2, 3 AD.  Likewise, "01/02/-3" is parsed as Jan 2, 4 BC.
                         &lt;/ul&gt;
                         Otherwise, calendar system specific forms are applied.
                         For both formatting and parsing, if the number of pattern
                         letters is 4 or more, a calendar specific {@linkplain
                         Calendar#LONG long form} is used. Otherwise, a calendar
                         specific {@linkplain Calendar#SHORT short or abbreviated form}
                         is used.&lt;br&gt;
                         &lt;br&gt;
                         If week year {@code 'Y'} is specified and the {@linkplain
                         #getCalendar() calendar} doesn't support any &lt;a
                         href="../util/GregorianCalendar.html#week_year"&gt; week
                         years&lt;/a&gt;, the calendar year ({@code 'y'}) is used instead. The
                         support of week years can be tested with a call to {@link
                         DateFormat#getCalendar() getCalendar()}.{@link
                         java.util.Calendar#isWeekDateSupported()
                         isWeekDateSupported()}.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;strong&gt;&lt;a id="month"&gt;Month:&lt;/a&gt;&lt;/strong&gt;
                         If the number of pattern letters is 3 or more, the month is
                         interpreted as &lt;a href="#text"&gt;text&lt;/a&gt;; otherwise,
                         it is interpreted as a &lt;a href="#number"&gt;number&lt;/a&gt;.&lt;br&gt;
                         &lt;ul&gt;
                         &lt;li&gt;Letter &lt;em&gt;M&lt;/em&gt; produces context-sensitive month names, such as the
                             embedded form of names. Letter &lt;em&gt;M&lt;/em&gt; is context-sensitive in the
                             sense that when it is used in the standalone pattern, for example,
                             "MMMM", it gives the standalone form of a month name and when it is
                             used in the pattern containing other field(s), for example, "d MMMM",
                             it gives the format form of a month name. For example, January in the
                             Catalan language is "de gener" in the format form while it is "gener"
                             in the standalone form. In this case, "MMMM" will produce "gener" and
                             the month part of the "d MMMM" will produce "de gener". If a
                             {@code DateFormatSymbols} has been set explicitly with constructor
                             {@link #SimpleDateFormat(String,DateFormatSymbols)} or method {@link
                             #setDateFormatSymbols(DateFormatSymbols)}, the month names given by
                             the {@code DateFormatSymbols} are used.&lt;/li&gt;
                         &lt;li&gt;Letter &lt;em&gt;L&lt;/em&gt; produces the standalone form of month names.&lt;/li&gt;
                         &lt;/ul&gt;
                         &lt;br&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;strong&gt;&lt;a id="timezone"&gt;General time zone:&lt;/a&gt;&lt;/strong&gt;
                         Time zones are interpreted as &lt;a href="#text"&gt;text&lt;/a&gt; if they have
                         names. For time zones representing a GMT offset value, the
                         following syntax is used:
                         &lt;pre&gt;
                         &lt;a id="GMTOffsetTimeZone"&gt;&lt;i&gt;GMTOffsetTimeZone:&lt;/i&gt;&lt;/a&gt;
                                 &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt; &lt;code&gt;:&lt;/code&gt; &lt;i&gt;Minutes&lt;/i&gt;
                         &lt;i&gt;Sign:&lt;/i&gt; one of
                                 &lt;code&gt;+ -&lt;/code&gt;
                         &lt;i&gt;Hours:&lt;/i&gt;
                                 &lt;i&gt;Digit&lt;/i&gt;
                                 &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
                         &lt;i&gt;Minutes:&lt;/i&gt;
                                 &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
                         &lt;i&gt;Digit:&lt;/i&gt; one of
                                 &lt;code&gt;0 1 2 3 4 5 6 7 8 9&lt;/code&gt;&lt;/pre&gt;
                         &lt;i&gt;Hours&lt;/i&gt; must be between 0 and 23, and &lt;i&gt;Minutes&lt;/i&gt; must be between
                         00 and 59. The format is locale independent and digits must be taken
                         from the Basic Latin block of the Unicode standard.
                         &lt;p&gt;For parsing, &lt;a href="#rfc822timezone"&gt;RFC 822 time zones&lt;/a&gt; are also
                         accepted.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;strong&gt;&lt;a id="rfc822timezone"&gt;RFC 822 time zone:&lt;/a&gt;&lt;/strong&gt;
                         For formatting, the RFC 822 4-digit time zone format is used:
                    
                         &lt;pre&gt;
                         &lt;i&gt;RFC822TimeZone:&lt;/i&gt;
                                 &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; &lt;i&gt;Minutes&lt;/i&gt;
                         &lt;i&gt;TwoDigitHours:&lt;/i&gt;
                                 &lt;i&gt;Digit Digit&lt;/i&gt;&lt;/pre&gt;
                         &lt;i&gt;TwoDigitHours&lt;/i&gt; must be between 00 and 23. Other definitions
                         are as for &lt;a href="#timezone"&gt;general time zones&lt;/a&gt;.
                    
                         &lt;p&gt;For parsing, &lt;a href="#timezone"&gt;general time zones&lt;/a&gt; are also
                         accepted.
                     &lt;li&gt;&lt;strong&gt;&lt;a id="iso8601timezone"&gt;ISO 8601 Time zone:&lt;/a&gt;&lt;/strong&gt;
                         The number of pattern letters designates the format for both formatting
                         and parsing as follows:
                         &lt;pre&gt;
                         &lt;i&gt;ISO8601TimeZone:&lt;/i&gt;
                                 &lt;i&gt;OneLetterISO8601TimeZone&lt;/i&gt;
                                 &lt;i&gt;TwoLetterISO8601TimeZone&lt;/i&gt;
                                 &lt;i&gt;ThreeLetterISO8601TimeZone&lt;/i&gt;
                         &lt;i&gt;OneLetterISO8601TimeZone:&lt;/i&gt;
                                 &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt;
                                 {@code Z}
                         &lt;i&gt;TwoLetterISO8601TimeZone:&lt;/i&gt;
                                 &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; &lt;i&gt;Minutes&lt;/i&gt;
                                 {@code Z}
                         &lt;i&gt;ThreeLetterISO8601TimeZone:&lt;/i&gt;
                                 &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; {@code :} &lt;i&gt;Minutes&lt;/i&gt;
                                 {@code Z}&lt;/pre&gt;
                         Other definitions are as for &lt;a href="#timezone"&gt;general time zones&lt;/a&gt; or
                         &lt;a href="#rfc822timezone"&gt;RFC 822 time zones&lt;/a&gt;.
                    
                         &lt;p&gt;For formatting, if the offset value from GMT is 0, {@code "Z"} is
                         produced. If the number of pattern letters is 1, any fraction of an hour
                         is ignored. For example, if the pattern is {@code "X"} and the time zone is
                         {@code "GMT+05:30"}, {@code "+05"} is produced.
                    
                         &lt;p&gt;For parsing, {@code "Z"} is parsed as the UTC time zone designator.
                         &lt;a href="#timezone"&gt;General time zones&lt;/a&gt; are &lt;em&gt;not&lt;/em&gt; accepted.
                    
                         &lt;p&gt;If the number of pattern letters is 4 or more, {@link
                         IllegalArgumentException} is thrown when constructing a {@code
                         SimpleDateFormat} or {@linkplain #applyPattern(String) applying a
                         pattern}.
                     &lt;/ul&gt;
                     &lt;code&gt;SimpleDateFormat&lt;/code&gt; also supports &lt;em&gt;localized date and time
                     pattern&lt;/em&gt; strings. In these strings, the pattern letters described above
                     may be replaced with other, locale dependent, pattern letters.
                     &lt;code&gt;SimpleDateFormat&lt;/code&gt; does not deal with the localization of text
                     other than the pattern letters; that's up to the client of the class.
                    
                     &lt;h4&gt;Examples&lt;/h4&gt;
                    
                     The following examples show how date and time patterns are interpreted in
                     the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time
                     in the U.S. Pacific Time time zone.
                     &lt;blockquote&gt;
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;Examples of date and time patterns interpreted in the U.S. locale&lt;/caption&gt;
                     &lt;thead&gt;
                         &lt;tr&gt;
                             &lt;th scope="col" style="text-align:left"&gt;Date and Time Pattern
                             &lt;th scope="col" style="text-align:left"&gt;Result
                     &lt;/thead&gt;
                     &lt;tbody&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;"yyyy.MM.dd G 'at' HH:mm:ss z"&lt;/code&gt;
                             &lt;td&gt;&lt;code&gt;2001.07.04 AD at 12:08:56 PDT&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;"EEE, MMM d, ''yy"&lt;/code&gt;
                             &lt;td&gt;&lt;code&gt;Wed, Jul 4, '01&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;"h:mm a"&lt;/code&gt;
                             &lt;td&gt;&lt;code&gt;12:08 PM&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;"hh 'o''clock' a, zzzz"&lt;/code&gt;
                             &lt;td&gt;&lt;code&gt;12 o'clock PM, Pacific Daylight Time&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;"K:mm a, z"&lt;/code&gt;
                             &lt;td&gt;&lt;code&gt;0:08 PM, PDT&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;"yyyyy.MMMMM.dd GGG hh:mm aaa"&lt;/code&gt;
                             &lt;td&gt;&lt;code&gt;02001.July.04 AD 12:08 PM&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;"EEE, d MMM yyyy HH:mm:ss Z"&lt;/code&gt;
                             &lt;td&gt;&lt;code&gt;Wed, 4 Jul 2001 12:08:56 -0700&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;"yyMMddHHmmssZ"&lt;/code&gt;
                             &lt;td&gt;&lt;code&gt;010704120856-0700&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;"yyyy-MM-dd'T'HH:mm:ss.SSSZ"&lt;/code&gt;
                             &lt;td&gt;&lt;code&gt;2001-07-04T12:08:56.235-0700&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;"yyyy-MM-dd'T'HH:mm:ss.SSSXXX"&lt;/code&gt;
                             &lt;td&gt;&lt;code&gt;2001-07-04T12:08:56.235-07:00&lt;/code&gt;
                         &lt;tr&gt;
                             &lt;th scope="row"&gt;&lt;code&gt;"YYYY-'W'ww-u"&lt;/code&gt;
                             &lt;td&gt;&lt;code&gt;2001-W27-3&lt;/code&gt;
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;h4&gt;&lt;a id="synchronization"&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;p&gt;
                     Date formats are not synchronized.
                     It is recommended to create separate format instances for each thread.
                     If multiple threads access a format concurrently, it must be synchronized
                     externally.
                    
                     @see          &lt;a href="http://docs.oracle.com/javase/tutorial/i18n/format/simpleDateFormat.html"&gt;Java Tutorial&lt;/a&gt;
                     @see          java.util.Calendar
                     @see          java.util.TimeZone
                     @see          DateFormat
                     @see          DateFormatSymbols
                     @author       Mark Davis, Chen-Lieh Huang, Alan Liu
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="Field" access="PUBLIC" declaringClass="Format" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.text.AttributedCharacterIterator$Attribute"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="NumberFormat" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.text">
                <superTypes>
                    <superType superType="java.text.Format"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;code&gt;NumberFormat&lt;/code&gt; is the abstract base class for all number
                     formats. This class provides the interface for formatting and parsing
                     numbers. &lt;code&gt;NumberFormat&lt;/code&gt; also provides methods for determining
                     which locales have number formats, and what their names are.
                    
                     &lt;p&gt;
                     &lt;code&gt;NumberFormat&lt;/code&gt; helps you to format and parse numbers for any locale.
                     Your code can be completely independent of the locale conventions for
                     decimal points, thousands-separators, or even the particular decimal
                     digits used, or whether the number format is even decimal.
                    
                     &lt;p&gt;
                     To format a number for the current Locale, use one of the factory
                     class methods:
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     myString = NumberFormat.getInstance().format(myNumber);
                     }&lt;/pre&gt;
                     &lt;/blockquote&gt;
                     If you are formatting multiple numbers, it is
                     more efficient to get the format and use it multiple times so that
                     the system doesn't have to fetch the information about the local
                     language and country conventions multiple times.
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     NumberFormat nf = NumberFormat.getInstance();
                     for (int i = 0; i &lt; myNumber.length; ++i) {
                         output.println(nf.format(myNumber[i]) + "; ");
                     }
                     }&lt;/pre&gt;
                     &lt;/blockquote&gt;
                     To format a number for a different Locale, specify it in the
                     call to &lt;code&gt;getInstance&lt;/code&gt;.
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);
                     }&lt;/pre&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt;If the locale contains "nu" (numbers) and/or "rg" (region override)
                     &lt;a href="../util/Locale.html#def_locale_extension"&gt;Unicode extensions&lt;/a&gt;,
                     the decimal digits, and/or the country used for formatting are overridden.
                     If both "nu" and "rg" are specified, the decimal digits from the "nu"
                     extension supersedes the implicit one from the "rg" extension.
                    
                     &lt;p&gt;You can also use a {@code NumberFormat} to parse numbers:
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                     myNumber = nf.parse(myString);
                     }&lt;/pre&gt;
                     &lt;/blockquote&gt;
                     Use &lt;code&gt;getInstance&lt;/code&gt; or &lt;code&gt;getNumberInstance&lt;/code&gt; to get the
                     normal number format. Use &lt;code&gt;getIntegerInstance&lt;/code&gt; to get an
                     integer number format. Use &lt;code&gt;getCurrencyInstance&lt;/code&gt; to get the
                     currency number format. And use &lt;code&gt;getPercentInstance&lt;/code&gt; to get a
                     format for displaying percentages. With this format, a fraction like
                     0.53 is displayed as 53%.
                    
                     &lt;p&gt;
                     You can also control the display of numbers with such methods as
                     &lt;code&gt;setMinimumFractionDigits&lt;/code&gt;.
                     If you want even more control over the format or parsing,
                     or want to give your users more control,
                     you can try casting the &lt;code&gt;NumberFormat&lt;/code&gt; you get from the factory methods
                     to a &lt;code&gt;DecimalFormat&lt;/code&gt;. This will work for the vast majority
                     of locales; just remember to put it in a &lt;code&gt;try&lt;/code&gt; block in case you
                     encounter an unusual one.
                    
                     &lt;p&gt;
                     NumberFormat and DecimalFormat are designed such that some controls
                     work for formatting and others work for parsing.  The following is
                     the detailed description for each these control methods,
                     &lt;p&gt;
                     setParseIntegerOnly : only affects parsing, e.g.
                     if true,  "3456.78" &amp;rarr; 3456 (and leaves the parse position just after index 6)
                     if false, "3456.78" &amp;rarr; 3456.78 (and leaves the parse position just after index 8)
                     This is independent of formatting.  If you want to not show a decimal point
                     where there might be no digits after the decimal point, use
                     setDecimalSeparatorAlwaysShown.
                     &lt;p&gt;
                     setDecimalSeparatorAlwaysShown : only affects formatting, and only where
                     there might be no digits after the decimal point, such as with a pattern
                     like "#,##0.##", e.g.,
                     if true,  3456.00 &amp;rarr; "3,456."
                     if false, 3456.00 &amp;rarr; "3456"
                     This is independent of parsing.  If you want parsing to stop at the decimal
                     point, use setParseIntegerOnly.
                    
                     &lt;p&gt;
                     You can also use forms of the &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt;
                     methods with &lt;code&gt;ParsePosition&lt;/code&gt; and &lt;code&gt;FieldPosition&lt;/code&gt; to
                     allow you to:
                     &lt;ul&gt;
                     &lt;li&gt; progressively parse through pieces of a string
                     &lt;li&gt; align the decimal point and other areas
                     &lt;/ul&gt;
                     For example, you can align numbers in two ways:
                     &lt;ol&gt;
                     &lt;li&gt; If you are using a monospaced font with spacing for alignment,
                          you can pass the &lt;code&gt;FieldPosition&lt;/code&gt; in your format call, with
                          &lt;code&gt;field&lt;/code&gt; = &lt;code&gt;INTEGER_FIELD&lt;/code&gt;. On output,
                          &lt;code&gt;getEndIndex&lt;/code&gt; will be set to the offset between the
                          last character of the integer and the decimal. Add
                          (desiredSpaceCount - getEndIndex) spaces at the front of the string.
                    
                     &lt;li&gt; If you are using proportional fonts,
                          instead of padding with spaces, measure the width
                          of the string in pixels from the start to &lt;code&gt;getEndIndex&lt;/code&gt;.
                          Then move the pen by
                          (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.
                          It also works where there is no decimal, but possibly additional
                          characters at the end, e.g., with parentheses in negative
                          numbers: "(12)" for -12.
                     &lt;/ol&gt;
                    
                     &lt;h3&gt;&lt;a id="synchronization"&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;
                    
                     &lt;p&gt;
                     Number formats are generally not synchronized.
                     It is recommended to create separate format instances for each thread.
                     If multiple threads access a format concurrently, it must be synchronized
                     externally.
                    
                     @implSpec The {@link #format(double, StringBuffer, FieldPosition)},
                     {@link #format(long, StringBuffer, FieldPosition)} and
                     {@link #parse(String, ParsePosition)} methods may throw
                     {@code NullPointerException}, if any of their parameter is {@code null}.
                     The subclass may provide its own implementation and specification about
                     {@code NullPointerException}.
                    
                     &lt;p&gt;
                     The default implementation provides rounding modes defined
                     in {@link java.math.RoundingMode} for formatting numbers. It
                     uses the {@linkplain java.math.RoundingMode#HALF_EVEN
                     round half-even algorithm}. To change the rounding mode use
                     {@link #setRoundingMode(java.math.RoundingMode) setRoundingMode}.
                     The {@code NumberFormat} returned by the static factory methods is
                     configured to round floating point numbers using half-even
                     rounding (see {@link java.math.RoundingMode#HALF_EVEN
                     RoundingMode.HALF_EVEN}) for formatting.
                    
                     @see          DecimalFormat
                     @see          ChoiceFormat
                     @author       Mark Davis
                     @author       Helena Shih
                     @since 1.1
                    </javadoc>
            </acts>
            <package name="spi"/>
        </package>
        <package name="time">
            <acts name="LocalDateTime" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.temporal.Temporal"/>
                    <superType superType="java.time.temporal.TemporalAdjuster"/>
                    <superType superType="java.time.chrono.ChronoLocalDateTime"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A date-time without a time-zone in the ISO-8601 calendar system,
                     such as {@code 2007-12-03T10:15:30}.
                     &lt;p&gt;
                     {@code LocalDateTime} is an immutable date-time object that represents a date-time,
                     often viewed as year-month-day-hour-minute-second. Other date and time fields,
                     such as day-of-year, day-of-week and week-of-year, can also be accessed.
                     Time is represented to nanosecond precision.
                     For example, the value "2nd October 2007 at 13:45.30.123456789" can be
                     stored in a {@code LocalDateTime}.
                     &lt;p&gt;
                     This class does not store or represent a time-zone.
                     Instead, it is a description of the date, as used for birthdays, combined with
                     the local time as seen on a wall clock.
                     It cannot represent an instant on the time-line without additional information
                     such as an offset or time-zone.
                     &lt;p&gt;
                     The ISO-8601 calendar system is the modern civil calendar system used today
                     in most of the world. It is equivalent to the proleptic Gregorian calendar
                     system, in which today's rules for leap years are applied for all time.
                     For most applications written today, the ISO-8601 rules are entirely suitable.
                     However, any application that makes use of historical dates, and requires them
                     to be accurate will find the ISO-8601 approach unsuitable.
                    
                     &lt;p&gt;
                     This is a &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code LocalDateTime} may have unpredictable results and should be avoided.
                     The {@code equals} method should be used for comparisons.
                    
                     @implSpec
                     This class is immutable and thread-safe.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="DayOfWeek" access="PUBLIC" kind="TYPE" typeKind="ENUM" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.temporal.TemporalAccessor"/>
                    <superType superType="java.time.temporal.TemporalAdjuster"/>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A day-of-week, such as 'Tuesday'.
                     &lt;p&gt;
                     {@code DayOfWeek} is an enum representing the 7 days of the week -
                     Monday, Tuesday, Wednesday, Thursday, Friday, Saturday and Sunday.
                     &lt;p&gt;
                     In addition to the textual enum name, each day-of-week has an {@code int} value.
                     The {@code int} value follows the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).
                     It is recommended that applications use the enum rather than the {@code int} value
                     to ensure code clarity.
                     &lt;p&gt;
                     This enum provides access to the localized textual form of the day-of-week.
                     Some locales also assign different numeric values to the days, declaring
                     Sunday to have the value 1, however this class provides no support for this.
                     See {@link WeekFields} for localized week-numbering.
                     &lt;p&gt;
                     &lt;b&gt;Do not use {@code ordinal()} to obtain the numeric representation of {@code DayOfWeek}.
                     Use {@code getValue()} instead.&lt;/b&gt;
                     &lt;p&gt;
                     This enum represents a common concept that is found in many calendar systems.
                     As such, this enum may be used by any calendar system that has the day-of-week
                     concept defined exactly equivalent to the ISO calendar system.
                    
                     @implSpec
                     This is an immutable and thread-safe enum.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="LocalTime" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.temporal.Temporal"/>
                    <superType superType="java.time.temporal.TemporalAdjuster"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A time without a time-zone in the ISO-8601 calendar system,
                     such as {@code 10:15:30}.
                     &lt;p&gt;
                     {@code LocalTime} is an immutable date-time object that represents a time,
                     often viewed as hour-minute-second.
                     Time is represented to nanosecond precision.
                     For example, the value "13:45.30.123456789" can be stored in a {@code LocalTime}.
                     &lt;p&gt;
                     This class does not store or represent a date or time-zone.
                     Instead, it is a description of the local time as seen on a wall clock.
                     It cannot represent an instant on the time-line without additional information
                     such as an offset or time-zone.
                     &lt;p&gt;
                     The ISO-8601 calendar system is the modern civil calendar system used today
                     in most of the world. This API assumes that all calendar systems use the same
                     representation, this class, for time-of-day.
                    
                     &lt;p&gt;
                     This is a &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code LocalTime} may have unpredictable results and should be avoided.
                     The {@code equals} method should be used for comparisons.
                    
                     @implSpec
                     This class is immutable and thread-safe.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="ZoneId" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A time-zone ID, such as {@code Europe/Paris}.
                     &lt;p&gt;
                     A {@code ZoneId} is used to identify the rules used to convert between
                     an {@link Instant} and a {@link LocalDateTime}.
                     There are two distinct types of ID:
                     &lt;ul&gt;
                     &lt;li&gt;Fixed offsets - a fully resolved offset from UTC/Greenwich, that uses
                      the same offset for all local date-times
                     &lt;li&gt;Geographical regions - an area where a specific set of rules for finding
                      the offset from UTC/Greenwich apply
                     &lt;/ul&gt;
                     Most fixed offsets are represented by {@link ZoneOffset}.
                     Calling {@link #normalized()} on any {@code ZoneId} will ensure that a
                     fixed offset ID will be represented as a {@code ZoneOffset}.
                     &lt;p&gt;
                     The actual rules, describing when and how the offset changes, are defined by {@link ZoneRules}.
                     This class is simply an ID used to obtain the underlying rules.
                     This approach is taken because rules are defined by governments and change
                     frequently, whereas the ID is stable.
                     &lt;p&gt;
                     The distinction has other effects. Serializing the {@code ZoneId} will only send
                     the ID, whereas serializing the rules sends the entire data set.
                     Similarly, a comparison of two IDs only examines the ID, whereas
                     a comparison of two rules examines the entire data set.
                    
                     &lt;h3&gt;Time-zone IDs&lt;/h3&gt;
                     The ID is unique within the system.
                     There are three types of ID.
                     &lt;p&gt;
                     The simplest type of ID is that from {@code ZoneOffset}.
                     This consists of 'Z' and IDs starting with '+' or '-'.
                     &lt;p&gt;
                     The next type of ID are offset-style IDs with some form of prefix,
                     such as 'GMT+2' or 'UTC+01:00'.
                     The recognised prefixes are 'UTC', 'GMT' and 'UT'.
                     The offset is the suffix and will be normalized during creation.
                     These IDs can be normalized to a {@code ZoneOffset} using {@code normalized()}.
                     &lt;p&gt;
                     The third type of ID are region-based IDs. A region-based ID must be of
                     two or more characters, and not start with 'UTC', 'GMT', 'UT' '+' or '-'.
                     Region-based IDs are defined by configuration, see {@link ZoneRulesProvider}.
                     The configuration focuses on providing the lookup from the ID to the
                     underlying {@code ZoneRules}.
                     &lt;p&gt;
                     Time-zone rules are defined by governments and change frequently.
                     There are a number of organizations, known here as groups, that monitor
                     time-zone changes and collate them.
                     The default group is the IANA Time Zone Database (TZDB).
                     Other organizations include IATA (the airline industry body) and Microsoft.
                     &lt;p&gt;
                     Each group defines its own format for the region ID it provides.
                     The TZDB group defines IDs such as 'Europe/London' or 'America/New_York'.
                     TZDB IDs take precedence over other groups.
                     &lt;p&gt;
                     It is strongly recommended that the group name is included in all IDs supplied by
                     groups other than TZDB to avoid conflicts. For example, IATA airline time-zone
                     region IDs are typically the same as the three letter airport code.
                     However, the airport of Utrecht has the code 'UTC', which is obviously a conflict.
                     The recommended format for region IDs from groups other than TZDB is 'group~region'.
                     Thus if IATA data were defined, Utrecht airport would be 'IATA~UTC'.
                    
                     &lt;h3&gt;Serialization&lt;/h3&gt;
                     This class can be serialized and stores the string zone ID in the external form.
                     The {@code ZoneOffset} subclass uses a dedicated format that only stores the
                     offset from UTC/Greenwich.
                     &lt;p&gt;
                     A {@code ZoneId} can be deserialized in a Java Runtime where the ID is unknown.
                     For example, if a server-side Java Runtime has been updated with a new zone ID, but
                     the client-side Java Runtime has not been updated. In this case, the {@code ZoneId}
                     object will exist, and can be queried using {@code getId}, {@code equals},
                     {@code hashCode}, {@code toString}, {@code getDisplayName} and {@code normalized}.
                     However, any call to {@code getRules} will fail with {@code ZoneRulesException}.
                     This approach is designed to allow a {@link ZonedDateTime} to be loaded and
                     queried, but not modified, on a Java Runtime with incomplete time-zone information.
                    
                     &lt;p&gt;
                     This is a &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code ZoneId} may have unpredictable results and should be avoided.
                     The {@code equals} method should be used for comparisons.
                    
                     @implSpec
                     This abstract class has two implementations, both of which are immutable and thread-safe.
                     One implementation models region-based IDs, the other is {@code ZoneOffset} modelling
                     offset-based IDs. This difference is visible in serialization.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="Instant" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.temporal.Temporal"/>
                    <superType superType="java.time.temporal.TemporalAdjuster"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An instantaneous point on the time-line.
                     &lt;p&gt;
                     This class models a single instantaneous point on the time-line.
                     This might be used to record event time-stamps in the application.
                     &lt;p&gt;
                     The range of an instant requires the storage of a number larger than a {@code long}.
                     To achieve this, the class stores a {@code long} representing epoch-seconds and an
                     {@code int} representing nanosecond-of-second, which will always be between 0 and 999,999,999.
                     The epoch-seconds are measured from the standard Java epoch of {@code 1970-01-01T00:00:00Z}
                     where instants after the epoch have positive values, and earlier instants have negative values.
                     For both the epoch-second and nanosecond parts, a larger value is always later on the time-line
                     than a smaller value.
                    
                     &lt;h3&gt;Time-scale&lt;/h3&gt;
                     &lt;p&gt;
                     The length of the solar day is the standard way that humans measure time.
                     This has traditionally been subdivided into 24 hours of 60 minutes of 60 seconds,
                     forming a 86400 second day.
                     &lt;p&gt;
                     Modern timekeeping is based on atomic clocks which precisely define an SI second
                     relative to the transitions of a Caesium atom. The length of an SI second was defined
                     to be very close to the 86400th fraction of a day.
                     &lt;p&gt;
                     Unfortunately, as the Earth rotates the length of the day varies.
                     In addition, over time the average length of the day is getting longer as the Earth slows.
                     As a result, the length of a solar day in 2012 is slightly longer than 86400 SI seconds.
                     The actual length of any given day and the amount by which the Earth is slowing
                     are not predictable and can only be determined by measurement.
                     The UT1 time-scale captures the accurate length of day, but is only available some
                     time after the day has completed.
                     &lt;p&gt;
                     The UTC time-scale is a standard approach to bundle up all the additional fractions
                     of a second from UT1 into whole seconds, known as &lt;i&gt;leap-seconds&lt;/i&gt;.
                     A leap-second may be added or removed depending on the Earth's rotational changes.
                     As such, UTC permits a day to have 86399 SI seconds or 86401 SI seconds where
                     necessary in order to keep the day aligned with the Sun.
                     &lt;p&gt;
                     The modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds.
                     Between 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and
                     alterations to the length of the notional second. As of 2012, discussions are underway
                     to change the definition of UTC again, with the potential to remove leap seconds or
                     introduce other changes.
                     &lt;p&gt;
                     Given the complexity of accurate timekeeping described above, this Java API defines
                     its own time-scale, the &lt;i&gt;Java Time-Scale&lt;/i&gt;.
                     &lt;p&gt;
                     The Java Time-Scale divides each calendar day into exactly 86400
                     subdivisions, known as seconds.  These seconds may differ from the
                     SI second.  It closely matches the de facto international civil time
                     scale, the definition of which changes from time to time.
                     &lt;p&gt;
                     The Java Time-Scale has slightly different definitions for different
                     segments of the time-line, each based on the consensus international
                     time scale that is used as the basis for civil time. Whenever the
                     internationally-agreed time scale is modified or replaced, a new
                     segment of the Java Time-Scale must be defined for it.  Each segment
                     must meet these requirements:
                     &lt;ul&gt;
                     &lt;li&gt;the Java Time-Scale shall closely match the underlying international
                      civil time scale;&lt;/li&gt;
                     &lt;li&gt;the Java Time-Scale shall exactly match the international civil
                      time scale at noon each day;&lt;/li&gt;
                     &lt;li&gt;the Java Time-Scale shall have a precisely-defined relationship to
                      the international civil time scale.&lt;/li&gt;
                     &lt;/ul&gt;
                     There are currently, as of 2013, two segments in the Java time-scale.
                     &lt;p&gt;
                     For the segment from 1972-11-03 (exact boundary discussed below) until
                     further notice, the consensus international time scale is UTC (with
                     leap seconds).  In this segment, the Java Time-Scale is identical to
                     &lt;a href="http://www.cl.cam.ac.uk/~mgk25/time/utc-sls/"&gt;UTC-SLS&lt;/a&gt;.
                     This is identical to UTC on days that do not have a leap second.
                     On days that do have a leap second, the leap second is spread equally
                     over the last 1000 seconds of the day, maintaining the appearance of
                     exactly 86400 seconds per day.
                     &lt;p&gt;
                     For the segment prior to 1972-11-03, extending back arbitrarily far,
                     the consensus international time scale is defined to be UT1, applied
                     proleptically, which is equivalent to the (mean) solar time on the
                     prime meridian (Greenwich). In this segment, the Java Time-Scale is
                     identical to the consensus international time scale. The exact
                     boundary between the two segments is the instant where UT1 = UTC
                     between 1972-11-03T00:00 and 1972-11-04T12:00.
                     &lt;p&gt;
                     Implementations of the Java time-scale using the JSR-310 API are not
                     required to provide any clock that is sub-second accurate, or that
                     progresses monotonically or smoothly. Implementations are therefore
                     not required to actually perform the UTC-SLS slew or to otherwise be
                     aware of leap seconds. JSR-310 does, however, require that
                     implementations must document the approach they use when defining a
                     clock representing the current instant.
                     See {@link Clock} for details on the available clocks.
                     &lt;p&gt;
                     The Java time-scale is used for all date-time classes.
                     This includes {@code Instant}, {@code LocalDate}, {@code LocalTime}, {@code OffsetDateTime},
                     {@code ZonedDateTime} and {@code Duration}.
                    
                     &lt;p&gt;
                     This is a &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code Instant} may have unpredictable results and should be avoided.
                     The {@code equals} method should be used for comparisons.
                    
                     @implSpec
                     This class is immutable and thread-safe.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="Period" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.chrono.ChronoPeriod"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A date-based amount of time in the ISO-8601 calendar system,
                     such as '2 years, 3 months and 4 days'.
                     &lt;p&gt;
                     This class models a quantity or amount of time in terms of years, months and days.
                     See {@link Duration} for the time-based equivalent to this class.
                     &lt;p&gt;
                     Durations and periods differ in their treatment of daylight savings time
                     when added to {@link ZonedDateTime}. A {@code Duration} will add an exact
                     number of seconds, thus a duration of one day is always exactly 24 hours.
                     By contrast, a {@code Period} will add a conceptual day, trying to maintain
                     the local time.
                     &lt;p&gt;
                     For example, consider adding a period of one day and a duration of one day to
                     18:00 on the evening before a daylight savings gap. The {@code Period} will add
                     the conceptual day and result in a {@code ZonedDateTime} at 18:00 the following day.
                     By contrast, the {@code Duration} will add exactly 24 hours, resulting in a
                     {@code ZonedDateTime} at 19:00 the following day (assuming a one hour DST gap).
                     &lt;p&gt;
                     The supported units of a period are {@link ChronoUnit#YEARS YEARS},
                     {@link ChronoUnit#MONTHS MONTHS} and {@link ChronoUnit#DAYS DAYS}.
                     All three fields are always present, but may be set to zero.
                     &lt;p&gt;
                     The ISO-8601 calendar system is the modern civil calendar system used today
                     in most of the world. It is equivalent to the proleptic Gregorian calendar
                     system, in which today's rules for leap years are applied for all time.
                     &lt;p&gt;
                     The period is modeled as a directed amount of time, meaning that individual parts of the
                     period may be negative.
                    
                     &lt;p&gt;
                     This is a &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code Period} may have unpredictable results and should be avoided.
                     The {@code equals} method should be used for comparisons.
                    
                     @implSpec
                     This class is immutable and thread-safe.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="Duration" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.temporal.TemporalAmount"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A time-based amount of time, such as '34.5 seconds'.
                     &lt;p&gt;
                     This class models a quantity or amount of time in terms of seconds and nanoseconds.
                     It can be accessed using other duration-based units, such as minutes and hours.
                     In addition, the {@link ChronoUnit#DAYS DAYS} unit can be used and is treated as
                     exactly equal to 24 hours, thus ignoring daylight savings effects.
                     See {@link Period} for the date-based equivalent to this class.
                     &lt;p&gt;
                     A physical duration could be of infinite length.
                     For practicality, the duration is stored with constraints similar to {@link Instant}.
                     The duration uses nanosecond resolution with a maximum value of the seconds that can
                     be held in a {@code long}. This is greater than the current estimated age of the universe.
                     &lt;p&gt;
                     The range of a duration requires the storage of a number larger than a {@code long}.
                     To achieve this, the class stores a {@code long} representing seconds and an {@code int}
                     representing nanosecond-of-second, which will always be between 0 and 999,999,999.
                     The model is of a directed duration, meaning that the duration may be negative.
                     &lt;p&gt;
                     The duration is measured in "seconds", but these are not necessarily identical to
                     the scientific "SI second" definition based on atomic clocks.
                     This difference only impacts durations measured near a leap-second and should not affect
                     most applications.
                     See {@link Instant} for a discussion as to the meaning of the second and time-scales.
                    
                     &lt;p&gt;
                     This is a &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code Duration} may have unpredictable results and should be avoided.
                     The {@code equals} method should be used for comparisons.
                    
                     @implSpec
                     This class is immutable and thread-safe.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="MonthDay" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.temporal.TemporalAccessor"/>
                    <superType superType="java.time.temporal.TemporalAdjuster"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A month-day in the ISO-8601 calendar system, such as {@code --12-03}.
                     &lt;p&gt;
                     {@code MonthDay} is an immutable date-time object that represents the combination
                     of a month and day-of-month. Any field that can be derived from a month and day,
                     such as quarter-of-year, can be obtained.
                     &lt;p&gt;
                     This class does not store or represent a year, time or time-zone.
                     For example, the value "December 3rd" can be stored in a {@code MonthDay}.
                     &lt;p&gt;
                     Since a {@code MonthDay} does not possess a year, the leap day of
                     February 29th is considered valid.
                     &lt;p&gt;
                     This class implements {@link TemporalAccessor} rather than {@link Temporal}.
                     This is because it is not possible to define whether February 29th is valid or not
                     without external information, preventing the implementation of plus/minus.
                     Related to this, {@code MonthDay} only provides access to query and set the fields
                     {@code MONTH_OF_YEAR} and {@code DAY_OF_MONTH}.
                     &lt;p&gt;
                     The ISO-8601 calendar system is the modern civil calendar system used today
                     in most of the world. It is equivalent to the proleptic Gregorian calendar
                     system, in which today's rules for leap years are applied for all time.
                     For most applications written today, the ISO-8601 rules are entirely suitable.
                     However, any application that makes use of historical dates, and requires them
                     to be accurate will find the ISO-8601 approach unsuitable.
                    
                     &lt;p&gt;
                     This is a &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code MonthDay} may have unpredictable results and should be avoided.
                     The {@code equals} method should be used for comparisons.
                    
                     @implSpec
                     This class is immutable and thread-safe.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="Clock" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A clock providing access to the current instant, date and time using a time-zone.
                     &lt;p&gt;
                     Instances of this class are used to find the current instant, which can be
                     interpreted using the stored time-zone to find the current date and time.
                     As such, a clock can be used instead of {@link System#currentTimeMillis()}
                     and {@link TimeZone#getDefault()}.
                     &lt;p&gt;
                     Use of a {@code Clock} is optional. All key date-time classes also have a
                     {@code now()} factory method that uses the system clock in the default time zone.
                     The primary purpose of this abstraction is to allow alternate clocks to be
                     plugged in as and when required. Applications use an object to obtain the
                     current time rather than a static method. This can simplify testing.
                     &lt;p&gt;
                     Best practice for applications is to pass a {@code Clock} into any method
                     that requires the current instant. A dependency injection framework is one
                     way to achieve this:
                     &lt;pre&gt;
                      public class MyBean {
                        private Clock clock;  // dependency inject
                        ...
                        public void process(LocalDate eventDate) {
                          if (eventDate.isBefore(LocalDate.now(clock)) {
                            ...
                          }
                        }
                      }
                     &lt;/pre&gt;
                     This approach allows an alternate clock, such as {@link #fixed(Instant, ZoneId) fixed}
                     or {@link #offset(Clock, Duration) offset} to be used during testing.
                     &lt;p&gt;
                     The {@code system} factory methods provide clocks based on the best available
                     system clock This may use {@link System#currentTimeMillis()}, or a higher
                     resolution clock if one is available.
                    
                     @implSpec
                     This abstract class must be implemented with care to ensure other classes operate correctly.
                     All implementations that can be instantiated must be final, immutable and thread-safe.
                     &lt;p&gt;
                     The principal methods are defined to allow the throwing of an exception.
                     In normal use, no exceptions will be thrown, however one possible implementation would be to
                     obtain the time from a central time server across the network. Obviously, in this case the
                     lookup could fail, and so the method is permitted to throw an exception.
                     &lt;p&gt;
                     The returned instants from {@code Clock} work on a time-scale that ignores leap seconds,
                     as described in {@link Instant}. If the implementation wraps a source that provides leap
                     second information, then a mechanism should be used to "smooth" the leap second.
                     The Java Time-Scale mandates the use of UTC-SLS, however clock implementations may choose
                     how accurate they are with the time-scale so long as they document how they work.
                     Implementations are therefore not required to actually perform the UTC-SLS slew or to
                     otherwise be aware of leap seconds.
                     &lt;p&gt;
                     Implementations should implement {@code Serializable} wherever possible and must
                     document whether or not they do support serialization.
                    
                     @implNote
                     The clock implementation provided here is based on the same underlying clock
                     as {@link System#currentTimeMillis()}, but may have a precision finer than
                     milliseconds if available.
                     However, little to no guarantee is provided about the accuracy of the
                     underlying clock. Applications requiring a more accurate clock must implement
                     this abstract class themselves using a different external clock, such as an
                     NTP server.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="LocalDate" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.temporal.Temporal"/>
                    <superType superType="java.time.temporal.TemporalAdjuster"/>
                    <superType superType="java.time.chrono.ChronoLocalDate"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A date without a time-zone in the ISO-8601 calendar system,
                     such as {@code 2007-12-03}.
                     &lt;p&gt;
                     {@code LocalDate} is an immutable date-time object that represents a date,
                     often viewed as year-month-day. Other date fields, such as day-of-year,
                     day-of-week and week-of-year, can also be accessed.
                     For example, the value "2nd October 2007" can be stored in a {@code LocalDate}.
                     &lt;p&gt;
                     This class does not store or represent a time or time-zone.
                     Instead, it is a description of the date, as used for birthdays.
                     It cannot represent an instant on the time-line without additional information
                     such as an offset or time-zone.
                     &lt;p&gt;
                     The ISO-8601 calendar system is the modern civil calendar system used today
                     in most of the world. It is equivalent to the proleptic Gregorian calendar
                     system, in which today's rules for leap years are applied for all time.
                     For most applications written today, the ISO-8601 rules are entirely suitable.
                     However, any application that makes use of historical dates, and requires them
                     to be accurate will find the ISO-8601 approach unsuitable.
                    
                     &lt;p&gt;
                     This is a &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code LocalDate} may have unpredictable results and should be avoided.
                     The {@code equals} method should be used for comparisons.
                    
                     @implSpec
                     This class is immutable and thread-safe.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="ZoneOffset" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.temporal.TemporalAccessor"/>
                    <superType superType="java.time.temporal.TemporalAdjuster"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.time.ZoneId"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A time-zone offset from Greenwich/UTC, such as {@code +02:00}.
                     &lt;p&gt;
                     A time-zone offset is the amount of time that a time-zone differs from Greenwich/UTC.
                     This is usually a fixed number of hours and minutes.
                     &lt;p&gt;
                     Different parts of the world have different time-zone offsets.
                     The rules for how offsets vary by place and time of year are captured in the
                     {@link ZoneId} class.
                     &lt;p&gt;
                     For example, Paris is one hour ahead of Greenwich/UTC in winter and two hours
                     ahead in summer. The {@code ZoneId} instance for Paris will reference two
                     {@code ZoneOffset} instances - a {@code +01:00} instance for winter,
                     and a {@code +02:00} instance for summer.
                     &lt;p&gt;
                     In 2008, time-zone offsets around the world extended from -12:00 to +14:00.
                     To prevent any problems with that range being extended, yet still provide
                     validation, the range of offsets is restricted to -18:00 to 18:00 inclusive.
                     &lt;p&gt;
                     This class is designed for use with the ISO calendar system.
                     The fields of hours, minutes and seconds make assumptions that are valid for the
                     standard ISO definitions of those fields. This class may be used with other
                     calendar systems providing the definition of the time fields matches those
                     of the ISO calendar system.
                     &lt;p&gt;
                     Instances of {@code ZoneOffset} must be compared using {@link #equals}.
                     Implementations may choose to cache certain common offsets, however
                     applications must not rely on such caching.
                    
                     &lt;p&gt;
                     This is a &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code ZoneOffset} may have unpredictable results and should be avoided.
                     The {@code equals} method should be used for comparisons.
                    
                     @implSpec
                     This class is immutable and thread-safe.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="Month" access="PUBLIC" kind="TYPE" typeKind="ENUM" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.temporal.TemporalAccessor"/>
                    <superType superType="java.time.temporal.TemporalAdjuster"/>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A month-of-year, such as 'July'.
                     &lt;p&gt;
                     {@code Month} is an enum representing the 12 months of the year -
                     January, February, March, April, May, June, July, August, September, October,
                     November and December.
                     &lt;p&gt;
                     In addition to the textual enum name, each month-of-year has an {@code int} value.
                     The {@code int} value follows normal usage and the ISO-8601 standard,
                     from 1 (January) to 12 (December). It is recommended that applications use the enum
                     rather than the {@code int} value to ensure code clarity.
                     &lt;p&gt;
                     &lt;b&gt;Do not use {@code ordinal()} to obtain the numeric representation of {@code Month}.
                     Use {@code getValue()} instead.&lt;/b&gt;
                     &lt;p&gt;
                     This enum represents a common concept that is found in many calendar systems.
                     As such, this enum may be used by any calendar system that has the month-of-year
                     concept defined exactly equivalent to the ISO-8601 calendar system.
                    
                     @implSpec
                     This is an immutable and thread-safe enum.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="DateTimeException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Exception used to indicate a problem while calculating a date-time.
                     &lt;p&gt;
                     This exception is used to indicate problems with creating, querying
                     and manipulating date-time objects.
                    
                     @implSpec
                     This class is intended for use in a single thread.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="Year" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.temporal.Temporal"/>
                    <superType superType="java.time.temporal.TemporalAdjuster"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A year in the ISO-8601 calendar system, such as {@code 2007}.
                     &lt;p&gt;
                     {@code Year} is an immutable date-time object that represents a year.
                     Any field that can be derived from a year can be obtained.
                     &lt;p&gt;
                     &lt;b&gt;Note that years in the ISO chronology only align with years in the
                     Gregorian-Julian system for modern years. Parts of Russia did not switch to the
                     modern Gregorian/ISO rules until 1920.
                     As such, historical years must be treated with caution.&lt;/b&gt;
                     &lt;p&gt;
                     This class does not store or represent a month, day, time or time-zone.
                     For example, the value "2007" can be stored in a {@code Year}.
                     &lt;p&gt;
                     Years represented by this class follow the ISO-8601 standard and use
                     the proleptic numbering system. Year 1 is preceded by year 0, then by year -1.
                     &lt;p&gt;
                     The ISO-8601 calendar system is the modern civil calendar system used today
                     in most of the world. It is equivalent to the proleptic Gregorian calendar
                     system, in which today's rules for leap years are applied for all time.
                     For most applications written today, the ISO-8601 rules are entirely suitable.
                     However, any application that makes use of historical dates, and requires them
                     to be accurate will find the ISO-8601 approach unsuitable.
                    
                     &lt;p&gt;
                     This is a &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code Year} may have unpredictable results and should be avoided.
                     The {@code equals} method should be used for comparisons.
                    
                     @implSpec
                     This class is immutable and thread-safe.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="YearMonth" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.temporal.Temporal"/>
                    <superType superType="java.time.temporal.TemporalAdjuster"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A year-month in the ISO-8601 calendar system, such as {@code 2007-12}.
                     &lt;p&gt;
                     {@code YearMonth} is an immutable date-time object that represents the combination
                     of a year and month. Any field that can be derived from a year and month, such as
                     quarter-of-year, can be obtained.
                     &lt;p&gt;
                     This class does not store or represent a day, time or time-zone.
                     For example, the value "October 2007" can be stored in a {@code YearMonth}.
                     &lt;p&gt;
                     The ISO-8601 calendar system is the modern civil calendar system used today
                     in most of the world. It is equivalent to the proleptic Gregorian calendar
                     system, in which today's rules for leap years are applied for all time.
                     For most applications written today, the ISO-8601 rules are entirely suitable.
                     However, any application that makes use of historical dates, and requires them
                     to be accurate will find the ISO-8601 approach unsuitable.
                    
                     &lt;p&gt;
                     This is a &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code YearMonth} may have unpredictable results and should be avoided.
                     The {@code equals} method should be used for comparisons.
                    
                     @implSpec
                     This class is immutable and thread-safe.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="OffsetDateTime" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.temporal.Temporal"/>
                    <superType superType="java.time.temporal.TemporalAdjuster"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system,
                     such as {@code 2007-12-03T10:15:30+01:00}.
                     &lt;p&gt;
                     {@code OffsetDateTime} is an immutable representation of a date-time with an offset.
                     This class stores all date and time fields, to a precision of nanoseconds,
                     as well as the offset from UTC/Greenwich. For example, the value
                     "2nd October 2007 at 13:45:30.123456789 +02:00" can be stored in an {@code OffsetDateTime}.
                     &lt;p&gt;
                     {@code OffsetDateTime}, {@link java.time.ZonedDateTime} and {@link java.time.Instant} all store an instant
                     on the time-line to nanosecond precision.
                     {@code Instant} is the simplest, simply representing the instant.
                     {@code OffsetDateTime} adds to the instant the offset from UTC/Greenwich, which allows
                     the local date-time to be obtained.
                     {@code ZonedDateTime} adds full time-zone rules.
                     &lt;p&gt;
                     It is intended that {@code ZonedDateTime} or {@code Instant} is used to model data
                     in simpler applications. This class may be used when modeling date-time concepts in
                     more detail, or when communicating to a database or in a network protocol.
                    
                     &lt;p&gt;
                     This is a &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code OffsetDateTime} may have unpredictable results and should be avoided.
                     The {@code equals} method should be used for comparisons.
                    
                     @implSpec
                     This class is immutable and thread-safe.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="ZonedDateTime" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.temporal.Temporal"/>
                    <superType superType="java.time.chrono.ChronoZonedDateTime"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A date-time with a time-zone in the ISO-8601 calendar system,
                     such as {@code 2007-12-03T10:15:30+01:00 Europe/Paris}.
                     &lt;p&gt;
                     {@code ZonedDateTime} is an immutable representation of a date-time with a time-zone.
                     This class stores all date and time fields, to a precision of nanoseconds,
                     and a time-zone, with a zone offset used to handle ambiguous local date-times.
                     For example, the value
                     "2nd October 2007 at 13:45.30.123456789 +02:00 in the Europe/Paris time-zone"
                     can be stored in a {@code ZonedDateTime}.
                     &lt;p&gt;
                     This class handles conversion from the local time-line of {@code LocalDateTime}
                     to the instant time-line of {@code Instant}.
                     The difference between the two time-lines is the offset from UTC/Greenwich,
                     represented by a {@code ZoneOffset}.
                     &lt;p&gt;
                     Converting between the two time-lines involves calculating the offset using the
                     {@link ZoneRules rules} accessed from the {@code ZoneId}.
                     Obtaining the offset for an instant is simple, as there is exactly one valid
                     offset for each instant. By contrast, obtaining the offset for a local date-time
                     is not straightforward. There are three cases:
                     &lt;ul&gt;
                     &lt;li&gt;Normal, with one valid offset. For the vast majority of the year, the normal
                      case applies, where there is a single valid offset for the local date-time.&lt;/li&gt;
                     &lt;li&gt;Gap, with zero valid offsets. This is when clocks jump forward typically
                      due to the spring daylight savings change from "winter" to "summer".
                      In a gap there are local date-time values with no valid offset.&lt;/li&gt;
                     &lt;li&gt;Overlap, with two valid offsets. This is when clocks are set back typically
                      due to the autumn daylight savings change from "summer" to "winter".
                      In an overlap there are local date-time values with two valid offsets.&lt;/li&gt;
                     &lt;/ul&gt;
                     &lt;p&gt;
                     Any method that converts directly or implicitly from a local date-time to an
                     instant by obtaining the offset has the potential to be complicated.
                     &lt;p&gt;
                     For Gaps, the general strategy is that if the local date-time falls in the
                     middle of a Gap, then the resulting zoned date-time will have a local date-time
                     shifted forwards by the length of the Gap, resulting in a date-time in the later
                     offset, typically "summer" time.
                     &lt;p&gt;
                     For Overlaps, the general strategy is that if the local date-time falls in the
                     middle of an Overlap, then the previous offset will be retained. If there is no
                     previous offset, or the previous offset is invalid, then the earlier offset is
                     used, typically "summer" time.. Two additional methods,
                     {@link #withEarlierOffsetAtOverlap()} and {@link #withLaterOffsetAtOverlap()},
                     help manage the case of an overlap.
                     &lt;p&gt;
                     In terms of design, this class should be viewed primarily as the combination
                     of a {@code LocalDateTime} and a {@code ZoneId}. The {@code ZoneOffset} is
                     a vital, but secondary, piece of information, used to ensure that the class
                     represents an instant, especially during a daylight savings overlap.
                    
                     &lt;p&gt;
                     This is a &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code ZonedDateTime} may have unpredictable results and should be avoided.
                     The {@code equals} method should be used for comparisons.
                    
                     @implSpec
                     A {@code ZonedDateTime} holds state equivalent to three separate objects,
                     a {@code LocalDateTime}, a {@code ZoneId} and the resolved {@code ZoneOffset}.
                     The offset and local date-time are used to define an instant when necessary.
                     The zone ID is used to obtain the rules for how and when the offset changes.
                     The offset cannot be freely set, as the zone controls which offsets are valid.
                     &lt;p&gt;
                     This class is immutable and thread-safe.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="OffsetTime" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.time">
                <superTypes>
                    <superType superType="java.time.temporal.Temporal"/>
                    <superType superType="java.time.temporal.TemporalAdjuster"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A time with an offset from UTC/Greenwich in the ISO-8601 calendar system,
                     such as {@code 10:15:30+01:00}.
                     &lt;p&gt;
                     {@code OffsetTime} is an immutable date-time object that represents a time, often
                     viewed as hour-minute-second-offset.
                     This class stores all time fields, to a precision of nanoseconds,
                     as well as a zone offset.
                     For example, the value "13:45:30.123456789+02:00" can be stored
                     in an {@code OffsetTime}.
                    
                     &lt;p&gt;
                     This is a &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;
                     class; use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on instances of
                     {@code OffsetTime} may have unpredictable results and should be avoided.
                     The {@code equals} method should be used for comparisons.
                    
                     @implSpec
                     This class is immutable and thread-safe.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <package name="zone"/>
            <package name="format"/>
            <package name="chrono"/>
            <package name="temporal"/>
        </package>
        <package name="lang">
            <acts name="Enum" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This is the common base class of all Java language enumeration types.
                    
                     More information about enums, including descriptions of the
                     implicitly declared methods synthesized by the compiler, can be
                     found in section 8.9 of
                     &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
                    
                     &lt;p&gt; Note that when using an enumeration type as the type of a set
                     or as the type of the keys in a map, specialized and efficient
                     {@linkplain java.util.EnumSet set} and {@linkplain
                     java.util.EnumMap map} implementations are available.
                    
                     @param &lt;E&gt; The enum type subclass
                     @author  Josh Bloch
                     @author  Neal Gafter
                     @see     Class#getEnumConstants()
                     @see     java.util.EnumSet
                     @see     java.util.EnumMap
                     @since   1.5
                    </javadoc>
            </acts>
            <acts name="ClassValue" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Lazily associate a computed value with (potentially) every type.
                     For example, if a dynamic language needs to construct a message dispatch
                     table for each class encountered at a message send call site,
                     it can use a {@code ClassValue} to cache information needed to
                     perform the message send quickly, for each class encountered.
                     @author John Rose, JSR 292 EG
                     @since 1.7
                    </javadoc>
            </acts>
            <acts name="UnicodeScript" access="PUBLIC" declaringClass="Character" kind="TYPE" typeKind="ENUM" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="String" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.CharSequence"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code String} class represents character strings. All
                     string literals in Java programs, such as {@code "abc"}, are
                     implemented as instances of this class.
                     &lt;p&gt;
                     Strings are constant; their values cannot be changed after they
                     are created. String buffers support mutable strings.
                     Because String objects are immutable they can be shared. For example:
                     &lt;blockquote&gt;&lt;pre&gt;
                         String str = "abc";
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
                     is equivalent to:
                     &lt;blockquote&gt;&lt;pre&gt;
                         char data[] = {'a', 'b', 'c'};
                         String str = new String(data);
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
                     Here are some more examples of how strings can be used:
                     &lt;blockquote&gt;&lt;pre&gt;
                         System.out.println("abc");
                         String cde = "cde";
                         System.out.println("abc" + cde);
                         String c = "abc".substring(2,3);
                         String d = cde.substring(1, 2);
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     &lt;p&gt;
                     The class {@code String} includes methods for examining
                     individual characters of the sequence, for comparing strings, for
                     searching strings, for extracting substrings, and for creating a
                     copy of a string with all characters translated to uppercase or to
                     lowercase. Case mapping is based on the Unicode Standard version
                     specified by the {@link java.lang.Character Character} class.
                     &lt;p&gt;
                     The Java language provides special support for the string
                     concatenation operator (&amp;nbsp;+&amp;nbsp;), and for conversion of
                     other objects to strings. For additional information on string
                     concatenation and conversion, see &lt;i&gt;The Java&amp;trade; Language Specification&lt;/i&gt;.
                    
                     &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
                     or method in this class will cause a {@link NullPointerException} to be
                     thrown.
                    
                     &lt;p&gt;A {@code String} represents a string in the UTF-16 format
                     in which &lt;em&gt;supplementary characters&lt;/em&gt; are represented by &lt;em&gt;surrogate
                     pairs&lt;/em&gt; (see the section &lt;a href="Character.html#unicode"&gt;Unicode
                     Character Representations&lt;/a&gt; in the {@code Character} class for
                     more information).
                     Index values refer to {@code char} code units, so a supplementary
                     character uses two positions in a {@code String}.
                     &lt;p&gt;The {@code String} class provides methods for dealing with
                     Unicode code points (i.e., characters), in addition to those for
                     dealing with Unicode code units (i.e., {@code char} values).
                    
                     &lt;p&gt;Unless otherwise noted, methods for comparing Strings do not take locale
                     into account.  The {@link java.text.Collator} class provides methods for
                     finer-grain, locale-sensitive String comparison.
                    
                     @implNote The implementation of the string concatenation operator is left to
                     the discretion of a Java compiler, as long as the compiler ultimately conforms
                     to &lt;i&gt;The Java&amp;trade; Language Specification&lt;/i&gt;. For example, the {@code javac} compiler
                     may implement the operator with {@code StringBuffer}, {@code StringBuilder},
                     or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The
                     implementation of string conversion is typically through the method {@code toString},
                     defined by {@code Object} and inherited by all classes in Java.
                    
                     @author  Lee Boynton
                     @author  Arthur van Hoff
                     @author  Martin Buchholz
                     @author  Ulf Zibis
                     @see     java.lang.Object#toString()
                     @see     java.lang.StringBuffer
                     @see     java.lang.StringBuilder
                     @see     java.nio.charset.Charset
                     @since   1.0
                     @jls     15.18.1 String Concatenation Operator +
                    </javadoc>
            </acts>
            <acts name="Math" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The class {@code Math} contains methods for performing basic
                     numeric operations such as the elementary exponential, logarithm,
                     square root, and trigonometric functions.
                    
                     &lt;p&gt;Unlike some of the numeric methods of class
                     {@code StrictMath}, all implementations of the equivalent
                     functions of class {@code Math} are not defined to return the
                     bit-for-bit same results.  This relaxation permits
                     better-performing implementations where strict reproducibility is
                     not required.
                    
                     &lt;p&gt;By default many of the {@code Math} methods simply call
                     the equivalent method in {@code StrictMath} for their
                     implementation.  Code generators are encouraged to use
                     platform-specific native libraries or microprocessor instructions,
                     where available, to provide higher-performance implementations of
                     {@code Math} methods.  Such higher-performance
                     implementations still must conform to the specification for
                     {@code Math}.
                    
                     &lt;p&gt;The quality of implementation specifications concern two
                     properties, accuracy of the returned result and monotonicity of the
                     method.  Accuracy of the floating-point {@code Math} methods is
                     measured in terms of &lt;i&gt;ulps&lt;/i&gt;, units in the last place.  For a
                     given floating-point format, an {@linkplain #ulp(double) ulp} of a
                     specific real number value is the distance between the two
                     floating-point values bracketing that numerical value.  When
                     discussing the accuracy of a method as a whole rather than at a
                     specific argument, the number of ulps cited is for the worst-case
                     error at any argument.  If a method always has an error less than
                     0.5 ulps, the method always returns the floating-point number
                     nearest the exact result; such a method is &lt;i&gt;correctly
                     rounded&lt;/i&gt;.  A correctly rounded method is generally the best a
                     floating-point approximation can be; however, it is impractical for
                     many floating-point methods to be correctly rounded.  Instead, for
                     the {@code Math} class, a larger error bound of 1 or 2 ulps is
                     allowed for certain methods.  Informally, with a 1 ulp error bound,
                     when the exact result is a representable number, the exact result
                     should be returned as the computed result; otherwise, either of the
                     two floating-point values which bracket the exact result may be
                     returned.  For exact results large in magnitude, one of the
                     endpoints of the bracket may be infinite.  Besides accuracy at
                     individual arguments, maintaining proper relations between the
                     method at different arguments is also important.  Therefore, most
                     methods with more than 0.5 ulp errors are required to be
                     &lt;i&gt;semi-monotonic&lt;/i&gt;: whenever the mathematical function is
                     non-decreasing, so is the floating-point approximation, likewise,
                     whenever the mathematical function is non-increasing, so is the
                     floating-point approximation.  Not all approximations that have 1
                     ulp accuracy will automatically meet the monotonicity requirements.
                    
                     &lt;p&gt;
                     The platform uses signed two's complement integer arithmetic with
                     int and long primitive types.  The developer should choose
                     the primitive type to ensure that arithmetic operations consistently
                     produce correct results, which in some cases means the operations
                     will not overflow the range of values of the computation.
                     The best practice is to choose the primitive type and algorithm to avoid
                     overflow. In cases where the size is {@code int} or {@code long} and
                     overflow errors need to be detected, the methods {@code addExact},
                     {@code subtractExact}, {@code multiplyExact}, and {@code toIntExact}
                     throw an {@code ArithmeticException} when the results overflow.
                     For other arithmetic operations such as divide, absolute value,
                     increment by one, decrement by one, and negation, overflow occurs only with
                     a specific minimum or maximum value and should be checked against
                     the minimum or maximum as appropriate.
                    
                     @author  unascribed
                     @author  Joseph D. Darcy
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Runtime" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Every Java application has a single instance of class
                     {@code Runtime} that allows the application to interface with
                     the environment in which the application is running. The current
                     runtime can be obtained from the {@code getRuntime} method.
                     &lt;p&gt;
                     An application cannot create its own instance of this class.
                    
                     @author  unascribed
                     @see     java.lang.Runtime#getRuntime()
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ArithmeticException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when an exceptional arithmetic condition has occurred. For
                     example, an integer "divide by zero" throws an
                     instance of this class.
                    
                     {@code ArithmeticException} objects may be constructed by the
                     virtual machine as if {@linkplain Throwable#Throwable(String,
                     Throwable, boolean, boolean) suppression were disabled and/or the
                     stack trace was not writable}.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ReflectiveOperationException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Common superclass of exceptions thrown by reflective operations in
                     core reflection.
                    
                     @see LinkageError
                     @since 1.7
                    </javadoc>
            </acts>
            <acts name="ThreadLocal" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class provides thread-local variables.  These variables differ from
                     their normal counterparts in that each thread that accesses one (via its
                     {@code get} or {@code set} method) has its own, independently initialized
                     copy of the variable.  {@code ThreadLocal} instances are typically private
                     static fields in classes that wish to associate state with a thread (e.g.,
                     a user ID or Transaction ID).
                    
                     &lt;p&gt;For example, the class below generates unique identifiers local to each
                     thread.
                     A thread's id is assigned the first time it invokes {@code ThreadId.get()}
                     and remains unchanged on subsequent calls.
                     &lt;pre&gt;
                     import java.util.concurrent.atomic.AtomicInteger;
                    
                     public class ThreadId {
                         // Atomic integer containing the next thread ID to be assigned
                         private static final AtomicInteger nextId = new AtomicInteger(0);
                    
                         // Thread local variable containing each thread's ID
                         private static final ThreadLocal&amp;lt;Integer&amp;gt; threadId =
                             new ThreadLocal&amp;lt;Integer&amp;gt;() {
                                 &amp;#64;Override protected Integer initialValue() {
                                     return nextId.getAndIncrement();
                             }
                         };
                    
                         // Returns the current thread's unique ID, assigning it if necessary
                         public static int get() {
                             return threadId.get();
                         }
                     }
                     &lt;/pre&gt;
                     &lt;p&gt;Each thread holds an implicit reference to its copy of a thread-local
                     variable as long as the thread is alive and the {@code ThreadLocal}
                     instance is accessible; after a thread goes away, all of its copies of
                     thread-local instances are subject to garbage collection (unless other
                     references to these copies exist).
                    
                     @author  Josh Bloch and Doug Lea
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="StackWalker" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A stack walker.
                    
                     &lt;p&gt; The {@link StackWalker#walk walk} method opens a sequential stream
                     of {@link StackFrame StackFrame}s for the current thread and then applies
                     the given function to walk the {@code StackFrame} stream.
                     The stream reports stack frame elements in order, from the top most frame
                     that represents the execution point at which the stack was generated to
                     the bottom most frame.
                     The {@code StackFrame} stream is closed when the {@code walk} method returns.
                     If an attempt is made to reuse the closed stream,
                     {@code IllegalStateException} will be thrown.
                    
                     &lt;p&gt; The {@linkplain Option &lt;em&gt;stack walking options&lt;/em&gt;} of a
                     {@code StackWalker} determines the information of
                     {@link StackFrame StackFrame} objects to be returned.
                     By default, stack frames of the reflection API and implementation
                     classes are {@linkplain Option#SHOW_HIDDEN_FRAMES hidden}
                     and {@code StackFrame}s have the class name and method name
                     available but not the {@link StackFrame#getDeclaringClass() Class reference}.
                    
                     &lt;p&gt; {@code StackWalker} is thread-safe. Multiple threads can share
                     a single {@code StackWalker} object to traverse its own stack.
                     A permission check is performed when a {@code StackWalker} is created,
                     according to the options it requests.
                     No further permission check is done at stack walking time.
                    
                     @apiNote
                     Examples
                    
                     &lt;p&gt;1. To find the first caller filtering a known list of implementation class:
                     &lt;pre&gt;{@code
                         StackWalker walker = StackWalker.getInstance(Option.RETAIN_CLASS_REFERENCE);
                         Optional&lt;Class&lt;?&gt;&gt; callerClass = walker.walk(s -&gt;
                             s.map(StackFrame::getDeclaringClass)
                              .filter(interestingClasses::contains)
                              .findFirst());
                     }&lt;/pre&gt;
                    
                     &lt;p&gt;2. To snapshot the top 10 stack frames of the current thread,
                     &lt;pre&gt;{@code
                         List&lt;StackFrame&gt; stack = StackWalker.getInstance().walk(s -&gt;
                             s.limit(10).collect(Collectors.toList()));
                     }&lt;/pre&gt;
                    
                     Unless otherwise noted, passing a {@code null} argument to a
                     constructor or method in this {@code StackWalker} class
                     will cause a {@link NullPointerException NullPointerException}
                     to be thrown.
                    
                     @since 9
                    </javadoc>
            </acts>
            <acts name="Logger" access="PUBLIC" declaringClass="System" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes/>
            </acts>
            <acts name="Boolean" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The Boolean class wraps a value of the primitive type
                     {@code boolean} in an object. An object of type
                     {@code Boolean} contains a single field whose type is
                     {@code boolean}.
                     &lt;p&gt;
                     In addition, this class provides many methods for
                     converting a {@code boolean} to a {@code String} and a
                     {@code String} to a {@code boolean}, as well as other
                     constants and methods useful when dealing with a
                     {@code boolean}.
                    
                     @author  Arthur van Hoff
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="EnumConstantNotPresentException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when an application tries to access an enum constant by name
                     and the enum type contains no constant with the specified name.
                     This exception can be thrown by the {@linkplain
                     java.lang.reflect.AnnotatedElement API used to read annotations
                     reflectively}.
                    
                     @author  Josh Bloch
                     @see     java.lang.reflect.AnnotatedElement
                     @since   1.5
                    </javadoc>
            </acts>
            <acts name="IllegalArgumentException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that a method has been passed an illegal or
                     inappropriate argument.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="StackOverflowError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.VirtualMachineError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when a stack overflow occurs because an application
                     recurses too deeply.
                    
                     @author unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="AbstractMethodError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.IncompatibleClassChangeError"/>
                    <superType superType="java.lang.LinkageError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when an application tries to call an abstract method.
                     Normally, this error is caught by the compiler; this error can
                     only occur at run time if the definition of some class has
                     incompatibly changed since the currently executing method was last
                     compiled.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="IncompatibleClassChangeError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.LinkageError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when an incompatible class change has occurred to some class
                     definition. The definition of some class, on which the currently
                     executing method depends, has since changed.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="State" access="PUBLIC" declaringClass="Thread" kind="TYPE" typeKind="ENUM" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="UnsatisfiedLinkError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.LinkageError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown if the Java Virtual Machine cannot find an appropriate
                     native-language definition of a method declared &lt;code&gt;native&lt;/code&gt;.
                    
                     @author unascribed
                     @see     java.lang.Runtime
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Weak" access="PUBLIC" declaringClass="WeakPairMap.Pair" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.WeakPairMap$Pair"/>
                    <superType superType="java.lang.WeakPairMap$WeakRefPeer"/>
                    <superType superType="java.lang.ref.WeakReference"/>
                    <superType superType="java.lang.ref.Reference"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="NegativeArraySizeException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown if an application tries to create an array with negative size.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="OutOfMemoryError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.VirtualMachineError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when the Java Virtual Machine cannot allocate an object
                     because it is out of memory, and no more memory could be made
                     available by the garbage collector.
                    
                     {@code OutOfMemoryError} objects may be constructed by the virtual
                     machine as if {@linkplain Throwable#Throwable(String, Throwable,
                     boolean, boolean) suppression were disabled and/or the stack trace was not
                     writable}.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Float" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Number"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Float} class wraps a value of primitive type
                     {@code float} in an object. An object of type
                     {@code Float} contains a single field whose type is
                     {@code float}.
                    
                     &lt;p&gt;In addition, this class provides several methods for converting a
                     {@code float} to a {@code String} and a
                     {@code String} to a {@code float}, as well as other
                     constants and methods useful when dealing with a
                     {@code float}.
                    
                     @author  Lee Boynton
                     @author  Arthur van Hoff
                     @author  Joseph D. Darcy
                     @since 1.0
                    </javadoc>
            </acts>
            <acts name="InstantiationError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.IncompatibleClassChangeError"/>
                    <superType superType="java.lang.LinkageError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when an application tries to use the Java &lt;code&gt;new&lt;/code&gt;
                     construct to instantiate an abstract class or an interface.
                     &lt;p&gt;
                     Normally, this error is caught by the compiler; this error can
                     only occur at run time if the definition of a class has
                     incompatibly changed.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="VerifyError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.LinkageError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when the "verifier" detects that a class file,
                     though well formed, contains some sort of internal inconsistency
                     or security problem.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="UnicodeBlock" access="PUBLIC" declaringClass="Character" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Character$Subset"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Byte" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Number"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                    
                     The {@code Byte} class wraps a value of primitive type {@code byte}
                     in an object.  An object of type {@code Byte} contains a single
                     field whose type is {@code byte}.
                    
                     &lt;p&gt;In addition, this class provides several methods for converting
                     a {@code byte} to a {@code String} and a {@code String} to a {@code
                     byte}, as well as other constants and methods useful when dealing
                     with a {@code byte}.
                    
                     @author  Nakul Saraiya
                     @author  Joseph D. Darcy
                     @see     java.lang.Number
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="Object" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes/>
                <javadoc xml:space="preserve">
                     Class {@code Object} is the root of the class hierarchy.
                     Every class has {@code Object} as a superclass. All objects,
                     including arrays, implement the methods of this class.
                    
                     @author  unascribed
                     @see     java.lang.Class
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Cloneable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes/>
                <javadoc xml:space="preserve">
                     A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to
                     indicate to the {@link java.lang.Object#clone()} method that it
                     is legal for that method to make a
                     field-for-field copy of instances of that class.
                     &lt;p&gt;
                     Invoking Object's clone method on an instance that does not implement the
                     &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception
                     &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown.
                     &lt;p&gt;
                     By convention, classes that implement this interface should override
                     {@code Object.clone} (which is protected) with a public method.
                     See {@link java.lang.Object#clone()} for details on overriding this
                     method.
                     &lt;p&gt;
                     Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the {@code clone} method.
                     Therefore, it is not possible to clone an object merely by virtue of the
                     fact that it implements this interface.  Even if the clone method is invoked
                     reflectively, there is no guarantee that it will succeed.
                    
                     @author  unascribed
                     @see     java.lang.CloneNotSupportedException
                     @see     java.lang.Object#clone()
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Readable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes/>
                <javadoc xml:space="preserve">
                     A {@code Readable} is a source of characters. Characters from
                     a {@code Readable} are made available to callers of the read
                     method via a {@link java.nio.CharBuffer CharBuffer}.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="InternalError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.VirtualMachineError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate some unexpected internal error has occurred in
                     the Java Virtual Machine.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ModuleLayer" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A layer of modules in the Java virtual machine.
                    
                     &lt;p&gt; A layer is created from a graph of modules in a {@link Configuration}
                     and a function that maps each module to a {@link ClassLoader}.
                     Creating a layer informs the Java virtual machine about the classes that
                     may be loaded from the modules so that the Java virtual machine knows which
                     module that each class is a member of. &lt;/p&gt;
                    
                     &lt;p&gt; Creating a layer creates a {@link Module} object for each {@link
                     ResolvedModule} in the configuration. For each resolved module that is
                     {@link ResolvedModule#reads() read}, the {@code Module} {@link
                     Module#canRead reads} the corresponding run-time {@code Module}, which may
                     be in the same layer or a {@link #parents() parent} layer. &lt;/p&gt;
                    
                     &lt;p&gt; The {@link #defineModulesWithOneLoader defineModulesWithOneLoader} and
                     {@link #defineModulesWithManyLoaders defineModulesWithManyLoaders} methods
                     provide convenient ways to create a module layer where all modules are
                     mapped to a single class loader or where each module is mapped to its own
                     class loader. The {@link #defineModules defineModules} method is for more
                     advanced cases where modules are mapped to custom class loaders by means of
                     a function specified to the method. Each of these methods has an instance
                     and static variant. The instance methods create a layer with the receiver
                     as the parent layer. The static methods are for more advanced cases where
                     there can be more than one parent layer or where a {@link
                     ModuleLayer.Controller Controller} is needed to control modules in the layer
                     &lt;/p&gt;
                    
                     &lt;p&gt; A Java virtual machine has at least one non-empty layer, the {@link
                     #boot() boot} layer, that is created when the Java virtual machine is
                     started. The boot layer contains module {@code java.base} and is the only
                     layer in the Java virtual machine with a module named "{@code java.base}".
                     The modules in the boot layer are mapped to the bootstrap class loader and
                     other class loaders that are &lt;a href="ClassLoader.html#builtinLoaders"&gt;
                     built-in&lt;/a&gt; into the Java virtual machine. The boot layer will often be
                     the {@link #parents() parent} when creating additional layers. &lt;/p&gt;
                    
                     &lt;p&gt; Each {@code Module} in a layer is created so that it {@link
                     Module#isExported(String) exports} and {@link Module#isOpen(String) opens}
                     the packages described by its {@link ModuleDescriptor}. Qualified exports
                     (where a package is exported to a set of target modules rather than all
                     modules) are reified when creating the layer as follows: &lt;/p&gt;
                     &lt;ul&gt;
                         &lt;li&gt; If module {@code X} exports a package to {@code Y}, and if the
                         runtime {@code Module} {@code X} reads {@code Module} {@code Y}, then
                         the package is exported to {@code Module} {@code Y} (which may be in
                         the same layer as {@code X} or a parent layer). &lt;/li&gt;
                    
                         &lt;li&gt; If module {@code X} exports a package to {@code Y}, and if the
                         runtime {@code Module} {@code X} does not read {@code Y} then target
                         {@code Y} is located as if by invoking {@link #findModule(String)
                         findModule} to find the module in the layer or its parent layers. If
                         {@code Y} is found then the package is exported to the instance of
                         {@code Y} that was found. If {@code Y} is not found then the qualified
                         export is ignored. &lt;/li&gt;
                     &lt;/ul&gt;
                    
                     &lt;p&gt; Qualified opens are handled in same way as qualified exports. &lt;/p&gt;
                    
                     &lt;p&gt; As when creating a {@code Configuration},
                     {@link ModuleDescriptor#isAutomatic() automatic} modules receive special
                     treatment when creating a layer. An automatic module is created in the
                     Java virtual machine as a {@code Module} that reads every unnamed {@code
                     Module} in the Java virtual machine. &lt;/p&gt;
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to a method
                     in this class causes a {@link NullPointerException NullPointerException} to
                     be thrown. &lt;/p&gt;
                    
                     &lt;h3&gt; Example usage: &lt;/h3&gt;
                    
                     &lt;p&gt; This example creates a configuration by resolving a module named
                     "{@code myapp}" with the configuration for the boot layer as the parent. It
                     then creates a new layer with the modules in this configuration. All modules
                     are defined to the same class loader. &lt;/p&gt;
                    
                     &lt;pre&gt;{@code
                         ModuleFinder finder = ModuleFinder.of(dir1, dir2, dir3);
                    
                         ModuleLayer parent = ModuleLayer.boot();
                    
                         Configuration cf = parent.configuration().resolve(finder, ModuleFinder.of(), Set.of("myapp"));
                    
                         ClassLoader scl = ClassLoader.getSystemClassLoader();
                    
                         ModuleLayer layer = parent.defineModulesWithOneLoader(cf, scl);
                    
                         Class&lt;?&gt; c = layer.findLoader("myapp").loadClass("app.Main");
                     }&lt;/pre&gt;
                    
                     @since 9
                     @spec JPMS
                     @see Module#getLayer()
                    </javadoc>
            </acts>
            <acts name="Package" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.reflect.AnnotatedElement"/>
                    <superType superType="java.lang.NamedPackage"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Represents metadata about a run-time package associated with a class loader.
                     Metadata includes annotations, versioning, and sealing.
                     &lt;p&gt;
                     Annotations for the run-time package are read from {@code package-info.class}
                     at the same code source as classes in the run-time package.
                     &lt;p&gt;
                     The set of classes that make up the run-time package may implement a
                     particular specification. The specification title, version, and vendor
                     (indicating the owner/maintainer of the specification) can be provided
                     when the {@code Package} is defined. An application can ask if the
                     {@code Package} is compatible with a particular specification version
                     by using the {@link #isCompatibleWith Package.isCompatibleWith(String)}
                     method. In addition, information about the actual classes that make up the
                     run-time package can be provided when the Package is defined.
                     This information consists of an implementation title, version, and vendor
                     (indicating the supplier of the classes).
                     &lt;p&gt;
                     A {@code Package} may be explicitly defined with
                     the {@link ClassLoader#definePackage(String, String, String, String,
                     String, String, String, URL)} method.
                     The caller supplies the specification and implementation titles, versions, and
                     vendors. The caller also indicates whether the package is
                     {@linkplain java.util.jar.Attributes.Name#SEALED sealed}.
                     If a {@code Package} is not explicitly defined for a run-time package when
                     a class in that run-time package is defined, then a {@code Package} is
                     automatically defined by the class's defining class loader, as follows.
                     &lt;p&gt;
                     A {@code Package} automatically defined for classes in a named module has
                     the following properties:
                     &lt;ul&gt;
                     &lt;li&gt;The name of the package is derived from the {@linkplain Class#getName() binary names}
                         of the classes. Since classes in a named module must be in a named package,
                         the derived name is never empty.&lt;/li&gt;
                     &lt;li&gt;The package is sealed with the {@linkplain java.lang.module.ModuleReference#location()
                         module location} as the code source, if known.&lt;/li&gt;
                     &lt;li&gt;The specification and implementation titles, versions, and vendors
                         are unspecified.&lt;/li&gt;
                     &lt;li&gt;Any annotations on the package are read from {@code package-info.class}
                         as specified above.&lt;/li&gt;
                     &lt;/ul&gt;
                     &lt;p&gt;
                     A {@code Package} automatically defined for classes in an unnamed module
                     has the following properties:
                     &lt;ul&gt;
                     &lt;li&gt;The name of the package is either {@code ""} (for classes in an unnamed package)
                         or derived from the {@linkplain Class#getName() binary names} of the classes
                         (for classes in a named package).&lt;/li&gt;
                     &lt;li&gt;The package is not sealed.&lt;/li&gt;
                     &lt;li&gt;The specification and implementation titles, versions, and vendors
                         are unspecified.&lt;/li&gt;
                     &lt;li&gt;Any annotations on the package are read from {@code package-info.class}
                         as specified above.&lt;/li&gt;
                     &lt;/ul&gt;
                    
                     &lt;p&gt;
                     A {@code Package} can be obtained with the {@link Package#getPackage
                     Package.getPackage(String)} and {@link ClassLoader#getDefinedPackage
                     ClassLoader.getDefinedPackage(String)} methods.
                     Every {@code Package} defined by a class loader can be obtained
                     with the {@link Package#getPackages Package.getPackages()} and
                     {@link ClassLoader#getDefinedPackages} methods.
                    
                     @implNote
                     The &lt;a href="ClassLoader.html#builtinLoaders"&gt;builtin class loaders&lt;/a&gt;
                     do not explicitly define {@code Package} objects for packages in
                     &lt;em&gt;named modules&lt;/em&gt;.  Instead those packages are automatically defined
                     and have no specification and implementation versioning information.
                    
                     @jvms 5.3 Run-time package
                     @see &lt;a href="{@docRoot}/../specs/jar/jar.html#package-sealing"&gt;
                     The JAR File Specification: Package Sealing&lt;/a&gt;
                     @see ClassLoader#definePackage(String, String, String, String, String, String, String, URL)
                    
                     @since 1.2
                     @revised 9
                     @spec JPMS
                    </javadoc>
            </acts>
            <acts name="Module" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.reflect.AnnotatedElement"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Represents a run-time module, either {@link #isNamed() named} or unnamed.
                    
                     &lt;p&gt; Named modules have a {@link #getName() name} and are constructed by the
                     Java Virtual Machine when a graph of modules is defined to the Java virtual
                     machine to create a {@linkplain ModuleLayer module layer}. &lt;/p&gt;
                    
                     &lt;p&gt; An unnamed module does not have a name. There is an unnamed module for
                     each {@link ClassLoader ClassLoader}, obtained by invoking its {@link
                     ClassLoader#getUnnamedModule() getUnnamedModule} method. All types that are
                     not in a named module are members of their defining class loader's unnamed
                     module. &lt;/p&gt;
                    
                     &lt;p&gt; The package names that are parameters or returned by methods defined in
                     this class are the fully-qualified names of the packages as defined in
                     section 6.5.3 of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, for
                     example, {@code "java.lang"}. &lt;/p&gt;
                    
                     &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to a method
                     in this class causes a {@link NullPointerException NullPointerException} to
                     be thrown. &lt;/p&gt;
                    
                     @since 9
                     @spec JPMS
                     @see Class#getModule()
                    </javadoc>
            </acts>
            <acts name="Hypot" access="PUBLIC" declaringClass="FdLibm" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="UnknownError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.VirtualMachineError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when an unknown but serious exception has occurred in the
                     Java Virtual Machine.
                    
                     @author unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="StackTraceElement" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An element in a stack trace, as returned by {@link
                     Throwable#getStackTrace()}.  Each element represents a single stack frame.
                     All stack frames except for the one at the top of the stack represent
                     a method invocation.  The frame at the top of the stack represents the
                     execution point at which the stack trace was generated.  Typically,
                     this is the point at which the throwable corresponding to the stack trace
                     was created.
                    
                     @since  1.4
                     @author Josh Bloch
                    </javadoc>
            </acts>
            <acts name="NoSuchFieldException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.ReflectiveOperationException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that the class doesn't have a field of a specified name.
                    
                     @author  unascribed
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="InterruptedException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when a thread is waiting, sleeping, or otherwise occupied,
                     and the thread is interrupted, either before or during the activity.
                     Occasionally a method may wish to test whether the current
                     thread has been interrupted, and if so, to immediately throw
                     this exception.  The following code can be used to achieve
                     this effect:
                     &lt;pre&gt;
                      if (Thread.interrupted())  // Clears interrupted status!
                          throw new InterruptedException();
                     &lt;/pre&gt;
                    
                     @author  Frank Yellin
                     @see     java.lang.Object#wait()
                     @see     java.lang.Object#wait(long)
                     @see     java.lang.Object#wait(long, int)
                     @see     java.lang.Thread#sleep(long)
                     @see     java.lang.Thread#interrupt()
                     @see     java.lang.Thread#interrupted()
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Deprecated" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.annotation.Annotation"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A program element annotated {@code @Deprecated} is one that programmers
                     are discouraged from using. An element may be deprecated for any of several
                     reasons, for example, its usage is likely to lead to errors; it may
                     be changed incompatibly or removed in a future version; it has been
                     superseded by a newer, usually preferable alternative; or it is obsolete.
                    
                     &lt;p&gt;Compilers issue warnings when a deprecated program element is used or
                     overridden in non-deprecated code. Use of the {@code @Deprecated}
                     annotation on a local variable declaration or on a parameter declaration
                     or a package declaration has no effect on the warnings issued by a compiler.
                    
                     &lt;p&gt;When a module is deprecated, the use of that module in {@code
                     requires}, but not in {@code exports} or {@code opens} clauses causes
                     a warning to be issued. A module being deprecated does &lt;em&gt;not&lt;/em&gt; cause
                     warnings to be issued for uses of types within the module.
                    
                     &lt;p&gt;This annotation type has a string-valued element {@code since}. The value
                     of this element indicates the version in which the annotated program element
                     was first deprecated.
                    
                     &lt;p&gt;This annotation type has a boolean-valued element {@code forRemoval}.
                     A value of {@code true} indicates intent to remove the annotated program
                     element in a future version. A value of {@code false} indicates that use of
                     the annotated program element is discouraged, but at the time the program
                     element was annotated, there was no specific intent to remove it.
                    
                     @apiNote
                     It is strongly recommended that the reason for deprecating a program element
                     be explained in the documentation, using the {@code @deprecated}
                     javadoc tag. The documentation should also suggest and link to a
                     recommended replacement API, if applicable. A replacement API often
                     has subtly different semantics, so such issues should be discussed as
                     well.
                    
                     &lt;p&gt;It is recommended that a {@code since} value be provided with all newly
                     annotated program elements. Note that {@code since} cannot be mandatory,
                     as there are many existing annotations that lack this element value.
                    
                     &lt;p&gt;There is no defined order among annotation elements. As a matter of
                     style, the {@code since} element should be placed first.
                    
                     &lt;p&gt;The {@code @Deprecated} annotation should always be present if
                     the {@code @deprecated} javadoc tag is present, and vice-versa.
                    
                     @author  Neal Gafter
                     @since 1.5
                     @jls 9.6.4.6 @Deprecated
                    </javadoc>
            </acts>
            <acts name="StringIndexOutOfBoundsException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.IndexOutOfBoundsException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown by {@code String} methods to indicate that an index is either negative
                     or greater than the size of the string.  For some methods such as the
                     {@link String#charAt charAt} method, this exception also is thrown when the
                     index is equal to the size of the string.
                    
                     @see java.lang.String#charAt(int)
                     @since 1.0
                    </javadoc>
            </acts>
            <acts name="ThreadGroup" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Thread$UncaughtExceptionHandler"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve"> The locking strategy for this code is to try to lock only one level of the
                     tree wherever possible, but otherwise to lock from the bottom up.
                     That is, from child thread groups to parents.
                     This has the advantage of limiting the number of locks that need to be held
                     and in particular avoids having to grab the lock for the root thread group,
                     (or a global lock) which would be a source of contention on a
                     multi-processor system with many thread groups.
                     This policy often leads to taking a snapshot of the state of a thread group
                     and working off of that snapshot, rather than holding the thread group locked
                     while we work on the children.
                    </javadoc>
            </acts>
            <acts name="CloneNotSupportedException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that the &lt;code&gt;clone&lt;/code&gt; method in class
                     &lt;code&gt;Object&lt;/code&gt; has been called to clone an object, but that
                     the object's class does not implement the &lt;code&gt;Cloneable&lt;/code&gt;
                     interface.
                     &lt;p&gt;
                     Applications that override the &lt;code&gt;clone&lt;/code&gt; method can also
                     throw this exception to indicate that an object could not or
                     should not be cloned.
                    
                     @author  unascribed
                     @see     java.lang.Cloneable
                     @see     java.lang.Object#clone()
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="LinkageError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Subclasses of {@code LinkageError} indicate that a class has
                     some dependency on another class; however, the latter class has
                     incompatibly changed after the compilation of the former class.
                    
                    
                     @author  Frank Yellin
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Info" access="PUBLIC" declaringClass="ProcessHandle" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes/>
            </acts>
            <acts name="ClassCircularityError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.LinkageError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when the Java Virtual Machine detects a circularity in the
                     superclass hierarchy of a class being loaded.
                    
                     @author     unascribed
                     @since      1.0
                    </javadoc>
            </acts>
            <acts name="TypeNotPresentException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when an application tries to access a type using a string
                     representing the type's name, but no definition for the type with
                     the specified name can be found.   This exception differs from
                     {@link ClassNotFoundException} in that {@code ClassNotFoundException} is a
                     checked exception, whereas this exception is unchecked.
                    
                     &lt;p&gt;Note that this exception may be used when undefined type variables
                     are accessed as well as when types (e.g., classes, interfaces or
                     annotation types) are loaded.
                     In particular, this exception can be thrown by the {@linkplain
                     java.lang.reflect.AnnotatedElement API used to read annotations
                     reflectively}.
                    
                     @author  Josh Bloch
                     @see     java.lang.reflect.AnnotatedElement
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="ExceptionInInitializerError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.LinkageError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that an unexpected exception has occurred in a static initializer.
                     An &lt;code&gt;ExceptionInInitializerError&lt;/code&gt; is thrown to indicate that an
                     exception occurred during evaluation of a static initializer or the
                     initializer for a static variable.
                    
                     &lt;p&gt;As of release 1.4, this exception has been retrofitted to conform to
                     the general purpose exception-chaining mechanism.  The "saved throwable
                     object" that may be provided at construction time and accessed via
                     the {@link #getException()} method is now known as the &lt;i&gt;cause&lt;/i&gt;,
                     and may be accessed via the {@link Throwable#getCause()} method, as well
                     as the aforementioned "legacy method."
                    
                     @author  Frank Yellin
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="FunctionalInterface" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.annotation.Annotation"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An informative annotation type used to indicate that an interface
                     type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as
                     defined by the Java Language Specification.
                    
                     Conceptually, a functional interface has exactly one abstract
                     method.  Since {@linkplain java.lang.reflect.Method#isDefault()
                     default methods} have an implementation, they are not abstract.  If
                     an interface declares an abstract method overriding one of the
                     public methods of {@code java.lang.Object}, that also does
                     &lt;em&gt;not&lt;/em&gt; count toward the interface's abstract method count
                     since any implementation of the interface will have an
                     implementation from {@code java.lang.Object} or elsewhere.
                    
                     &lt;p&gt;Note that instances of functional interfaces can be created with
                     lambda expressions, method references, or constructor references.
                    
                     &lt;p&gt;If a type is annotated with this annotation type, compilers are
                     required to generate an error message unless:
                    
                     &lt;ul&gt;
                     &lt;li&gt; The type is an interface type and not an annotation type, enum, or class.
                     &lt;li&gt; The annotated type satisfies the requirements of a functional interface.
                     &lt;/ul&gt;
                    
                     &lt;p&gt;However, the compiler will treat any interface meeting the
                     definition of a functional interface as a functional interface
                     regardless of whether or not a {@code FunctionalInterface}
                     annotation is present on the interface declaration.
                    
                     @jls 4.3.2. The Class Object
                     @jls 9.8 Functional Interfaces
                     @jls 9.4.3 Interface Method Body
                     @jls 9.6.4.9 @FunctionalInterface
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="IllegalAccessError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.IncompatibleClassChangeError"/>
                    <superType superType="java.lang.LinkageError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown if an application attempts to access or modify a field, or
                     to call a method that it does not have access to.
                     &lt;p&gt;
                     Normally, this error is caught by the compiler; this error can
                     only occur at run time if the definition of a class has
                     incompatibly changed.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="StackFrame" access="PUBLIC" declaringClass="StackWalker" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes/>
            </acts>
            <acts name="StrictMath" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The class {@code StrictMath} contains methods for performing basic
                     numeric operations such as the elementary exponential, logarithm,
                     square root, and trigonometric functions.
                    
                     &lt;p&gt;To help ensure portability of Java programs, the definitions of
                     some of the numeric functions in this package require that they
                     produce the same results as certain published algorithms. These
                     algorithms are available from the well-known network library
                     {@code netlib} as the package "Freely Distributable Math
                     Library," &lt;a
                     href="ftp://ftp.netlib.org/fdlibm.tar"&gt;{@code fdlibm}&lt;/a&gt;. These
                     algorithms, which are written in the C programming language, are
                     then to be understood as executed with all floating-point
                     operations following the rules of Java floating-point arithmetic.
                    
                     &lt;p&gt;The Java math library is defined with respect to
                     {@code fdlibm} version 5.3. Where {@code fdlibm} provides
                     more than one definition for a function (such as
                     {@code acos}), use the "IEEE 754 core function" version
                     (residing in a file whose name begins with the letter
                     {@code e}).  The methods which require {@code fdlibm}
                     semantics are {@code sin}, {@code cos}, {@code tan},
                     {@code asin}, {@code acos}, {@code atan},
                     {@code exp}, {@code log}, {@code log10},
                     {@code cbrt}, {@code atan2}, {@code pow},
                     {@code sinh}, {@code cosh}, {@code tanh},
                     {@code hypot}, {@code expm1}, and {@code log1p}.
                    
                     &lt;p&gt;
                     The platform uses signed two's complement integer arithmetic with
                     int and long primitive types.  The developer should choose
                     the primitive type to ensure that arithmetic operations consistently
                     produce correct results, which in some cases means the operations
                     will not overflow the range of values of the computation.
                     The best practice is to choose the primitive type and algorithm to avoid
                     overflow. In cases where the size is {@code int} or {@code long} and
                     overflow errors need to be detected, the methods {@code addExact},
                     {@code subtractExact}, {@code multiplyExact}, and {@code toIntExact}
                     throw an {@code ArithmeticException} when the results overflow.
                     For other arithmetic operations such as divide, absolute value,
                     increment by one, decrement by one, and negation overflow occurs only with
                     a specific minimum or maximum value and should be checked against
                     the minimum or maximum as appropriate.
                    
                     @author  unascribed
                     @author  Joseph D. Darcy
                     @since   1.3
                    </javadoc>
            </acts>
            <acts name="IllegalAccessException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.ReflectiveOperationException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An IllegalAccessException is thrown when an application tries
                     to reflectively create an instance (other than an array),
                     set or get a field, or invoke a method, but the currently
                     executing method does not have access to the definition of
                     the specified class, field, method or constructor.
                    
                     @author  unascribed
                     @see     Class#newInstance()
                     @see     java.lang.reflect.Field#set(Object, Object)
                     @see     java.lang.reflect.Field#setBoolean(Object, boolean)
                     @see     java.lang.reflect.Field#setByte(Object, byte)
                     @see     java.lang.reflect.Field#setShort(Object, short)
                     @see     java.lang.reflect.Field#setChar(Object, char)
                     @see     java.lang.reflect.Field#setInt(Object, int)
                     @see     java.lang.reflect.Field#setLong(Object, long)
                     @see     java.lang.reflect.Field#setFloat(Object, float)
                     @see     java.lang.reflect.Field#setDouble(Object, double)
                     @see     java.lang.reflect.Field#get(Object)
                     @see     java.lang.reflect.Field#getBoolean(Object)
                     @see     java.lang.reflect.Field#getByte(Object)
                     @see     java.lang.reflect.Field#getShort(Object)
                     @see     java.lang.reflect.Field#getChar(Object)
                     @see     java.lang.reflect.Field#getInt(Object)
                     @see     java.lang.reflect.Field#getLong(Object)
                     @see     java.lang.reflect.Field#getFloat(Object)
                     @see     java.lang.reflect.Field#getDouble(Object)
                     @see     java.lang.reflect.Method#invoke(Object, Object[])
                     @see     java.lang.reflect.Constructor#newInstance(Object[])
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Thread" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Runnable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A &lt;i&gt;thread&lt;/i&gt; is a thread of execution in a program. The Java
                     Virtual Machine allows an application to have multiple threads of
                     execution running concurrently.
                     &lt;p&gt;
                     Every thread has a priority. Threads with higher priority are
                     executed in preference to threads with lower priority. Each thread
                     may or may not also be marked as a daemon. When code running in
                     some thread creates a new {@code Thread} object, the new
                     thread has its priority initially set equal to the priority of the
                     creating thread, and is a daemon thread if and only if the
                     creating thread is a daemon.
                     &lt;p&gt;
                     When a Java Virtual Machine starts up, there is usually a single
                     non-daemon thread (which typically calls the method named
                     {@code main} of some designated class). The Java Virtual
                     Machine continues to execute threads until either of the following
                     occurs:
                     &lt;ul&gt;
                     &lt;li&gt;The {@code exit} method of class {@code Runtime} has been
                         called and the security manager has permitted the exit operation
                         to take place.
                     &lt;li&gt;All threads that are not daemon threads have died, either by
                         returning from the call to the {@code run} method or by
                         throwing an exception that propagates beyond the {@code run}
                         method.
                     &lt;/ul&gt;
                     &lt;p&gt;
                     There are two ways to create a new thread of execution. One is to
                     declare a class to be a subclass of {@code Thread}. This
                     subclass should override the {@code run} method of class
                     {@code Thread}. An instance of the subclass can then be
                     allocated and started. For example, a thread that computes primes
                     larger than a stated value could be written as follows:
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                         class PrimeThread extends Thread {
                             long minPrime;
                             PrimeThread(long minPrime) {
                                 this.minPrime = minPrime;
                             }
                    
                             public void run() {
                                 // compute primes larger than minPrime
                                 &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
                             }
                         }
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                     &lt;p&gt;
                     The following code would then create a thread and start it running:
                     &lt;blockquote&gt;&lt;pre&gt;
                         PrimeThread p = new PrimeThread(143);
                         p.start();
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     &lt;p&gt;
                     The other way to create a thread is to declare a class that
                     implements the {@code Runnable} interface. That class then
                     implements the {@code run} method. An instance of the class can
                     then be allocated, passed as an argument when creating
                     {@code Thread}, and started. The same example in this other
                     style looks like the following:
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                         class PrimeRun implements Runnable {
                             long minPrime;
                             PrimeRun(long minPrime) {
                                 this.minPrime = minPrime;
                             }
                    
                             public void run() {
                                 // compute primes larger than minPrime
                                 &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
                             }
                         }
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                     &lt;p&gt;
                     The following code would then create a thread and start it running:
                     &lt;blockquote&gt;&lt;pre&gt;
                         PrimeRun p = new PrimeRun(143);
                         new Thread(p).start();
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     &lt;p&gt;
                     Every thread has a name for identification purposes. More than
                     one thread may have the same name. If a name is not specified when
                     a thread is created, a new name is generated for it.
                     &lt;p&gt;
                     Unless otherwise noted, passing a {@code null} argument to a constructor
                     or method in this class will cause a {@link NullPointerException} to be
                     thrown.
                    
                     @author  unascribed
                     @see     Runnable
                     @see     Runtime#exit(int)
                     @see     #run()
                     @see     #stop()
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="SafeVarargs" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.annotation.Annotation"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A programmer assertion that the body of the annotated method or
                     constructor does not perform potentially unsafe operations on its
                     varargs parameter.  Applying this annotation to a method or
                     constructor suppresses unchecked warnings about a
                     &lt;i&gt;non-reifiable&lt;/i&gt; variable arity (vararg) type and suppresses
                     unchecked warnings about parameterized array creation at call
                     sites.
                    
                     &lt;p&gt; In addition to the usage restrictions imposed by its {@link
                     Target @Target} meta-annotation, compilers are required to implement
                     additional usage restrictions on this annotation type; it is a
                     compile-time error if a method or constructor declaration is
                     annotated with a {@code @SafeVarargs} annotation, and either:
                     &lt;ul&gt;
                     &lt;li&gt;  the declaration is a fixed arity method or constructor
                    
                     &lt;li&gt; the declaration is a variable arity method that is neither
                     {@code static} nor {@code final} nor {@code private}.
                    
                     &lt;/ul&gt;
                    
                     &lt;p&gt; Compilers are encouraged to issue warnings when this annotation
                     type is applied to a method or constructor declaration where:
                    
                     &lt;ul&gt;
                    
                     &lt;li&gt; The variable arity parameter has a reifiable element type,
                     which includes primitive types, {@code Object}, and {@code String}.
                     (The unchecked warnings this annotation type suppresses already do
                     not occur for a reifiable element type.)
                    
                     &lt;li&gt; The body of the method or constructor declaration performs
                     potentially unsafe operations, such as an assignment to an element
                     of the variable arity parameter's array that generates an unchecked
                     warning.  Some unsafe operations do not trigger an unchecked
                     warning.  For example, the aliasing in
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                     &amp;#64;SafeVarargs // Not actually safe!
                     static void m(List&amp;lt;String&amp;gt;... stringLists) {
                       Object[] array = stringLists;
                       List&amp;lt;Integer&amp;gt; tmpList = Arrays.asList(42);
                       array[0] = tmpList; // Semantically invalid, but compiles without warnings
                       String s = stringLists[0].get(0); // Oh no, ClassCastException at runtime!
                     }
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     leads to a {@code ClassCastException} at runtime.
                    
                     &lt;p&gt;Future versions of the platform may mandate compiler errors for
                     such unsafe operations.
                    
                     &lt;/ul&gt;
                    
                     @since 1.7
                     @jls 4.7 Reifiable Types
                     @jls 8.4.1 Formal Parameters
                     @jls 9.6.4.7 @SafeVarargs
                    </javadoc>
            </acts>
            <acts name="StringBuffer" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.CharSequence"/>
                    <superType superType="java.lang.AbstractStringBuilder"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A thread-safe, mutable sequence of characters.
                     A string buffer is like a {@link String}, but can be modified. At any
                     point in time it contains some particular sequence of characters, but
                     the length and content of the sequence can be changed through certain
                     method calls.
                     &lt;p&gt;
                     String buffers are safe for use by multiple threads. The methods
                     are synchronized where necessary so that all the operations on any
                     particular instance behave as if they occur in some serial order
                     that is consistent with the order of the method calls made by each of
                     the individual threads involved.
                     &lt;p&gt;
                     The principal operations on a {@code StringBuffer} are the
                     {@code append} and {@code insert} methods, which are
                     overloaded so as to accept data of any type. Each effectively
                     converts a given datum to a string and then appends or inserts the
                     characters of that string to the string buffer. The
                     {@code append} method always adds these characters at the end
                     of the buffer; the {@code insert} method adds the characters at
                     a specified point.
                     &lt;p&gt;
                     For example, if {@code z} refers to a string buffer object
                     whose current contents are {@code "start"}, then
                     the method call {@code z.append("le")} would cause the string
                     buffer to contain {@code "startle"}, whereas
                     {@code z.insert(4, "le")} would alter the string buffer to
                     contain {@code "starlet"}.
                     &lt;p&gt;
                     In general, if sb refers to an instance of a {@code StringBuffer},
                     then {@code sb.append(x)} has the same effect as
                     {@code sb.insert(sb.length(), x)}.
                     &lt;p&gt;
                     Whenever an operation occurs involving a source sequence (such as
                     appending or inserting from a source sequence), this class synchronizes
                     only on the string buffer performing the operation, not on the source.
                     Note that while {@code StringBuffer} is designed to be safe to use
                     concurrently from multiple threads, if the constructor or the
                     {@code append} or {@code insert} operation is passed a source sequence
                     that is shared across threads, the calling code must ensure
                     that the operation has a consistent and unchanging view of the source
                     sequence for the duration of the operation.
                     This could be satisfied by the caller holding a lock during the
                     operation's call, by using an immutable source sequence, or by not
                     sharing the source sequence across threads.
                     &lt;p&gt;
                     Every string buffer has a capacity. As long as the length of the
                     character sequence contained in the string buffer does not exceed
                     the capacity, it is not necessary to allocate a new internal
                     buffer array. If the internal buffer overflows, it is
                     automatically made larger.
                     &lt;p&gt;
                     Unless otherwise noted, passing a {@code null} argument to a constructor
                     or method in this class will cause a {@link NullPointerException} to be
                     thrown.
                     &lt;p&gt;
                     As of  release JDK 5, this class has been supplemented with an equivalent
                     class designed for use by a single thread, {@link StringBuilder}.  The
                     {@code StringBuilder} class should generally be used in preference to
                     this one, as it supports all of the same operations but it is faster, as
                     it performs no synchronization.
                    
                     @apiNote
                     {@code StringBuffer} implements {@code Comparable} but does not override
                     {@link Object#equals equals}. Thus, the natural ordering of {@code StringBuffer}
                     is inconsistent with equals. Care should be exercised if {@code StringBuffer}
                     objects are used as keys in a {@code SortedMap} or elements in a {@code SortedSet}.
                     See {@link Comparable}, {@link java.util.SortedMap SortedMap}, or
                     {@link java.util.SortedSet SortedSet} for more information.
                    
                     @author      Arthur van Hoff
                     @see     java.lang.StringBuilder
                     @see     java.lang.String
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="NoClassDefFoundError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.LinkageError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown if the Java Virtual Machine or a &lt;code&gt;ClassLoader&lt;/code&gt; instance
                     tries to load in the definition of a class (as part of a normal method call
                     or as part of creating a new instance using the &lt;code&gt;new&lt;/code&gt; expression)
                     and no definition of the class could be found.
                     &lt;p&gt;
                     The searched-for class definition existed when the currently
                     executing class was compiled, but the definition can no longer be
                     found.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Type" access="PUBLIC" declaringClass="ProcessBuilder.Redirect" kind="TYPE" typeKind="ENUM" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Runnable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes/>
                <javadoc xml:space="preserve">
                     The &lt;code&gt;Runnable&lt;/code&gt; interface should be implemented by any
                     class whose instances are intended to be executed by a thread. The
                     class must define a method of no arguments called &lt;code&gt;run&lt;/code&gt;.
                     &lt;p&gt;
                     This interface is designed to provide a common protocol for objects that
                     wish to execute code while they are active. For example,
                     &lt;code&gt;Runnable&lt;/code&gt; is implemented by class &lt;code&gt;Thread&lt;/code&gt;.
                     Being active simply means that a thread has been started and has not
                     yet been stopped.
                     &lt;p&gt;
                     In addition, &lt;code&gt;Runnable&lt;/code&gt; provides the means for a class to be
                     active while not subclassing &lt;code&gt;Thread&lt;/code&gt;. A class that implements
                     &lt;code&gt;Runnable&lt;/code&gt; can run without subclassing &lt;code&gt;Thread&lt;/code&gt;
                     by instantiating a &lt;code&gt;Thread&lt;/code&gt; instance and passing itself in
                     as the target.  In most cases, the &lt;code&gt;Runnable&lt;/code&gt; interface should
                     be used if you are only planning to override the &lt;code&gt;run()&lt;/code&gt;
                     method and no other &lt;code&gt;Thread&lt;/code&gt; methods.
                     This is important because classes should not be subclassed
                     unless the programmer intends on modifying or enhancing the fundamental
                     behavior of the class.
                    
                     @author  Arthur van Hoff
                     @see     java.lang.Thread
                     @see     java.util.concurrent.Callable
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Cbrt" access="PUBLIC" declaringClass="FdLibm" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Pow" access="PUBLIC" declaringClass="FdLibm" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="IllegalMonitorStateException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that a thread has attempted to wait on an
                     object's monitor or to notify other threads waiting on an object's
                     monitor without owning the specified monitor.
                    
                     @author  unascribed
                     @see     java.lang.Object#notify()
                     @see     java.lang.Object#notifyAll()
                     @see     java.lang.Object#wait()
                     @see     java.lang.Object#wait(long)
                     @see     java.lang.Object#wait(long, int)
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="InstantiationException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.ReflectiveOperationException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when an application tries to create an instance of a class
                     using the {@code newInstance} method in class
                     {@code Class}, but the specified class object cannot be
                     instantiated.  The instantiation can fail for a variety of
                     reasons including but not limited to:
                    
                     &lt;ul&gt;
                     &lt;li&gt; the class object represents an abstract class, an interface,
                          an array class, a primitive type, or {@code void}
                     &lt;li&gt; the class has no nullary constructor
                    &lt;/ul&gt;
                    
                     @author  unascribed
                     @see     java.lang.Class#newInstance()
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ClassFormatError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.LinkageError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when the Java Virtual Machine attempts to read a class
                     file and determines that the file is malformed or otherwise cannot
                     be interpreted as a class file.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Comparable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes/>
                <javadoc xml:space="preserve">
                     This interface imposes a total ordering on the objects of each class that
                     implements it.  This ordering is referred to as the class's &lt;i&gt;natural
                     ordering&lt;/i&gt;, and the class's {@code compareTo} method is referred to as
                     its &lt;i&gt;natural comparison method&lt;/i&gt;.&lt;p&gt;
                    
                     Lists (and arrays) of objects that implement this interface can be sorted
                     automatically by {@link Collections#sort(List) Collections.sort} (and
                     {@link Arrays#sort(Object[]) Arrays.sort}).  Objects that implement this
                     interface can be used as keys in a {@linkplain SortedMap sorted map} or as
                     elements in a {@linkplain SortedSet sorted set}, without the need to
                     specify a {@linkplain Comparator comparator}.&lt;p&gt;
                    
                     The natural ordering for a class {@code C} is said to be &lt;i&gt;consistent
                     with equals&lt;/i&gt; if and only if {@code e1.compareTo(e2) == 0} has
                     the same boolean value as {@code e1.equals(e2)} for every
                     {@code e1} and {@code e2} of class {@code C}.  Note that {@code null}
                     is not an instance of any class, and {@code e.compareTo(null)} should
                     throw a {@code NullPointerException} even though {@code e.equals(null)}
                     returns {@code false}.&lt;p&gt;
                    
                     It is strongly recommended (though not required) that natural orderings be
                     consistent with equals.  This is so because sorted sets (and sorted maps)
                     without explicit comparators behave "strangely" when they are used with
                     elements (or keys) whose natural ordering is inconsistent with equals.  In
                     particular, such a sorted set (or sorted map) violates the general contract
                     for set (or map), which is defined in terms of the {@code equals}
                     method.&lt;p&gt;
                    
                     For example, if one adds two keys {@code a} and {@code b} such that
                     {@code (!a.equals(b) &amp;&amp; a.compareTo(b) == 0)} to a sorted
                     set that does not use an explicit comparator, the second {@code add}
                     operation returns false (and the size of the sorted set does not increase)
                     because {@code a} and {@code b} are equivalent from the sorted set's
                     perspective.&lt;p&gt;
                    
                     Virtually all Java core classes that implement {@code Comparable} have natural
                     orderings that are consistent with equals.  One exception is
                     {@code java.math.BigDecimal}, whose natural ordering equates
                     {@code BigDecimal} objects with equal values and different precisions
                     (such as 4.0 and 4.00).&lt;p&gt;
                    
                     For the mathematically inclined, the &lt;i&gt;relation&lt;/i&gt; that defines
                     the natural ordering on a given class C is:&lt;pre&gt;{@code
                           {(x, y) such that x.compareTo(y) &lt;= 0}.
                     }&lt;/pre&gt; The &lt;i&gt;quotient&lt;/i&gt; for this total order is: &lt;pre&gt;{@code
                           {(x, y) such that x.compareTo(y) == 0}.
                     }&lt;/pre&gt;
                    
                     It follows immediately from the contract for {@code compareTo} that the
                     quotient is an &lt;i&gt;equivalence relation&lt;/i&gt; on {@code C}, and that the
                     natural ordering is a &lt;i&gt;total order&lt;/i&gt; on {@code C}.  When we say that a
                     class's natural ordering is &lt;i&gt;consistent with equals&lt;/i&gt;, we mean that the
                     quotient for the natural ordering is the equivalence relation defined by
                     the class's {@link Object#equals(Object) equals(Object)} method:&lt;pre&gt;
                         {(x, y) such that x.equals(y)}. &lt;/pre&gt;&lt;p&gt;
                    
                     This interface is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @param &lt;T&gt; the type of objects that this object may be compared to
                    
                     @author  Josh Bloch
                     @see java.util.Comparator
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="Process" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     {@code Process} provides control of native processes started by
                     ProcessBuilder.start and Runtime.exec.
                     The class provides methods for performing input from the process, performing
                     output to the process, waiting for the process to complete,
                     checking the exit status of the process, and destroying (killing)
                     the process.
                     The {@link ProcessBuilder#start()} and
                     {@link Runtime#exec(String[],String[],File) Runtime.exec}
                     methods create a native process and return an instance of a
                     subclass of {@code Process} that can be used to control the process
                     and obtain information about it.
                    
                     &lt;p&gt;The methods that create processes may not work well for special
                     processes on certain native platforms, such as native windowing
                     processes, daemon processes, Win16/DOS processes on Microsoft
                     Windows, or shell scripts.
                    
                     &lt;p&gt;By default, the created process does not have its own terminal
                     or console.  All its standard I/O (i.e. stdin, stdout, stderr)
                     operations will be redirected to the parent process, where they can
                     be accessed via the streams obtained using the methods
                     {@link #getOutputStream()},
                     {@link #getInputStream()}, and
                     {@link #getErrorStream()}.
                     The parent process uses these streams to feed input to and get output
                     from the process.  Because some native platforms only provide
                     limited buffer size for standard input and output streams, failure
                     to promptly write the input stream or read the output stream of
                     the process may cause the process to block, or even deadlock.
                    
                     &lt;p&gt;Where desired, &lt;a href="ProcessBuilder.html#redirect-input"&gt;
                     process I/O can also be redirected&lt;/a&gt;
                     using methods of the {@link ProcessBuilder} class.
                    
                     &lt;p&gt;The process is not killed when there are no more references to
                     the {@code Process} object, but rather the process
                     continues executing asynchronously.
                    
                     &lt;p&gt;There is no requirement that the process represented by a {@code
                     Process} object execute asynchronously or concurrently with respect
                     to the Java process that owns the {@code Process} object.
                    
                     &lt;p&gt;As of 1.5, {@link ProcessBuilder#start()} is the preferred way
                     to create a {@code Process}.
                    
                     &lt;p&gt;Subclasses of Process should override the {@link #onExit()} and
                     {@link #toHandle()} methods to provide a fully functional Process including the
                     {@linkplain #pid() process id},
                     {@linkplain #info() information about the process},
                     {@linkplain #children() direct children}, and
                     {@linkplain #descendants() direct children plus descendants of those children} of the process.
                     Delegating to the underlying Process or ProcessHandle is typically
                     easiest and most efficient.
                    
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="UncaughtExceptionHandler" access="PUBLIC" declaringClass="Thread" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes/>
            </acts>
            <acts name="PrimitiveSlot" access="PUBLIC" declaringClass="LiveStackFrame" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Level" access="PUBLIC" declaringClass="System.Logger" kind="TYPE" typeKind="ENUM" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="ThreadDeath" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An instance of {@code ThreadDeath} is thrown in the victim thread
                     when the (deprecated) {@link Thread#stop()} method is invoked.
                    
                     &lt;p&gt;An application should catch instances of this class only if it
                     must clean up after being terminated asynchronously.  If
                     {@code ThreadDeath} is caught by a method, it is important that it
                     be rethrown so that the thread actually dies.
                    
                     &lt;p&gt;The {@linkplain ThreadGroup#uncaughtException top-level error
                     handler} does not print out a message if {@code ThreadDeath} is
                     never caught.
                    
                     &lt;p&gt;The class {@code ThreadDeath} is specifically a subclass of
                     {@code Error} rather than {@code Exception}, even though it is a
                     "normal occurrence", because many applications catch all
                     occurrences of {@code Exception} and then discard the exception.
                    
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="AssertionError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that an assertion has failed.
                    
                     &lt;p&gt;The seven one-argument public constructors provided by this
                     class ensure that the assertion error returned by the invocation:
                     &lt;pre&gt;
                         new AssertionError(&lt;i&gt;expression&lt;/i&gt;)
                     &lt;/pre&gt;
                     has as its detail message the &lt;i&gt;string conversion&lt;/i&gt; of
                     &lt;i&gt;expression&lt;/i&gt; (as defined in section 15.18.1.1 of
                     &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;),
                     regardless of the type of &lt;i&gt;expression&lt;/i&gt;.
                    
                     @since   1.4
                    </javadoc>
            </acts>
            <acts name="Version" access="PUBLIC" declaringClass="Runtime" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Subset" access="PUBLIC" declaringClass="Character" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Void" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Void} class is an uninstantiable placeholder class to hold a
                     reference to the {@code Class} object representing the Java keyword
                     void.
                    
                     @author  unascribed
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="ClassNotFoundException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.ReflectiveOperationException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when an application tries to load in a class through its
                     string name using:
                     &lt;ul&gt;
                     &lt;li&gt;The &lt;code&gt;forName&lt;/code&gt; method in class &lt;code&gt;Class&lt;/code&gt;.
                     &lt;li&gt;The &lt;code&gt;findSystemClass&lt;/code&gt; method in class
                         &lt;code&gt;ClassLoader&lt;/code&gt; .
                     &lt;li&gt;The &lt;code&gt;loadClass&lt;/code&gt; method in class &lt;code&gt;ClassLoader&lt;/code&gt;.
                     &lt;/ul&gt;
                     &lt;p&gt;
                     but no definition for the class with the specified name could be found.
                    
                     &lt;p&gt;As of release 1.4, this exception has been retrofitted to conform to
                     the general purpose exception-chaining mechanism.  The "optional exception
                     that was raised while loading the class" that may be provided at
                     construction time and accessed via the {@link #getException()} method is
                     now known as the &lt;i&gt;cause&lt;/i&gt;, and may be accessed via the {@link
                     Throwable#getCause()} method, as well as the aforementioned "legacy method."
                    
                     @author  unascribed
                     @see     java.lang.Class#forName(java.lang.String)
                     @see     java.lang.ClassLoader#findSystemClass(java.lang.String)
                     @see     java.lang.ClassLoader#loadClass(java.lang.String, boolean)
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Override" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.annotation.Annotation"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Indicates that a method declaration is intended to override a
                     method declaration in a supertype. If a method is annotated with
                     this annotation type compilers are required to generate an error
                     message unless at least one of the following conditions hold:
                    
                     &lt;ul&gt;&lt;li&gt;
                     The method does override or implement a method declared in a
                     supertype.
                     &lt;/li&gt;&lt;li&gt;
                     The method has a signature that is override-equivalent to that of
                     any public method declared in {@linkplain Object}.
                     &lt;/li&gt;&lt;/ul&gt;
                    
                     @author  Peter von der Ah&amp;eacute;
                     @author  Joshua Bloch
                     @jls 8.4.8 Inheritance, Overriding, and Hiding
                     @jls 9.4.1 Inheritance and Overriding
                     @jls 9.6.4.4 @Override
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="Short" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Number"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Short} class wraps a value of primitive type {@code
                     short} in an object.  An object of type {@code Short} contains a
                     single field whose type is {@code short}.
                    
                     &lt;p&gt;In addition, this class provides several methods for converting
                     a {@code short} to a {@code String} and a {@code String} to a
                     {@code short}, as well as other constants and methods useful when
                     dealing with a {@code short}.
                    
                     @author  Nakul Saraiya
                     @author  Joseph D. Darcy
                     @see     java.lang.Number
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="UnsupportedOperationException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that the requested operation is not supported.&lt;p&gt;
                    
                     This class is a member of the
                     &lt;a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"&gt;
                     Java Collections Framework&lt;/a&gt;.
                    
                     @author  Josh Bloch
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="Compiler" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Compiler} class is provided to support Java-to-native-code
                     compilers and related services. By design, the {@code Compiler} class does
                     nothing; it serves as a placeholder for a JIT compiler implementation.
                     If no compiler is available, these methods do nothing.
                    
                     @deprecated JIT compilers and their technologies vary too widely to
                     be controlled effectively by a standardized interface. As such, many
                     JIT compiler implementations ignore this interface, and are instead
                     controllable by implementation-specific mechanisms such as command-line
                     options. This class is subject to removal in a future version of Java SE.
                    
                     @author  Frank Yellin
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Character" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Character} class wraps a value of the primitive
                     type {@code char} in an object. An object of class
                     {@code Character} contains a single field whose type is
                     {@code char}.
                     &lt;p&gt;
                     In addition, this class provides a large number of static methods for
                     determining a character's category (lowercase letter, digit, etc.)
                     and for converting characters from uppercase to lowercase and vice
                     versa.
                    
                     &lt;h3&gt;&lt;a id="conformance"&gt;Unicode Conformance&lt;/a&gt;&lt;/h3&gt;
                     &lt;p&gt;
                     The fields and methods of class {@code Character} are defined in terms
                     of character information from the Unicode Standard, specifically the
                     &lt;i&gt;UnicodeData&lt;/i&gt; file that is part of the Unicode Character Database.
                     This file specifies properties including name and category for every
                     assigned Unicode code point or character range. The file is available
                     from the Unicode Consortium at
                     &lt;a href="http://www.unicode.org"&gt;http://www.unicode.org&lt;/a&gt;.
                     &lt;p&gt;
                     The Java SE 11 Platform uses character information from version 10.0
                     of the Unicode Standard, with an extension. The Java SE 11 Platform allows
                     an implementation of class {@code Character} to use the Japanese Era
                     code point, {@code U+32FF}, from the first version of the Unicode Standard
                     after 10.0 that assigns the code point. Consequently, the behavior of
                     fields and methods of class {@code Character} may vary across
                     implementations of the Java SE 11 Platform when processing the
                     aforementioned code point ( outside of version 10.0 ), except for
                     the following methods that define Java identifiers:
                     {@link #isJavaIdentifierStart(int)}, {@link #isJavaIdentifierStart(char)},
                     {@link #isJavaIdentifierPart(int)}, and {@link #isJavaIdentifierPart(char)}.
                     Code points in Java identifiers must be drawn from version 10.0 of
                     the Unicode Standard.
                    
                     &lt;h3&gt;&lt;a id="unicode"&gt;Unicode Character Representations&lt;/a&gt;&lt;/h3&gt;
                    
                     &lt;p&gt;The {@code char} data type (and therefore the value that a
                     {@code Character} object encapsulates) are based on the
                     original Unicode specification, which defined characters as
                     fixed-width 16-bit entities. The Unicode Standard has since been
                     changed to allow for characters whose representation requires more
                     than 16 bits.  The range of legal &lt;em&gt;code point&lt;/em&gt;s is now
                     U+0000 to U+10FFFF, known as &lt;em&gt;Unicode scalar value&lt;/em&gt;.
                     (Refer to the &lt;a
                     href="http://www.unicode.org/reports/tr27/#notation"&gt;&lt;i&gt;
                     definition&lt;/i&gt;&lt;/a&gt; of the U+&lt;i&gt;n&lt;/i&gt; notation in the Unicode
                     Standard.)
                    
                     &lt;p&gt;&lt;a id="BMP"&gt;The set of characters from U+0000 to U+FFFF&lt;/a&gt; is
                     sometimes referred to as the &lt;em&gt;Basic Multilingual Plane (BMP)&lt;/em&gt;.
                     &lt;a id="supplementary"&gt;Characters&lt;/a&gt; whose code points are greater
                     than U+FFFF are called &lt;em&gt;supplementary character&lt;/em&gt;s.  The Java
                     platform uses the UTF-16 representation in {@code char} arrays and
                     in the {@code String} and {@code StringBuffer} classes. In
                     this representation, supplementary characters are represented as a pair
                     of {@code char} values, the first from the &lt;em&gt;high-surrogates&lt;/em&gt;
                     range, (&amp;#92;uD800-&amp;#92;uDBFF), the second from the
                     &lt;em&gt;low-surrogates&lt;/em&gt; range (&amp;#92;uDC00-&amp;#92;uDFFF).
                    
                     &lt;p&gt;A {@code char} value, therefore, represents Basic
                     Multilingual Plane (BMP) code points, including the surrogate
                     code points, or code units of the UTF-16 encoding. An
                     {@code int} value represents all Unicode code points,
                     including supplementary code points. The lower (least significant)
                     21 bits of {@code int} are used to represent Unicode code
                     points and the upper (most significant) 11 bits must be zero.
                     Unless otherwise specified, the behavior with respect to
                     supplementary characters and surrogate {@code char} values is
                     as follows:
                    
                     &lt;ul&gt;
                     &lt;li&gt;The methods that only accept a {@code char} value cannot support
                     supplementary characters. They treat {@code char} values from the
                     surrogate ranges as undefined characters. For example,
                     {@code Character.isLetter('\uD840')} returns {@code false}, even though
                     this specific value if followed by any low-surrogate value in a string
                     would represent a letter.
                    
                     &lt;li&gt;The methods that accept an {@code int} value support all
                     Unicode characters, including supplementary characters. For
                     example, {@code Character.isLetter(0x2F81A)} returns
                     {@code true} because the code point value represents a letter
                     (a CJK ideograph).
                     &lt;/ul&gt;
                    
                     &lt;p&gt;In the Java SE API documentation, &lt;em&gt;Unicode code point&lt;/em&gt; is
                     used for character values in the range between U+0000 and U+10FFFF,
                     and &lt;em&gt;Unicode code unit&lt;/em&gt; is used for 16-bit
                     {@code char} values that are code units of the &lt;em&gt;UTF-16&lt;/em&gt;
                     encoding. For more information on Unicode terminology, refer to the
                     &lt;a href="http://www.unicode.org/glossary/"&gt;Unicode Glossary&lt;/a&gt;.
                    
                     @author  Lee Boynton
                     @author  Guy Steele
                     @author  Akira Tanaka
                     @author  Martin Buchholz
                     @author  Ulf Zibis
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="IndexOutOfBoundsException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that an index of some sort (such as to an array, to a
                     string, or to a vector) is out of range.
                     &lt;p&gt;
                     Applications can subclass this class to indicate similar exceptions.
                    
                     @author Frank Yellin
                     @since 1.0
                    </javadoc>
            </acts>
            <acts name="Controller" access="PUBLIC" declaringClass="ModuleLayer" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="CharSequence" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes/>
                <javadoc xml:space="preserve">
                     A {@code CharSequence} is a readable sequence of {@code char} values. This
                     interface provides uniform, read-only access to many different kinds of
                     {@code char} sequences.
                     A {@code char} value represents a character in the &lt;i&gt;Basic
                     Multilingual Plane (BMP)&lt;/i&gt; or a surrogate. Refer to &lt;a
                     href="Character.html#unicode"&gt;Unicode Character Representation&lt;/a&gt; for details.
                    
                     &lt;p&gt; This interface does not refine the general contracts of the {@link
                     java.lang.Object#equals(java.lang.Object) equals} and {@link
                     java.lang.Object#hashCode() hashCode} methods. The result of testing two objects
                     that implement {@code CharSequence} for equality is therefore, in general, undefined.
                     Each object may be implemented by a different class, and there
                     is no guarantee that each class will be capable of testing its instances
                     for equality with those of the other.  It is therefore inappropriate to use
                     arbitrary {@code CharSequence} instances as elements in a set or as keys in
                     a map. &lt;/p&gt;
                    
                     @author Mike McCloskey
                     @since 1.4
                     @spec JSR-51
                    </javadoc>
            </acts>
            <acts name="NoSuchFieldError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.IncompatibleClassChangeError"/>
                    <superType superType="java.lang.LinkageError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown if an application tries to access or modify a specified
                     field of an object, and that object no longer has that field.
                     &lt;p&gt;
                     Normally, this error is caught by the compiler; this error can
                     only occur at run time if the definition of a class has
                     incompatibly changed.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="NumberFormatException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.IllegalArgumentException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that the application has attempted to convert
                     a string to one of the numeric types, but that the string does not
                     have the appropriate format.
                    
                     @author  unascribed
                     @see     java.lang.Integer#parseInt(String)
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Double" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Number"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Double} class wraps a value of the primitive type
                     {@code double} in an object. An object of type
                     {@code Double} contains a single field whose type is
                     {@code double}.
                    
                     &lt;p&gt;In addition, this class provides several methods for converting a
                     {@code double} to a {@code String} and a
                     {@code String} to a {@code double}, as well as other
                     constants and methods useful when dealing with a
                     {@code double}.
                    
                     @author  Lee Boynton
                     @author  Arthur van Hoff
                     @author  Joseph D. Darcy
                     @since 1.0
                    </javadoc>
            </acts>
            <acts name="NoSuchMethodError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.IncompatibleClassChangeError"/>
                    <superType superType="java.lang.LinkageError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown if an application tries to call a specified method of a
                     class (either static or instance), and that class no longer has a
                     definition of that method.
                     &lt;p&gt;
                     Normally, this error is caught by the compiler; this error can
                     only occur at run time if the definition of a class has
                     incompatibly changed.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ProcessBuilder" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class is used to create operating system processes.
                    
                     &lt;p&gt;Each {@code ProcessBuilder} instance manages a collection
                     of process attributes.  The {@link #start()} method creates a new
                     {@link Process} instance with those attributes.  The {@link
                     #start()} method can be invoked repeatedly from the same instance
                     to create new subprocesses with identical or related attributes.
                     &lt;p&gt;
                     The {@link #startPipeline startPipeline} method can be invoked to create
                     a pipeline of new processes that send the output of each process
                     directly to the next process.  Each process has the attributes of
                     its respective ProcessBuilder.
                    
                     &lt;p&gt;Each process builder manages these process attributes:
                    
                     &lt;ul&gt;
                    
                     &lt;li&gt;a &lt;i&gt;command&lt;/i&gt;, a list of strings which signifies the
                     external program file to be invoked and its arguments, if any.
                     Which string lists represent a valid operating system command is
                     system-dependent.  For example, it is common for each conceptual
                     argument to be an element in this list, but there are operating
                     systems where programs are expected to tokenize command line
                     strings themselves - on such a system a Java implementation might
                     require commands to contain exactly two elements.
                    
                     &lt;li&gt;an &lt;i&gt;environment&lt;/i&gt;, which is a system-dependent mapping from
                     &lt;i&gt;variables&lt;/i&gt; to &lt;i&gt;values&lt;/i&gt;.  The initial value is a copy of
                     the environment of the current process (see {@link System#getenv()}).
                    
                     &lt;li&gt;a &lt;i&gt;working directory&lt;/i&gt;.  The default value is the current
                     working directory of the current process, usually the directory
                     named by the system property {@code user.dir}.
                    
                     &lt;li&gt;&lt;a id="redirect-input"&gt;a source of &lt;i&gt;standard input&lt;/i&gt;&lt;/a&gt;.
                     By default, the subprocess reads input from a pipe.  Java code
                     can access this pipe via the output stream returned by
                     {@link Process#getOutputStream()}.  However, standard input may
                     be redirected to another source using
                     {@link #redirectInput(Redirect) redirectInput}.
                     In this case, {@link Process#getOutputStream()} will return a
                     &lt;i&gt;null output stream&lt;/i&gt;, for which:
                    
                     &lt;ul&gt;
                     &lt;li&gt;the {@link OutputStream#write(int) write} methods always
                     throw {@code IOException}
                     &lt;li&gt;the {@link OutputStream#close() close} method does nothing
                     &lt;/ul&gt;
                    
                     &lt;li&gt;&lt;a id="redirect-output"&gt;a destination for &lt;i&gt;standard output&lt;/i&gt;
                     and &lt;i&gt;standard error&lt;/i&gt;&lt;/a&gt;.  By default, the subprocess writes standard
                     output and standard error to pipes.  Java code can access these pipes
                     via the input streams returned by {@link Process#getOutputStream()} and
                     {@link Process#getErrorStream()}.  However, standard output and
                     standard error may be redirected to other destinations using
                     {@link #redirectOutput(Redirect) redirectOutput} and
                     {@link #redirectError(Redirect) redirectError}.
                     In this case, {@link Process#getInputStream()} and/or
                     {@link Process#getErrorStream()} will return a &lt;i&gt;null input
                     stream&lt;/i&gt;, for which:
                    
                     &lt;ul&gt;
                     &lt;li&gt;the {@link InputStream#read() read} methods always return
                     {@code -1}
                     &lt;li&gt;the {@link InputStream#available() available} method always returns
                     {@code 0}
                     &lt;li&gt;the {@link InputStream#close() close} method does nothing
                     &lt;/ul&gt;
                    
                     &lt;li&gt;a &lt;i&gt;redirectErrorStream&lt;/i&gt; property.  Initially, this property
                     is {@code false}, meaning that the standard output and error
                     output of a subprocess are sent to two separate streams, which can
                     be accessed using the {@link Process#getInputStream()} and {@link
                     Process#getErrorStream()} methods.
                    
                     &lt;p&gt;If the value is set to {@code true}, then:
                    
                     &lt;ul&gt;
                     &lt;li&gt;standard error is merged with the standard output and always sent
                     to the same destination (this makes it easier to correlate error
                     messages with the corresponding output)
                     &lt;li&gt;the common destination of standard error and standard output can be
                     redirected using
                     {@link #redirectOutput(Redirect) redirectOutput}
                     &lt;li&gt;any redirection set by the
                     {@link #redirectError(Redirect) redirectError}
                     method is ignored when creating a subprocess
                     &lt;li&gt;the stream returned from {@link Process#getErrorStream()} will
                     always be a &lt;a href="#redirect-output"&gt;null input stream&lt;/a&gt;
                     &lt;/ul&gt;
                    
                     &lt;/ul&gt;
                    
                     &lt;p&gt;Modifying a process builder's attributes will affect processes
                     subsequently started by that object's {@link #start()} method, but
                     will never affect previously started processes or the Java process
                     itself.
                    
                     &lt;p&gt;Most error checking is performed by the {@link #start()} method.
                     It is possible to modify the state of an object so that {@link
                     #start()} will fail.  For example, setting the command attribute to
                     an empty list will not throw an exception unless {@link #start()}
                     is invoked.
                    
                     &lt;p&gt;&lt;strong&gt;Note that this class is not synchronized.&lt;/strong&gt;
                     If multiple threads access a {@code ProcessBuilder} instance
                     concurrently, and at least one of the threads modifies one of the
                     attributes structurally, it &lt;i&gt;must&lt;/i&gt; be synchronized externally.
                    
                     &lt;p&gt;Starting a new process which uses the default working directory
                     and environment is easy:
                    
                     &lt;pre&gt; {@code
                     Process p = new ProcessBuilder("myCommand", "myArg").start();
                     }&lt;/pre&gt;
                    
                     &lt;p&gt;Here is an example that starts a process with a modified working
                     directory and environment, and redirects standard output and error
                     to be appended to a log file:
                    
                     &lt;pre&gt; {@code
                     ProcessBuilder pb =
                       new ProcessBuilder("myCommand", "myArg1", "myArg2");
                     Map&lt;String, String&gt; env = pb.environment();
                     env.put("VAR1", "myValue");
                     env.remove("OTHERVAR");
                     env.put("VAR2", env.get("VAR1") + "suffix");
                     pb.directory(new File("myDir"));
                     File log = new File("log");
                     pb.redirectErrorStream(true);
                     pb.redirectOutput(Redirect.appendTo(log));
                     Process p = pb.start();
                     assert pb.redirectInput() == Redirect.PIPE;
                     assert pb.redirectOutput().file() == log;
                     assert p.getInputStream().read() == -1;
                     }&lt;/pre&gt;
                    
                     &lt;p&gt;To start a process with an explicit set of environment
                     variables, first call {@link java.util.Map#clear() Map.clear()}
                     before adding environment variables.
                    
                     &lt;p&gt;
                     Unless otherwise noted, passing a {@code null} argument to a constructor
                     or method in this class will cause a {@link NullPointerException} to be
                     thrown.
                    
                     @author Martin Buchholz
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="Long" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Number"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Long} class wraps a value of the primitive type {@code
                     long} in an object. An object of type {@code Long} contains a
                     single field whose type is {@code long}.
                    
                     &lt;p&gt; In addition, this class provides several methods for converting
                     a {@code long} to a {@code String} and a {@code String} to a {@code
                     long}, as well as other constants and methods useful when dealing
                     with a {@code long}.
                    
                     &lt;p&gt;Implementation note: The implementations of the "bit twiddling"
                     methods (such as {@link #highestOneBit(long) highestOneBit} and
                     {@link #numberOfTrailingZeros(long) numberOfTrailingZeros}) are
                     based on material from Henry S. Warren, Jr.'s &lt;i&gt;Hacker's
                     Delight&lt;/i&gt;, (Addison Wesley, 2002).
                    
                     @author  Lee Boynton
                     @author  Arthur van Hoff
                     @author  Josh Bloch
                     @author  Joseph D. Darcy
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Throwable" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Throwable} class is the superclass of all errors and
                     exceptions in the Java language. Only objects that are instances of this
                     class (or one of its subclasses) are thrown by the Java Virtual Machine or
                     can be thrown by the Java {@code throw} statement. Similarly, only
                     this class or one of its subclasses can be the argument type in a
                     {@code catch} clause.
                    
                     For the purposes of compile-time checking of exceptions, {@code
                     Throwable} and any subclass of {@code Throwable} that is not also a
                     subclass of either {@link RuntimeException} or {@link Error} are
                     regarded as checked exceptions.
                    
                     &lt;p&gt;Instances of two subclasses, {@link java.lang.Error} and
                     {@link java.lang.Exception}, are conventionally used to indicate
                     that exceptional situations have occurred. Typically, these instances
                     are freshly created in the context of the exceptional situation so
                     as to include relevant information (such as stack trace data).
                    
                     &lt;p&gt;A throwable contains a snapshot of the execution stack of its
                     thread at the time it was created. It can also contain a message
                     string that gives more information about the error. Over time, a
                     throwable can {@linkplain Throwable#addSuppressed suppress} other
                     throwables from being propagated.  Finally, the throwable can also
                     contain a &lt;i&gt;cause&lt;/i&gt;: another throwable that caused this
                     throwable to be constructed.  The recording of this causal information
                     is referred to as the &lt;i&gt;chained exception&lt;/i&gt; facility, as the
                     cause can, itself, have a cause, and so on, leading to a "chain" of
                     exceptions, each caused by another.
                    
                     &lt;p&gt;One reason that a throwable may have a cause is that the class that
                     throws it is built atop a lower layered abstraction, and an operation on
                     the upper layer fails due to a failure in the lower layer.  It would be bad
                     design to let the throwable thrown by the lower layer propagate outward, as
                     it is generally unrelated to the abstraction provided by the upper layer.
                     Further, doing so would tie the API of the upper layer to the details of
                     its implementation, assuming the lower layer's exception was a checked
                     exception.  Throwing a "wrapped exception" (i.e., an exception containing a
                     cause) allows the upper layer to communicate the details of the failure to
                     its caller without incurring either of these shortcomings.  It preserves
                     the flexibility to change the implementation of the upper layer without
                     changing its API (in particular, the set of exceptions thrown by its
                     methods).
                    
                     &lt;p&gt;A second reason that a throwable may have a cause is that the method
                     that throws it must conform to a general-purpose interface that does not
                     permit the method to throw the cause directly.  For example, suppose
                     a persistent collection conforms to the {@link java.util.Collection
                     Collection} interface, and that its persistence is implemented atop
                     {@code java.io}.  Suppose the internals of the {@code add} method
                     can throw an {@link java.io.IOException IOException}.  The implementation
                     can communicate the details of the {@code IOException} to its caller
                     while conforming to the {@code Collection} interface by wrapping the
                     {@code IOException} in an appropriate unchecked exception.  (The
                     specification for the persistent collection should indicate that it is
                     capable of throwing such exceptions.)
                    
                     &lt;p&gt;A cause can be associated with a throwable in two ways: via a
                     constructor that takes the cause as an argument, or via the
                     {@link #initCause(Throwable)} method.  New throwable classes that
                     wish to allow causes to be associated with them should provide constructors
                     that take a cause and delegate (perhaps indirectly) to one of the
                     {@code Throwable} constructors that takes a cause.
                    
                     Because the {@code initCause} method is public, it allows a cause to be
                     associated with any throwable, even a "legacy throwable" whose
                     implementation predates the addition of the exception chaining mechanism to
                     {@code Throwable}.
                    
                     &lt;p&gt;By convention, class {@code Throwable} and its subclasses have two
                     constructors, one that takes no arguments and one that takes a
                     {@code String} argument that can be used to produce a detail message.
                     Further, those subclasses that might likely have a cause associated with
                     them should have two more constructors, one that takes a
                     {@code Throwable} (the cause), and one that takes a
                     {@code String} (the detail message) and a {@code Throwable} (the
                     cause).
                    
                     @author  unascribed
                     @author  Josh Bloch (Added exception chaining and programmatic access to
                              stack trace in 1.4.)
                     @jls 11.2 Compile-Time Checking of Exceptions
                     @since 1.0
                    </javadoc>
            </acts>
            <acts name="Class" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.reflect.GenericDeclaration"/>
                    <superType superType="java.lang.reflect.Type"/>
                    <superType superType="java.lang.reflect.AnnotatedElement"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Instances of the class {@code Class} represent classes and interfaces
                     in a running Java application. An enum type is a kind of class and an
                     annotation type is a kind of interface. Every array also
                     belongs to a class that is reflected as a {@code Class} object
                     that is shared by all arrays with the same element type and number
                     of dimensions.  The primitive Java types ({@code boolean},
                     {@code byte}, {@code char}, {@code short},
                     {@code int}, {@code long}, {@code float}, and
                     {@code double}), and the keyword {@code void} are also
                     represented as {@code Class} objects.
                    
                     &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
                     object is constructed automatically by the Java Virtual Machine
                     when a class loader invokes one of the
                     {@link ClassLoader#defineClass(String,byte[], int,int) defineClass} methods
                     and passes the bytes of a {@code class} file.
                    
                     &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
                     class or interface. Most characteristics are derived from the {@code class}
                     file that the class loader passed to the Java Virtual Machine. A few
                     characteristics are determined by the class loading environment at run time,
                     such as the module returned by {@link #getModule() getModule()}.
                    
                     &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
                     a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
                     another declaration. Other methods describe how a class or interface
                     is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id="nest"&gt;nest&lt;/a&gt; is a set of
                     classes and interfaces, in the same run-time package, that
                     allow mutual access to their {@code private} members.
                     The classes and interfaces are known as &lt;em&gt;nestmates&lt;/em&gt;.
                     One nestmate acts as the
                     &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
                     belong to the nest; each of them in turn records it as the nest host.
                     The classes and interfaces which belong to a nest, including its host, are
                     determined when
                     {@code class} files are generated, for example, a Java compiler
                     will typically record a top-level class as the host of a nest where the
                     other members are the classes and interfaces whose declarations are
                     enclosed within the top-level class declaration.
                    
                     &lt;p&gt; The following example uses a {@code Class} object to print the
                     class name of an object:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                         void printClassName(Object obj) {
                             System.out.println("The class of " + obj +
                                                " is " + obj.getClass().getName());
                         }
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt; It is also possible to get the {@code Class} object for a named
                     type (or for void) using a class literal.  See Section 15.8.2 of
                     &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
                     For example:
                    
                     &lt;blockquote&gt;
                         {@code System.out.println("The name of class Foo is: "+Foo.class.getName());}
                     &lt;/blockquote&gt;
                    
                     @param &lt;T&gt; the type of the class modeled by this {@code Class}
                     object.  For example, the type of {@code String.class} is {@code
                     Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
                     unknown.
                    
                     @author  unascribed
                     @see     java.lang.ClassLoader#defineClass(byte[], int, int)
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ArrayStoreException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that an attempt has been made to store the
                     wrong type of object into an array of objects. For example, the
                     following code generates an &lt;code&gt;ArrayStoreException&lt;/code&gt;:
                     &lt;blockquote&gt;&lt;pre&gt;
                         Object x[] = new String[3];
                         x[0] = new Integer(0);
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="IllegalStateException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that a method has been invoked at an illegal or
                     inappropriate time.  In other words, the Java environment or
                     Java application is not in an appropriate state for the requested
                     operation.
                    
                     @author  Jonni Kanerva
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="Iterable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes/>
                <javadoc xml:space="preserve">
                     Implementing this interface allows an object to be the target of the enhanced
                     {@code for} statement (sometimes called the "for-each loop" statement).
                    
                     @param &lt;T&gt; the type of elements returned by the iterator
                    
                     @since 1.5
                     @jls 14.14.2 The enhanced {@code for} statement
                    </javadoc>
            </acts>
            <acts name="SecurityManager" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The security manager is a class that allows
                     applications to implement a security policy. It allows an
                     application to determine, before performing a possibly unsafe or
                     sensitive operation, what the operation is and whether
                     it is being attempted in a security context that allows the
                     operation to be performed. The
                     application can allow or disallow the operation.
                     &lt;p&gt;
                     The &lt;code&gt;SecurityManager&lt;/code&gt; class contains many methods with
                     names that begin with the word &lt;code&gt;check&lt;/code&gt;. These methods
                     are called by various methods in the Java libraries before those
                     methods perform certain potentially sensitive operations. The
                     invocation of such a &lt;code&gt;check&lt;/code&gt; method typically looks like this:
                     &lt;blockquote&gt;&lt;pre&gt;
                         SecurityManager security = System.getSecurityManager();
                         if (security != null) {
                             security.check&lt;i&gt;XXX&lt;/i&gt;(argument, &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.&amp;nbsp;);
                         }
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     &lt;p&gt;
                     The security manager is thereby given an opportunity to prevent
                     completion of the operation by throwing an exception. A security
                     manager routine simply returns if the operation is permitted, but
                     throws a &lt;code&gt;SecurityException&lt;/code&gt; if the operation is not
                     permitted.
                     &lt;p&gt;
                     The current security manager is set by the
                     &lt;code&gt;setSecurityManager&lt;/code&gt; method in class
                     &lt;code&gt;System&lt;/code&gt;. The current security manager is obtained
                     by the &lt;code&gt;getSecurityManager&lt;/code&gt; method.
                     &lt;p&gt;
                     The special method
                     {@link SecurityManager#checkPermission(java.security.Permission)}
                     determines whether an access request indicated by a specified
                     permission should be granted or denied. The
                     default implementation calls
                    
                     &lt;pre&gt;
                       AccessController.checkPermission(perm);
                     &lt;/pre&gt;
                    
                     &lt;p&gt;
                     If a requested access is allowed,
                     &lt;code&gt;checkPermission&lt;/code&gt; returns quietly. If denied, a
                     &lt;code&gt;SecurityException&lt;/code&gt; is thrown.
                     &lt;p&gt;
                     The default implementation of each of the other
                     &lt;code&gt;check&lt;/code&gt; methods in &lt;code&gt;SecurityManager&lt;/code&gt; is to
                     call the &lt;code&gt;SecurityManager checkPermission&lt;/code&gt; method
                     to determine if the calling thread has permission to perform the requested
                     operation.
                     &lt;p&gt;
                     Note that the &lt;code&gt;checkPermission&lt;/code&gt; method with
                     just a single permission argument always performs security checks
                     within the context of the currently executing thread.
                     Sometimes a security check that should be made within a given context
                     will actually need to be done from within a
                     &lt;i&gt;different&lt;/i&gt; context (for example, from within a worker thread).
                     The {@link SecurityManager#getSecurityContext getSecurityContext} method
                     and the {@link SecurityManager#checkPermission(java.security.Permission,
                     java.lang.Object) checkPermission}
                     method that includes a context argument are provided
                     for this situation. The
                     &lt;code&gt;getSecurityContext&lt;/code&gt; method returns a "snapshot"
                     of the current calling context. (The default implementation
                     returns an AccessControlContext object.) A sample call is
                     the following:
                    
                     &lt;pre&gt;
                       Object context = null;
                       SecurityManager sm = System.getSecurityManager();
                       if (sm != null) context = sm.getSecurityContext();
                     &lt;/pre&gt;
                    
                     &lt;p&gt;
                     The &lt;code&gt;checkPermission&lt;/code&gt; method
                     that takes a context object in addition to a permission
                     makes access decisions based on that context,
                     rather than on that of the current execution thread.
                     Code within a different context can thus call that method,
                     passing the permission and the
                     previously-saved context object. A sample call, using the
                     SecurityManager &lt;code&gt;sm&lt;/code&gt; obtained as in the previous example,
                     is the following:
                    
                     &lt;pre&gt;
                       if (sm != null) sm.checkPermission(permission, context);
                     &lt;/pre&gt;
                    
                     &lt;p&gt;Permissions fall into these categories: File, Socket, Net,
                     Security, Runtime, Property, AWT, Reflect, and Serializable.
                     The classes managing these various
                     permission categories are &lt;code&gt;java.io.FilePermission&lt;/code&gt;,
                     &lt;code&gt;java.net.SocketPermission&lt;/code&gt;,
                     &lt;code&gt;java.net.NetPermission&lt;/code&gt;,
                     &lt;code&gt;java.security.SecurityPermission&lt;/code&gt;,
                     &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;,
                     &lt;code&gt;java.util.PropertyPermission&lt;/code&gt;,
                     &lt;code&gt;java.awt.AWTPermission&lt;/code&gt;,
                     &lt;code&gt;java.lang.reflect.ReflectPermission&lt;/code&gt;, and
                     &lt;code&gt;java.io.SerializablePermission&lt;/code&gt;.
                    
                     &lt;p&gt;All but the first two (FilePermission and SocketPermission) are
                     subclasses of &lt;code&gt;java.security.BasicPermission&lt;/code&gt;, which itself
                     is an abstract subclass of the
                     top-level class for permissions, which is
                     &lt;code&gt;java.security.Permission&lt;/code&gt;. BasicPermission defines the
                     functionality needed for all permissions that contain a name
                     that follows the hierarchical property naming convention
                     (for example, "exitVM", "setFactory", "queuePrintJob", etc).
                     An asterisk
                     may appear at the end of the name, following a ".", or by itself, to
                     signify a wildcard match. For example: "a.*" or "*" is valid,
                     "*a" or "a*b" is not valid.
                    
                     &lt;p&gt;FilePermission and SocketPermission are subclasses of the
                     top-level class for permissions
                     (&lt;code&gt;java.security.Permission&lt;/code&gt;). Classes like these
                     that have a more complicated name syntax than that used by
                     BasicPermission subclass directly from Permission rather than from
                     BasicPermission. For example,
                     for a &lt;code&gt;java.io.FilePermission&lt;/code&gt; object, the permission name is
                     the path name of a file (or directory).
                    
                     &lt;p&gt;Some of the permission classes have an "actions" list that tells
                     the actions that are permitted for the object.  For example,
                     for a &lt;code&gt;java.io.FilePermission&lt;/code&gt; object, the actions list
                     (such as "read, write") specifies which actions are granted for the
                     specified file (or for files in the specified directory).
                    
                     &lt;p&gt;Other permission classes are for "named" permissions -
                     ones that contain a name but no actions list; you either have the
                     named permission or you don't.
                    
                     &lt;p&gt;Note: There is also a &lt;code&gt;java.security.AllPermission&lt;/code&gt;
                     permission that implies all permissions. It exists to simplify the work
                     of system administrators who might need to perform multiple
                     tasks that require all (or numerous) permissions.
                     &lt;p&gt;
                     See {@extLink security_guide_permissions
                     Permissions in the Java Development Kit (JDK)}
                     for permission-related information.
                     This document includes a table listing the various SecurityManager
                     &lt;code&gt;check&lt;/code&gt; methods and the permission(s) the default
                     implementation of each such method requires.
                     It also contains a table of the methods
                     that require permissions, and for each such method tells
                     which permission it requires.
                    
                     @author  Arthur van Hoff
                     @author  Roland Schemers
                    
                     @see     java.lang.ClassLoader
                     @see     java.lang.SecurityException
                     @see     java.lang.System#getSecurityManager() getSecurityManager
                     @see     java.lang.System#setSecurityManager(java.lang.SecurityManager)
                      setSecurityManager
                     @see     java.security.AccessController AccessController
                     @see     java.security.AccessControlContext AccessControlContext
                     @see     java.security.AccessControlException AccessControlException
                     @see     java.security.Permission
                     @see     java.security.BasicPermission
                     @see     java.io.FilePermission
                     @see     java.net.SocketPermission
                     @see     java.util.PropertyPermission
                     @see     java.lang.RuntimePermission
                     @see     java.awt.AWTPermission
                     @see     java.security.Policy Policy
                     @see     java.security.SecurityPermission SecurityPermission
                     @see     java.security.ProtectionDomain
                    
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="StringBuilder" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.CharSequence"/>
                    <superType superType="java.lang.AbstractStringBuilder"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A mutable sequence of characters.  This class provides an API compatible
                     with {@code StringBuffer}, but with no guarantee of synchronization.
                     This class is designed for use as a drop-in replacement for
                     {@code StringBuffer} in places where the string buffer was being
                     used by a single thread (as is generally the case).   Where possible,
                     it is recommended that this class be used in preference to
                     {@code StringBuffer} as it will be faster under most implementations.
                    
                     &lt;p&gt;The principal operations on a {@code StringBuilder} are the
                     {@code append} and {@code insert} methods, which are
                     overloaded so as to accept data of any type. Each effectively
                     converts a given datum to a string and then appends or inserts the
                     characters of that string to the string builder. The
                     {@code append} method always adds these characters at the end
                     of the builder; the {@code insert} method adds the characters at
                     a specified point.
                     &lt;p&gt;
                     For example, if {@code z} refers to a string builder object
                     whose current contents are "{@code start}", then
                     the method call {@code z.append("le")} would cause the string
                     builder to contain "{@code startle}", whereas
                     {@code z.insert(4, "le")} would alter the string builder to
                     contain "{@code starlet}".
                     &lt;p&gt;
                     In general, if sb refers to an instance of a {@code StringBuilder},
                     then {@code sb.append(x)} has the same effect as
                     {@code sb.insert(sb.length(), x)}.
                     &lt;p&gt;
                     Every string builder has a capacity. As long as the length of the
                     character sequence contained in the string builder does not exceed
                     the capacity, it is not necessary to allocate a new internal
                     buffer. If the internal buffer overflows, it is automatically made larger.
                    
                     &lt;p&gt;Instances of {@code StringBuilder} are not safe for
                     use by multiple threads. If such synchronization is required then it is
                     recommended that {@link java.lang.StringBuffer} be used.
                    
                     &lt;p&gt;Unless otherwise noted, passing a {@code null} argument to a constructor
                     or method in this class will cause a {@link NullPointerException} to be
                     thrown.
                    
                     @apiNote
                     {@code StringBuilder} implements {@code Comparable} but does not override
                     {@link Object#equals equals}. Thus, the natural ordering of {@code StringBuilder}
                     is inconsistent with equals. Care should be exercised if {@code StringBuilder}
                     objects are used as keys in a {@code SortedMap} or elements in a {@code SortedSet}.
                     See {@link Comparable}, {@link java.util.SortedMap SortedMap}, or
                     {@link java.util.SortedSet SortedSet} for more information.
                    
                     @author      Michael McCloskey
                     @see         java.lang.StringBuffer
                     @see         java.lang.String
                     @since       1.5
                    </javadoc>
            </acts>
            <acts name="SuppressWarnings" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.annotation.Annotation"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Indicates that the named compiler warnings should be suppressed in the
                     annotated element (and in all program elements contained in the annotated
                     element).  Note that the set of warnings suppressed in a given element is
                     a superset of the warnings suppressed in all containing elements.  For
                     example, if you annotate a class to suppress one warning and annotate a
                     method to suppress another, both warnings will be suppressed in the method.
                     However, note that if a warning is suppressed in a {@code
                     module-info} file, the suppression applies to elements within the
                     file and &lt;em&gt;not&lt;/em&gt; to types contained within the module.
                    
                     &lt;p&gt;As a matter of style, programmers should always use this annotation
                     on the most deeply nested element where it is effective.  If you want to
                     suppress a warning in a particular method, you should annotate that
                     method rather than its class.
                    
                     @author Josh Bloch
                     @since 1.5
                     @jls 4.8 Raw Types
                     @jls 4.12.2 Variables of Reference Type
                     @jls 5.1.9 Unchecked Conversion
                     @jls 5.5.2 Checked Casts and Unchecked Casts
                     @jls 9.6.4.5 @SuppressWarnings
                    </javadoc>
            </acts>
            <acts name="Appendable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes/>
                <javadoc xml:space="preserve">
                     An object to which {@code char} sequences and values can be appended.  The
                     {@code Appendable} interface must be implemented by any class whose
                     instances are intended to receive formatted output from a {@link
                     java.util.Formatter}.
                    
                     &lt;p&gt; The characters to be appended should be valid Unicode characters as
                     described in &lt;a href="Character.html#unicode"&gt;Unicode Character
                     Representation&lt;/a&gt;.  Note that supplementary characters may be composed of
                     multiple 16-bit {@code char} values.
                    
                     &lt;p&gt; Appendables are not necessarily safe for multithreaded access.  Thread
                     safety is the responsibility of classes that extend and implement this
                     interface.
                    
                     &lt;p&gt; Since this interface may be implemented by existing classes
                     with different styles of error handling there is no guarantee that
                     errors will be propagated to the invoker.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="UnsupportedClassVersionError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.ClassFormatError"/>
                    <superType superType="java.lang.LinkageError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when the Java Virtual Machine attempts to read a class
                     file and determines that the major and minor version numbers
                     in the file are not supported.
                    
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="RuntimePermission" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.security.BasicPermission"/>
                    <superType superType="java.security.Permission"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class is for runtime permissions. A {@code RuntimePermission}
                     contains a name (also referred to as a "target name") but no actions
                     list; you either have the named permission or you don't.
                     &lt;p&gt;
                     The target name is the name of the runtime permission (see below). The
                     naming convention follows the  hierarchical property naming convention.
                     Also, an asterisk may appear at the end of the name, following a ".",
                     or by itself, to signify a wildcard match. For example: "loadLibrary.*"
                     and "*" signify a wildcard match, while "*loadLibrary" and "a*b" do not.
                     &lt;p&gt;
                     The following table lists the standard {@code RuntimePermission}
                     target names, and for each provides a description of what the permission
                     allows and a discussion of the risks of granting code the permission.
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;permission target name,
                      what the target allows, and associated risks&lt;/caption&gt;
                     &lt;thead&gt;
                     &lt;tr&gt;
                     &lt;th scope="col"&gt;Permission Target Name&lt;/th&gt;
                     &lt;th scope="col"&gt;What the Permission Allows&lt;/th&gt;
                     &lt;th scope="col"&gt;Risks of Allowing this Permission&lt;/th&gt;
                     &lt;/tr&gt;
                     &lt;/thead&gt;
                     &lt;tbody&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;createClassLoader&lt;/th&gt;
                       &lt;td&gt;Creation of a class loader&lt;/td&gt;
                       &lt;td&gt;This is an extremely dangerous permission to grant.
                     Malicious applications that can instantiate their own class
                     loaders could then load their own rogue classes into the system.
                     These newly loaded classes could be placed into any protection
                     domain by the class loader, thereby automatically granting the
                     classes the permissions for that domain.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;getClassLoader&lt;/th&gt;
                       &lt;td&gt;Retrieval of a class loader (e.g., the class loader for the calling
                     class)&lt;/td&gt;
                       &lt;td&gt;This would grant an attacker permission to get the
                     class loader for a particular class. This is dangerous because
                     having access to a class's class loader allows the attacker to
                     load other classes available to that class loader. The attacker
                     would typically otherwise not have access to those classes.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;setContextClassLoader&lt;/th&gt;
                       &lt;td&gt;Setting of the context class loader used by a thread&lt;/td&gt;
                       &lt;td&gt;The context class loader is used by system code and extensions
                     when they need to lookup resources that might not exist in the system
                     class loader. Granting setContextClassLoader permission would allow
                     code to change which context class loader is used
                     for a particular thread, including system threads.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;enableContextClassLoaderOverride&lt;/th&gt;
                       &lt;td&gt;Subclass implementation of the thread context class loader methods&lt;/td&gt;
                       &lt;td&gt;The context class loader is used by system code and extensions
                     when they need to lookup resources that might not exist in the system
                     class loader. Granting enableContextClassLoaderOverride permission would allow
                     a subclass of Thread to override the methods that are used
                     to get or set the context class loader for a particular thread.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;closeClassLoader&lt;/th&gt;
                       &lt;td&gt;Closing of a ClassLoader&lt;/td&gt;
                       &lt;td&gt;Granting this permission allows code to close any URLClassLoader
                     that it has a reference to.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;setSecurityManager&lt;/th&gt;
                       &lt;td&gt;Setting of the security manager (possibly replacing an existing one)
                     &lt;/td&gt;
                       &lt;td&gt;The security manager is a class that allows
                     applications to implement a security policy. Granting the setSecurityManager
                     permission would allow code to change which security manager is used by
                     installing a different, possibly less restrictive security manager,
                     thereby bypassing checks that would have been enforced by the original
                     security manager.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;createSecurityManager&lt;/th&gt;
                       &lt;td&gt;Creation of a new security manager&lt;/td&gt;
                       &lt;td&gt;This gives code access to protected, sensitive methods that may
                     disclose information about other classes or the execution stack.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;getenv.{variable name}&lt;/th&gt;
                       &lt;td&gt;Reading of the value of the specified environment variable&lt;/td&gt;
                       &lt;td&gt;This would allow code to read the value, or determine the
                           existence, of a particular environment variable.  This is
                           dangerous if the variable contains confidential data.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;exitVM.{exit status}&lt;/th&gt;
                       &lt;td&gt;Halting of the Java Virtual Machine with the specified exit status&lt;/td&gt;
                       &lt;td&gt;This allows an attacker to mount a denial-of-service attack
                     by automatically forcing the virtual machine to halt.
                     Note: The "exitVM.*" permission is automatically granted to all code
                     loaded from the application class path, thus enabling applications
                     to terminate themselves. Also, the "exitVM" permission is equivalent to
                     "exitVM.*".&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;shutdownHooks&lt;/th&gt;
                       &lt;td&gt;Registration and cancellation of virtual-machine shutdown hooks&lt;/td&gt;
                       &lt;td&gt;This allows an attacker to register a malicious shutdown
                     hook that interferes with the clean shutdown of the virtual machine.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;setFactory&lt;/th&gt;
                       &lt;td&gt;Setting of the socket factory used by ServerSocket or Socket,
                     or of the stream handler factory used by URL&lt;/td&gt;
                       &lt;td&gt;This allows code to set the actual implementation
                     for the socket, server socket, stream handler, or RMI socket factory.
                     An attacker may set a faulty implementation which mangles the data
                     stream.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;setIO&lt;/th&gt;
                       &lt;td&gt;Setting of System.out, System.in, and System.err&lt;/td&gt;
                       &lt;td&gt;This allows changing the value of the standard system streams.
                     An attacker may change System.in to monitor and
                     steal user input, or may set System.err to a "null" OutputStream,
                     which would hide any error messages sent to System.err. &lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;modifyThread&lt;/th&gt;
                       &lt;td&gt;Modification of threads, e.g., via calls to Thread
                     {@code interrupt, stop, suspend, resume, setDaemon, setPriority,
                     setName} and {@code setUncaughtExceptionHandler}
                     methods&lt;/td&gt;
                     &lt;td&gt;This allows an attacker to modify the behaviour of
                     any thread in the system.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;stopThread&lt;/th&gt;
                       &lt;td&gt;Stopping of threads via calls to the Thread &lt;code&gt;stop&lt;/code&gt;
                     method&lt;/td&gt;
                       &lt;td&gt;This allows code to stop any thread in the system provided that it is
                     already granted permission to access that thread.
                     This poses as a threat, because that code may corrupt the system by
                     killing existing threads.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;modifyThreadGroup&lt;/th&gt;
                       &lt;td&gt;modification of thread groups, e.g., via calls to ThreadGroup
                     &lt;code&gt;destroy&lt;/code&gt;, &lt;code&gt;getParent&lt;/code&gt;, &lt;code&gt;resume&lt;/code&gt;,
                     &lt;code&gt;setDaemon&lt;/code&gt;, &lt;code&gt;setMaxPriority&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;,
                     and &lt;code&gt;suspend&lt;/code&gt; methods&lt;/td&gt;
                       &lt;td&gt;This allows an attacker to create thread groups and
                     set their run priority.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;getProtectionDomain&lt;/th&gt;
                       &lt;td&gt;Retrieval of the ProtectionDomain for a class&lt;/td&gt;
                       &lt;td&gt;This allows code to obtain policy information
                     for a particular code source. While obtaining policy information
                     does not compromise the security of the system, it does give
                     attackers additional information, such as local file names for
                     example, to better aim an attack.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;getFileSystemAttributes&lt;/th&gt;
                       &lt;td&gt;Retrieval of file system attributes&lt;/td&gt;
                       &lt;td&gt;This allows code to obtain file system information such as disk usage
                           or disk space available to the caller.  This is potentially dangerous
                           because it discloses information about the system hardware
                           configuration and some information about the caller's privilege to
                           write files.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;readFileDescriptor&lt;/th&gt;
                       &lt;td&gt;Reading of file descriptors&lt;/td&gt;
                       &lt;td&gt;This would allow code to read the particular file associated
                           with the file descriptor read. This is dangerous if the file
                           contains confidential data.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;writeFileDescriptor&lt;/th&gt;
                       &lt;td&gt;Writing to file descriptors&lt;/td&gt;
                       &lt;td&gt;This allows code to write to a particular file associated
                           with the descriptor. This is dangerous because it may allow
                           malicious code to plant viruses or at the very least, fill up
                           your entire disk.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;loadLibrary.{library name}&lt;/th&gt;
                       &lt;td&gt;Dynamic linking of the specified library&lt;/td&gt;
                       &lt;td&gt;It is dangerous to allow an applet permission to load native code
                     libraries, because the Java security architecture is not designed to and
                     does not prevent malicious behavior at the level of native code.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;accessClassInPackage.{package name}&lt;/th&gt;
                       &lt;td&gt;Access to the specified package via a class loader's
                     &lt;code&gt;loadClass&lt;/code&gt; method when that class loader calls
                     the SecurityManager &lt;code&gt;checkPackageAccess&lt;/code&gt; method&lt;/td&gt;
                       &lt;td&gt;This gives code access to classes in packages
                     to which it normally does not have access. Malicious code
                     may use these classes to help in its attempt to compromise
                     security in the system.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;defineClassInPackage.{package name}&lt;/th&gt;
                       &lt;td&gt;Definition of classes in the specified package, via a class
                     loader's &lt;code&gt;defineClass&lt;/code&gt; method when that class loader calls
                     the SecurityManager &lt;code&gt;checkPackageDefinition&lt;/code&gt; method.&lt;/td&gt;
                       &lt;td&gt;This grants code permission to define a class
                     in a particular package. This is dangerous because malicious
                     code with this permission may define rogue classes in
                     trusted packages like &lt;code&gt;java.security&lt;/code&gt; or &lt;code&gt;java.lang&lt;/code&gt;,
                     for example.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;defineClass&lt;/th&gt;
                       &lt;td&gt;Define a class with
                     {@link java.lang.invoke.MethodHandles.Lookup#defineClass(byte[])
                     Lookup.defineClass}.&lt;/td&gt;
                       &lt;td&gt;This grants code with a suitably privileged {@code Lookup} object
                     permission to define classes in the same package as the {@code Lookup}'s
                     lookup class. &lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;accessDeclaredMembers&lt;/th&gt;
                       &lt;td&gt;Access to the declared members of a class&lt;/td&gt;
                       &lt;td&gt;This grants code permission to query a class for its public,
                     protected, default (package) access, and private fields and/or
                     methods. Although the code would have
                     access to the private and protected field and method names, it would not
                     have access to the private/protected field data and would not be able
                     to invoke any private methods. Nevertheless, malicious code
                     may use this information to better aim an attack.
                     Additionally, it may invoke any public methods and/or access public fields
                     in the class.  This could be dangerous if
                     the code would normally not be able to invoke those methods and/or
                     access the fields  because
                     it can't cast the object to the class/interface with those methods
                     and fields.
                    &lt;/td&gt;
                     &lt;/tr&gt;
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;queuePrintJob&lt;/th&gt;
                       &lt;td&gt;Initiation of a print job request&lt;/td&gt;
                       &lt;td&gt;This could print sensitive information to a printer,
                     or simply waste paper.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;getStackTrace&lt;/th&gt;
                       &lt;td&gt;Retrieval of the stack trace information of another thread.&lt;/td&gt;
                       &lt;td&gt;This allows retrieval of the stack trace information of
                     another thread.  This might allow malicious code to monitor the
                     execution of threads and discover vulnerabilities in applications.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;getStackWalkerWithClassReference&lt;/th&gt;
                       &lt;td&gt;Get a stack walker that can retrieve stack frames with class reference.&lt;/td&gt;
                       &lt;td&gt;This allows retrieval of Class objects from stack walking.
                       This might allow malicious code to access Class objects on the stack
                       outside its own context.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;setDefaultUncaughtExceptionHandler&lt;/th&gt;
                       &lt;td&gt;Setting the default handler to be used when a thread
                       terminates abruptly due to an uncaught exception&lt;/td&gt;
                       &lt;td&gt;This allows an attacker to register a malicious
                       uncaught exception handler that could interfere with termination
                       of a thread&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;preferences&lt;/th&gt;
                       &lt;td&gt;Represents the permission required to get access to the
                       java.util.prefs.Preferences implementations user or system root
                       which in turn allows retrieval or update operations within the
                       Preferences persistent backing store.) &lt;/td&gt;
                       &lt;td&gt;This permission allows the user to read from or write to the
                       preferences backing store if the user running the code has
                       sufficient OS privileges to read/write to that backing store.
                       The actual backing store may reside within a traditional filesystem
                       directory or within a registry depending on the platform OS&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;manageProcess&lt;/th&gt;
                       &lt;td&gt;Native process termination and information about processes
                           {@link ProcessHandle}.&lt;/td&gt;
                       &lt;td&gt;Allows code to identify and terminate processes that it did not create.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;localeServiceProvider&lt;/th&gt;
                       &lt;td&gt;This {@code RuntimePermission} is required to be granted to
                       classes which subclass and implement
                       {@code java.util.spi.LocaleServiceProvider}. The permission is
                       checked during invocation of the abstract base class constructor.
                       This permission ensures trust in classes which implement this
                       security-sensitive provider mechanism. &lt;/td&gt;
                       &lt;td&gt;See &lt;a href= "../util/spi/LocaleServiceProvider.html"&gt;
                       {@code java.util.spi.LocaleServiceProvider}&lt;/a&gt; for more
                       information.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;loggerFinder&lt;/th&gt;
                       &lt;td&gt;This {@code RuntimePermission} is required to be granted to
                       classes which subclass or call methods on
                       {@code java.lang.System.LoggerFinder}. The permission is
                       checked during invocation of the abstract base class constructor, as
                       well as on the invocation of its public methods.
                       This permission ensures trust in classes which provide loggers
                       to system classes.&lt;/td&gt;
                       &lt;td&gt;See {@link java.lang.System.LoggerFinder java.lang.System.LoggerFinder}
                       for more information.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;accessSystemModules&lt;/th&gt;
                       &lt;td&gt;Access system modules in the runtime image.&lt;/td&gt;
                       &lt;td&gt;This grants the permission to access resources in the
                       {@linkplain ModuleFinder#ofSystem system modules} in the runtime image.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     @implNote
                     Implementations may define additional target names, but should use naming
                     conventions such as reverse domain name notation to avoid name clashes.
                    
                     @see java.security.BasicPermission
                     @see java.security.Permission
                     @see java.security.Permissions
                     @see java.security.PermissionCollection
                     @see java.lang.SecurityManager
                    
                    
                     @author Marianne Mueller
                     @author Roland Schemers
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="Option" access="PUBLIC" declaringClass="StackWalker" kind="TYPE" typeKind="ENUM" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="System" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code System} class contains several useful class fields
                     and methods. It cannot be instantiated.
                    
                     Among the facilities provided by the {@code System} class
                     are standard input, standard output, and error output streams;
                     access to externally defined properties and environment
                     variables; a means of loading files and libraries; and a utility
                     method for quickly copying a portion of an array.
                    
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="NoSuchMethodException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.ReflectiveOperationException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when a particular method cannot be found.
                    
                     @author     unascribed
                     @since      1.0
                    </javadoc>
            </acts>
            <acts name="ProcessHandle" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Comparable"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     ProcessHandle identifies and provides control of native processes. Each
                     individual process can be monitored for liveness, list its children,
                     get information about the process or destroy it.
                     By comparison, {@link java.lang.Process Process} instances were started
                     by the current process and additionally provide access to the process
                     input, output, and error streams.
                     &lt;p&gt;
                     The native process ID is an identification number that the
                     operating system assigns to the process.
                     The range for process id values is dependent on the operating system.
                     For example, an embedded system might use a 16-bit value.
                     Status information about a process is retrieved from the native system
                     and may change asynchronously; processes may be created or terminate
                     spontaneously.
                     The time between when a process terminates and the process id
                     is reused for a new process is unpredictable.
                     Race conditions can exist between checking the status of a process and
                     acting upon it. When using ProcessHandles avoid assumptions
                     about the liveness or identity of the underlying process.
                     &lt;p&gt;
                     Each ProcessHandle identifies and allows control of a process in the native
                     system. ProcessHandles are returned from the factory methods {@link #current()},
                     {@link #of(long)},
                     {@link #children}, {@link #descendants}, {@link #parent()} and
                     {@link #allProcesses()}.
                     &lt;p&gt;
                     The {@link Process} instances created by {@link ProcessBuilder} can be queried
                     for a ProcessHandle that provides information about the Process.
                     ProcessHandle references should not be freely distributed.
                    
                     &lt;p&gt;
                     A {@link java.util.concurrent.CompletableFuture} available from {@link #onExit}
                     can be used to wait for process termination, and possibly trigger dependent
                     actions.
                     &lt;p&gt;
                     The factory methods limit access to ProcessHandles using the
                     SecurityManager checking the {@link RuntimePermission RuntimePermission("manageProcess")}.
                     The ability to control processes is also restricted by the native system,
                     ProcessHandle provides no more access to, or control over, the native process
                     than would be allowed by a native application.
                    
                     @implSpec
                     In the case where ProcessHandles cannot be supported then the factory
                     methods must consistently throw {@link java.lang.UnsupportedOperationException}.
                     The methods of this class throw {@link java.lang.UnsupportedOperationException}
                     if the operating system does not allow access to query or kill a process.
                    
                     &lt;p&gt;
                     The {@code ProcessHandle} static factory methods return instances that are
                     &lt;a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt;,
                     immutable and thread-safe.
                     Use of identity-sensitive operations (including reference equality
                     ({@code ==}), identity hash code, or synchronization) on these instances of
                     {@code ProcessHandle} may have unpredictable results and should be avoided.
                     Use {@link #equals(Object) equals} or
                     {@link #compareTo(ProcessHandle) compareTo} methods to compare ProcessHandles.
                    
                     @see Process
                     @since 9
                    </javadoc>
            </acts>
            <acts name="RuntimeException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     {@code RuntimeException} is the superclass of those
                     exceptions that can be thrown during the normal operation of the
                     Java Virtual Machine.
                    
                     &lt;p&gt;{@code RuntimeException} and its subclasses are &lt;em&gt;unchecked
                     exceptions&lt;/em&gt;.  Unchecked exceptions do &lt;em&gt;not&lt;/em&gt; need to be
                     declared in a method or constructor's {@code throws} clause if they
                     can be thrown by the execution of the method or constructor and
                     propagate outside the method or constructor boundary.
                    
                     @author  Frank Yellin
                     @jls 11.2 Compile-Time Checking of Exceptions
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Number" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The abstract class {@code Number} is the superclass of platform
                     classes representing numeric values that are convertible to the
                     primitive types {@code byte}, {@code double}, {@code float}, {@code
                     int}, {@code long}, and {@code short}.
                    
                     The specific semantics of the conversion from the numeric value of
                     a particular {@code Number} implementation to a given primitive
                     type is defined by the {@code Number} implementation in question.
                    
                     For platform classes, the conversion is often analogous to a
                     narrowing primitive conversion or a widening primitive conversion
                     as defined in &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;
                     for converting between primitive types.  Therefore, conversions may
                     lose information about the overall magnitude of a numeric value, may
                     lose precision, and may even return a result of a different sign
                     than the input.
                    
                     See the documentation of a given {@code Number} implementation for
                     conversion details.
                    
                     @author      Lee Boynton
                     @author      Arthur van Hoff
                     @jls 5.1.2 Widening Primitive Conversions
                     @jls 5.1.3 Narrowing Primitive Conversions
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="NullPointerException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when an application attempts to use {@code null} in a
                     case where an object is required. These include:
                     &lt;ul&gt;
                     &lt;li&gt;Calling the instance method of a {@code null} object.
                     &lt;li&gt;Accessing or modifying the field of a {@code null} object.
                     &lt;li&gt;Taking the length of {@code null} as if it were an array.
                     &lt;li&gt;Accessing or modifying the slots of {@code null} as if it
                         were an array.
                     &lt;li&gt;Throwing {@code null} as if it were a {@code Throwable}
                         value.
                     &lt;/ul&gt;
                     &lt;p&gt;
                     Applications should throw instances of this class to indicate
                     other illegal uses of the {@code null} object.
                    
                     {@code NullPointerException} objects may be constructed by the
                     virtual machine as if {@linkplain Throwable#Throwable(String,
                     Throwable, boolean, boolean) suppression were disabled and/or the
                     stack trace was not writable}.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="BootstrapMethodError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.LinkageError"/>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that an {@code invokedynamic} instruction or a dynamic
                     constant failed to resolve its bootstrap method and arguments,
                     or for {@code invokedynamic} instruction the bootstrap method has failed to
                     provide a
                     {@linkplain java.lang.invoke.CallSite call site} with a
                     {@linkplain java.lang.invoke.CallSite#getTarget target}
                     of the correct {@linkplain java.lang.invoke.MethodHandle#type() method type},
                     or for a dynamic constant the bootstrap method has failed to provide a
                     constant value of the required type.
                    
                     @author John Rose, JSR 292 EG
                     @since 1.7
                    </javadoc>
            </acts>
            <acts name="ClassLoader" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A class loader is an object that is responsible for loading classes. The
                     class {@code ClassLoader} is an abstract class.  Given the &lt;a
                     href="#binary-name"&gt;binary name&lt;/a&gt; of a class, a class loader should attempt to
                     locate or generate data that constitutes a definition for the class.  A
                     typical strategy is to transform the name into a file name and then read a
                     "class file" of that name from a file system.
                    
                     &lt;p&gt; Every {@link java.lang.Class Class} object contains a {@link
                     Class#getClassLoader() reference} to the {@code ClassLoader} that defined
                     it.
                    
                     &lt;p&gt; {@code Class} objects for array classes are not created by class
                     loaders, but are created automatically as required by the Java runtime.
                     The class loader for an array class, as returned by {@link
                     Class#getClassLoader()} is the same as the class loader for its element
                     type; if the element type is a primitive type, then the array class has no
                     class loader.
                    
                     &lt;p&gt; Applications implement subclasses of {@code ClassLoader} in order to
                     extend the manner in which the Java virtual machine dynamically loads
                     classes.
                    
                     &lt;p&gt; Class loaders may typically be used by security managers to indicate
                     security domains.
                    
                     &lt;p&gt; In addition to loading classes, a class loader is also responsible for
                     locating resources. A resource is some data (a "{@code .class}" file,
                     configuration data, or an image for example) that is identified with an
                     abstract '/'-separated path name. Resources are typically packaged with an
                     application or library so that they can be located by code in the
                     application or library. In some cases, the resources are included so that
                     they can be located by other libraries.
                    
                     &lt;p&gt; The {@code ClassLoader} class uses a delegation model to search for
                     classes and resources.  Each instance of {@code ClassLoader} has an
                     associated parent class loader. When requested to find a class or
                     resource, a {@code ClassLoader} instance will usually delegate the search
                     for the class or resource to its parent class loader before attempting to
                     find the class or resource itself.
                    
                     &lt;p&gt; Class loaders that support concurrent loading of classes are known as
                     &lt;em&gt;{@linkplain #isRegisteredAsParallelCapable() parallel capable}&lt;/em&gt; class
                     loaders and are required to register themselves at their class initialization
                     time by invoking the {@link
                     #registerAsParallelCapable ClassLoader.registerAsParallelCapable}
                     method. Note that the {@code ClassLoader} class is registered as parallel
                     capable by default. However, its subclasses still need to register themselves
                     if they are parallel capable.
                     In environments in which the delegation model is not strictly
                     hierarchical, class loaders need to be parallel capable, otherwise class
                     loading can lead to deadlocks because the loader lock is held for the
                     duration of the class loading process (see {@link #loadClass
                     loadClass} methods).
                    
                     &lt;h3&gt; &lt;a id="builtinLoaders"&gt;Run-time Built-in Class Loaders&lt;/a&gt;&lt;/h3&gt;
                    
                     The Java run-time has the following built-in class loaders:
                    
                     &lt;ul&gt;
                     &lt;li&gt;&lt;p&gt;Bootstrap class loader.
                         It is the virtual machine's built-in class loader, typically represented
                         as {@code null}, and does not have a parent.&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;{@linkplain #getPlatformClassLoader() Platform class loader}.
                         All &lt;em&gt;platform classes&lt;/em&gt; are visible to the platform class loader
                         that can be used as the parent of a {@code ClassLoader} instance.
                         Platform classes include Java SE platform APIs, their implementation
                         classes and JDK-specific run-time classes that are defined by the
                         platform class loader or its ancestors.
                         &lt;p&gt; To allow for upgrading/overriding of modules defined to the platform
                         class loader, and where upgraded modules read modules defined to class
                         loaders other than the platform class loader and its ancestors, then
                         the platform class loader may have to delegate to other class loaders,
                         the application class loader for example.
                         In other words, classes in named modules defined to class loaders
                         other than the platform class loader and its ancestors may be visible
                         to the platform class loader. &lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;{@linkplain #getSystemClassLoader() System class loader}.
                         It is also known as &lt;em&gt;application class loader&lt;/em&gt; and is distinct
                         from the platform class loader.
                         The system class loader is typically used to define classes on the
                         application class path, module path, and JDK-specific tools.
                         The platform class loader is a parent or an ancestor of the system class
                         loader that all platform classes are visible to it.&lt;/li&gt;
                     &lt;/ul&gt;
                    
                     &lt;p&gt; Normally, the Java virtual machine loads classes from the local file
                     system in a platform-dependent manner.
                     However, some classes may not originate from a file; they may originate
                     from other sources, such as the network, or they could be constructed by an
                     application.  The method {@link #defineClass(String, byte[], int, int)
                     defineClass} converts an array of bytes into an instance of class
                     {@code Class}. Instances of this newly defined class can be created using
                     {@link Class#newInstance Class.newInstance}.
                    
                     &lt;p&gt; The methods and constructors of objects created by a class loader may
                     reference other classes.  To determine the class(es) referred to, the Java
                     virtual machine invokes the {@link #loadClass loadClass} method of
                     the class loader that originally created the class.
                    
                     &lt;p&gt; For example, an application could create a network class loader to
                     download class files from a server.  Sample code might look like:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                       ClassLoader loader&amp;nbsp;= new NetworkClassLoader(host,&amp;nbsp;port);
                       Object main&amp;nbsp;= loader.loadClass("Main", true).newInstance();
                           &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt; The network class loader subclass must define the methods {@link
                     #findClass findClass} and {@code loadClassData} to load a class
                     from the network.  Once it has downloaded the bytes that make up the class,
                     it should use the method {@link #defineClass defineClass} to
                     create a class instance.  A sample implementation is:
                    
                     &lt;blockquote&gt;&lt;pre&gt;
                         class NetworkClassLoader extends ClassLoader {
                             String host;
                             int port;
                    
                             public Class findClass(String name) {
                                 byte[] b = loadClassData(name);
                                 return defineClass(name, b, 0, b.length);
                             }
                    
                             private byte[] loadClassData(String name) {
                                 // load the class data from the connection
                                 &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
                             }
                         }
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;h3&gt; &lt;a id="binary-name"&gt;Binary names&lt;/a&gt; &lt;/h3&gt;
                    
                     &lt;p&gt; Any class name provided as a {@code String} parameter to methods in
                     {@code ClassLoader} must be a binary name as defined by
                     &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
                    
                     &lt;p&gt; Examples of valid class names include:
                     &lt;blockquote&gt;&lt;pre&gt;
                       "java.lang.String"
                       "javax.swing.JSpinner$DefaultEditor"
                       "java.security.KeyStore$Builder$FileBuilder$1"
                       "java.net.URLClassLoader$3$1"
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt; Any package name provided as a {@code String} parameter to methods in
                     {@code ClassLoader} must be either the empty string (denoting an unnamed package)
                     or a fully qualified name as defined by
                     &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
                    
                     @jls 6.7  Fully Qualified Names
                     @jls 13.1 The Form of a Binary
                     @see      #resolveClass(Class)
                     @since 1.0
                     @revised 9
                     @spec JPMS
                    </javadoc>
            </acts>
            <acts name="VirtualMachineError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that the Java Virtual Machine is broken or has
                     run out of resources necessary for it to continue operating.
                    
                    
                     @author  Frank Yellin
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="LayerInstantiationException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when creating a {@linkplain ModuleLayer module layer} fails.
                    
                     @see ModuleLayer
                     @since 9
                     @spec JPMS
                    </javadoc>
            </acts>
            <acts name="Redirect" access="PUBLIC" declaringClass="ProcessBuilder" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="InheritableThreadLocal" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.ThreadLocal"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class extends {@code ThreadLocal} to provide inheritance of values
                     from parent thread to child thread: when a child thread is created, the
                     child receives initial values for all inheritable thread-local variables
                     for which the parent has values.  Normally the child's values will be
                     identical to the parent's; however, the child's value can be made an
                     arbitrary function of the parent's by overriding the {@code childValue}
                     method in this class.
                    
                     &lt;p&gt;Inheritable thread-local variables are used in preference to
                     ordinary thread-local variables when the per-thread-attribute being
                     maintained in the variable (e.g., User ID, Transaction ID) must be
                     automatically transmitted to any child threads that are created.
                    
                     &lt;p&gt;Note: During the creation of a new {@link
                     Thread#Thread(ThreadGroup,Runnable,String,long,boolean) thread}, it is
                     possible to &lt;i&gt;opt out&lt;/i&gt; of receiving initial values for inheritable
                     thread-local variables.
                    
                     @author  Josh Bloch and Doug Lea
                     @see     ThreadLocal
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="AutoCloseable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.lang">
                <superTypes/>
                <javadoc xml:space="preserve">
                     An object that may hold resources (such as file or socket handles)
                     until it is closed. The {@link #close()} method of an {@code AutoCloseable}
                     object is called automatically when exiting a {@code
                     try}-with-resources block for which the object has been declared in
                     the resource specification header. This construction ensures prompt
                     release, avoiding resource exhaustion exceptions and errors that
                     may otherwise occur.
                    
                     @apiNote
                     &lt;p&gt;It is possible, and in fact common, for a base class to
                     implement AutoCloseable even though not all of its subclasses or
                     instances will hold releasable resources.  For code that must operate
                     in complete generality, or when it is known that the {@code AutoCloseable}
                     instance requires resource release, it is recommended to use {@code
                     try}-with-resources constructions. However, when using facilities such as
                     {@link java.util.stream.Stream} that support both I/O-based and
                     non-I/O-based forms, {@code try}-with-resources blocks are in
                     general unnecessary when using non-I/O-based forms.
                    
                     @author Josh Bloch
                     @since 1.7
                    </javadoc>
            </acts>
            <acts name="LoggerFinder" access="PUBLIC" declaringClass="System" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Error" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An {@code Error} is a subclass of {@code Throwable}
                     that indicates serious problems that a reasonable application
                     should not try to catch. Most such errors are abnormal conditions.
                     The {@code ThreadDeath} error, though a "normal" condition,
                     is also a subclass of {@code Error} because most applications
                     should not try to catch it.
                     &lt;p&gt;
                     A method is not required to declare in its {@code throws}
                     clause any subclasses of {@code Error} that might be thrown
                     during the execution of the method but not caught, since these
                     errors are abnormal conditions that should never occur.
                    
                     That is, {@code Error} and its subclasses are regarded as unchecked
                     exceptions for the purposes of compile-time checking of exceptions.
                    
                     @author  Frank Yellin
                     @see     java.lang.ThreadDeath
                     @jls 11.2 Compile-Time Checking of Exceptions
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="SecurityException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown by the security manager to indicate a security violation.
                    
                     @author  unascribed
                     @see     java.lang.SecurityManager
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Exception" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The class {@code Exception} and its subclasses are a form of
                     {@code Throwable} that indicates conditions that a reasonable
                     application might want to catch.
                    
                     &lt;p&gt;The class {@code Exception} and any subclasses that are not also
                     subclasses of {@link RuntimeException} are &lt;em&gt;checked
                     exceptions&lt;/em&gt;.  Checked exceptions need to be declared in a
                     method or constructor's {@code throws} clause if they can be thrown
                     by the execution of the method or constructor and propagate outside
                     the method or constructor boundary.
                    
                     @author  Frank Yellin
                     @see     java.lang.Error
                     @jls 11.2 Compile-Time Checking of Exceptions
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="IllegalCallerException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that a method has been called by an inappropriate caller.
                    
                     @since 9
                     @spec JPMS
                     @see StackWalker#getCallerClass
                    </javadoc>
            </acts>
            <acts name="IllegalThreadStateException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.IllegalArgumentException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that a thread is not in an appropriate state
                     for the requested operation. See, for example, the
                     &lt;code&gt;suspend&lt;/code&gt; and &lt;code&gt;resume&lt;/code&gt; methods in class
                     &lt;code&gt;Thread&lt;/code&gt;.
                    
                     @author  unascribed
                     @see     java.lang.Thread#resume()
                     @see     java.lang.Thread#suspend()
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Integer" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.lang.Number"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Integer} class wraps a value of the primitive type
                     {@code int} in an object. An object of type {@code Integer}
                     contains a single field whose type is {@code int}.
                    
                     &lt;p&gt;In addition, this class provides several methods for converting
                     an {@code int} to a {@code String} and a {@code String} to an
                     {@code int}, as well as other constants and methods useful when
                     dealing with an {@code int}.
                    
                     &lt;p&gt;Implementation note: The implementations of the "bit twiddling"
                     methods (such as {@link #highestOneBit(int) highestOneBit} and
                     {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are
                     based on material from Henry S. Warren, Jr.'s &lt;i&gt;Hacker's
                     Delight&lt;/i&gt;, (Addison Wesley, 2002).
                    
                     @author  Lee Boynton
                     @author  Arthur van Hoff
                     @author  Josh Bloch
                     @author  Joseph D. Darcy
                     @since 1.0
                    </javadoc>
            </acts>
            <acts name="Lookup" access="PUBLIC" declaringClass="WeakPairMap.Pair" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.WeakPairMap$Pair"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="ClassCastException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that the code has attempted to cast an object
                     to a subclass of which it is not an instance. For example, the
                     following code generates a &lt;code&gt;ClassCastException&lt;/code&gt;:
                     &lt;blockquote&gt;&lt;pre&gt;
                         Object x = new Integer(0);
                         System.out.println((String)x);
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ArrayIndexOutOfBoundsException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.lang">
                <superTypes>
                    <superType superType="java.lang.IndexOutOfBoundsException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that an array has been accessed with an illegal index. The
                     index is either negative or greater than or equal to the size of the array.
                    
                     @since 1.0
                    </javadoc>
            </acts>
            <package name="annotation"/>
            <package name="ref"/>
            <package name="reflect"/>
            <package name="management"/>
            <package name="module"/>
            <package name="instrument"/>
            <package name="invoke"/>
        </package>
        <package name="net">
            <acts name="SocketException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that there is an error creating or accessing a Socket.
                    
                     @author  Jonathan Payne
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="MalformedURLException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that a malformed URL has occurred. Either no
                     legal protocol could be found in a specification string or the
                     string could not be parsed.
                    
                     @author  Arthur van Hoff
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="InetSocketAddress" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.SocketAddress"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                    
                     This class implements an IP Socket Address (IP address + port number)
                     It can also be a pair (hostname + port number), in which case an attempt
                     will be made to resolve the hostname. If resolution fails then the address
                     is said to be &lt;I&gt;unresolved&lt;/I&gt; but can still be used on some circumstances
                     like connecting through a proxy.
                     &lt;p&gt;
                     It provides an immutable object used by sockets for binding, connecting, or
                     as returned values.
                     &lt;p&gt;
                     The &lt;i&gt;wildcard&lt;/i&gt; is a special local IP address. It usually means "any"
                     and can only be used for {@code bind} operations.
                    
                     @see java.net.Socket
                     @see java.net.ServerSocket
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="JarURLConnection" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.URLConnection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A URL Connection to a Java ARchive (JAR) file or an entry in a JAR
                     file.
                    
                     &lt;p&gt;The syntax of a JAR URL is:
                    
                     &lt;pre&gt;
                     jar:&amp;lt;url&amp;gt;!/{entry}
                     &lt;/pre&gt;
                    
                     &lt;p&gt;for example:
                    
                     &lt;p&gt;{@code jar:http://www.foo.com/bar/baz.jar!/COM/foo/Quux.class}
                    
                     &lt;p&gt;Jar URLs should be used to refer to a JAR file or entries in
                     a JAR file. The example above is a JAR URL which refers to a JAR
                     entry. If the entry name is omitted, the URL refers to the whole
                     JAR file:
                    
                     {@code jar:http://www.foo.com/bar/baz.jar!/}
                    
                     &lt;p&gt;Users should cast the generic URLConnection to a
                     JarURLConnection when they know that the URL they created is a JAR
                     URL, and they need JAR-specific functionality. For example:
                    
                     &lt;pre&gt;
                     URL url = new URL("jar:file:/home/duke/duke.jar!/");
                     JarURLConnection jarConnection = (JarURLConnection)url.openConnection();
                     Manifest manifest = jarConnection.getManifest();
                     &lt;/pre&gt;
                    
                     &lt;p&gt;JarURLConnection instances can only be used to read from JAR files.
                     It is not possible to get a {@link java.io.OutputStream} to modify or write
                     to the underlying JAR file using this class.
                     &lt;p&gt;Examples:
                    
                     &lt;dl&gt;
                    
                     &lt;dt&gt;A Jar entry
                     &lt;dd&gt;{@code jar:http://www.foo.com/bar/baz.jar!/COM/foo/Quux.class}
                    
                     &lt;dt&gt;A Jar file
                     &lt;dd&gt;{@code jar:http://www.foo.com/bar/baz.jar!/}
                    
                     &lt;dt&gt;A Jar directory
                     &lt;dd&gt;{@code jar:http://www.foo.com/bar/baz.jar!/COM/foo/}
                    
                     &lt;/dl&gt;
                    
                     &lt;p&gt;{@code !/} is referred to as the &lt;em&gt;separator&lt;/em&gt;.
                    
                     &lt;p&gt;When constructing a JAR url via {@code new URL(context, spec)},
                     the following rules apply:
                    
                     &lt;ul&gt;
                    
                     &lt;li&gt;if there is no context URL and the specification passed to the
                     URL constructor doesn't contain a separator, the URL is considered
                     to refer to a JarFile.
                    
                     &lt;li&gt;if there is a context URL, the context URL is assumed to refer
                     to a JAR file or a Jar directory.
                    
                     &lt;li&gt;if the specification begins with a '/', the Jar directory is
                     ignored, and the spec is considered to be at the root of the Jar
                     file.
                    
                     &lt;p&gt;Examples:
                    
                     &lt;dl&gt;
                    
                     &lt;dt&gt;context: &lt;b&gt;jar:http://www.foo.com/bar/jar.jar!/&lt;/b&gt;,
                     spec:&lt;b&gt;baz/entry.txt&lt;/b&gt;
                    
                     &lt;dd&gt;url:&lt;b&gt;jar:http://www.foo.com/bar/jar.jar!/baz/entry.txt&lt;/b&gt;
                    
                     &lt;dt&gt;context: &lt;b&gt;jar:http://www.foo.com/bar/jar.jar!/baz&lt;/b&gt;,
                     spec:&lt;b&gt;entry.txt&lt;/b&gt;
                    
                     &lt;dd&gt;url:&lt;b&gt;jar:http://www.foo.com/bar/jar.jar!/baz/entry.txt&lt;/b&gt;
                    
                     &lt;dt&gt;context: &lt;b&gt;jar:http://www.foo.com/bar/jar.jar!/baz&lt;/b&gt;,
                     spec:&lt;b&gt;/entry.txt&lt;/b&gt;
                    
                     &lt;dd&gt;url:&lt;b&gt;jar:http://www.foo.com/bar/jar.jar!/entry.txt&lt;/b&gt;
                    
                     &lt;/dl&gt;
                    
                     &lt;/ul&gt;
                    
                     @see java.net.URL
                     @see java.net.URLConnection
                    
                     @see java.util.jar.JarFile
                     @see java.util.jar.JarInputStream
                     @see java.util.jar.Manifest
                     @see java.util.zip.ZipEntry
                    
                     @author Benjamin Renaud
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="RequestorType" access="PUBLIC" declaringClass="Authenticator" kind="TYPE" typeKind="ENUM" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="NoRouteToHostException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.SocketException"/>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that an error occurred while attempting to connect a
                     socket to a remote address and port.  Typically, the remote
                     host cannot be reached because of an intervening firewall, or
                     if an intermediate router is down.
                    
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="ContentHandler" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The abstract class {@code ContentHandler} is the superclass
                     of all classes that read an {@code Object} from a
                     {@code URLConnection}.
                     &lt;p&gt;
                     An application does not generally call the
                     {@code getContent} method in this class directly. Instead, an
                     application calls the {@code getContent} method in class
                     {@code URL} or in {@code URLConnection}.
                     The application's content handler factory (an instance of a class that
                     implements the interface {@code ContentHandlerFactory} set up by a call to
                     {@link URLConnection#setContentHandlerFactory(ContentHandlerFactory)
                     setContentHandlerFactory} is called with a {@code String} giving the
                     MIME type of the object being received on the socket. The factory returns an
                     instance of a subclass of {@code ContentHandler}, and its
                     {@code getContent} method is called to create the object.
                     &lt;p&gt;
                     If no content handler could be {@linkplain URLConnection#getContent() found},
                     URLConnection will look for a content handler in a user-definable set of places.
                     Users can define a vertical-bar delimited set of class prefixes
                     to search through by defining the &lt;i&gt;{@link java.net.URLConnection#contentPathProp}&lt;/i&gt;
                     property. The class name must be of the form:
                     &lt;blockquote&gt;
                         &lt;i&gt;{package-prefix}.{major}.{minor}&lt;/i&gt;
                         &lt;p&gt;
                         where &lt;i&gt;{major}.{minor}&lt;/i&gt; is formed by taking the
                         content-type string, replacing all slash characters with a
                         {@code period} ('.'), and all other non-alphanumeric characters
                         with the underscore character '{@code _}'. The alphanumeric
                         characters are specifically the 26 uppercase ASCII letters
                         '{@code A}' through '{@code Z}', the 26 lowercase ASCII
                         letters '{@code a}' through '{@code z}', and the 10 ASCII
                         digits '{@code 0}' through '{@code 9}'.
                         &lt;p&gt;
                         e.g.
                         YoyoDyne.experimental.text.plain
                     &lt;/blockquote&gt;
                     If no user-defined content handler is found, then the system
                     tries to load a specific &lt;i&gt;content-type&lt;/i&gt; handler from one
                     of the built-in handlers, if one exists.
                     &lt;p&gt;
                     If the loading of the content handler class would be performed by
                     a classloader that is outside of the delegation chain of the caller,
                     the JVM will need the RuntimePermission "getClassLoader".
                    
                     @author  James Gosling
                     @see     java.net.ContentHandler#getContent(java.net.URLConnection)
                     @see     java.net.ContentHandlerFactory
                     @see     java.net.URL#getContent()
                     @see     java.net.URLConnection
                     @see     java.net.URLConnection#getContent()
                     @see     java.net.URLConnection#setContentHandlerFactory(java.net.ContentHandlerFactory)
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ProxySelector" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Selects the proxy server to use, if any, when connecting to the
                     network resource referenced by a URL. A proxy selector is a
                     concrete sub-class of this class and is registered by invoking the
                     {@link java.net.ProxySelector#setDefault setDefault} method. The
                     currently registered proxy selector can be retrieved by calling
                     {@link java.net.ProxySelector#getDefault getDefault} method.
                    
                     &lt;p&gt; When a proxy selector is registered, for instance, a subclass
                     of URLConnection class should call the {@link #select select}
                     method for each URL request so that the proxy selector can decide
                     if a direct, or proxied connection should be used. The {@link
                     #select select} method returns an iterator over a collection with
                     the preferred connection approach.
                    
                     &lt;p&gt; If a connection cannot be established to a proxy (PROXY or
                     SOCKS) servers then the caller should call the proxy selector's
                     {@link #connectFailed connectFailed} method to notify the proxy
                     selector that the proxy server is unavailable. &lt;/p&gt;
                    
                     &lt;P&gt;The default proxy selector does enforce a
                     &lt;a href="doc-files/net-properties.html#Proxies"&gt;set of System Properties&lt;/a&gt;
                     related to proxy settings.&lt;/P&gt;
                    
                     @author Yingxian Wang
                     @author Jean-Christophe Collet
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="IDN" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Provides methods to convert internationalized domain names (IDNs) between
                     a normal Unicode representation and an ASCII Compatible Encoding (ACE) representation.
                     Internationalized domain names can use characters from the entire range of
                     Unicode, while traditional domain names are restricted to ASCII characters.
                     ACE is an encoding of Unicode strings that uses only ASCII characters and
                     can be used with software (such as the Domain Name System) that only
                     understands traditional domain names.
                    
                     &lt;p&gt;Internationalized domain names are defined in &lt;a href="http://www.ietf.org/rfc/rfc3490.txt"&gt;RFC 3490&lt;/a&gt;.
                     RFC 3490 defines two operations: ToASCII and ToUnicode. These 2 operations employ
                     &lt;a href="http://www.ietf.org/rfc/rfc3491.txt"&gt;Nameprep&lt;/a&gt; algorithm, which is a
                     profile of &lt;a href="http://www.ietf.org/rfc/rfc3454.txt"&gt;Stringprep&lt;/a&gt;, and
                     &lt;a href="http://www.ietf.org/rfc/rfc3492.txt"&gt;Punycode&lt;/a&gt; algorithm to convert
                     domain name string back and forth.
                    
                     &lt;p&gt;The behavior of aforementioned conversion process can be adjusted by various flags:
                       &lt;ul&gt;
                         &lt;li&gt;If the ALLOW_UNASSIGNED flag is used, the domain name string to be converted
                             can contain code points that are unassigned in Unicode 3.2, which is the
                             Unicode version on which IDN conversion is based. If the flag is not used,
                             the presence of such unassigned code points is treated as an error.
                         &lt;li&gt;If the USE_STD3_ASCII_RULES flag is used, ASCII strings are checked against &lt;a href="http://www.ietf.org/rfc/rfc1122.txt"&gt;RFC 1122&lt;/a&gt; and &lt;a href="http://www.ietf.org/rfc/rfc1123.txt"&gt;RFC 1123&lt;/a&gt;.
                             It is an error if they don't meet the requirements.
                       &lt;/ul&gt;
                     These flags can be logically OR'ed together.
                    
                     &lt;p&gt;The security consideration is important with respect to internationalization
                     domain name support. For example, English domain names may be &lt;i&gt;homographed&lt;/i&gt;
                     - maliciously misspelled by substitution of non-Latin letters.
                     &lt;a href="http://www.unicode.org/reports/tr36/"&gt;Unicode Technical Report #36&lt;/a&gt;
                     discusses security issues of IDN support as well as possible solutions.
                     Applications are responsible for taking adequate security measures when using
                     international domain names.
                    
                     @author Edward Wang
                     @since 1.6
                    
                    </javadoc>
            </acts>
            <acts name="DatagramPacket" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class represents a datagram packet.
                     &lt;p&gt;
                     Datagram packets are used to implement a connectionless packet
                     delivery service. Each message is routed from one machine to
                     another based solely on information contained within that packet.
                     Multiple packets sent from one machine to another might be routed
                     differently, and might arrive in any order. Packet delivery is
                     not guaranteed.
                    
                     @author  Pavani Diwanji
                     @author  Benjamin Renaud
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="SocketAddress" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                    
                     This class represents a Socket Address with no protocol attachment.
                     As an abstract class, it is meant to be subclassed with a specific,
                     protocol dependent, implementation.
                     &lt;p&gt;
                     It provides an immutable object used by sockets for binding, connecting, or
                     as returned values.
                    
                     @see java.net.Socket
                     @see java.net.ServerSocket
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="Authenticator" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The class Authenticator represents an object that knows how to obtain
                     authentication for a network connection.  Usually, it will do this
                     by prompting the user for information.
                     &lt;p&gt;
                     Applications use this class by overriding {@link
                     #getPasswordAuthentication()} in a sub-class. This method will
                     typically use the various getXXX() accessor methods to get information
                     about the entity requesting authentication. It must then acquire a
                     username and password either by interacting with the user or through
                     some other non-interactive means. The credentials are then returned
                     as a {@link PasswordAuthentication} return value.
                     &lt;p&gt;
                     An instance of this concrete sub-class is then registered
                     with the system by calling {@link #setDefault(Authenticator)}.
                     When authentication is required, the system will invoke one of the
                     requestPasswordAuthentication() methods which in turn will call the
                     getPasswordAuthentication() method of the registered object.
                     &lt;p&gt;
                     All methods that request authentication have a default implementation
                     that fails.
                    
                     @see java.net.Authenticator#setDefault(java.net.Authenticator)
                     @see java.net.Authenticator#getPasswordAuthentication()
                    
                     @author  Bill Foote
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="CookieManager" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.CookieHandler"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     CookieManager provides a concrete implementation of {@link CookieHandler},
                     which separates the storage of cookies from the policy surrounding accepting
                     and rejecting cookies. A CookieManager is initialized with a {@link CookieStore}
                     which manages storage, and a {@link CookiePolicy} object, which makes
                     policy decisions on cookie acceptance/rejection.
                    
                     &lt;p&gt; The HTTP cookie management in java.net package looks like:
                     &lt;blockquote&gt;
                     &lt;pre&gt;{@code
                                      use
                     CookieHandler &lt;------- HttpURLConnection
                           ^
                           | impl
                           |         use
                     CookieManager -------&gt; CookiePolicy
                                 |   use
                                 |--------&gt; HttpCookie
                                 |              ^
                                 |              | use
                                 |   use        |
                                 |--------&gt; CookieStore
                                                ^
                                                | impl
                                                |
                                      Internal in-memory implementation
                     }&lt;/pre&gt;
                     &lt;ul&gt;
                       &lt;li&gt;
                         CookieHandler is at the core of cookie management. User can call
                         CookieHandler.setDefault to set a concrete CookieHanlder implementation
                         to be used.
                       &lt;/li&gt;
                       &lt;li&gt;
                         CookiePolicy.shouldAccept will be called by CookieManager.put to see whether
                         or not one cookie should be accepted and put into cookie store. User can use
                         any of three pre-defined CookiePolicy, namely ACCEPT_ALL, ACCEPT_NONE and
                         ACCEPT_ORIGINAL_SERVER, or user can define his own CookiePolicy implementation
                         and tell CookieManager to use it.
                       &lt;/li&gt;
                       &lt;li&gt;
                         CookieStore is the place where any accepted HTTP cookie is stored in.
                         If not specified when created, a CookieManager instance will use an internal
                         in-memory implementation. Or user can implements one and tell CookieManager
                         to use it.
                       &lt;/li&gt;
                       &lt;li&gt;
                         Currently, only CookieStore.add(URI, HttpCookie) and CookieStore.get(URI)
                         are used by CookieManager. Others are for completeness and might be needed
                         by a more sophisticated CookieStore implementation, e.g. a NetscapeCookieStore.
                       &lt;/li&gt;
                     &lt;/ul&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt;There're various ways user can hook up his own HTTP cookie management behavior, e.g.
                     &lt;blockquote&gt;
                     &lt;ul&gt;
                       &lt;li&gt;Use CookieHandler.setDefault to set a brand new {@link CookieHandler} implementation
                       &lt;li&gt;Let CookieManager be the default {@link CookieHandler} implementation,
                           but implement user's own {@link CookieStore} and {@link CookiePolicy}
                           and tell default CookieManager to use them:
                         &lt;blockquote&gt;&lt;pre&gt;
                           // this should be done at the beginning of an HTTP session
                           CookieHandler.setDefault(new CookieManager(new MyCookieStore(), new MyCookiePolicy()));
                         &lt;/pre&gt;&lt;/blockquote&gt;
                       &lt;li&gt;Let CookieManager be the default {@link CookieHandler} implementation, but
                           use customized {@link CookiePolicy}:
                         &lt;blockquote&gt;&lt;pre&gt;
                           // this should be done at the beginning of an HTTP session
                           CookieHandler.setDefault(new CookieManager());
                           // this can be done at any point of an HTTP session
                           ((CookieManager)CookieHandler.getDefault()).setCookiePolicy(new MyCookiePolicy());
                         &lt;/pre&gt;&lt;/blockquote&gt;
                     &lt;/ul&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt;The implementation conforms to &lt;a href="http://www.ietf.org/rfc/rfc2965.txt"&gt;RFC 2965&lt;/a&gt;, section 3.3.
                    
                     @see CookiePolicy
                     @author Edward Wang
                     @since 1.6
                    </javadoc>
            </acts>
            <acts name="PasswordAuthentication" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The class PasswordAuthentication is a data holder that is used by
                     Authenticator.  It is simply a repository for a user name and a password.
                    
                     @see java.net.Authenticator
                     @see java.net.Authenticator#getPasswordAuthentication()
                    
                     @author  Bill Foote
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="ContentHandlerFactory" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.net">
                <superTypes/>
                <javadoc xml:space="preserve">
                     This interface defines a factory for content handlers. An
                     implementation of this interface should map a MIME type into an
                     instance of {@code ContentHandler}.
                     &lt;p&gt;
                     This interface is used by the {@code URLStreamHandler} class
                     to create a {@code ContentHandler} for a MIME type.
                    
                     @author  James Gosling
                     @see     java.net.ContentHandler
                     @see     java.net.URLStreamHandler
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Inet4Address" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.InetAddress"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class represents an Internet Protocol version 4 (IPv4) address.
                     Defined by &lt;a href="http://www.ietf.org/rfc/rfc790.txt"&gt;
                     &lt;i&gt;RFC&amp;nbsp;790: Assigned Numbers&lt;/i&gt;&lt;/a&gt;,
                     &lt;a href="http://www.ietf.org/rfc/rfc1918.txt"&gt;
                     &lt;i&gt;RFC&amp;nbsp;1918: Address Allocation for Private Internets&lt;/i&gt;&lt;/a&gt;,
                     and &lt;a href="http://www.ietf.org/rfc/rfc2365.txt"&gt;&lt;i&gt;RFC&amp;nbsp;2365:
                     Administratively Scoped IP Multicast&lt;/i&gt;&lt;/a&gt;
                    
                     &lt;h3&gt; &lt;a id="format"&gt;Textual representation of IP addresses&lt;/a&gt; &lt;/h3&gt;
                    
                     Textual representation of IPv4 address used as input to methods
                     takes one of the following forms:
                    
                     &lt;blockquote&gt;&lt;ul style="list-style-type:none"&gt;
                     &lt;li&gt;{@code d.d.d.d}&lt;/li&gt;
                     &lt;li&gt;{@code d.d.d}&lt;/li&gt;
                     &lt;li&gt;{@code d.d}&lt;/li&gt;
                     &lt;li&gt;{@code d}&lt;/li&gt;
                     &lt;/ul&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt; When four parts are specified, each is interpreted as a byte of
                     data and assigned, from left to right, to the four bytes of an IPv4
                     address.
                    
                     &lt;p&gt; When a three part address is specified, the last part is
                     interpreted as a 16-bit quantity and placed in the right most two
                     bytes of the network address. This makes the three part address
                     format convenient for specifying Class B net- work addresses as
                     128.net.host.
                    
                     &lt;p&gt; When a two part address is supplied, the last part is
                     interpreted as a 24-bit quantity and placed in the right most three
                     bytes of the network address. This makes the two part address
                     format convenient for specifying Class A network addresses as
                     net.host.
                    
                     &lt;p&gt; When only one part is given, the value is stored directly in
                     the network address without any byte rearrangement.
                    
                     &lt;p&gt; For methods that return a textual representation as output
                     value, the first form, i.e. a dotted-quad string, is used.
                    
                     &lt;h4&gt; The Scope of a Multicast Address &lt;/h4&gt;
                    
                     Historically the IPv4 TTL field in the IP header has doubled as a
                     multicast scope field: a TTL of 0 means node-local, 1 means
                     link-local, up through 32 means site-local, up through 64 means
                     region-local, up through 128 means continent-local, and up through
                     255 are global. However, the administrative scoping is preferred.
                     Please refer to &lt;a href="http://www.ietf.org/rfc/rfc2365.txt"&gt;
                     &lt;i&gt;RFC&amp;nbsp;2365: Administratively Scoped IP Multicast&lt;/i&gt;&lt;/a&gt;
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="InterfaceAddress" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class represents a Network Interface address. In short it's an
                     IP address, a subnet mask and a broadcast address when the address is
                     an IPv4 one. An IP address and a network prefix length in the case
                     of IPv6 address.
                    
                     @see java.net.NetworkInterface
                     @since 1.6
                    </javadoc>
            </acts>
            <acts name="SocketImplFactory" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.net">
                <superTypes/>
                <javadoc xml:space="preserve">
                     This interface defines a factory for socket implementations. It
                     is used by the classes {@code Socket} and
                     {@code ServerSocket} to create actual socket
                     implementations.
                    
                     @author  Arthur van Hoff
                     @see     java.net.Socket
                     @see     java.net.ServerSocket
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="BindException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.SocketException"/>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that an error occurred while attempting to bind a
                     socket to a local address and port.  Typically, the port is
                     in use, or the requested local address could not be assigned.
                    
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="NetworkInterface" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class represents a Network Interface made up of a name,
                     and a list of IP addresses assigned to this interface.
                     It is used to identify the local interface on which a multicast group
                     is joined.
                    
                     Interfaces are normally known by names such as "le0".
                    
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="Inet6Address" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.InetAddress"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class represents an Internet Protocol version 6 (IPv6) address.
                     Defined by &lt;a href="http://www.ietf.org/rfc/rfc2373.txt"&gt;
                     &lt;i&gt;RFC&amp;nbsp;2373: IP Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt;.
                    
                     &lt;h3&gt; &lt;a id="format"&gt;Textual representation of IP addresses&lt;/a&gt; &lt;/h3&gt;
                    
                     Textual representation of IPv6 address used as input to methods
                     takes one of the following forms:
                    
                     &lt;ol&gt;
                       &lt;li&gt;&lt;p&gt; &lt;a id="lform"&gt;The preferred form&lt;/a&gt; is x:x:x:x:x:x:x:x,
                       where the 'x's are
                       the hexadecimal values of the eight 16-bit pieces of the
                       address. This is the full form.  For example,
                    
                       &lt;blockquote&gt;&lt;ul style="list-style-type:none"&gt;
                       &lt;li&gt;{@code 1080:0:0:0:8:800:200C:417A}&lt;/li&gt;
                       &lt;/ul&gt;&lt;/blockquote&gt;
                    
                       &lt;p&gt; Note that it is not necessary to write the leading zeros in
                       an individual field. However, there must be at least one numeral
                       in every field, except as described below.&lt;/li&gt;
                    
                       &lt;li&gt;&lt;p&gt; Due to some methods of allocating certain styles of IPv6
                       addresses, it will be common for addresses to contain long
                       strings of zero bits. In order to make writing addresses
                       containing zero bits easier, a special syntax is available to
                       compress the zeros. The use of "::" indicates multiple groups
                       of 16-bits of zeros. The "::" can only appear once in an address.
                       The "::" can also be used to compress the leading and/or trailing
                       zeros in an address. For example,
                    
                       &lt;blockquote&gt;&lt;ul style="list-style-type:none"&gt;
                       &lt;li&gt;{@code 1080::8:800:200C:417A}&lt;/li&gt;
                       &lt;/ul&gt;&lt;/blockquote&gt;
                    
                       &lt;li&gt;&lt;p&gt; An alternative form that is sometimes more convenient
                       when dealing with a mixed environment of IPv4 and IPv6 nodes is
                       x:x:x:x:x:x:d.d.d.d, where the 'x's are the hexadecimal values
                       of the six high-order 16-bit pieces of the address, and the 'd's
                       are the decimal values of the four low-order 8-bit pieces of the
                       standard IPv4 representation address, for example,
                    
                       &lt;blockquote&gt;&lt;ul style="list-style-type:none"&gt;
                       &lt;li&gt;{@code ::FFFF:129.144.52.38}&lt;/li&gt;
                       &lt;li&gt;{@code ::129.144.52.38}&lt;/li&gt;
                       &lt;/ul&gt;&lt;/blockquote&gt;
                    
                       &lt;p&gt; where "::FFFF:d.d.d.d" and "::d.d.d.d" are, respectively, the
                       general forms of an IPv4-mapped IPv6 address and an
                       IPv4-compatible IPv6 address. Note that the IPv4 portion must be
                       in the "d.d.d.d" form. The following forms are invalid:
                    
                       &lt;blockquote&gt;&lt;ul style="list-style-type:none"&gt;
                       &lt;li&gt;{@code ::FFFF:d.d.d}&lt;/li&gt;
                       &lt;li&gt;{@code ::FFFF:d.d}&lt;/li&gt;
                       &lt;li&gt;{@code ::d.d.d}&lt;/li&gt;
                       &lt;li&gt;{@code ::d.d}&lt;/li&gt;
                       &lt;/ul&gt;&lt;/blockquote&gt;
                    
                       &lt;p&gt; The following form:
                    
                       &lt;blockquote&gt;&lt;ul style="list-style-type:none"&gt;
                       &lt;li&gt;{@code ::FFFF:d}&lt;/li&gt;
                       &lt;/ul&gt;&lt;/blockquote&gt;
                    
                       &lt;p&gt; is valid, however it is an unconventional representation of
                       the IPv4-compatible IPv6 address,
                    
                       &lt;blockquote&gt;&lt;ul style="list-style-type:none"&gt;
                       &lt;li&gt;{@code ::255.255.0.d}&lt;/li&gt;
                       &lt;/ul&gt;&lt;/blockquote&gt;
                    
                       &lt;p&gt; while "::d" corresponds to the general IPv6 address
                       "0:0:0:0:0:0:0:d".&lt;/li&gt;
                     &lt;/ol&gt;
                    
                     &lt;p&gt; For methods that return a textual representation as output
                     value, the full form is used. Inet6Address will return the full
                     form because it is unambiguous when used in combination with other
                     textual data.
                    
                     &lt;h4&gt; Special IPv6 address &lt;/h4&gt;
                    
                     &lt;blockquote&gt;
                     &lt;table class="borderless"&gt;
                     &lt;caption style="display:none"&gt;Description of IPv4-mapped address&lt;/caption&gt;
                     &lt;tr&gt;&lt;th style="vertical-align:top; padding-right:2px"&gt;&lt;i&gt;IPv4-mapped address&lt;/i&gt;&lt;/th&gt;
                             &lt;td&gt;Of the form ::ffff:w.x.y.z, this IPv6 address is used to
                             represent an IPv4 address. It allows the native program to
                             use the same address data structure and also the same
                             socket when communicating with both IPv4 and IPv6 nodes.
                    
                             &lt;p&gt;In InetAddress and Inet6Address, it is used for internal
                             representation; it has no functional role. Java will never
                             return an IPv4-mapped address.  These classes can take an
                             IPv4-mapped address as input, both in byte array and text
                             representation. However, it will be converted into an IPv4
                             address.&lt;/td&gt;&lt;/tr&gt;
                     &lt;/table&gt;&lt;/blockquote&gt;
                    
                     &lt;h4&gt;&lt;a id="scoped"&gt;Textual representation of IPv6 scoped addresses&lt;/a&gt;&lt;/h4&gt;
                    
                     &lt;p&gt; The textual representation of IPv6 addresses as described above can be
                     extended to specify IPv6 scoped addresses. This extension to the basic
                     addressing architecture is described in [draft-ietf-ipngwg-scoping-arch-04.txt].
                    
                     &lt;p&gt; Because link-local and site-local addresses are non-global, it is possible
                     that different hosts may have the same destination address and may be
                     reachable through different interfaces on the same originating system. In
                     this case, the originating system is said to be connected to multiple zones
                     of the same scope. In order to disambiguate which is the intended destination
                     zone, it is possible to append a zone identifier (or &lt;i&gt;scope_id&lt;/i&gt;) to an
                     IPv6 address.
                    
                     &lt;p&gt; The general format for specifying the &lt;i&gt;scope_id&lt;/i&gt; is the following:
                    
                     &lt;blockquote&gt;&lt;i&gt;IPv6-address&lt;/i&gt;%&lt;i&gt;scope_id&lt;/i&gt;&lt;/blockquote&gt;
                     &lt;p&gt; The IPv6-address is a literal IPv6 address as described above.
                     The &lt;i&gt;scope_id&lt;/i&gt; refers to an interface on the local system, and it can be
                     specified in two ways.
                     &lt;ol&gt;&lt;li&gt;&lt;i&gt;As a numeric identifier.&lt;/i&gt; This must be a positive integer
                     that identifies the particular interface and scope as understood by the
                     system. Usually, the numeric values can be determined through administration
                     tools on the system. Each interface may have multiple values, one for each
                     scope. If the scope is unspecified, then the default value used is zero.&lt;/li&gt;
                     &lt;li&gt;&lt;i&gt;As a string.&lt;/i&gt; This must be the exact string that is returned by
                     {@link java.net.NetworkInterface#getName()} for the particular interface in
                     question. When an Inet6Address is created in this way, the numeric scope-id
                     is determined at the time the object is created by querying the relevant
                     NetworkInterface.&lt;/li&gt;&lt;/ol&gt;
                    
                     &lt;p&gt; Note also, that the numeric &lt;i&gt;scope_id&lt;/i&gt; can be retrieved from
                     Inet6Address instances returned from the NetworkInterface class. This can be
                     used to find out the current scope ids configured on the system.
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="FileNameMap" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.net">
                <superTypes/>
                <javadoc xml:space="preserve">
                     A simple interface which provides a mechanism to map
                     between a file name and a MIME type string.
                    
                     @author  Steven B. Byrne
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="URLStreamHandler" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The abstract class {@code URLStreamHandler} is the common
                     superclass for all stream protocol handlers. A stream protocol
                     handler knows how to make a connection for a particular protocol
                     type, such as {@code http} or {@code https}.
                     &lt;p&gt;
                     In most cases, an instance of a {@code URLStreamHandler}
                     subclass is not created directly by an application. Rather, the
                     first time a protocol name is encountered when constructing a
                     {@code URL}, the appropriate stream protocol handler is
                     automatically loaded.
                    
                     @author  James Gosling
                     @see     java.net.URL#URL(java.lang.String, java.lang.String, int, java.lang.String)
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="CacheResponse" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Represent channels for retrieving resources from the
                     ResponseCache. Instances of such a class provide an
                     InputStream that returns the entity body, and also a
                     getHeaders() method which returns the associated response headers.
                    
                     @author Yingxian Wang
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="CookieStore" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.net">
                <superTypes/>
                <javadoc xml:space="preserve">
                     A CookieStore object represents a storage for cookie. Can store and retrieve
                     cookies.
                    
                     &lt;p&gt;{@link CookieManager} will call {@code CookieStore.add} to save cookies
                     for every incoming HTTP response, and call {@code CookieStore.get} to
                     retrieve cookie for every outgoing HTTP request. A CookieStore
                     is responsible for removing HttpCookie instances which have expired.
                    
                     @author Edward Wang
                     @since 1.6
                    </javadoc>
            </acts>
            <acts name="SocketTimeoutException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.InterruptedIOException"/>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that a timeout has occurred on a socket read or accept.
                    
                     @since   1.4
                    </javadoc>
            </acts>
            <acts name="NetPermission" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.security.BasicPermission"/>
                    <superType superType="java.security.Permission"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class is for various network permissions.
                     A NetPermission contains a name (also referred to as a "target name") but
                     no actions list; you either have the named permission
                     or you don't.
                     &lt;P&gt;
                     The target name is the name of the network permission (see below). The naming
                     convention follows the  hierarchical property naming convention.
                     Also, an asterisk
                     may appear at the end of the name, following a ".", or by itself, to
                     signify a wildcard match. For example: "foo.*" and "*" signify a wildcard
                     match, while "*foo" and "a*b" do not.
                     &lt;P&gt;
                     The following table lists all the possible NetPermission target names,
                     and for each provides a description of what the permission allows
                     and a discussion of the risks of granting code the permission.
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;Permission target name, what the permission allows, and associated risks&lt;/caption&gt;
                     &lt;thead&gt;
                     &lt;tr&gt;
                     &lt;th scope="col"&gt;Permission Target Name&lt;/th&gt;
                     &lt;th scope="col"&gt;What the Permission Allows&lt;/th&gt;
                     &lt;th scope="col"&gt;Risks of Allowing this Permission&lt;/th&gt;
                     &lt;/tr&gt;
                     &lt;/thead&gt;
                     &lt;tbody&gt;
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;allowHttpTrace&lt;/th&gt;
                       &lt;td&gt;The ability to use the HTTP TRACE method in HttpURLConnection.&lt;/td&gt;
                       &lt;td&gt;Malicious code using HTTP TRACE could get access to security sensitive
                       information in the HTTP headers (such as cookies) that it might not
                       otherwise have access to.&lt;/td&gt;
                       &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;getCookieHandler&lt;/th&gt;
                       &lt;td&gt;The ability to get the cookie handler that processes highly
                       security sensitive cookie information for an Http session.&lt;/td&gt;
                       &lt;td&gt;Malicious code can get a cookie handler to obtain access to
                       highly security sensitive cookie information. Some web servers
                       use cookies to save user private information such as access
                       control information, or to track user browsing habit.&lt;/td&gt;
                       &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;getNetworkInformation&lt;/th&gt;
                       &lt;td&gt;The ability to retrieve all information about local network interfaces.&lt;/td&gt;
                       &lt;td&gt;Malicious code can read information about network hardware such as
                       MAC addresses, which could be used to construct local IPv6 addresses.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;getProxySelector&lt;/th&gt;
                       &lt;td&gt;The ability to get the proxy selector used to make decisions
                       on which proxies to use when making network connections.&lt;/td&gt;
                       &lt;td&gt;Malicious code can get a ProxySelector to discover proxy
                       hosts and ports on internal networks, which could then become
                       targets for attack.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;getResponseCache&lt;/th&gt;
                       &lt;td&gt;The ability to get the response cache that provides
                       access to a local response cache.&lt;/td&gt;
                       &lt;td&gt;Malicious code getting access to the local response cache
                       could access security sensitive information.&lt;/td&gt;
                       &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;requestPasswordAuthentication&lt;/th&gt;
                       &lt;td&gt;The ability
                       to ask the authenticator registered with the system for
                       a password&lt;/td&gt;
                       &lt;td&gt;Malicious code may steal this password.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;setCookieHandler&lt;/th&gt;
                       &lt;td&gt;The ability to set the cookie handler that processes highly
                       security sensitive cookie information for an Http session.&lt;/td&gt;
                       &lt;td&gt;Malicious code can set a cookie handler to obtain access to
                       highly security sensitive cookie information. Some web servers
                       use cookies to save user private information such as access
                       control information, or to track user browsing habit.&lt;/td&gt;
                       &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;setDefaultAuthenticator&lt;/th&gt;
                       &lt;td&gt;The ability to set the
                       way authentication information is retrieved when
                       a proxy or HTTP server asks for authentication&lt;/td&gt;
                       &lt;td&gt;Malicious
                       code can set an authenticator that monitors and steals user
                       authentication input as it retrieves the input from the user.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;setProxySelector&lt;/th&gt;
                       &lt;td&gt;The ability to set the proxy selector used to make decisions
                       on which proxies to use when making network connections.&lt;/td&gt;
                       &lt;td&gt;Malicious code can set a ProxySelector that directs network
                       traffic to an arbitrary network host.&lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;setResponseCache&lt;/th&gt;
                       &lt;td&gt;The ability to set the response cache that provides access to
                       a local response cache.&lt;/td&gt;
                       &lt;td&gt;Malicious code getting access to the local response cache
                       could access security sensitive information, or create false
                       entries in the response cache.&lt;/td&gt;
                       &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;setSocketImpl&lt;/th&gt;
                       &lt;td&gt;The ability to create a sub-class of Socket or ServerSocket with a
                       user specified SocketImpl.&lt;/td&gt;
                       &lt;td&gt;Malicious user-defined SocketImpls can change the behavior of
                       Socket and ServerSocket in surprising ways, by virtue of their
                       ability to access the protected fields of SocketImpl.&lt;/td&gt;
                       &lt;/tr&gt;
                    
                     &lt;tr&gt;
                       &lt;th scope="row"&gt;specifyStreamHandler&lt;/th&gt;
                       &lt;td&gt;The ability
                       to specify a stream handler when constructing a URL&lt;/td&gt;
                       &lt;td&gt;Malicious code may create a URL with resources that it would
                       normally not have access to (like file:/foo/fum/), specifying a
                       stream handler that gets the actual bytes from someplace it does
                       have access to. Thus it might be able to trick the system into
                       creating a ProtectionDomain/CodeSource for a class even though
                       that class really didn't come from that location.&lt;/td&gt;
                     &lt;/tr&gt;
                       &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     @see java.security.BasicPermission
                     @see java.security.Permission
                     @see java.security.Permissions
                     @see java.security.PermissionCollection
                     @see java.lang.SecurityManager
                    
                    
                     @author Marianne Mueller
                     @author Roland Schemers
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="URLDecoder" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Utility class for HTML form decoding. This class contains static methods
                     for decoding a String from the &lt;CODE&gt;application/x-www-form-urlencoded&lt;/CODE&gt;
                     MIME format.
                     &lt;p&gt;
                     The conversion process is the reverse of that used by the URLEncoder class. It is assumed
                     that all characters in the encoded string are one of the following:
                     &amp;quot;{@code a}&amp;quot; through &amp;quot;{@code z}&amp;quot;,
                     &amp;quot;{@code A}&amp;quot; through &amp;quot;{@code Z}&amp;quot;,
                     &amp;quot;{@code 0}&amp;quot; through &amp;quot;{@code 9}&amp;quot;, and
                     &amp;quot;{@code -}&amp;quot;, &amp;quot;{@code _}&amp;quot;,
                     &amp;quot;{@code .}&amp;quot;, and &amp;quot;{@code *}&amp;quot;. The
                     character &amp;quot;{@code %}&amp;quot; is allowed but is interpreted
                     as the start of a special escaped sequence.
                     &lt;p&gt;
                     The following rules are applied in the conversion:
                    
                     &lt;ul&gt;
                     &lt;li&gt;The alphanumeric characters &amp;quot;{@code a}&amp;quot; through
                         &amp;quot;{@code z}&amp;quot;, &amp;quot;{@code A}&amp;quot; through
                         &amp;quot;{@code Z}&amp;quot; and &amp;quot;{@code 0}&amp;quot;
                         through &amp;quot;{@code 9}&amp;quot; remain the same.
                     &lt;li&gt;The special characters &amp;quot;{@code .}&amp;quot;,
                         &amp;quot;{@code -}&amp;quot;, &amp;quot;{@code *}&amp;quot;, and
                         &amp;quot;{@code _}&amp;quot; remain the same.
                     &lt;li&gt;The plus sign &amp;quot;{@code +}&amp;quot; is converted into a
                         space character &amp;quot; &amp;nbsp; &amp;quot; .
                     &lt;li&gt;A sequence of the form "&lt;i&gt;{@code %xy}&lt;/i&gt;" will be
                         treated as representing a byte where &lt;i&gt;xy&lt;/i&gt; is the two-digit
                         hexadecimal representation of the 8 bits. Then, all substrings
                         that contain one or more of these byte sequences consecutively
                         will be replaced by the character(s) whose encoding would result
                         in those consecutive bytes.
                         The encoding scheme used to decode these characters may be specified,
                         or if unspecified, the default encoding of the platform will be used.
                     &lt;/ul&gt;
                     &lt;p&gt;
                     There are two possible ways in which this decoder could deal with
                     illegal strings.  It could either leave illegal characters alone or
                     it could throw an {@link java.lang.IllegalArgumentException}.
                     Which approach the decoder takes is left to the
                     implementation.
                    
                     @author  Mark Chamness
                     @author  Michael McCloskey
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="URLPermission" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.security.Permission"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Represents permission to access a resource or set of resources defined by a
                     given url, and for a given set of user-settable request methods
                     and request headers. The &lt;i&gt;name&lt;/i&gt; of the permission is the url string.
                     The &lt;i&gt;actions&lt;/i&gt; string is a concatenation of the request methods and headers.
                     The range of method and header names is not restricted by this class.
                     &lt;p&gt;&lt;b&gt;The url&lt;/b&gt;&lt;p&gt;
                     The url string has the following expected structure.
                     &lt;pre&gt;
                         scheme : // authority [ / path ]
                     &lt;/pre&gt;
                     &lt;i&gt;scheme&lt;/i&gt; will typically be http or https, but is not restricted by this
                     class.
                     &lt;i&gt;authority&lt;/i&gt; is specified as:
                     &lt;pre&gt;
                         authority = [ userinfo @ ] hostrange [ : portrange ]
                         portrange = portnumber | -portnumber | portnumber-[portnumber] | *
                         hostrange = ([*.] dnsname) | IPv4address | IPv6address
                     &lt;/pre&gt;
                     &lt;i&gt;dnsname&lt;/i&gt; is a standard DNS host or domain name, ie. one or more labels
                     separated by ".". &lt;i&gt;IPv4address&lt;/i&gt; is a standard literal IPv4 address and
                     &lt;i&gt;IPv6address&lt;/i&gt; is as defined in &lt;a href="http://www.ietf.org/rfc/rfc2732.txt"&gt;
                     RFC 2732&lt;/a&gt;. Literal IPv6 addresses must however, be enclosed in '[]' characters.
                     The &lt;i&gt;dnsname&lt;/i&gt; specification can be preceded by "*." which means
                     the name will match any hostname whose right-most domain labels are the same as
                     this name. For example, "*.oracle.com" matches "foo.bar.oracle.com"
                     &lt;p&gt;
                     &lt;i&gt;portrange&lt;/i&gt; is used to specify a port number, or a bounded or unbounded range of ports
                     that this permission applies to. If portrange is absent or invalid, then a default
                     port number is assumed if the scheme is {@code http} (default 80) or {@code https}
                     (default 443). No default is assumed for other schemes. A wildcard may be specified
                     which means all ports.
                     &lt;p&gt;
                     &lt;i&gt;userinfo&lt;/i&gt; is optional. A userinfo component if present, is ignored when
                     creating a URLPermission, and has no effect on any other methods defined by this class.
                     &lt;p&gt;
                     The &lt;i&gt;path&lt;/i&gt; component comprises a sequence of path segments,
                     separated by '/' characters. &lt;i&gt;path&lt;/i&gt; may also be empty. The path is specified
                     in a similar way to the path in {@link java.io.FilePermission}. There are
                     three different ways as the following examples show:
                     &lt;table class="striped"&gt;
                     &lt;caption&gt;URL Examples&lt;/caption&gt;
                     &lt;thead&gt;
                     &lt;tr&gt;&lt;th scope="col"&gt;Example url&lt;/th&gt;&lt;th scope="col"&gt;Description&lt;/th&gt;&lt;/tr&gt;
                     &lt;/thead&gt;
                     &lt;tbody style="text-align:left"&gt;
                     &lt;tr&gt;&lt;th scope="row" style="white-space:nowrap;"&gt;http://www.oracle.com/a/b/c.html&lt;/th&gt;
                       &lt;td&gt;A url which identifies a specific (single) resource&lt;/td&gt;
                     &lt;/tr&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;http://www.oracle.com/a/b/*&lt;/th&gt;
                       &lt;td&gt;The '*' character refers to all resources in the same "directory" - in
                           other words all resources with the same number of path components, and
                           which only differ in the final path component, represented by the '*'.
                       &lt;/td&gt;
                     &lt;/tr&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;http://www.oracle.com/a/b/-&lt;/th&gt;
                       &lt;td&gt;The '-' character refers to all resources recursively below the
                           preceding path (eg. http://www.oracle.com/a/b/c/d/e.html matches this
                           example).
                       &lt;/td&gt;
                     &lt;/tr&gt;
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                     &lt;p&gt;
                     The '*' and '-' may only be specified in the final segment of a path and must be
                     the only character in that segment. Any query or fragment components of the
                     url are ignored when constructing URLPermissions.
                     &lt;p&gt;
                     As a special case, urls of the form, "scheme:*" are accepted to
                     mean any url of the given scheme.
                     &lt;p&gt;
                     The &lt;i&gt;scheme&lt;/i&gt; and &lt;i&gt;authority&lt;/i&gt; components of the url string are handled
                     without regard to case. This means {@link #equals(Object)},
                     {@link #hashCode()} and {@link #implies(Permission)} are case insensitive with respect
                     to these components. If the &lt;i&gt;authority&lt;/i&gt; contains a literal IP address,
                     then the address is normalized for comparison. The path component is case sensitive.
                     &lt;p&gt;&lt;b&gt;The actions string&lt;/b&gt;&lt;p&gt;
                     The actions string of a URLPermission is a concatenation of the &lt;i&gt;method list&lt;/i&gt;
                     and the &lt;i&gt;request headers list&lt;/i&gt;. These are lists of the permitted request
                     methods and permitted request headers of the permission (respectively). The two lists
                     are separated by a colon ':' character and elements of each list are comma separated.
                     Some examples are:
                     &lt;ul&gt;
                     &lt;li&gt;"POST,GET,DELETE"
                     &lt;li&gt;"GET:X-Foo-Request,X-Bar-Request"
                     &lt;li&gt;"POST,GET:Header1,Header2"
                     &lt;/ul&gt;
                     &lt;p&gt;
                     The first example specifies the methods: POST, GET and DELETE, but no request headers.
                     The second example specifies one request method and two headers. The third
                     example specifies two request methods, and two headers.
                     &lt;p&gt;
                     The colon separator need not be present if the request headers list is empty.
                     No white-space is permitted in the actions string. The action strings supplied to
                     the URLPermission constructors are case-insensitive and are normalized by converting
                     method names to upper-case and header names to the form defines in RFC2616 (lower case
                     with initial letter of each word capitalized). Either list can contain a wild-card '*'
                     character which signifies all request methods or headers respectively.
                     &lt;p&gt;
                     Note. Depending on the context of use, some request methods and headers may be permitted
                     at all times, and others may not be permitted at any time. For example, the
                     HTTP protocol handler might disallow certain headers such as Content-Length
                     from being set by application code, regardless of whether the security policy
                     in force, permits it.
                    
                     @since 1.8
                    </javadoc>
            </acts>
            <acts name="HttpCookie" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An HttpCookie object represents an HTTP cookie, which carries state
                     information between server and user agent. Cookie is widely adopted
                     to create stateful sessions.
                    
                     &lt;p&gt; There are 3 HTTP cookie specifications:
                     &lt;blockquote&gt;
                       Netscape draft&lt;br&gt;
                       RFC 2109 - &lt;a href="http://www.ietf.org/rfc/rfc2109.txt"&gt;
                     &lt;i&gt;http://www.ietf.org/rfc/rfc2109.txt&lt;/i&gt;&lt;/a&gt;&lt;br&gt;
                       RFC 2965 - &lt;a href="http://www.ietf.org/rfc/rfc2965.txt"&gt;
                     &lt;i&gt;http://www.ietf.org/rfc/rfc2965.txt&lt;/i&gt;&lt;/a&gt;
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt; HttpCookie class can accept all these 3 forms of syntax.
                    
                     @author Edward Wang
                     @since 1.6
                    </javadoc>
            </acts>
            <acts name="InetAddress" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class represents an Internet Protocol (IP) address.
                    
                     &lt;p&gt; An IP address is either a 32-bit or 128-bit unsigned number
                     used by IP, a lower-level protocol on which protocols like UDP and
                     TCP are built. The IP address architecture is defined by &lt;a
                     href="http://www.ietf.org/rfc/rfc790.txt"&gt;&lt;i&gt;RFC&amp;nbsp;790:
                     Assigned Numbers&lt;/i&gt;&lt;/a&gt;, &lt;a
                     href="http://www.ietf.org/rfc/rfc1918.txt"&gt; &lt;i&gt;RFC&amp;nbsp;1918:
                     Address Allocation for Private Internets&lt;/i&gt;&lt;/a&gt;, &lt;a
                     href="http://www.ietf.org/rfc/rfc2365.txt"&gt;&lt;i&gt;RFC&amp;nbsp;2365:
                     Administratively Scoped IP Multicast&lt;/i&gt;&lt;/a&gt;, and &lt;a
                     href="http://www.ietf.org/rfc/rfc2373.txt"&gt;&lt;i&gt;RFC&amp;nbsp;2373: IP
                     Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt;. An instance of an
                     InetAddress consists of an IP address and possibly its
                     corresponding host name (depending on whether it is constructed
                     with a host name or whether it has already done reverse host name
                     resolution).
                    
                     &lt;h3&gt; Address types &lt;/h3&gt;
                    
                     &lt;table class="striped" style="margin-left:2em"&gt;
                       &lt;caption style="display:none"&gt;Description of unicast and multicast address types&lt;/caption&gt;
                       &lt;thead&gt;
                       &lt;tr&gt;&lt;th scope="col"&gt;Address Type&lt;/th&gt;&lt;th scope="col"&gt;Description&lt;/th&gt;&lt;/tr&gt;
                       &lt;/thead&gt;
                       &lt;tbody&gt;
                       &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;unicast&lt;/th&gt;
                           &lt;td&gt;An identifier for a single interface. A packet sent to
                             a unicast address is delivered to the interface identified by
                             that address.
                    
                             &lt;p&gt; The Unspecified Address -- Also called anylocal or wildcard
                             address. It must never be assigned to any node. It indicates the
                             absence of an address. One example of its use is as the target of
                             bind, which allows a server to accept a client connection on any
                             interface, in case the server host has multiple interfaces.
                    
                             &lt;p&gt; The &lt;i&gt;unspecified&lt;/i&gt; address must not be used as
                             the destination address of an IP packet.
                    
                             &lt;p&gt; The &lt;i&gt;Loopback&lt;/i&gt; Addresses -- This is the address
                             assigned to the loopback interface. Anything sent to this
                             IP address loops around and becomes IP input on the local
                             host. This address is often used when testing a
                             client.&lt;/td&gt;&lt;/tr&gt;
                       &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;multicast&lt;/th&gt;
                           &lt;td&gt;An identifier for a set of interfaces (typically belonging
                             to different nodes). A packet sent to a multicast address is
                             delivered to all interfaces identified by that address.&lt;/td&gt;&lt;/tr&gt;
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;h4&gt; IP address scope &lt;/h4&gt;
                    
                     &lt;p&gt; &lt;i&gt;Link-local&lt;/i&gt; addresses are designed to be used for addressing
                     on a single link for purposes such as auto-address configuration,
                     neighbor discovery, or when no routers are present.
                    
                     &lt;p&gt; &lt;i&gt;Site-local&lt;/i&gt; addresses are designed to be used for addressing
                     inside of a site without the need for a global prefix.
                    
                     &lt;p&gt; &lt;i&gt;Global&lt;/i&gt; addresses are unique across the internet.
                    
                     &lt;h4&gt; Textual representation of IP addresses &lt;/h4&gt;
                    
                     The textual representation of an IP address is address family specific.
                    
                     &lt;p&gt;
                    
                     For IPv4 address format, please refer to &lt;A
                     HREF="Inet4Address.html#format"&gt;Inet4Address#format&lt;/A&gt;; For IPv6
                     address format, please refer to &lt;A
                     HREF="Inet6Address.html#format"&gt;Inet6Address#format&lt;/A&gt;.
                    
                     &lt;P&gt;There is a &lt;a href="doc-files/net-properties.html#Ipv4IPv6"&gt;couple of
                     System Properties&lt;/a&gt; affecting how IPv4 and IPv6 addresses are used.&lt;/P&gt;
                    
                     &lt;h4&gt; Host Name Resolution &lt;/h4&gt;
                    
                     Host name-to-IP address &lt;i&gt;resolution&lt;/i&gt; is accomplished through
                     the use of a combination of local machine configuration information
                     and network naming services such as the Domain Name System (DNS)
                     and Network Information Service(NIS). The particular naming
                     services(s) being used is by default the local machine configured
                     one. For any host name, its corresponding IP address is returned.
                    
                     &lt;p&gt; &lt;i&gt;Reverse name resolution&lt;/i&gt; means that for any IP address,
                     the host associated with the IP address is returned.
                    
                     &lt;p&gt; The InetAddress class provides methods to resolve host names to
                     their IP addresses and vice versa.
                    
                     &lt;h4&gt; InetAddress Caching &lt;/h4&gt;
                    
                     The InetAddress class has a cache to store successful as well as
                     unsuccessful host name resolutions.
                    
                     &lt;p&gt; By default, when a security manager is installed, in order to
                     protect against DNS spoofing attacks,
                     the result of positive host name resolutions are
                     cached forever. When a security manager is not installed, the default
                     behavior is to cache entries for a finite (implementation dependent)
                     period of time. The result of unsuccessful host
                     name resolution is cached for a very short period of time (10
                     seconds) to improve performance.
                    
                     &lt;p&gt; If the default behavior is not desired, then a Java security property
                     can be set to a different Time-to-live (TTL) value for positive
                     caching. Likewise, a system admin can configure a different
                     negative caching TTL value when needed.
                    
                     &lt;p&gt; Two Java security properties control the TTL values used for
                      positive and negative host name resolution caching:
                    
                     &lt;dl style="margin-left:2em"&gt;
                     &lt;dt&gt;&lt;b&gt;networkaddress.cache.ttl&lt;/b&gt;&lt;/dt&gt;
                     &lt;dd&gt;Indicates the caching policy for successful name lookups from
                     the name service. The value is specified as an integer to indicate
                     the number of seconds to cache the successful lookup. The default
                     setting is to cache for an implementation specific period of time.
                     &lt;p&gt;
                     A value of -1 indicates "cache forever".
                     &lt;/dd&gt;
                     &lt;dt&gt;&lt;b&gt;networkaddress.cache.negative.ttl&lt;/b&gt; (default: 10)&lt;/dt&gt;
                     &lt;dd&gt;Indicates the caching policy for un-successful name lookups
                     from the name service. The value is specified as an integer to
                     indicate the number of seconds to cache the failure for
                     un-successful lookups.
                     &lt;p&gt;
                     A value of 0 indicates "never cache".
                     A value of -1 indicates "cache forever".
                     &lt;/dd&gt;
                     &lt;/dl&gt;
                    
                     @author  Chris Warth
                     @see     java.net.InetAddress#getByAddress(byte[])
                     @see     java.net.InetAddress#getByAddress(java.lang.String, byte[])
                     @see     java.net.InetAddress#getAllByName(java.lang.String)
                     @see     java.net.InetAddress#getByName(java.lang.String)
                     @see     java.net.InetAddress#getLocalHost()
                     @since 1.0
                    </javadoc>
            </acts>
            <acts name="CookieHandler" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A CookieHandler object provides a callback mechanism to hook up a
                     HTTP state management policy implementation into the HTTP protocol
                     handler. The HTTP state management mechanism specifies a way to
                     create a stateful session with HTTP requests and responses.
                    
                     &lt;p&gt; A system-wide CookieHandler to be used by the {@linkplain
                     HttpURLConnection HTTP URL stream protocol handler} can be registered by
                     doing a CookieHandler.setDefault(CookieHandler). The currently registered
                     CookieHandler can be retrieved by calling
                     CookieHandler.getDefault().
                    
                     For more information on HTTP state management, see &lt;a
                     href="http://www.ietf.org/rfc/rfc2965.txt"&gt;&lt;i&gt;RFC&amp;nbsp;2965: HTTP
                     State Management Mechanism&lt;/i&gt;&lt;/a&gt;
                    
                     @author Yingxian Wang
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="MulticastSocket" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.DatagramSocket"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The multicast datagram socket class is useful for sending
                     and receiving IP multicast packets.  A MulticastSocket is
                     a (UDP) DatagramSocket, with additional capabilities for
                     joining "groups" of other multicast hosts on the internet.
                     &lt;P&gt;
                     A multicast group is specified by a class D IP address
                     and by a standard UDP port number. Class D IP addresses
                     are in the range &lt;CODE&gt;224.0.0.0&lt;/CODE&gt; to &lt;CODE&gt;239.255.255.255&lt;/CODE&gt;,
                     inclusive. The address 224.0.0.0 is reserved and should not be used.
                     &lt;P&gt;
                     One would join a multicast group by first creating a MulticastSocket
                     with the desired port, then invoking the
                     &lt;CODE&gt;joinGroup(InetAddress groupAddr)&lt;/CODE&gt;
                     method:
                     &lt;PRE&gt;
                     // join a Multicast group and send the group salutations
                     ...
                     String msg = "Hello";
                     InetAddress group = InetAddress.getByName("228.5.6.7");
                     MulticastSocket s = new MulticastSocket(6789);
                     s.joinGroup(group);
                     DatagramPacket hi = new DatagramPacket(msg.getBytes(), msg.length(),
                                                 group, 6789);
                     s.send(hi);
                     // get their responses!
                     byte[] buf = new byte[1000];
                     DatagramPacket recv = new DatagramPacket(buf, buf.length);
                     s.receive(recv);
                     ...
                     // OK, I'm done talking - leave the group...
                     s.leaveGroup(group);
                     &lt;/PRE&gt;
                    
                     When one sends a message to a multicast group, &lt;B&gt;all&lt;/B&gt; subscribing
                     recipients to that host and port receive the message (within the
                     time-to-live range of the packet, see below).  The socket needn't
                     be a member of the multicast group to send messages to it.
                     &lt;P&gt;
                     When a socket subscribes to a multicast group/port, it receives
                     datagrams sent by other hosts to the group/port, as do all other
                     members of the group and port.  A socket relinquishes membership
                     in a group by the leaveGroup(InetAddress addr) method.  &lt;B&gt;
                     Multiple MulticastSocket's&lt;/B&gt; may subscribe to a multicast group
                     and port concurrently, and they will all receive group datagrams.
                     &lt;P&gt;
                     Currently applets are not allowed to use multicast sockets.
                    
                     @author Pavani Diwanji
                     @since  1.1
                    </javadoc>
            </acts>
            <acts name="StandardSocketOptions" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Defines the &lt;em&gt;standard&lt;/em&gt; socket options.
                    
                     &lt;p&gt; The {@link SocketOption#name name} of each socket option defined by this
                     class is its field name.
                    
                     &lt;p&gt; In this release, the socket options defined here are used by {@link
                     java.nio.channels.NetworkChannel network} channels in the {@link
                     java.nio.channels channels} package.
                    
                     @since 1.7
                    </javadoc>
            </acts>
            <acts name="PortUnreachableException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.SocketException"/>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that an ICMP Port Unreachable message has been
                     received on a connected datagram.
                    
                     @since   1.4
                    </javadoc>
            </acts>
            <acts name="SecureCacheResponse" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.CacheResponse"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Represents a cache response originally retrieved through secure
                     means, such as TLS.
                    
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="UnknownServiceException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that an unknown service exception has
                     occurred. Either the MIME type returned by a URL connection does
                     not make sense, or the application is attempting to write to a
                     read-only URL connection.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="URLStreamHandlerFactory" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.net">
                <superTypes/>
                <javadoc xml:space="preserve">
                     This interface defines a factory for {@code URL} stream
                     protocol handlers.
                    
                     &lt;p&gt; A URL stream handler factory is used as specified in the
                     {@linkplain java.net.URL#URL(String,String,int,String) URL constructor}.
                    
                     @author  Arthur van Hoff
                     @see     java.net.URL
                     @see     java.net.URLStreamHandler
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="CookiePolicy" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.net">
                <superTypes/>
                <javadoc xml:space="preserve">
                     CookiePolicy implementations decide which cookies should be accepted
                     and which should be rejected. Three pre-defined policy implementations
                     are provided, namely ACCEPT_ALL, ACCEPT_NONE and ACCEPT_ORIGINAL_SERVER.
                    
                     &lt;p&gt;See RFC 2965 sec. 3.3 and 7 for more detail.
                    
                     @author Edward Wang
                     @since 1.6
                    </javadoc>
            </acts>
            <acts name="URISyntaxException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Checked exception thrown to indicate that a string could not be parsed as a
                     URI reference.
                    
                     @author Mark Reinhold
                     @see URI
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="URI" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Comparable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Represents a Uniform Resource Identifier (URI) reference.
                    
                     &lt;p&gt; Aside from some minor deviations noted below, an instance of this
                     class represents a URI reference as defined by
                     &lt;a href="http://www.ietf.org/rfc/rfc2396.txt"&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
                     Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a
                     href="http://www.ietf.org/rfc/rfc2732.txt"&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
                     Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format
                     also supports scope_ids. The syntax and usage of scope_ids is described
                     &lt;a href="Inet6Address.html#scoped"&gt;here&lt;/a&gt;.
                     This class provides constructors for creating URI instances from
                     their components or by parsing their string forms, methods for accessing the
                     various components of an instance, and methods for normalizing, resolving,
                     and relativizing URI instances.  Instances of this class are immutable.
                    
                    
                     &lt;h3&gt; URI syntax and components &lt;/h3&gt;
                    
                     At the highest level a URI reference (hereinafter simply "URI") in string
                     form has the syntax
                    
                     &lt;blockquote&gt;
                     [&lt;i&gt;scheme&lt;/i&gt;&lt;b&gt;{@code :}&lt;/b&gt;]&lt;i&gt;scheme-specific-part&lt;/i&gt;[&lt;b&gt;{@code #}&lt;/b&gt;&lt;i&gt;fragment&lt;/i&gt;]
                     &lt;/blockquote&gt;
                    
                     where square brackets [...] delineate optional components and the characters
                     &lt;b&gt;{@code :}&lt;/b&gt; and &lt;b&gt;{@code #}&lt;/b&gt; stand for themselves.
                    
                     &lt;p&gt; An &lt;i&gt;absolute&lt;/i&gt; URI specifies a scheme; a URI that is not absolute is
                     said to be &lt;i&gt;relative&lt;/i&gt;.  URIs are also classified according to whether
                     they are &lt;i&gt;opaque&lt;/i&gt; or &lt;i&gt;hierarchical&lt;/i&gt;.
                    
                     &lt;p&gt; An &lt;i&gt;opaque&lt;/i&gt; URI is an absolute URI whose scheme-specific part does
                     not begin with a slash character ({@code '/'}).  Opaque URIs are not
                     subject to further parsing.  Some examples of opaque URIs are:
                    
                     &lt;blockquote&gt;&lt;ul style="list-style-type:none"&gt;
                     &lt;li&gt;{@code mailto:java-net@java.sun.com}&lt;/li&gt;
                     &lt;li&gt;{@code news:comp.lang.java}&lt;/li&gt;
                     &lt;li&gt;{@code urn:isbn:096139210x}&lt;/li&gt;
                     &lt;/ul&gt;&lt;/blockquote&gt;
                    
                     &lt;p&gt; A &lt;i&gt;hierarchical&lt;/i&gt; URI is either an absolute URI whose
                     scheme-specific part begins with a slash character, or a relative URI, that
                     is, a URI that does not specify a scheme.  Some examples of hierarchical
                     URIs are:
                    
                     &lt;blockquote&gt;
                     {@code http://example.com/languages/java/}&lt;br&gt;
                     {@code sample/a/index.html#28}&lt;br&gt;
                     {@code ../../demo/b/index.html}&lt;br&gt;
                     {@code file:///~/calendar}
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt; A hierarchical URI is subject to further parsing according to the syntax
                    
                     &lt;blockquote&gt;
                     [&lt;i&gt;scheme&lt;/i&gt;&lt;b&gt;{@code :}&lt;/b&gt;][&lt;b&gt;{@code //}&lt;/b&gt;&lt;i&gt;authority&lt;/i&gt;][&lt;i&gt;path&lt;/i&gt;][&lt;b&gt;{@code ?}&lt;/b&gt;&lt;i&gt;query&lt;/i&gt;][&lt;b&gt;{@code #}&lt;/b&gt;&lt;i&gt;fragment&lt;/i&gt;]
                     &lt;/blockquote&gt;
                    
                     where the characters &lt;b&gt;{@code :}&lt;/b&gt;, &lt;b&gt;{@code /}&lt;/b&gt;,
                     &lt;b&gt;{@code ?}&lt;/b&gt;, and &lt;b&gt;{@code #}&lt;/b&gt; stand for themselves.  The
                     scheme-specific part of a hierarchical URI consists of the characters
                     between the scheme and fragment components.
                    
                     &lt;p&gt; The authority component of a hierarchical URI is, if specified, either
                     &lt;i&gt;server-based&lt;/i&gt; or &lt;i&gt;registry-based&lt;/i&gt;.  A server-based authority
                     parses according to the familiar syntax
                    
                     &lt;blockquote&gt;
                     [&lt;i&gt;user-info&lt;/i&gt;&lt;b&gt;{@code @}&lt;/b&gt;]&lt;i&gt;host&lt;/i&gt;[&lt;b&gt;{@code :}&lt;/b&gt;&lt;i&gt;port&lt;/i&gt;]
                     &lt;/blockquote&gt;
                    
                     where the characters &lt;b&gt;{@code @}&lt;/b&gt; and &lt;b&gt;{@code :}&lt;/b&gt; stand for
                     themselves.  Nearly all URI schemes currently in use are server-based.  An
                     authority component that does not parse in this way is considered to be
                     registry-based.
                    
                     &lt;p&gt; The path component of a hierarchical URI is itself said to be absolute
                     if it begins with a slash character ({@code '/'}); otherwise it is
                     relative.  The path of a hierarchical URI that is either absolute or
                     specifies an authority is always absolute.
                    
                     &lt;p&gt; All told, then, a URI instance has the following nine components:
                    
                     &lt;table class="striped" style="margin-left:2em"&gt;
                     &lt;caption style="display:none"&gt;Describes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment&lt;/caption&gt;
                     &lt;thead&gt;
                     &lt;tr&gt;&lt;th scope="col"&gt;Component&lt;/th&gt;&lt;th scope="col"&gt;Type&lt;/th&gt;&lt;/tr&gt;
                     &lt;/thead&gt;
                     &lt;tbody style="text-align:left"&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;scheme&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;scheme-specific-part&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;authority&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;user-info&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;host&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;port&lt;/th&gt;&lt;td&gt;{@code int}&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;path&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;query&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;th scope="row"&gt;fragment&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     In a given instance any particular component is either &lt;i&gt;undefined&lt;/i&gt; or
                     &lt;i&gt;defined&lt;/i&gt; with a distinct value.  Undefined string components are
                     represented by {@code null}, while undefined integer components are
                     represented by {@code -1}.  A string component may be defined to have the
                     empty string as its value; this is not equivalent to that component being
                     undefined.
                    
                     &lt;p&gt; Whether a particular component is or is not defined in an instance
                     depends upon the type of the URI being represented.  An absolute URI has a
                     scheme component.  An opaque URI has a scheme, a scheme-specific part, and
                     possibly a fragment, but has no other components.  A hierarchical URI always
                     has a path (though it may be empty) and a scheme-specific-part (which at
                     least contains the path), and may have any of the other components.  If the
                     authority component is present and is server-based then the host component
                     will be defined and the user-information and port components may be defined.
                    
                    
                     &lt;h4&gt; Operations on URI instances &lt;/h4&gt;
                    
                     The key operations supported by this class are those of
                     &lt;i&gt;normalization&lt;/i&gt;, &lt;i&gt;resolution&lt;/i&gt;, and &lt;i&gt;relativization&lt;/i&gt;.
                    
                     &lt;p&gt; &lt;i&gt;Normalization&lt;/i&gt; is the process of removing unnecessary {@code "."}
                     and {@code ".."} segments from the path component of a hierarchical URI.
                     Each {@code "."} segment is simply removed.  A {@code ".."} segment is
                     removed only if it is preceded by a non-{@code ".."} segment.
                     Normalization has no effect upon opaque URIs.
                    
                     &lt;p&gt; &lt;i&gt;Resolution&lt;/i&gt; is the process of resolving one URI against another,
                     &lt;i&gt;base&lt;/i&gt; URI.  The resulting URI is constructed from components of both
                     URIs in the manner specified by RFC&amp;nbsp;2396, taking components from the
                     base URI for those not specified in the original.  For hierarchical URIs,
                     the path of the original is resolved against the path of the base and then
                     normalized.  The result, for example, of resolving
                    
                     &lt;blockquote&gt;
                     {@code sample/a/index.html#28}
                     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
                     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(1)
                     &lt;/blockquote&gt;
                    
                     against the base URI {@code http://example.com/languages/java/} is the result
                     URI
                    
                     &lt;blockquote&gt;
                     {@code http://example.com/languages/java/sample/a/index.html#28}
                     &lt;/blockquote&gt;
                    
                     Resolving the relative URI
                    
                     &lt;blockquote&gt;
                     {@code ../../demo/b/index.html}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(2)
                     &lt;/blockquote&gt;
                    
                     against this result yields, in turn,
                    
                     &lt;blockquote&gt;
                     {@code http://example.com/languages/java/demo/b/index.html}
                     &lt;/blockquote&gt;
                    
                     Resolution of both absolute and relative URIs, and of both absolute and
                     relative paths in the case of hierarchical URIs, is supported.  Resolving
                     the URI {@code file:///~calendar} against any other URI simply yields the
                     original URI, since it is absolute.  Resolving the relative URI (2) above
                     against the relative base URI (1) yields the normalized, but still relative,
                     URI
                    
                     &lt;blockquote&gt;
                     {@code demo/b/index.html}
                     &lt;/blockquote&gt;
                    
                     &lt;p&gt; &lt;i&gt;Relativization&lt;/i&gt;, finally, is the inverse of resolution: For any
                     two normalized URIs &lt;i&gt;u&lt;/i&gt; and&amp;nbsp;&lt;i&gt;v&lt;/i&gt;,
                    
                     &lt;blockquote&gt;
                       &lt;i&gt;u&lt;/i&gt;{@code .relativize(}&lt;i&gt;u&lt;/i&gt;{@code .resolve(}&lt;i&gt;v&lt;/i&gt;{@code )).equals(}&lt;i&gt;v&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;and&lt;br&gt;
                       &lt;i&gt;u&lt;/i&gt;{@code .resolve(}&lt;i&gt;u&lt;/i&gt;{@code .relativize(}&lt;i&gt;v&lt;/i&gt;{@code )).equals(}&lt;i&gt;v&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;.&lt;br&gt;
                     &lt;/blockquote&gt;
                    
                     This operation is often useful when constructing a document containing URIs
                     that must be made relative to the base URI of the document wherever
                     possible.  For example, relativizing the URI
                    
                     &lt;blockquote&gt;
                     {@code http://example.com/languages/java/sample/a/index.html#28}
                     &lt;/blockquote&gt;
                    
                     against the base URI
                    
                     &lt;blockquote&gt;
                     {@code http://example.com/languages/java/}
                     &lt;/blockquote&gt;
                    
                     yields the relative URI {@code sample/a/index.html#28}.
                    
                    
                     &lt;h4&gt; Character categories &lt;/h4&gt;
                    
                     RFC&amp;nbsp;2396 specifies precisely which characters are permitted in the
                     various components of a URI reference.  The following categories, most of
                     which are taken from that specification, are used below to describe these
                     constraints:
                    
                     &lt;table class="striped" style="margin-left:2em"&gt;
                     &lt;caption style="display:none"&gt;Describes categories alpha,digit,alphanum,unreserved,punct,reserved,escaped,and other&lt;/caption&gt;
                       &lt;thead&gt;
                       &lt;tr&gt;&lt;th scope="col"&gt;Category&lt;/th&gt;&lt;th scope="col"&gt;Description&lt;/th&gt;&lt;/tr&gt;
                       &lt;/thead&gt;
                       &lt;tbody style="text-align:left"&gt;
                       &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;alpha&lt;/th&gt;
                           &lt;td&gt;The US-ASCII alphabetic characters,
                            {@code 'A'}&amp;nbsp;through&amp;nbsp;{@code 'Z'}
                            and {@code 'a'}&amp;nbsp;through&amp;nbsp;{@code 'z'}&lt;/td&gt;&lt;/tr&gt;
                       &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;digit&lt;/th&gt;
                           &lt;td&gt;The US-ASCII decimal digit characters,
                           {@code '0'}&amp;nbsp;through&amp;nbsp;{@code '9'}&lt;/td&gt;&lt;/tr&gt;
                       &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;alphanum&lt;/th&gt;
                           &lt;td&gt;All &lt;i&gt;alpha&lt;/i&gt; and &lt;i&gt;digit&lt;/i&gt; characters&lt;/td&gt;&lt;/tr&gt;
                       &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;unreserved&lt;/th&gt;
                           &lt;td&gt;All &lt;i&gt;alphanum&lt;/i&gt; characters together with those in the string
                            {@code "_-!.~'()*"}&lt;/td&gt;&lt;/tr&gt;
                       &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;punct&lt;/th&gt;
                           &lt;td&gt;The characters in the string {@code ",;:$&amp;+="}&lt;/td&gt;&lt;/tr&gt;
                       &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;reserved&lt;/th&gt;
                           &lt;td&gt;All &lt;i&gt;punct&lt;/i&gt; characters together with those in the string
                            {@code "?/[]@"}&lt;/td&gt;&lt;/tr&gt;
                       &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;escaped&lt;/th&gt;
                           &lt;td&gt;Escaped octets, that is, triplets consisting of the percent
                               character ({@code '%'}) followed by two hexadecimal digits
                               ({@code '0'}-{@code '9'}, {@code 'A'}-{@code 'F'}, and
                               {@code 'a'}-{@code 'f'})&lt;/td&gt;&lt;/tr&gt;
                       &lt;tr&gt;&lt;th scope="row" style="vertical-align:top"&gt;other&lt;/th&gt;
                           &lt;td&gt;The Unicode characters that are not in the US-ASCII character set,
                               are not control characters (according to the {@link
                               java.lang.Character#isISOControl(char) Character.isISOControl}
                               method), and are not space characters (according to the {@link
                               java.lang.Character#isSpaceChar(char) Character.isSpaceChar}
                               method)&amp;nbsp;&amp;nbsp;&lt;i&gt;(&lt;b&gt;Deviation from RFC 2396&lt;/b&gt;, which is
                               limited to US-ASCII)&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;p&gt;&lt;a id="legal-chars"&gt;&lt;/a&gt; The set of all legal URI characters consists of
                     the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;reserved&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;
                     characters.
                    
                    
                     &lt;h4&gt; Escaped octets, quotation, encoding, and decoding &lt;/h4&gt;
                    
                     RFC 2396 allows escaped octets to appear in the user-info, path, query, and
                     fragment components.  Escaping serves two purposes in URIs:
                    
                     &lt;ul&gt;
                    
                       &lt;li&gt;&lt;p&gt; To &lt;i&gt;encode&lt;/i&gt; non-US-ASCII characters when a URI is required to
                       conform strictly to RFC&amp;nbsp;2396 by not containing any &lt;i&gt;other&lt;/i&gt;
                       characters.  &lt;/p&gt;&lt;/li&gt;
                    
                       &lt;li&gt;&lt;p&gt; To &lt;i&gt;quote&lt;/i&gt; characters that are otherwise illegal in a
                       component.  The user-info, path, query, and fragment components differ
                       slightly in terms of which characters are considered legal and illegal.
                       &lt;/p&gt;&lt;/li&gt;
                    
                     &lt;/ul&gt;
                    
                     These purposes are served in this class by three related operations:
                    
                     &lt;ul&gt;
                    
                       &lt;li&gt;&lt;p&gt;&lt;a id="encode"&gt;&lt;/a&gt; A character is &lt;i&gt;encoded&lt;/i&gt; by replacing it
                       with the sequence of escaped octets that represent that character in the
                       UTF-8 character set.  The Euro currency symbol ({@code '\u20AC'}),
                       for example, is encoded as {@code "%E2%82%AC"}.  &lt;i&gt;(&lt;b&gt;Deviation from
                       RFC&amp;nbsp;2396&lt;/b&gt;, which does not specify any particular character
                       set.)&lt;/i&gt; &lt;/p&gt;&lt;/li&gt;
                    
                       &lt;li&gt;&lt;p&gt;&lt;a id="quote"&gt;&lt;/a&gt; An illegal character is &lt;i&gt;quoted&lt;/i&gt; simply by
                       encoding it.  The space character, for example, is quoted by replacing it
                       with {@code "%20"}.  UTF-8 contains US-ASCII, hence for US-ASCII
                       characters this transformation has exactly the effect required by
                       RFC&amp;nbsp;2396. &lt;/p&gt;&lt;/li&gt;
                    
                       &lt;li&gt;&lt;p&gt;&lt;a id="decode"&gt;&lt;/a&gt;
                       A sequence of escaped octets is &lt;i&gt;decoded&lt;/i&gt; by
                       replacing it with the sequence of characters that it represents in the
                       UTF-8 character set.  UTF-8 contains US-ASCII, hence decoding has the
                       effect of de-quoting any quoted US-ASCII characters as well as that of
                       decoding any encoded non-US-ASCII characters.  If a &lt;a
                       href="../nio/charset/CharsetDecoder.html#ce"&gt;decoding error&lt;/a&gt; occurs
                       when decoding the escaped octets then the erroneous octets are replaced by
                       {@code '\uFFFD'}, the Unicode replacement character.  &lt;/p&gt;&lt;/li&gt;
                    
                     &lt;/ul&gt;
                    
                     These operations are exposed in the constructors and methods of this class
                     as follows:
                    
                     &lt;ul&gt;
                    
                       &lt;li&gt;&lt;p&gt; The {@linkplain #URI(java.lang.String) single-argument
                       constructor} requires any illegal characters in its argument to be
                       quoted and preserves any escaped octets and &lt;i&gt;other&lt;/i&gt; characters that
                       are present.  &lt;/p&gt;&lt;/li&gt;
                    
                       &lt;li&gt;&lt;p&gt; The {@linkplain
                       #URI(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)
                       multi-argument constructors} quote illegal characters as
                       required by the components in which they appear.  The percent character
                       ({@code '%'}) is always quoted by these constructors.  Any &lt;i&gt;other&lt;/i&gt;
                       characters are preserved.  &lt;/p&gt;&lt;/li&gt;
                    
                       &lt;li&gt;&lt;p&gt; The {@link #getRawUserInfo() getRawUserInfo}, {@link #getRawPath()
                       getRawPath}, {@link #getRawQuery() getRawQuery}, {@link #getRawFragment()
                       getRawFragment}, {@link #getRawAuthority() getRawAuthority}, and {@link
                       #getRawSchemeSpecificPart() getRawSchemeSpecificPart} methods return the
                       values of their corresponding components in raw form, without interpreting
                       any escaped octets.  The strings returned by these methods may contain
                       both escaped octets and &lt;i&gt;other&lt;/i&gt; characters, and will not contain any
                       illegal characters.  &lt;/p&gt;&lt;/li&gt;
                    
                       &lt;li&gt;&lt;p&gt; The {@link #getUserInfo() getUserInfo}, {@link #getPath()
                       getPath}, {@link #getQuery() getQuery}, {@link #getFragment()
                       getFragment}, {@link #getAuthority() getAuthority}, and {@link
                       #getSchemeSpecificPart() getSchemeSpecificPart} methods decode any escaped
                       octets in their corresponding components.  The strings returned by these
                       methods may contain both &lt;i&gt;other&lt;/i&gt; characters and illegal characters,
                       and will not contain any escaped octets.  &lt;/p&gt;&lt;/li&gt;
                    
                       &lt;li&gt;&lt;p&gt; The {@link #toString() toString} method returns a URI string with
                       all necessary quotation but which may contain &lt;i&gt;other&lt;/i&gt; characters.
                       &lt;/p&gt;&lt;/li&gt;
                    
                       &lt;li&gt;&lt;p&gt; The {@link #toASCIIString() toASCIIString} method returns a fully
                       quoted and encoded URI string that does not contain any &lt;i&gt;other&lt;/i&gt;
                       characters.  &lt;/p&gt;&lt;/li&gt;
                    
                     &lt;/ul&gt;
                    
                    
                     &lt;h4&gt; Identities &lt;/h4&gt;
                    
                     For any URI &lt;i&gt;u&lt;/i&gt;, it is always the case that
                    
                     &lt;blockquote&gt;
                     {@code new URI(}&lt;i&gt;u&lt;/i&gt;{@code .toString()).equals(}&lt;i&gt;u&lt;/i&gt;{@code )}&amp;nbsp;.
                     &lt;/blockquote&gt;
                    
                     For any URI &lt;i&gt;u&lt;/i&gt; that does not contain redundant syntax such as two
                     slashes before an empty authority (as in {@code file:///tmp/}&amp;nbsp;) or a
                     colon following a host name but no port (as in
                     {@code http://java.sun.com:}&amp;nbsp;), and that does not encode characters
                     except those that must be quoted, the following identities also hold:
                     &lt;pre&gt;
                         new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
                                 &lt;i&gt;u&lt;/i&gt;.getSchemeSpecificPart(),
                                 &lt;i&gt;u&lt;/i&gt;.getFragment())
                         .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
                     in all cases,
                     &lt;pre&gt;
                         new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
                                 &lt;i&gt;u&lt;/i&gt;.getAuthority(),
                                 &lt;i&gt;u&lt;/i&gt;.getPath(), &lt;i&gt;u&lt;/i&gt;.getQuery(),
                                 &lt;i&gt;u&lt;/i&gt;.getFragment())
                         .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
                     if &lt;i&gt;u&lt;/i&gt; is hierarchical, and
                     &lt;pre&gt;
                         new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
                                 &lt;i&gt;u&lt;/i&gt;.getUserInfo(), &lt;i&gt;u&lt;/i&gt;.getHost(), &lt;i&gt;u&lt;/i&gt;.getPort(),
                                 &lt;i&gt;u&lt;/i&gt;.getPath(), &lt;i&gt;u&lt;/i&gt;.getQuery(),
                                 &lt;i&gt;u&lt;/i&gt;.getFragment())
                         .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
                     if &lt;i&gt;u&lt;/i&gt; is hierarchical and has either no authority or a server-based
                     authority.
                    
                    
                     &lt;h4&gt; URIs, URLs, and URNs &lt;/h4&gt;
                    
                     A URI is a uniform resource &lt;i&gt;identifier&lt;/i&gt; while a URL is a uniform
                     resource &lt;i&gt;locator&lt;/i&gt;.  Hence every URL is a URI, abstractly speaking, but
                     not every URI is a URL.  This is because there is another subcategory of
                     URIs, uniform resource &lt;i&gt;names&lt;/i&gt; (URNs), which name resources but do not
                     specify how to locate them.  The {@code mailto}, {@code news}, and
                     {@code isbn} URIs shown above are examples of URNs.
                    
                     &lt;p&gt; The conceptual distinction between URIs and URLs is reflected in the
                     differences between this class and the {@link URL} class.
                    
                     &lt;p&gt; An instance of this class represents a URI reference in the syntactic
                     sense defined by RFC&amp;nbsp;2396.  A URI may be either absolute or relative.
                     A URI string is parsed according to the generic syntax without regard to the
                     scheme, if any, that it specifies.  No lookup of the host, if any, is
                     performed, and no scheme-dependent stream handler is constructed.  Equality,
                     hashing, and comparison are defined strictly in terms of the character
                     content of the instance.  In other words, a URI instance is little more than
                     a structured string that supports the syntactic, scheme-independent
                     operations of comparison, normalization, resolution, and relativization.
                    
                     &lt;p&gt; An instance of the {@link URL} class, by contrast, represents the
                     syntactic components of a URL together with some of the information required
                     to access the resource that it describes.  A URL must be absolute, that is,
                     it must always specify a scheme.  A URL string is parsed according to its
                     scheme.  A stream handler is always established for a URL, and in fact it is
                     impossible to create a URL instance for a scheme for which no handler is
                     available.  Equality and hashing depend upon both the scheme and the
                     Internet address of the host, if any; comparison is not defined.  In other
                     words, a URL is a structured string that supports the syntactic operation of
                     resolution as well as the network I/O operations of looking up the host and
                     opening a connection to the specified resource.
                    
                    
                     @author Mark Reinhold
                     @since 1.4
                    
                     @see &lt;a href="http://www.ietf.org/rfc/rfc2279.txt"&gt;&lt;i&gt;RFC&amp;nbsp;2279: UTF-8, a
                     transformation format of ISO 10646&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
                     href="http://www.ietf.org/rfc/rfc2373.txt"&gt;&lt;i&gt;RFC&amp;nbsp;2373: IPv6 Addressing
                     Architecture&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
                     href="http://www.ietf.org/rfc/rfc2396.txt"&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
                     Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
                     href="http://www.ietf.org/rfc/rfc2732.txt"&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
                     Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
                     href="URISyntaxException.html"&gt;URISyntaxException&lt;/a&gt;
                    </javadoc>
            </acts>
            <acts name="DatagramSocketImplFactory" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.net">
                <superTypes/>
                <javadoc xml:space="preserve">
                     This interface defines a factory for datagram socket implementations. It
                     is used by the classes {@code DatagramSocket} to create actual socket
                     implementations.
                    
                     @author  Yingxian Wang
                     @see     java.net.DatagramSocket
                     @since   1.3
                    </javadoc>
            </acts>
            <acts name="URL" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Class {@code URL} represents a Uniform Resource
                     Locator, a pointer to a "resource" on the World
                     Wide Web. A resource can be something as simple as a file or a
                     directory, or it can be a reference to a more complicated object,
                     such as a query to a database or to a search engine. More
                     information on the types of URLs and their formats can be found at:
                     &lt;a href=
                     "http://web.archive.org/web/20051219043731/http://archive.ncsa.uiuc.edu/SDG/Software/Mosaic/Demo/url-primer.html"&gt;
                     &lt;i&gt;Types of URL&lt;/i&gt;&lt;/a&gt;
                     &lt;p&gt;
                     In general, a URL can be broken into several parts. Consider the
                     following example:
                     &lt;blockquote&gt;&lt;pre&gt;
                         http://www.example.com/docs/resource1.html
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     &lt;p&gt;
                     The URL above indicates that the protocol to use is
                     {@code http} (HyperText Transfer Protocol) and that the
                     information resides on a host machine named
                     {@code www.example.com}. The information on that host
                     machine is named {@code /docs/resource1.html}. The exact
                     meaning of this name on the host machine is both protocol
                     dependent and host dependent. The information normally resides in
                     a file, but it could be generated on the fly. This component of
                     the URL is called the &lt;i&gt;path&lt;/i&gt; component.
                     &lt;p&gt;
                     A URL can optionally specify a "port", which is the
                     port number to which the TCP connection is made on the remote host
                     machine. If the port is not specified, the default port for
                     the protocol is used instead. For example, the default port for
                     {@code http} is {@code 80}. An alternative port could be
                     specified as:
                     &lt;blockquote&gt;&lt;pre&gt;
                         http://www.example.com:1080/docs/resource1.html
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     &lt;p&gt;
                     The syntax of {@code URL} is defined by  &lt;a
                     href="http://www.ietf.org/rfc/rfc2396.txt"&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
                     Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a
                     href="http://www.ietf.org/rfc/rfc2732.txt"&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
                     Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format
                     also supports scope_ids. The syntax and usage of scope_ids is described
                     &lt;a href="Inet6Address.html#scoped"&gt;here&lt;/a&gt;.
                     &lt;p&gt;
                     A URL may have appended to it a "fragment", also known
                     as a "ref" or a "reference". The fragment is indicated by the sharp
                     sign character "#" followed by more characters. For example,
                     &lt;blockquote&gt;&lt;pre&gt;
                         http://java.sun.com/index.html#chapter1
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     &lt;p&gt;
                     This fragment is not technically part of the URL. Rather, it
                     indicates that after the specified resource is retrieved, the
                     application is specifically interested in that part of the
                     document that has the tag {@code chapter1} attached to it. The
                     meaning of a tag is resource specific.
                     &lt;p&gt;
                     An application can also specify a "relative URL",
                     which contains only enough information to reach the resource
                     relative to another URL. Relative URLs are frequently used within
                     HTML pages. For example, if the contents of the URL:
                     &lt;blockquote&gt;&lt;pre&gt;
                         http://java.sun.com/index.html
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     contained within it the relative URL:
                     &lt;blockquote&gt;&lt;pre&gt;
                         FAQ.html
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     it would be a shorthand for:
                     &lt;blockquote&gt;&lt;pre&gt;
                         http://java.sun.com/FAQ.html
                     &lt;/pre&gt;&lt;/blockquote&gt;
                     &lt;p&gt;
                     The relative URL need not specify all the components of a URL. If
                     the protocol, host name, or port number is missing, the value is
                     inherited from the fully specified URL. The file component must be
                     specified. The optional fragment is not inherited.
                     &lt;p&gt;
                     The URL class does not itself encode or decode any URL components
                     according to the escaping mechanism defined in RFC2396. It is the
                     responsibility of the caller to encode any fields, which need to be
                     escaped prior to calling URL, and also to decode any escaped fields,
                     that are returned from URL. Furthermore, because URL has no knowledge
                     of URL escaping, it does not recognise equivalence between the encoded
                     or decoded form of the same URL. For example, the two URLs:&lt;br&gt;
                     &lt;pre&gt;    http://foo.com/hello world/ and http://foo.com/hello%20world&lt;/pre&gt;
                     would be considered not equal to each other.
                     &lt;p&gt;
                     Note, the {@link java.net.URI} class does perform escaping of its
                     component fields in certain circumstances. The recommended way
                     to manage the encoding and decoding of URLs is to use {@link java.net.URI},
                     and to convert between these two classes using {@link #toURI()} and
                     {@link URI#toURL()}.
                     &lt;p&gt;
                     The {@link URLEncoder} and {@link URLDecoder} classes can also be
                     used, but only for HTML form encoding, which is not the same
                     as the encoding scheme defined in RFC2396.
                    
                     @author  James Gosling
                     @since 1.0
                    </javadoc>
            </acts>
            <acts name="StandardProtocolFamily" access="PUBLIC" kind="TYPE" typeKind="ENUM" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.ProtocolFamily"/>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Defines the standard families of communication protocols.
                    
                     @since 1.7
                    </javadoc>
            </acts>
            <acts name="Proxy" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class represents a proxy setting, typically a type (http, socks) and
                     a socket address.
                     A {@code Proxy} is an immutable object.
                    
                     @see     java.net.ProxySelector
                     @author Yingxian Wang
                     @author Jean-Christophe Collet
                     @since   1.5
                    </javadoc>
            </acts>
            <acts name="HttpURLConnection" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.URLConnection"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A URLConnection with support for HTTP-specific features. See
                     &lt;A HREF="http://www.w3.org/pub/WWW/Protocols/"&gt; the spec &lt;/A&gt; for
                     details.
                     &lt;p&gt;
                    
                     Each HttpURLConnection instance is used to make a single request
                     but the underlying network connection to the HTTP server may be
                     transparently shared by other instances. Calling the close() methods
                     on the InputStream or OutputStream of an HttpURLConnection
                     after a request may free network resources associated with this
                     instance but has no effect on any shared persistent connection.
                     Calling the disconnect() method may close the underlying socket
                     if a persistent connection is otherwise idle at that time.
                    
                     &lt;P&gt;The HTTP protocol handler has a few settings that can be accessed through
                     System Properties. This covers
                     &lt;a href="doc-files/net-properties.html#Proxies"&gt;Proxy settings&lt;/a&gt; as well as
                     &lt;a href="doc-files/net-properties.html#MiscHTTP"&gt; various other settings&lt;/a&gt;.
                     &lt;/P&gt;
                     &lt;p&gt;
                     &lt;b&gt;Security permissions&lt;/b&gt;
                     &lt;p&gt;
                     If a security manager is installed, and if a method is called which results in an
                     attempt to open a connection, the caller must possess either:
                     &lt;ul&gt;&lt;li&gt;a "connect" {@link SocketPermission} to the host/port combination of the
                     destination URL or&lt;/li&gt;
                     &lt;li&gt;a {@link URLPermission} that permits this request.&lt;/li&gt;
                     &lt;/ul&gt;&lt;p&gt;
                     If automatic redirection is enabled, and this request is redirected to another
                     destination, then the caller must also have permission to connect to the
                     redirected host/URL.
                    
                     @see     java.net.HttpURLConnection#disconnect()
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="ResponseCache" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Represents implementations of URLConnection caches. An instance of
                     such a class can be registered with the system by doing
                     ResponseCache.setDefault(ResponseCache), and the system will call
                     this object in order to:
                    
                        &lt;ul&gt;&lt;li&gt;store resource data which has been retrieved from an
                                external source into the cache&lt;/li&gt;
                             &lt;li&gt;try to fetch a requested resource that may have been
                                stored in the cache&lt;/li&gt;
                        &lt;/ul&gt;
                    
                     The ResponseCache implementation decides which resources
                     should be cached, and for how long they should be cached. If a
                     request resource cannot be retrieved from the cache, then the
                     protocol handlers will fetch the resource from its original
                     location.
                    
                     The settings for URLConnection#useCaches controls whether the
                     protocol is allowed to use a cached response.
                    
                     For more information on HTTP caching, see &lt;a
                     href="http://www.ietf.org/rfc/rfc2616.txt"&gt;&lt;i&gt;RFC&amp;nbsp;2616: Hypertext
                     Transfer Protocol -- HTTP/1.1&lt;/i&gt;&lt;/a&gt;
                    
                     @author Yingxian Wang
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="URLEncoder" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Utility class for HTML form encoding. This class contains static methods
                     for converting a String to the &lt;CODE&gt;application/x-www-form-urlencoded&lt;/CODE&gt; MIME
                     format. For more information about HTML form encoding, consult the HTML
                     &lt;A HREF="http://www.w3.org/TR/html4/"&gt;specification&lt;/A&gt;.
                    
                     &lt;p&gt;
                     When encoding a String, the following rules apply:
                    
                     &lt;ul&gt;
                     &lt;li&gt;The alphanumeric characters &amp;quot;{@code a}&amp;quot; through
                         &amp;quot;{@code z}&amp;quot;, &amp;quot;{@code A}&amp;quot; through
                         &amp;quot;{@code Z}&amp;quot; and &amp;quot;{@code 0}&amp;quot;
                         through &amp;quot;{@code 9}&amp;quot; remain the same.
                     &lt;li&gt;The special characters &amp;quot;{@code .}&amp;quot;,
                         &amp;quot;{@code -}&amp;quot;, &amp;quot;{@code *}&amp;quot;, and
                         &amp;quot;{@code _}&amp;quot; remain the same.
                     &lt;li&gt;The space character &amp;quot; &amp;nbsp; &amp;quot; is
                         converted into a plus sign &amp;quot;{@code +}&amp;quot;.
                     &lt;li&gt;All other characters are unsafe and are first converted into
                         one or more bytes using some encoding scheme. Then each byte is
                         represented by the 3-character string
                         &amp;quot;&lt;i&gt;{@code %xy}&lt;/i&gt;&amp;quot;, where &lt;i&gt;xy&lt;/i&gt; is the
                         two-digit hexadecimal representation of the byte.
                         The recommended encoding scheme to use is UTF-8. However,
                         for compatibility reasons, if an encoding is not specified,
                         then the default encoding of the platform is used.
                     &lt;/ul&gt;
                    
                     &lt;p&gt;
                     For example using UTF-8 as the encoding scheme the string &amp;quot;The
                     string &amp;#252;@foo-bar&amp;quot; would get converted to
                     &amp;quot;The+string+%C3%BC%40foo-bar&amp;quot; because in UTF-8 the character
                     &amp;#252; is encoded as two bytes C3 (hex) and BC (hex), and the
                     character @ is encoded as one byte 40 (hex).
                    
                     @author  Herb Jellinek
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ConnectException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.SocketException"/>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that an error occurred while attempting to connect a
                     socket to a remote address and port.  Typically, the connection
                     was refused remotely (e.g., no process is listening on the
                     remote address/port).
                    
                     @since   1.1
                    </javadoc>
            </acts>
            <acts name="ProtocolException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that there is an error in the underlying
                     protocol, such as a TCP error.
                    
                     @author  Chris Warth
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="ProtocolFamily" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.net">
                <superTypes/>
                <javadoc xml:space="preserve">
                     Represents a family of communication protocols.
                    
                     @since 1.7
                    </javadoc>
            </acts>
            <acts name="UnknownHostException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that the IP address of a host could not be determined.
                    
                     @author  Jonathan Payne
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="SocketOptions" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.net">
                <superTypes/>
                <javadoc xml:space="preserve">
                     Interface of methods to get/set socket options.  This interface is
                     implemented by: &lt;B&gt;SocketImpl&lt;/B&gt; and  &lt;B&gt;DatagramSocketImpl&lt;/B&gt;.
                     Subclasses of these should override the methods
                     of this interface in order to support their own options.
                     &lt;P&gt;
                     The methods and constants which specify options in this interface are
                     for implementation only.  If you're not subclassing SocketImpl or
                     DatagramSocketImpl, &lt;B&gt;you won't use these directly.&lt;/B&gt; There are
                     type-safe methods to get/set each of these options in Socket, ServerSocket,
                     DatagramSocket and MulticastSocket.
                    
                     @author David Brown
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="SocketPermission" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.security.Permission"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class represents access to a network via sockets.
                     A SocketPermission consists of a
                     host specification and a set of "actions" specifying ways to
                     connect to that host. The host is specified as
                     &lt;pre&gt;
                        host = (hostname | IPv4address | iPv6reference) [:portrange]
                        portrange = portnumber | -portnumber | portnumber-[portnumber]
                     &lt;/pre&gt;
                     The host is expressed as a DNS name, as a numerical IP address,
                     or as "localhost" (for the local machine).
                     The wildcard "*" may be included once in a DNS name host
                     specification. If it is included, it must be in the leftmost
                     position, as in "*.sun.com".
                     &lt;p&gt;
                     The format of the IPv6reference should follow that specified in &lt;a
                     href="http://www.ietf.org/rfc/rfc2732.txt"&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format
                     for Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;:
                     &lt;pre&gt;
                        ipv6reference = "[" IPv6address "]"
                    &lt;/pre&gt;
                     For example, you can construct a SocketPermission instance
                     as the following:
                     &lt;pre&gt;
                        String hostAddress = inetaddress.getHostAddress();
                        if (inetaddress instanceof Inet6Address) {
                            sp = new SocketPermission("[" + hostAddress + "]:" + port, action);
                        } else {
                            sp = new SocketPermission(hostAddress + ":" + port, action);
                        }
                     &lt;/pre&gt;
                     or
                     &lt;pre&gt;
                        String host = url.getHost();
                        sp = new SocketPermission(host + ":" + port, action);
                     &lt;/pre&gt;
                     &lt;p&gt;
                     The &lt;A HREF="Inet6Address.html#lform"&gt;full uncompressed form&lt;/A&gt; of
                     an IPv6 literal address is also valid.
                     &lt;p&gt;
                     The port or portrange is optional. A port specification of the
                     form "N-", where &lt;i&gt;N&lt;/i&gt; is a port number, signifies all ports
                     numbered &lt;i&gt;N&lt;/i&gt; and above, while a specification of the
                     form "-N" indicates all ports numbered &lt;i&gt;N&lt;/i&gt; and below.
                     The special port value {@code 0} refers to the entire &lt;i&gt;ephemeral&lt;/i&gt;
                     port range. This is a fixed range of ports a system may use to
                     allocate dynamic ports from. The actual range may be system dependent.
                     &lt;p&gt;
                     The possible ways to connect to the host are
                     &lt;pre&gt;
                     accept
                     connect
                     listen
                     resolve
                     &lt;/pre&gt;
                     The "listen" action is only meaningful when used with "localhost" and
                     means the ability to bind to a specified port.
                     The "resolve" action is implied when any of the other actions are present.
                     The action "resolve" refers to host/ip name service lookups.
                     &lt;P&gt;
                     The actions string is converted to lowercase before processing.
                     &lt;p&gt;As an example of the creation and meaning of SocketPermissions,
                     note that if the following permission:
                    
                     &lt;pre&gt;
                       p1 = new SocketPermission("puffin.eng.sun.com:7777", "connect,accept");
                     &lt;/pre&gt;
                    
                     is granted to some code, it allows that code to connect to port 7777 on
                     {@code puffin.eng.sun.com}, and to accept connections on that port.
                    
                     &lt;p&gt;Similarly, if the following permission:
                    
                     &lt;pre&gt;
                       p2 = new SocketPermission("localhost:1024-", "accept,connect,listen");
                     &lt;/pre&gt;
                    
                     is granted to some code, it allows that code to
                     accept connections on, connect to, or listen on any port between
                     1024 and 65535 on the local host.
                    
                     &lt;p&gt;Note: Granting code permission to accept or make connections to remote
                     hosts may be dangerous because malevolent code can then more easily
                     transfer and share confidential data among parties who may not
                     otherwise have access to the data.
                    
                     @see java.security.Permissions
                     @see SocketPermission
                    
                    
                     @author Marianne Mueller
                     @author Roland Schemers
                     @since 1.2
                    
                     @serial exclude
                    </javadoc>
            </acts>
            <acts name="Type" access="PUBLIC" declaringClass="Proxy" kind="TYPE" typeKind="ENUM" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="ServerSocket" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.Closeable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class implements server sockets. A server socket waits for
                     requests to come in over the network. It performs some operation
                     based on that request, and then possibly returns a result to the requester.
                     &lt;p&gt;
                     The actual work of the server socket is performed by an instance
                     of the {@code SocketImpl} class. An application can
                     change the socket factory that creates the socket
                     implementation to configure itself to create sockets
                     appropriate to the local firewall.
                    
                     @author  unascribed
                     @see     java.net.SocketImpl
                     @see     java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
                     @see     java.nio.channels.ServerSocketChannel
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="HttpRetryException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.IOException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown to indicate that a HTTP request needs to be retried
                     but cannot be retried automatically, due to streaming mode
                     being enabled.
                    
                     @author  Michael McMahon
                     @since   1.5
                    </javadoc>
            </acts>
            <acts name="URLConnection" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The abstract class {@code URLConnection} is the superclass
                     of all classes that represent a communications link between the
                     application and a URL. Instances of this class can be used both to
                     read from and to write to the resource referenced by the URL.
                    
                     &lt;p&gt;
                     In general, creating a connection to a URL is a multistep process:
                     &lt;ol&gt;
                     &lt;li&gt;The connection object is created by invoking the
                         {@link URL#openConnection() openConnection} method on a URL.
                     &lt;li&gt;The setup parameters and general request properties are manipulated.
                     &lt;li&gt;The actual connection to the remote object is made, using the
                        {@link #connect() connect} method.
                     &lt;li&gt;The remote object becomes available. The header fields and the contents
                         of the remote object can be accessed.
                     &lt;/ol&gt;
                     &lt;p&gt;
                     The setup parameters are modified using the following methods:
                     &lt;ul&gt;
                       &lt;li&gt;{@code setAllowUserInteraction}
                       &lt;li&gt;{@code setDoInput}
                       &lt;li&gt;{@code setDoOutput}
                       &lt;li&gt;{@code setIfModifiedSince}
                       &lt;li&gt;{@code setUseCaches}
                     &lt;/ul&gt;
                     &lt;p&gt;
                     and the general request properties are modified using the method:
                     &lt;ul&gt;
                       &lt;li&gt;{@code setRequestProperty}
                     &lt;/ul&gt;
                     &lt;p&gt;
                     Default values for the {@code AllowUserInteraction} and
                     {@code UseCaches} parameters can be set using the methods
                     {@code setDefaultAllowUserInteraction} and
                     {@code setDefaultUseCaches}.
                     &lt;p&gt;
                     Each of the above {@code set} methods has a corresponding
                     {@code get} method to retrieve the value of the parameter or
                     general request property. The specific parameters and general
                     request properties that are applicable are protocol specific.
                     &lt;p&gt;
                     The following methods are used to access the header fields and
                     the contents after the connection is made to the remote object:
                     &lt;ul&gt;
                       &lt;li&gt;{@code getContent}
                       &lt;li&gt;{@code getHeaderField}
                       &lt;li&gt;{@code getInputStream}
                       &lt;li&gt;{@code getOutputStream}
                     &lt;/ul&gt;
                     &lt;p&gt;
                     Certain header fields are accessed frequently. The methods:
                     &lt;ul&gt;
                       &lt;li&gt;{@code getContentEncoding}
                       &lt;li&gt;{@code getContentLength}
                       &lt;li&gt;{@code getContentType}
                       &lt;li&gt;{@code getDate}
                       &lt;li&gt;{@code getExpiration}
                       &lt;li&gt;{@code getLastModified}
                     &lt;/ul&gt;
                     &lt;p&gt;
                     provide convenient access to these fields. The
                     {@code getContentType} method is used by the
                     {@code getContent} method to determine the type of the remote
                     object; subclasses may find it convenient to override the
                     {@code getContentType} method.
                     &lt;p&gt;
                     In the common case, all of the pre-connection parameters and
                     general request properties can be ignored: the pre-connection
                     parameters and request properties default to sensible values. For
                     most clients of this interface, there are only two interesting
                     methods: {@code getInputStream} and {@code getContent},
                     which are mirrored in the {@code URL} class by convenience methods.
                     &lt;p&gt;
                     More information on the request properties and header fields of
                     an {@code http} connection can be found at:
                     &lt;blockquote&gt;&lt;pre&gt;
                     &lt;a href="http://www.ietf.org/rfc/rfc2616.txt"&gt;http://www.ietf.org/rfc/rfc2616.txt&lt;/a&gt;
                     &lt;/pre&gt;&lt;/blockquote&gt;
                    
                     Invoking the {@code close()} methods on the {@code InputStream} or {@code OutputStream} of an
                     {@code URLConnection} after a request may free network resources associated with this
                     instance, unless particular protocol specifications specify different behaviours
                     for it.
                    
                     @author  James Gosling
                     @see     java.net.URL#openConnection()
                     @see     java.net.URLConnection#connect()
                     @see     java.net.URLConnection#getContent()
                     @see     java.net.URLConnection#getContentEncoding()
                     @see     java.net.URLConnection#getContentLength()
                     @see     java.net.URLConnection#getContentType()
                     @see     java.net.URLConnection#getDate()
                     @see     java.net.URLConnection#getExpiration()
                     @see     java.net.URLConnection#getHeaderField(int)
                     @see     java.net.URLConnection#getHeaderField(java.lang.String)
                     @see     java.net.URLConnection#getInputStream()
                     @see     java.net.URLConnection#getLastModified()
                     @see     java.net.URLConnection#getOutputStream()
                     @see     java.net.URLConnection#setAllowUserInteraction(boolean)
                     @see     java.net.URLConnection#setDefaultUseCaches(boolean)
                     @see     java.net.URLConnection#setDoInput(boolean)
                     @see     java.net.URLConnection#setDoOutput(boolean)
                     @see     java.net.URLConnection#setIfModifiedSince(long)
                     @see     java.net.URLConnection#setRequestProperty(java.lang.String, java.lang.String)
                     @see     java.net.URLConnection#setUseCaches(boolean)
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="DatagramSocketImpl" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.SocketOptions"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Abstract datagram and multicast socket implementation base class.
                     @author Pavani Diwanji
                     @since  1.1
                    </javadoc>
            </acts>
            <acts name="SocketOption" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.net">
                <superTypes/>
                <javadoc xml:space="preserve">
                     A socket option associated with a socket.
                    
                     &lt;p&gt; In the {@link java.nio.channels channels} package, the {@link
                     java.nio.channels.NetworkChannel} interface defines the {@link
                     java.nio.channels.NetworkChannel#setOption(SocketOption,Object) setOption}
                     and {@link java.nio.channels.NetworkChannel#getOption(SocketOption) getOption}
                     methods to set and query the channel's socket options.
                    
                     @param   &lt;T&gt;     The type of the socket option value.
                    
                     @since 1.7
                    
                     @see StandardSocketOptions
                    </javadoc>
            </acts>
            <acts name="CacheRequest" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Represents channels for storing resources in the
                     ResponseCache. Instances of such a class provide an
                     OutputStream object which is called by protocol handlers to
                     store the resource data into the cache, and also an abort() method
                     which allows a cache store operation to be interrupted and
                     abandoned. If an IOException is encountered while reading the
                     response or writing to the cache, the current cache store operation
                     will be aborted.
                    
                     @author Yingxian Wang
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="DatagramSocket" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.Closeable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class represents a socket for sending and receiving datagram packets.
                    
                     &lt;p&gt;A datagram socket is the sending or receiving point for a packet
                     delivery service. Each packet sent or received on a datagram socket
                     is individually addressed and routed. Multiple packets sent from
                     one machine to another may be routed differently, and may arrive in
                     any order.
                    
                     &lt;p&gt; Where possible, a newly constructed {@code DatagramSocket} has the
                     {@link SocketOptions#SO_BROADCAST SO_BROADCAST} socket option enabled so as
                     to allow the transmission of broadcast datagrams. In order to receive
                     broadcast packets a DatagramSocket should be bound to the wildcard address.
                     In some implementations, broadcast packets may also be received when
                     a DatagramSocket is bound to a more specific address.
                     &lt;p&gt;
                     Example:
                     {@code
                                  DatagramSocket s = new DatagramSocket(null);
                                  s.bind(new InetSocketAddress(8888));
                     }
                     Which is equivalent to:
                     {@code
                                  DatagramSocket s = new DatagramSocket(8888);
                     }
                     Both cases will create a DatagramSocket able to receive broadcasts on
                     UDP port 8888.
                    
                     @author  Pavani Diwanji
                     @see     java.net.DatagramPacket
                     @see     java.nio.channels.DatagramChannel
                     @since 1.0
                    </javadoc>
            </acts>
            <acts name="URLClassLoader" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.Closeable"/>
                    <superType superType="java.security.SecureClassLoader"/>
                    <superType superType="java.lang.ClassLoader"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class loader is used to load classes and resources from a search
                     path of URLs referring to both JAR files and directories. Any {@code jar:}
                     scheme URL (see {@link java.net.JarURLConnection}) is assumed to refer to a
                     JAR file.  Any {@code file:} scheme URL that ends with a '/' is assumed to
                     refer to a directory. Otherwise, the URL is assumed to refer to a JAR file
                     which will be opened as needed.
                     &lt;p&gt;
                     This class loader supports the loading of classes and resources from the
                     contents of a &lt;a href="../util/jar/JarFile.html#multirelease"&gt;multi-release&lt;/a&gt;
                     JAR file that is referred to by a given URL.
                     &lt;p&gt;
                     The AccessControlContext of the thread that created the instance of
                     URLClassLoader will be used when subsequently loading classes and
                     resources.
                     &lt;p&gt;
                     The classes that are loaded are by default granted permission only to
                     access the URLs specified when the URLClassLoader was created.
                    
                     @author  David Connelly
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="SocketImpl" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.net.SocketOptions"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The abstract class {@code SocketImpl} is a common superclass
                     of all classes that actually implement sockets. It is used to
                     create both client and server sockets.
                     &lt;p&gt;
                     A "plain" socket implements these methods exactly as
                     described, without attempting to go through a firewall or proxy.
                    
                     @author  unascribed
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="Socket" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.net">
                <superTypes>
                    <superType superType="java.io.Closeable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class implements client sockets (also called just
                     "sockets"). A socket is an endpoint for communication
                     between two machines.
                     &lt;p&gt;
                     The actual work of the socket is performed by an instance of the
                     {@code SocketImpl} class. An application, by changing
                     the socket factory that creates the socket implementation,
                     can configure itself to create sockets appropriate to the local
                     firewall.
                    
                     @author  unascribed
                     @see     java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
                     @see     java.net.SocketImpl
                     @see     java.nio.channels.SocketChannel
                     @since   1.0
                    </javadoc>
            </acts>
            <package name="http"/>
            <package name="spi"/>
        </package>
        <package name="applet"/>
        <package name="awt">
            <acts name="ScrollPaneAdjustable" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Adjustable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class represents the state of a horizontal or vertical
                     scrollbar of a {@code ScrollPane}.  Objects of this class are
                     returned by {@code ScrollPane} methods.
                    
                     @since       1.4
                    </javadoc>
            </acts>
            <acts name="Feature" access="PUBLIC" declaringClass="Taskbar" kind="TYPE" typeKind="ENUM" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="ContainerOrderFocusTraversalPolicy" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.awt.FocusTraversalPolicy"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A FocusTraversalPolicy that determines traversal order based on the order
                     of child Components in a Container. From a particular focus cycle root, the
                     policy makes a pre-order traversal of the Component hierarchy, and traverses
                     a Container's children according to the ordering of the array returned by
                     {@code Container.getComponents()}. Portions of the hierarchy that are
                     not visible and displayable will not be searched.
                     &lt;p&gt;
                     By default, ContainerOrderFocusTraversalPolicy implicitly transfers focus
                     down-cycle. That is, during normal forward focus traversal, the Component
                     traversed after a focus cycle root will be the focus-cycle-root's default
                     Component to focus. This behavior can be disabled using the
                     {@code setImplicitDownCycleTraversal} method.
                     &lt;p&gt;
                     By default, methods of this class will return a Component only if it is
                     visible, displayable, enabled, and focusable. Subclasses can modify this
                     behavior by overriding the {@code accept} method.
                     &lt;p&gt;
                     This policy takes into account &lt;a
                     href="doc-files/FocusSpec.html#FocusTraversalPolicyProviders"&gt;focus traversal
                     policy providers&lt;/a&gt;.  When searching for first/last/next/previous Component,
                     if a focus traversal policy provider is encountered, its focus traversal
                     policy is used to perform the search operation.
                    
                     @author David Mendenhall
                    
                     @see Container#getComponents
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTTextComponent" access="PROTECTED" declaringClass="TextComponent" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.AccessibleText"/>
                    <superType superType="java.awt.event.TextListener"/>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="AccessibleAWTWindow" access="PROTECTED" declaringClass="Window" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Container$AccessibleAWTContainer"/>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="SystemTray" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code SystemTray} class represents the system tray for a
                     desktop.  On Microsoft Windows it is referred to as the "Taskbar
                     Status Area", on Gnome it is referred to as the "Notification
                     Area", on KDE it is referred to as the "System Tray".  The system
                     tray is shared by all applications running on the desktop.
                    
                     &lt;p&gt; On some platforms the system tray may not be present or may not
                     be supported, in this case {@link SystemTray#getSystemTray()}
                     throws {@link UnsupportedOperationException}.  To detect whether the
                     system tray is supported, use {@link SystemTray#isSupported}.
                    
                     &lt;p&gt;The {@code SystemTray} may contain one or more {@link
                     TrayIcon TrayIcons}, which are added to the tray using the {@link
                     #add} method, and removed when no longer needed, using the
                     {@link #remove}.  {@code TrayIcon} consists of an
                     image, a popup menu and a set of associated listeners.  Please see
                     the {@link TrayIcon} class for details.
                    
                     &lt;p&gt;Every Java application has a single {@code SystemTray}
                     instance that allows the app to interface with the system tray of
                     the desktop while the app is running.  The {@code SystemTray}
                     instance can be obtained from the {@link #getSystemTray} method.
                     An application may not create its own instance of
                     {@code SystemTray}.
                    
                     &lt;p&gt;The following code snippet demonstrates how to access
                     and customize the system tray:
                     &lt;pre&gt;
                     &lt;code&gt;
                         {@link TrayIcon} trayIcon = null;
                         if (SystemTray.isSupported()) {
                             // get the SystemTray instance
                             SystemTray tray = SystemTray.{@link #getSystemTray};
                             // load an image
                             {@link java.awt.Image} image = {@link java.awt.Toolkit#getImage(String) Toolkit.getDefaultToolkit().getImage}(...);
                             // create a action listener to listen for default action executed on the tray icon
                             {@link java.awt.event.ActionListener} listener = new {@link java.awt.event.ActionListener ActionListener}() {
                                 public void {@link java.awt.event.ActionListener#actionPerformed actionPerformed}({@link java.awt.event.ActionEvent} e) {
                                     // execute default action of the application
                                     // ...
                                 }
                             };
                             // create a popup menu
                             {@link java.awt.PopupMenu} popup = new {@link java.awt.PopupMenu#PopupMenu PopupMenu}();
                             // create menu item for the default action
                             MenuItem defaultItem = new MenuItem(...);
                             defaultItem.addActionListener(listener);
                             popup.add(defaultItem);
                             /// ... add other items
                             // construct a TrayIcon
                             trayIcon = new {@link TrayIcon#TrayIcon(java.awt.Image, String, java.awt.PopupMenu) TrayIcon}(image, "Tray Demo", popup);
                             // set the TrayIcon properties
                             trayIcon.{@link TrayIcon#addActionListener(java.awt.event.ActionListener) addActionListener}(listener);
                             // ...
                             // add the tray image
                             try {
                                 tray.{@link SystemTray#add(TrayIcon) add}(trayIcon);
                             } catch (AWTException e) {
                                 System.err.println(e);
                             }
                             // ...
                         } else {
                             // disable tray option in your application or
                             // perform other actions
                             ...
                         }
                         // ...
                         // some time later
                         // the application state has changed - update the image
                         if (trayIcon != null) {
                             trayIcon.{@link TrayIcon#setImage(java.awt.Image) setImage}(updatedImage);
                         }
                         // ...
                     &lt;/code&gt;
                     &lt;/pre&gt;
                    
                     @since 1.6
                     @see TrayIcon
                    
                     @author Bino George
                     @author Denis Mikhalkin
                     @author Sharon Zakhour
                     @author Anton Tarasov
                    </javadoc>
            </acts>
            <acts name="Rectangle" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Shape"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.awt.geom.Rectangle2D"/>
                    <superType superType="java.awt.geom.RectangularShape"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@code Rectangle} specifies an area in a coordinate space that is
                     enclosed by the {@code Rectangle} object's upper-left point
                     {@code (x,y)}
                     in the coordinate space, its width, and its height.
                     &lt;p&gt;
                     A {@code Rectangle} object's {@code width} and
                     {@code height} are {@code public} fields. The constructors
                     that create a {@code Rectangle}, and the methods that can modify
                     one, do not prevent setting a negative value for width or height.
                     &lt;p&gt;
                     &lt;a id="Empty"&gt;
                     A {@code Rectangle} whose width or height is exactly zero has location
                     along those axes with zero dimension, but is otherwise considered empty.&lt;/a&gt;
                     The {@link #isEmpty} method will return true for such a {@code Rectangle}.
                     Methods which test if an empty {@code Rectangle} contains or intersects
                     a point or rectangle will always return false if either dimension is zero.
                     Methods which combine such a {@code Rectangle} with a point or rectangle
                     will include the location of the {@code Rectangle} on that axis in the
                     result as if the {@link #add(Point)} method were being called.
                     &lt;p&gt;
                     &lt;a id="NonExistent"&gt;
                     A {@code Rectangle} whose width or height is negative has neither
                     location nor dimension along those axes with negative dimensions.
                     Such a {@code Rectangle} is treated as non-existent along those axes.
                     Such a {@code Rectangle} is also empty with respect to containment
                     calculations and methods which test if it contains or intersects a
                     point or rectangle will always return false.
                     Methods which combine such a {@code Rectangle} with a point or rectangle
                     will ignore the {@code Rectangle} entirely in generating the result.
                     If two {@code Rectangle} objects are combined and each has a negative
                     dimension, the result will have at least one negative dimension.
                     &lt;/a&gt;
                     &lt;p&gt;
                     Methods which affect only the location of a {@code Rectangle} will
                     operate on its location regardless of whether or not it has a negative
                     or zero dimension along either axis.
                     &lt;p&gt;
                     Note that a {@code Rectangle} constructed with the default no-argument
                     constructor will have dimensions of {@code 0x0} and therefore be empty.
                     That {@code Rectangle} will still have a location of {@code (0,0)} and
                     will contribute that location to the union and add operations.
                     Code attempting to accumulate the bounds of a set of points should
                     therefore initially construct the {@code Rectangle} with a specifically
                     negative width and height or it should use the first point in the set
                     to construct the {@code Rectangle}.
                     For example:
                     &lt;pre&gt;{@code
                         Rectangle bounds = new Rectangle(0, 0, -1, -1);
                         for (int i = 0; i &lt; points.length; i++) {
                             bounds.add(points[i]);
                         }
                     }&lt;/pre&gt;
                     or if we know that the points array contains at least one point:
                     &lt;pre&gt;{@code
                         Rectangle bounds = new Rectangle(points[0]);
                         for (int i = 1; i &lt; points.length; i++) {
                             bounds.add(points[i]);
                         }
                     }&lt;/pre&gt;
                     &lt;p&gt;
                     This class uses 32-bit integers to store its location and dimensions.
                     Frequently operations may produce a result that exceeds the range of
                     a 32-bit integer.
                     The methods will calculate their results in a way that avoids any
                     32-bit overflow for intermediate results and then choose the best
                     representation to store the final results back into the 32-bit fields
                     which hold the location and dimensions.
                     The location of the result will be stored into the {@link #x} and
                     {@link #y} fields by clipping the true result to the nearest 32-bit value.
                     The values stored into the {@link #width} and {@link #height} dimension
                     fields will be chosen as the 32-bit values that encompass the largest
                     part of the true result as possible.
                     Generally this means that the dimension will be clipped independently
                     to the range of 32-bit integers except that if the location had to be
                     moved to store it into its pair of 32-bit fields then the dimensions
                     will be adjusted relative to the "best representation" of the location.
                     If the true result had a negative dimension and was therefore
                     non-existent along one or both axes, the stored dimensions will be
                     negative numbers in those axes.
                     If the true result had a location that could be represented within
                     the range of 32-bit integers, but zero dimension along one or both
                     axes, then the stored dimensions will be zero in those axes.
                    
                     @author      Sami Shaio
                     @since 1.0
                    </javadoc>
            </acts>
            <acts name="SystemColor" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.awt.Color"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A class to encapsulate symbolic colors representing the color of
                     native GUI objects on a system.  For systems which support the dynamic
                     update of the system colors (when the user changes the colors)
                     the actual RGB values of these symbolic colors will also change
                     dynamically.  In order to compare the "current" RGB value of a
                     {@code SystemColor} object with a non-symbolic Color object,
                     {@code getRGB} should be used rather than {@code equals}.
                     &lt;p&gt;
                     Note that the way in which these system colors are applied to GUI objects
                     may vary slightly from platform to platform since GUI objects may be
                     rendered differently on each platform.
                     &lt;p&gt;
                     System color values may also be available through the {@code getDesktopProperty}
                     method on {@code java.awt.Toolkit}.
                    
                     @see Toolkit#getDesktopProperty
                    
                     @author      Carl Quinn
                     @author      Amy Fowler
                    </javadoc>
            </acts>
            <acts name="AWTError" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Error"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when a serious Abstract Window Toolkit error has occurred.
                    
                     @author      Arthur van Hoff
                    </javadoc>
            </acts>
            <acts name="MenuShortcut" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code MenuShortcut} class represents a keyboard accelerator
                     for a MenuItem.
                     &lt;p&gt;
                     Menu shortcuts are created using virtual keycodes, not characters.
                     For example, a menu shortcut for Ctrl-a (assuming that Control is
                     the accelerator key) would be created with code like the following:
                     &lt;p&gt;
                     {@code MenuShortcut ms = new MenuShortcut(KeyEvent.VK_A, false);}
                     &lt;p&gt; or alternatively
                     &lt;p&gt;
                     {@code MenuShortcut ms = new MenuShortcut(KeyEvent.getExtendedKeyCodeForChar('A'), false);}
                     &lt;p&gt;
                     Menu shortcuts may also be constructed for a wider set of keycodes
                     using the {@code java.awt.event.KeyEvent.getExtendedKeyCodeForChar} call.
                     For example, a menu shortcut for "Ctrl+cyrillic ef" is created by
                     &lt;p&gt;
                     &lt;code&gt;MenuShortcut ms = new MenuShortcut(KeyEvent.getExtendedKeyCodeForChar('ф'), false);&lt;/code&gt;
                     &lt;p&gt;
                     Note that shortcuts created with a keycode or an extended keycode defined as a constant in {@code KeyEvent}
                     work regardless of the current keyboard layout. However, a shortcut made of
                     an extended keycode not listed in {@code KeyEvent}
                     only work if the current keyboard layout produces a corresponding letter.
                     &lt;p&gt;
                     The accelerator key is platform-dependent and may be obtained
                     via {@link Toolkit#getMenuShortcutKeyMaskEx()}.
                    
                     @author Thomas Ball
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="Image" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The abstract class {@code Image} is the superclass of all
                     classes that represent graphical images. The image must be
                     obtained in a platform-specific manner.
                    
                     @author      Sami Shaio
                     @author      Arthur van Hoff
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="EventQueue" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     {@code EventQueue} is a platform-independent class
                     that queues events, both from the underlying peer classes
                     and from trusted application classes.
                     &lt;p&gt;
                     It encapsulates asynchronous event dispatch machinery which
                     extracts events from the queue and dispatches them by calling
                     {@link #dispatchEvent(AWTEvent) dispatchEvent(AWTEvent)} method
                     on this {@code EventQueue} with the event to be dispatched
                     as an argument.  The particular behavior of this machinery is
                     implementation-dependent.  The only requirements are that events
                     which were actually enqueued to this queue (note that events
                     being posted to the {@code EventQueue} can be coalesced)
                     are dispatched:
                     &lt;dl&gt;
                       &lt;dt&gt; Sequentially.
                       &lt;dd&gt; That is, it is not permitted that several events from
                            this queue are dispatched simultaneously.
                       &lt;dt&gt; In the same order as they are enqueued.
                       &lt;dd&gt; That is, if {@code AWTEvent}&amp;nbsp;A is enqueued
                            to the {@code EventQueue} before
                            {@code AWTEvent}&amp;nbsp;B then event B will not be
                            dispatched before event A.
                     &lt;/dl&gt;
                     &lt;p&gt;
                     Some browsers partition applets in different code bases into
                     separate contexts, and establish walls between these contexts.
                     In such a scenario, there will be one {@code EventQueue}
                     per context. Other browsers place all applets into the same
                     context, implying that there will be only a single, global
                     {@code EventQueue} for all applets. This behavior is
                     implementation-dependent.  Consult your browser's documentation
                     for more information.
                     &lt;p&gt;
                     For information on the threading issues of the event dispatch
                     machinery, see &lt;a href="doc-files/AWTThreadIssues.html#Autoshutdown"
                     &gt;AWT Threading Issues&lt;/a&gt;.
                    
                     @author Thomas Ball
                     @author Fred Ecks
                     @author David Mendenhall
                    
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="GraphicsConfiguration" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     REMIND:  What to do about capabilities?
                     The
                     capabilities of the device can be determined by enumerating the possible
                     capabilities and checking if the GraphicsConfiguration
                     implements the interface for that capability.
                    
                    </javadoc>
            </acts>
            <acts name="MultipleGradientPaint" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Paint"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This is the superclass for Paints which use a multiple color
                     gradient to fill in their raster.  It provides storage for variables and
                     enumerated values common to
                     {@code LinearGradientPaint} and {@code RadialGradientPaint}.
                    
                     @author Nicholas Talian, Vincent Hardy, Jim Graham, Jerry Evans
                     @since 1.6
                    </javadoc>
            </acts>
            <acts name="Button" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class creates a labeled button. The application can cause
                     some action to happen when the button is pushed. This image
                     depicts three views of a "{@code Quit}" button as it appears
                     under the Solaris operating system:
                     &lt;p&gt;
                     &lt;img src="doc-files/Button-1.gif" alt="The following context describes the graphic"
                     style="float:center; margin: 7px 10px;"&gt;
                     &lt;p&gt;
                     The first view shows the button as it appears normally.
                     The second view shows the button
                     when it has input focus. Its outline is darkened to let the
                     user know that it is an active object. The third view shows the
                     button when the user clicks the mouse over the button, and thus
                     requests that an action be performed.
                     &lt;p&gt;
                     The gesture of clicking on a button with the mouse
                     is associated with one instance of {@code ActionEvent},
                     which is sent out when the mouse is both pressed and released
                     over the button. If an application is interested in knowing
                     when the button has been pressed but not released, as a separate
                     gesture, it can specialize {@code processMouseEvent},
                     or it can register itself as a listener for mouse events by
                     calling {@code addMouseListener}. Both of these methods are
                     defined by {@code Component}, the abstract superclass of
                     all components.
                     &lt;p&gt;
                     When a button is pressed and released, AWT sends an instance
                     of {@code ActionEvent} to the button, by calling
                     {@code processEvent} on the button. The button's
                     {@code processEvent} method receives all events
                     for the button; it passes an action event along by
                     calling its own {@code processActionEvent} method.
                     The latter method passes the action event on to any action
                     listeners that have registered an interest in action
                     events generated by this button.
                     &lt;p&gt;
                     If an application wants to perform some action based on
                     a button being pressed and released, it should implement
                     {@code ActionListener} and register the new listener
                     to receive events from this button, by calling the button's
                     {@code addActionListener} method. The application can
                     make use of the button's action command as a messaging protocol.
                    
                     @author      Sami Shaio
                     @see         java.awt.event.ActionEvent
                     @see         java.awt.event.ActionListener
                     @see         java.awt.Component#processMouseEvent
                     @see         java.awt.Component#addMouseListener
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="CheckboxMenuItem" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.ItemSelectable"/>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.MenuItem"/>
                    <superType superType="java.awt.MenuComponent"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class represents a check box that can be included in a menu.
                     Selecting the check box in the menu changes its state from
                     "on" to "off" or from "off" to "on."
                     &lt;p&gt;
                     The following picture depicts a menu which contains an instance
                     of {@code CheckBoxMenuItem}:
                     &lt;p&gt;
                     &lt;img src="doc-files/MenuBar-1.gif"
                     alt="Menu labeled Examples, containing items Basic, Simple, Check, and More
                     Examples. The Check item is a CheckBoxMenuItem instance, in the off state."
                     style="float:center; margin: 7px 10px;"&gt;
                     &lt;p&gt;
                     The item labeled {@code Check} shows a check box menu item
                     in its "off" state.
                     &lt;p&gt;
                     When a check box menu item is selected, AWT sends an item event to
                     the item. Since the event is an instance of {@code ItemEvent},
                     the {@code processEvent} method examines the event and passes
                     it along to {@code processItemEvent}. The latter method redirects
                     the event to any {@code ItemListener} objects that have
                     registered an interest in item events generated by this menu item.
                    
                     @author      Sami Shaio
                     @see         java.awt.event.ItemEvent
                     @see         java.awt.event.ItemListener
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTList" access="PROTECTED" declaringClass="List" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.AccessibleSelection"/>
                    <superType superType="java.awt.event.ItemListener"/>
                    <superType superType="java.awt.event.ActionListener"/>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="AccessibleAWTPanel" access="PROTECTED" declaringClass="Panel" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Container$AccessibleAWTContainer"/>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="DialogType" access="PUBLIC" declaringClass="JobAttributes" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.AttributeValue"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="DefaultSelectionType" access="PUBLIC" declaringClass="JobAttributes" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.AttributeValue"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="AccessibleAWTTextArea" access="PROTECTED" declaringClass="TextArea" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.TextComponent$AccessibleAWTTextComponent"/>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="AccessibleAWTMenuComponent" access="PROTECTED" declaringClass="MenuComponent" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="javax.accessibility.AccessibleComponent"/>
                    <superType superType="javax.accessibility.AccessibleSelection"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="AccessibleAWTScrollBar" access="PROTECTED" declaringClass="Scrollbar" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.AccessibleValue"/>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="AWTEventMulticaster" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.event.ComponentListener"/>
                    <superType superType="java.awt.event.ContainerListener"/>
                    <superType superType="java.awt.event.FocusListener"/>
                    <superType superType="java.awt.event.KeyListener"/>
                    <superType superType="java.awt.event.MouseListener"/>
                    <superType superType="java.awt.event.MouseMotionListener"/>
                    <superType superType="java.awt.event.WindowListener"/>
                    <superType superType="java.awt.event.WindowFocusListener"/>
                    <superType superType="java.awt.event.WindowStateListener"/>
                    <superType superType="java.awt.event.ActionListener"/>
                    <superType superType="java.awt.event.ItemListener"/>
                    <superType superType="java.awt.event.AdjustmentListener"/>
                    <superType superType="java.awt.event.TextListener"/>
                    <superType superType="java.awt.event.InputMethodListener"/>
                    <superType superType="java.awt.event.HierarchyListener"/>
                    <superType superType="java.awt.event.HierarchyBoundsListener"/>
                    <superType superType="java.awt.event.MouseWheelListener"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     {@code AWTEventMulticaster} implements efficient and thread-safe multi-cast
                     event dispatching for the AWT events defined in the {@code java.awt.event}
                     package.
                     &lt;p&gt;
                     The following example illustrates how to use this class:
                    
                     &lt;pre&gt;&lt;code&gt;
                     public myComponent extends Component {
                         ActionListener actionListener = null;
                    
                         public synchronized void addActionListener(ActionListener l) {
                             actionListener = AWTEventMulticaster.add(actionListener, l);
                         }
                         public synchronized void removeActionListener(ActionListener l) {
                             actionListener = AWTEventMulticaster.remove(actionListener, l);
                         }
                         public void processEvent(AWTEvent e) {
                             // when event occurs which causes "action" semantic
                             ActionListener listener = actionListener;
                             if (listener != null) {
                                 listener.actionPerformed(new ActionEvent());
                             }
                         }
                     }
                     &lt;/code&gt;&lt;/pre&gt;
                     The important point to note is the first argument to the {@code
                     add} and {@code remove} methods is the field maintaining the
                     listeners. In addition you must assign the result of the {@code add}
                     and {@code remove} methods to the field maintaining the listeners.
                     &lt;p&gt;
                     {@code AWTEventMulticaster} is implemented as a pair of {@code
                     EventListeners} that are set at construction time. {@code
                     AWTEventMulticaster} is immutable. The {@code add} and {@code
                     remove} methods do not alter {@code AWTEventMulticaster} in
                     anyway. If necessary, a new {@code AWTEventMulticaster} is
                     created. In this way it is safe to add and remove listeners during
                     the process of an event dispatching.  However, event listeners
                     added during the process of an event dispatch operation are not
                     notified of the event currently being dispatched.
                     &lt;p&gt;
                     All of the {@code add} methods allow {@code null} arguments. If the
                     first argument is {@code null}, the second argument is returned. If
                     the first argument is not {@code null} and the second argument is
                     {@code null}, the first argument is returned. If both arguments are
                     {@code non-null}, a new {@code AWTEventMulticaster} is created using
                     the two arguments and returned.
                     &lt;p&gt;
                     For the {@code remove} methods that take two arguments, the following is
                     returned:
                     &lt;ul&gt;
                       &lt;li&gt;{@code null}, if the first argument is {@code null}, or
                           the arguments are equal, by way of {@code ==}.
                       &lt;li&gt;the first argument, if the first argument is not an instance of
                           {@code AWTEventMulticaster}.
                       &lt;li&gt;result of invoking {@code remove(EventListener)} on the
                           first argument, supplying the second argument to the
                           {@code remove(EventListener)} method.
                     &lt;/ul&gt;
                     &lt;p&gt;Swing makes use of
                     {@link javax.swing.event.EventListenerList EventListenerList} for
                     similar logic. Refer to it for details.
                    
                     @see javax.swing.event.EventListenerList
                    
                     @author      John Rose
                     @author      Amy Fowler
                     @since       1.1
                    </javadoc>
            </acts>
            <acts name="DefaultFocusTraversalPolicy" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.ContainerOrderFocusTraversalPolicy"/>
                    <superType superType="java.awt.FocusTraversalPolicy"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A FocusTraversalPolicy that determines traversal order based on the order
                     of child Components in a Container. From a particular focus cycle root, the
                     policy makes a pre-order traversal of the Component hierarchy, and traverses
                     a Container's children according to the ordering of the array returned by
                     {@code Container.getComponents()}. Portions of the hierarchy that are
                     not visible and displayable will not be searched.
                     &lt;p&gt;
                     If client code has explicitly set the focusability of a Component by either
                     overriding {@code Component.isFocusTraversable()} or
                     {@code Component.isFocusable()}, or by calling
                     {@code Component.setFocusable()}, then a DefaultFocusTraversalPolicy
                     behaves exactly like a ContainerOrderFocusTraversalPolicy. If, however, the
                     Component is relying on default focusability, then a
                     DefaultFocusTraversalPolicy will reject all Components with non-focusable
                     peers. This is the default FocusTraversalPolicy for all AWT Containers.
                     &lt;p&gt;
                     The focusability of a peer is implementation-dependent. Sun recommends that
                     all implementations for a particular native platform construct peers with
                     the same focusability. The recommendations for Windows and Unix are that
                     Canvases, Labels, Panels, Scrollbars, ScrollPanes, Windows, and lightweight
                     Components have non-focusable peers, and all other Components have focusable
                     peers. These recommendations are used in the Sun AWT implementations. Note
                     that the focusability of a Component's peer is different from, and does not
                     impact, the focusability of the Component itself.
                     &lt;p&gt;
                     Please see
                     &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html"&gt;
                     How to Use the Focus Subsystem&lt;/a&gt;,
                     a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
                     &lt;a href="../../java/awt/doc-files/FocusSpec.html"&gt;Focus Specification&lt;/a&gt;
                     for more information.
                    
                     @author David Mendenhall
                    
                     @see Container#getComponents
                     @see Component#isFocusable
                     @see Component#setFocusable
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="GraphicsEnvironment" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                    
                     The {@code GraphicsEnvironment} class describes the collection
                     of {@link GraphicsDevice} objects and {@link java.awt.Font} objects
                     available to a Java(tm) application on a particular platform.
                     The resources in this {@code GraphicsEnvironment} might be local
                     or on a remote machine.  {@code GraphicsDevice} objects can be
                     screens, printers or image buffers and are the destination of
                     {@link Graphics2D} drawing methods.  Each {@code GraphicsDevice}
                     has a number of {@link GraphicsConfiguration} objects associated with
                     it.  These objects specify the different configurations in which the
                     {@code GraphicsDevice} can be used.
                     @see GraphicsDevice
                     @see GraphicsConfiguration
                    </javadoc>
            </acts>
            <acts name="ImageCapabilities" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Capabilities and properties of images.
                     @author Michael Martak
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="Adjustable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     The interface for objects which have an adjustable numeric value
                     contained within a bounded range of values.
                    
                     @author Amy Fowler
                     @author Tim Prinzing
                    </javadoc>
            </acts>
            <acts name="BaselineResizeBehavior" access="PUBLIC" declaringClass="Component" kind="TYPE" typeKind="ENUM" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="ScrollPane" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.Container"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A container class which implements automatic horizontal and/or
                     vertical scrolling for a single child component.  The display
                     policy for the scrollbars can be set to:
                     &lt;OL&gt;
                     &lt;LI&gt;as needed: scrollbars created and shown only when needed by scrollpane
                     &lt;LI&gt;always: scrollbars created and always shown by the scrollpane
                     &lt;LI&gt;never: scrollbars never created or shown by the scrollpane
                     &lt;/OL&gt;
                     &lt;P&gt;
                     The state of the horizontal and vertical scrollbars is represented
                     by two {@code ScrollPaneAdjustable} objects (one for each
                     dimension) which implement the {@code Adjustable} interface.
                     The API provides methods to access those objects such that the
                     attributes on the Adjustable object (such as unitIncrement, value,
                     etc.) can be manipulated.
                     &lt;P&gt;
                     Certain adjustable properties (minimum, maximum, blockIncrement,
                     and visibleAmount) are set internally by the scrollpane in accordance
                     with the geometry of the scrollpane and its child and these should
                     not be set by programs using the scrollpane.
                     &lt;P&gt;
                     If the scrollbar display policy is defined as "never", then the
                     scrollpane can still be programmatically scrolled using the
                     setScrollPosition() method and the scrollpane will move and clip
                     the child's contents appropriately.  This policy is useful if the
                     program needs to create and manage its own adjustable controls.
                     &lt;P&gt;
                     The placement of the scrollbars is controlled by platform-specific
                     properties set by the user outside of the program.
                     &lt;P&gt;
                     The initial size of this container is set to 100x100, but can
                     be reset using setSize().
                     &lt;P&gt;
                     Scrolling with the wheel on a wheel-equipped mouse is enabled by default.
                     This can be disabled using {@code setWheelScrollingEnabled}.
                     Wheel scrolling can be customized by setting the block and
                     unit increment of the horizontal and vertical Adjustables.
                     For information on how mouse wheel events are dispatched, see
                     the class description for {@link MouseWheelEvent}.
                     &lt;P&gt;
                     Insets are used to define any space used by scrollbars and any
                     borders created by the scroll pane. getInsets() can be used
                     to get the current value for the insets.  If the value of
                     scrollbarsAlwaysVisible is false, then the value of the insets
                     will change dynamically depending on whether the scrollbars are
                     currently visible or not.
                    
                     @author      Tom Ball
                     @author      Amy Fowler
                     @author      Tim Prinzing
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTFrame" access="PROTECTED" declaringClass="Frame" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Window$AccessibleAWTWindow"/>
                    <superType superType="java.awt.Container$AccessibleAWTContainer"/>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="PaintContext" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     The {@code PaintContext} interface defines the encapsulated
                     and optimized environment to generate color patterns in device
                     space for fill or stroke operations on a
                     {@link Graphics2D}.  The {@code PaintContext} provides
                     the necessary colors for {@code Graphics2D} operations in the
                     form of a {@link Raster} associated with a {@link ColorModel}.
                     The {@code PaintContext} maintains state for a particular paint
                     operation.  In a multi-threaded environment, several
                     contexts can exist simultaneously for a single {@link Paint} object.
                     @see Paint
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTListChild" access="PROTECTED" declaringClass="List.AccessibleAWTList" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Frame" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.MenuContainer"/>
                    <superType superType="java.awt.Window"/>
                    <superType superType="java.awt.Container"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@code Frame} is a top-level window with a title and a border.
                     &lt;p&gt;
                     The size of the frame includes any area designated for the
                     border.  The dimensions of the border area may be obtained
                     using the {@code getInsets} method, however, since
                     these dimensions are platform-dependent, a valid insets
                     value cannot be obtained until the frame is made displayable
                     by either calling {@code pack} or {@code show}.
                     Since the border area is included in the overall size of the
                     frame, the border effectively obscures a portion of the frame,
                     constraining the area available for rendering and/or displaying
                     subcomponents to the rectangle which has an upper-left corner
                     location of {@code (insets.left, insets.top)}, and has a size of
                     {@code width - (insets.left + insets.right)} by
                     {@code height - (insets.top + insets.bottom)}.
                     &lt;p&gt;
                     The default layout for a frame is {@code BorderLayout}.
                     &lt;p&gt;
                     A frame may have its native decorations (i.e. {@code Frame}
                     and {@code Titlebar}) turned off
                     with {@code setUndecorated}. This can only be done while the frame
                     is not {@link Component#isDisplayable() displayable}.
                     &lt;p&gt;
                     In a multi-screen environment, you can create a {@code Frame}
                     on a different screen device by constructing the {@code Frame}
                     with {@link #Frame(GraphicsConfiguration)} or
                     {@link #Frame(String title, GraphicsConfiguration)}.  The
                     {@code GraphicsConfiguration} object is one of the
                     {@code GraphicsConfiguration} objects of the target screen
                     device.
                     &lt;p&gt;
                     In a virtual device multi-screen environment in which the desktop
                     area could span multiple physical screen devices, the bounds of all
                     configurations are relative to the virtual-coordinate system.  The
                     origin of the virtual-coordinate system is at the upper left-hand
                     corner of the primary physical screen.  Depending on the location
                     of the primary screen in the virtual device, negative coordinates
                     are possible, as shown in the following figure.
                     &lt;p&gt;
                     &lt;img src="doc-files/MultiScreen.gif"
                     alt="Diagram of virtual device encompassing three physical screens and one primary physical screen. The primary physical screen
                     shows (0,0) coords while a different physical screen shows (-80,-100) coords."
                     style="float:center; margin: 7px 10px;"&gt;
                     &lt;p&gt;
                     In such an environment, when calling {@code setLocation},
                     you must pass a virtual coordinate to this method.  Similarly,
                     calling {@code getLocationOnScreen} on a {@code Frame}
                     returns virtual device coordinates.  Call the {@code getBounds}
                     method of a {@code GraphicsConfiguration} to find its origin in
                     the virtual coordinate system.
                     &lt;p&gt;
                     The following code sets the
                     location of the {@code Frame} at (10, 10) relative
                     to the origin of the physical screen of the corresponding
                     {@code GraphicsConfiguration}.  If the bounds of the
                     {@code GraphicsConfiguration} is not taken into account, the
                     {@code Frame} location would be set at (10, 10) relative to the
                     virtual-coordinate system and would appear on the primary physical
                     screen, which might be different from the physical screen of the
                     specified {@code GraphicsConfiguration}.
                    
                     &lt;pre&gt;
                          Frame f = new Frame(GraphicsConfiguration gc);
                          Rectangle bounds = gc.getBounds();
                          f.setLocation(10 + bounds.x, 10 + bounds.y);
                     &lt;/pre&gt;
                    
                     &lt;p&gt;
                     Frames are capable of generating the following types of
                     {@code WindowEvent}s:
                     &lt;ul&gt;
                     &lt;li&gt;{@code WINDOW_OPENED}
                     &lt;li&gt;{@code WINDOW_CLOSING}:
                         &lt;br&gt;If the program doesn't
                         explicitly hide or dispose the window while processing
                         this event, the window close operation is canceled.
                     &lt;li&gt;{@code WINDOW_CLOSED}
                     &lt;li&gt;{@code WINDOW_ICONIFIED}
                     &lt;li&gt;{@code WINDOW_DEICONIFIED}
                     &lt;li&gt;{@code WINDOW_ACTIVATED}
                     &lt;li&gt;{@code WINDOW_DEACTIVATED}
                     &lt;li&gt;{@code WINDOW_GAINED_FOCUS}
                     &lt;li&gt;{@code WINDOW_LOST_FOCUS}
                     &lt;li&gt;{@code WINDOW_STATE_CHANGED}
                     &lt;/ul&gt;
                    
                     @author      Sami Shaio
                     @see WindowEvent
                     @see Window#addWindowListener
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTScrollPane" access="PROTECTED" declaringClass="ScrollPane" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Container$AccessibleAWTContainer"/>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Transparency" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     The {@code Transparency} interface defines the common transparency
                     modes for implementing classes.
                    </javadoc>
            </acts>
            <acts name="MessageType" access="PUBLIC" declaringClass="TrayIcon" kind="TYPE" typeKind="ENUM" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Shape" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     The {@code Shape} interface provides definitions for objects
                     that represent some form of geometric shape.  The {@code Shape}
                     is described by a {@link PathIterator} object, which can express the
                     outline of the {@code Shape} as well as a rule for determining
                     how the outline divides the 2D plane into interior and exterior
                     points.  Each {@code Shape} object provides callbacks to get the
                     bounding box of the geometry, determine whether points or
                     rectangles lie partly or entirely within the interior
                     of the {@code Shape}, and retrieve a {@code PathIterator}
                     object that describes the trajectory path of the {@code Shape}
                     outline.
                     &lt;p&gt;
                     &lt;a id="def_insideness"&gt;&lt;b&gt;Definition of insideness:&lt;/b&gt;&lt;/a&gt;
                     A point is considered to lie inside a
                     {@code Shape} if and only if:
                     &lt;ul&gt;
                     &lt;li&gt; it lies completely
                     inside the {@code Shape} boundary &lt;i&gt;or&lt;/i&gt;
                     &lt;li&gt;
                     it lies exactly on the {@code Shape} boundary &lt;i&gt;and&lt;/i&gt; the
                     space immediately adjacent to the
                     point in the increasing {@code X} direction is
                     entirely inside the boundary &lt;i&gt;or&lt;/i&gt;
                     &lt;li&gt;
                     it lies exactly on a horizontal boundary segment &lt;b&gt;and&lt;/b&gt; the
                     space immediately adjacent to the point in the
                     increasing {@code Y} direction is inside the boundary.
                     &lt;/ul&gt;
                     &lt;p&gt;The {@code contains} and {@code intersects} methods
                     consider the interior of a {@code Shape} to be the area it
                     encloses as if it were filled.  This means that these methods
                     consider
                     unclosed shapes to be implicitly closed for the purpose of
                     determining if a shape contains or intersects a rectangle or if a
                     shape contains a point.
                    
                     @see java.awt.geom.PathIterator
                     @see java.awt.geom.AffineTransform
                     @see java.awt.geom.FlatteningPathIterator
                     @see java.awt.geom.GeneralPath
                    
                     @author Jim Graham
                     @since 1.2
                    </javadoc>
            </acts>
            <acts name="GridBagLayout" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.LayoutManager2"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code GridBagLayout} class is a flexible layout
                     manager that aligns components vertically, horizontally or along their
                     baseline without requiring that the components be of the same size.
                     Each {@code GridBagLayout} object maintains a dynamic,
                     rectangular grid of cells, with each component occupying
                     one or more cells, called its &lt;em&gt;display area&lt;/em&gt;.
                     &lt;p&gt;
                     Each component managed by a {@code GridBagLayout} is associated with
                     an instance of {@link GridBagConstraints}.  The constraints object
                     specifies where a component's display area should be located on the grid
                     and how the component should be positioned within its display area.  In
                     addition to its constraints object, the {@code GridBagLayout} also
                     considers each component's minimum and preferred sizes in order to
                     determine a component's size.
                     &lt;p&gt;
                     The overall orientation of the grid depends on the container's
                     {@link ComponentOrientation} property.  For horizontal left-to-right
                     orientations, grid coordinate (0,0) is in the upper left corner of the
                     container with x increasing to the right and y increasing downward.  For
                     horizontal right-to-left orientations, grid coordinate (0,0) is in the upper
                     right corner of the container with x increasing to the left and y
                     increasing downward.
                     &lt;p&gt;
                     To use a grid bag layout effectively, you must customize one or more
                     of the {@code GridBagConstraints} objects that are associated
                     with its components. You customize a {@code GridBagConstraints}
                     object by setting one or more of its instance variables:
                    
                     &lt;dl&gt;
                     &lt;dt&gt;{@link GridBagConstraints#gridx},
                     {@link GridBagConstraints#gridy}
                     &lt;dd&gt;Specifies the cell containing the leading corner of the component's
                     display area, where the cell at the origin of the grid has address
                     &lt;code&gt;gridx&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;,
                     &lt;code&gt;gridy&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;.  For horizontal left-to-right layout,
                     a component's leading corner is its upper left.  For horizontal
                     right-to-left layout, a component's leading corner is its upper right.
                     Use {@code GridBagConstraints.RELATIVE} (the default value)
                     to specify that the component be placed immediately following
                     (along the x axis for {@code gridx} or the y axis for
                     {@code gridy}) the component that was added to the container
                     just before this component was added.
                     &lt;dt&gt;{@link GridBagConstraints#gridwidth},
                     {@link GridBagConstraints#gridheight}
                     &lt;dd&gt;Specifies the number of cells in a row (for {@code gridwidth})
                     or column (for {@code gridheight})
                     in the component's display area.
                     The default value is 1.
                     Use {@code GridBagConstraints.REMAINDER} to specify
                     that the component's display area will be from {@code gridx}
                     to the last cell in the row (for {@code gridwidth})
                     or from {@code gridy} to the last cell in the column
                     (for {@code gridheight}).
                    
                     Use {@code GridBagConstraints.RELATIVE} to specify
                     that the component's display area will be from {@code gridx}
                     to the next to the last cell in its row (for {@code gridwidth}
                     or from {@code gridy} to the next to the last cell in its
                     column (for {@code gridheight}).
                    
                     &lt;dt&gt;{@link GridBagConstraints#fill}
                     &lt;dd&gt;Used when the component's display area
                     is larger than the component's requested size
                     to determine whether (and how) to resize the component.
                     Possible values are
                     {@code GridBagConstraints.NONE} (the default),
                     {@code GridBagConstraints.HORIZONTAL}
                     (make the component wide enough to fill its display area
                     horizontally, but don't change its height),
                     {@code GridBagConstraints.VERTICAL}
                     (make the component tall enough to fill its display area
                     vertically, but don't change its width), and
                     {@code GridBagConstraints.BOTH}
                     (make the component fill its display area entirely).
                     &lt;dt&gt;{@link GridBagConstraints#ipadx},
                     {@link GridBagConstraints#ipady}
                     &lt;dd&gt;Specifies the component's internal padding within the layout,
                     how much to add to the minimum size of the component.
                     The width of the component will be at least its minimum width
                     plus {@code ipadx} pixels. Similarly, the height of
                     the component will be at least the minimum height plus
                     {@code ipady} pixels.
                     &lt;dt&gt;{@link GridBagConstraints#insets}
                     &lt;dd&gt;Specifies the component's external padding, the minimum
                     amount of space between the component and the edges of its display area.
                     &lt;dt&gt;{@link GridBagConstraints#anchor}
                     &lt;dd&gt;Specifies where the component should be positioned in its display area.
                     There are three kinds of possible values: absolute, orientation-relative,
                     and baseline-relative
                     Orientation relative values are interpreted relative to the container's
                     {@code ComponentOrientation} property while absolute values
                     are not.  Baseline relative values are calculated relative to the
                     baseline.  Valid values are:
                    
                     &lt;table class="striped" style="margin: 0px auto"&gt;
                     &lt;caption&gt;Absolute, relative and baseline values as described above&lt;/caption&gt;
                     &lt;thead&gt;
                     &lt;tr&gt;
                     &lt;th&gt;&lt;p style="text-align:center"&gt;Absolute Values&lt;/th&gt;
                     &lt;th&gt;&lt;p style="text-align:center"&gt;Orientation Relative Values&lt;/th&gt;
                     &lt;th&gt;&lt;p style="text-align:center"&gt;Baseline Relative Values&lt;/th&gt;
                     &lt;/tr&gt;
                     &lt;/thead&gt;
                     &lt;tbody&gt;
                     &lt;tr&gt;
                     &lt;td&gt;
                     &lt;ul style="list-style-type:none"&gt;
                     &lt;li&gt;{@code GridBagConstraints.NORTH}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.SOUTH}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.WEST}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.EAST}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.NORTHWEST}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.NORTHEAST}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.SOUTHWEST}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.SOUTHEAST}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.CENTER} (the default)&lt;/li&gt;
                     &lt;/ul&gt;
                     &lt;/td&gt;
                     &lt;td&gt;
                     &lt;ul style="list-style-type:none"&gt;
                     &lt;li&gt;{@code GridBagConstraints.PAGE_START}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.PAGE_END}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.LINE_START}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.LINE_END}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.FIRST_LINE_START}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.FIRST_LINE_END}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.LAST_LINE_START}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.LAST_LINE_END}&lt;/li&gt;
                     &lt;/ul&gt;
                     &lt;/td&gt;
                     &lt;td&gt;
                     &lt;ul style="list-style-type:none"&gt;
                     &lt;li&gt;{@code GridBagConstraints.BASELINE}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.BASELINE_LEADING}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.BASELINE_TRAILING}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.ABOVE_BASELINE}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.ABOVE_BASELINE_LEADING}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.ABOVE_BASELINE_TRAILING}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.BELOW_BASELINE}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.BELOW_BASELINE_LEADING}&lt;/li&gt;
                     &lt;li&gt;{@code GridBagConstraints.BELOW_BASELINE_TRAILING}&lt;/li&gt;
                     &lt;/ul&gt;
                     &lt;/td&gt;
                     &lt;/tr&gt;
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                     &lt;dt&gt;{@link GridBagConstraints#weightx},
                     {@link GridBagConstraints#weighty}
                     &lt;dd&gt;Used to determine how to distribute space, which is
                     important for specifying resizing behavior.
                     Unless you specify a weight for at least one component
                     in a row ({@code weightx}) and column ({@code weighty}),
                     all the components clump together in the center of their container.
                     This is because when the weight is zero (the default),
                     the {@code GridBagLayout} object puts any extra space
                     between its grid of cells and the edges of the container.
                     &lt;/dl&gt;
                     &lt;p&gt;
                     Each row may have a baseline; the baseline is determined by the
                     components in that row that have a valid baseline and are aligned
                     along the baseline (the component's anchor value is one of {@code
                     BASELINE}, {@code BASELINE_LEADING} or {@code BASELINE_TRAILING}).
                     If none of the components in the row has a valid baseline, the row
                     does not have a baseline.
                     &lt;p&gt;
                     If a component spans rows it is aligned either to the baseline of
                     the start row (if the baseline-resize behavior is {@code
                     CONSTANT_ASCENT}) or the end row (if the baseline-resize behavior
                     is {@code CONSTANT_DESCENT}).  The row that the component is
                     aligned to is called the &lt;em&gt;prevailing row&lt;/em&gt;.
                     &lt;p&gt;
                     The following figure shows a baseline layout and includes a
                     component that spans rows:
                     &lt;table class="borderless" style="margin: 0px auto"&gt;
                     &lt;caption&gt;Baseline Layout&lt;/caption&gt;
                     &lt;tr style="text-align:center"&gt;
                     &lt;td&gt;
                     &lt;img src="doc-files/GridBagLayout-baseline.png"
                      alt="The following text describes this graphic (Figure 1)." style="float:center"&gt;
                     &lt;/td&gt;
                     &lt;/table&gt;
                     This layout consists of three components:
                     &lt;ul&gt;&lt;li&gt;A panel that starts in row 0 and ends in row 1.  The panel
                       has a baseline-resize behavior of {@code CONSTANT_DESCENT} and has
                       an anchor of {@code BASELINE}.  As the baseline-resize behavior
                       is {@code CONSTANT_DESCENT} the prevailing row for the panel is
                       row 1.
                     &lt;li&gt;Two buttons, each with a baseline-resize behavior of
                       {@code CENTER_OFFSET} and an anchor of {@code BASELINE}.
                     &lt;/ul&gt;
                     Because the second button and the panel share the same prevailing row,
                     they are both aligned along their baseline.
                     &lt;p&gt;
                     Components positioned using one of the baseline-relative values resize
                     differently than when positioned using an absolute or orientation-relative
                     value.  How components change is dictated by how the baseline of the
                     prevailing row changes.  The baseline is anchored to the
                     bottom of the display area if any components with the same prevailing row
                     have a baseline-resize behavior of {@code CONSTANT_DESCENT},
                     otherwise the baseline is anchored to the top of the display area.
                     The following rules dictate the resize behavior:
                     &lt;ul&gt;
                     &lt;li&gt;Resizable components positioned above the baseline can only
                     grow as tall as the baseline.  For example, if the baseline is at 100
                     and anchored at the top, a resizable component positioned above the
                     baseline can never grow more than 100 units.
                     &lt;li&gt;Similarly, resizable components positioned below the baseline can
                     only grow as high as the difference between the display height and the
                     baseline.
                     &lt;li&gt;Resizable components positioned on the baseline with a
                     baseline-resize behavior of {@code OTHER} are only resized if
                     the baseline at the resized size fits within the display area.  If
                     the baseline is such that it does not fit within the display area
                     the component is not resized.
                     &lt;li&gt;Components positioned on the baseline that do not have a
                     baseline-resize behavior of {@code OTHER}
                     can only grow as tall as {@code display height - baseline + baseline of component}.
                     &lt;/ul&gt;
                     If you position a component along the baseline, but the
                     component does not have a valid baseline, it will be vertically centered
                     in its space.  Similarly if you have positioned a component relative
                     to the baseline and none of the components in the row have a valid
                     baseline the component is vertically centered.
                     &lt;p&gt;
                     The following figures show ten components (all buttons)
                     managed by a grid bag layout.  Figure 2 shows the layout for a horizontal,
                     left-to-right container and Figure 3 shows the layout for a horizontal,
                     right-to-left container.
                    
                     &lt;table class="borderless" style="margin: 0px auto"&gt;
                     &lt;caption style="width:600;display:none"&gt;Figures&lt;/caption&gt;
                     &lt;tr style="text-align:center"&gt;
                     &lt;td&gt;
                     &lt;img src="doc-files/GridBagLayout-1.gif" alt="The preceding text describes this graphic (Figure 1)." style="float:center; margin: 7px 10px;"&gt;
                     &lt;/td&gt;
                     &lt;td&gt;
                     &lt;img src="doc-files/GridBagLayout-2.gif" alt="The preceding text describes this graphic (Figure 2)." style="float:center; margin: 7px 10px;"&gt;
                     &lt;/td&gt;
                     &lt;tr style="text-align:center"&gt;
                     &lt;td&gt;Figure 2: Horizontal, Left-to-Right&lt;/td&gt;
                     &lt;td&gt;Figure 3: Horizontal, Right-to-Left&lt;/td&gt;
                     &lt;/tr&gt;
                     &lt;/table&gt;
                     &lt;p&gt;
                     Each of the ten components has the {@code fill} field
                     of its associated {@code GridBagConstraints} object
                     set to {@code GridBagConstraints.BOTH}.
                     In addition, the components have the following non-default constraints:
                    
                     &lt;ul&gt;
                     &lt;li&gt;Button1, Button2, Button3: &lt;code&gt;weightx&amp;nbsp;=&amp;nbsp;1.0&lt;/code&gt;
                     &lt;li&gt;Button4: &lt;code&gt;weightx&amp;nbsp;=&amp;nbsp;1.0&lt;/code&gt;,
                     &lt;code&gt;gridwidth&amp;nbsp;=&amp;nbsp;GridBagConstraints.REMAINDER&lt;/code&gt;
                     &lt;li&gt;Button5: &lt;code&gt;gridwidth&amp;nbsp;=&amp;nbsp;GridBagConstraints.REMAINDER&lt;/code&gt;
                     &lt;li&gt;Button6: &lt;code&gt;gridwidth&amp;nbsp;=&amp;nbsp;GridBagConstraints.RELATIVE&lt;/code&gt;
                     &lt;li&gt;Button7: &lt;code&gt;gridwidth&amp;nbsp;=&amp;nbsp;GridBagConstraints.REMAINDER&lt;/code&gt;
                     &lt;li&gt;Button8: &lt;code&gt;gridheight&amp;nbsp;=&amp;nbsp;2&lt;/code&gt;,
                     &lt;code&gt;weighty&amp;nbsp;=&amp;nbsp;1.0&lt;/code&gt;
                     &lt;li&gt;Button9, Button 10:
                     &lt;code&gt;gridwidth&amp;nbsp;=&amp;nbsp;GridBagConstraints.REMAINDER&lt;/code&gt;
                     &lt;/ul&gt;
                     &lt;p&gt;
                     Here is the code that implements the example shown above:
                    
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                     import java.awt.*;
                     import java.util.*;
                     import java.applet.Applet;
                    
                     public class GridBagEx1 extends Applet {
                    
                         protected void makebutton(String name,
                                                   GridBagLayout gridbag,
                                                   GridBagConstraints c) {
                             Button button = new Button(name);
                             gridbag.setConstraints(button, c);
                             add(button);
                         }
                    
                         public void init() {
                             GridBagLayout gridbag = new GridBagLayout();
                             GridBagConstraints c = new GridBagConstraints();
                    
                             setFont(new Font("SansSerif", Font.PLAIN, 14));
                             setLayout(gridbag);
                    
                             c.fill = GridBagConstraints.BOTH;
                             c.weightx = 1.0;
                             makebutton("Button1", gridbag, c);
                             makebutton("Button2", gridbag, c);
                             makebutton("Button3", gridbag, c);
                    
                             c.gridwidth = GridBagConstraints.REMAINDER; //end row
                             makebutton("Button4", gridbag, c);
                    
                             c.weightx = 0.0;                //reset to the default
                             makebutton("Button5", gridbag, c); //another row
                    
                             c.gridwidth = GridBagConstraints.RELATIVE; //next-to-last in row
                             makebutton("Button6", gridbag, c);
                    
                             c.gridwidth = GridBagConstraints.REMAINDER; //end row
                             makebutton("Button7", gridbag, c);
                    
                             c.gridwidth = 1;                //reset to the default
                             c.gridheight = 2;
                             c.weighty = 1.0;
                             makebutton("Button8", gridbag, c);
                    
                             c.weighty = 0.0;                //reset to the default
                             c.gridwidth = GridBagConstraints.REMAINDER; //end row
                             c.gridheight = 1;               //reset to the default
                             makebutton("Button9", gridbag, c);
                             makebutton("Button10", gridbag, c);
                    
                             setSize(300, 100);
                         }
                    
                         public static void main(String args[]) {
                             Frame f = new Frame("GridBag Layout Example");
                             GridBagEx1 ex1 = new GridBagEx1();
                    
                             ex1.init();
                    
                             f.add("Center", ex1);
                             f.pack();
                             f.setSize(f.getPreferredSize());
                             f.show();
                         }
                     }
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                    
                     @author Doug Stein
                     @author Bill Spitzak (orignial NeWS &amp;amp; OLIT implementation)
                     @see       java.awt.GridBagConstraints
                     @see       java.awt.GridBagLayoutInfo
                     @see       java.awt.ComponentOrientation
                     @since 1.0
                    </javadoc>
            </acts>
            <acts name="HeadlessException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.UnsupportedOperationException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown when code that is dependent on a keyboard, display, or mouse
                     is called in an environment that does not support a keyboard, display,
                     or mouse. Any code that depends on any of those devices should firstly
                     ensure their availability using the {@code GraphicsEnvironment.isHeadless()}
                     method and throw {@code HeadlessException} if the latter returns
                     {@code true}.
                    
                     @since 1.4
                     @author  Michael Martak
                     @see GraphicsEnvironment#isHeadless
                    </javadoc>
            </acts>
            <acts name="ActiveEvent" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     An interface for events that know how to dispatch themselves.
                     By implementing this interface an event can be placed upon the event
                     queue and its {@code dispatch()} method will be called when the event
                     is dispatched, using the {@code EventDispatchThread}.
                     &lt;p&gt;
                     This is a very useful mechanism for avoiding deadlocks. If
                     a thread is executing in a critical section (i.e., it has entered
                     one or more monitors), calling other synchronized code may
                     cause deadlocks. To avoid the potential deadlocks, an
                     {@code ActiveEvent} can be created to run the second section of
                     code at later time. If there is contention on the monitor,
                     the second thread will simply block until the first thread
                     has finished its work and exited its monitors.
                     &lt;p&gt;
                     For security reasons, it is often desirable to use an {@code ActiveEvent}
                     to avoid calling untrusted code from a critical thread. For
                     instance, peer implementations can use this facility to avoid
                     making calls into user code from a system thread. Doing so avoids
                     potential deadlocks and denial-of-service attacks.
                    
                     @author  Timothy Prinzing
                     @since   1.2
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTCheckbox" access="PROTECTED" declaringClass="Checkbox" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.event.ItemListener"/>
                    <superType superType="javax.accessibility.AccessibleAction"/>
                    <superType superType="javax.accessibility.AccessibleValue"/>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="FocusTraversalPolicy" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A FocusTraversalPolicy defines the order in which Components with a
                     particular focus cycle root are traversed. Instances can apply the policy to
                     arbitrary focus cycle roots, allowing themselves to be shared across
                     Containers. They do not need to be reinitialized when the focus cycle roots
                     of a Component hierarchy change.
                     &lt;p&gt;
                     The core responsibility of a FocusTraversalPolicy is to provide algorithms
                     determining the next and previous Components to focus when traversing
                     forward or backward in a UI. Each FocusTraversalPolicy must also provide
                     algorithms for determining the first, last, and default Components in a
                     traversal cycle. First and last Components are used when normal forward and
                     backward traversal, respectively, wraps. The default Component is the first
                     to receive focus when traversing down into a new focus traversal cycle.
                     A FocusTraversalPolicy can optionally provide an algorithm for determining
                     a Window's initial Component. The initial Component is the first to receive
                     focus when a Window is first made visible.
                     &lt;p&gt;
                     FocusTraversalPolicy takes into account &lt;a
                     href="doc-files/FocusSpec.html#FocusTraversalPolicyProviders"&gt;focus traversal
                     policy providers&lt;/a&gt;.  When searching for first/last/next/previous Component,
                     if a focus traversal policy provider is encountered, its focus traversal
                     policy is used to perform the search operation.
                     &lt;p&gt;
                     Please see
                     &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html"&gt;
                     How to Use the Focus Subsystem&lt;/a&gt;,
                     a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
                     &lt;a href="../../java/awt/doc-files/FocusSpec.html"&gt;Focus Specification&lt;/a&gt;
                     for more information.
                    
                     @author David Mendenhall
                    
                     @see Container#setFocusTraversalPolicy
                     @see Container#getFocusTraversalPolicy
                     @see Container#setFocusCycleRoot
                     @see Container#isFocusCycleRoot
                     @see Container#setFocusTraversalPolicyProvider
                     @see Container#isFocusTraversalPolicyProvider
                     @see KeyboardFocusManager#setDefaultFocusTraversalPolicy
                     @see KeyboardFocusManager#getDefaultFocusTraversalPolicy
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTComponentHandler" access="PROTECTED" declaringClass="Component.AccessibleAWTComponent" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.event.ComponentListener"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="AccessibleAWTComponent" access="PROTECTED" declaringClass="Component" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="javax.accessibility.AccessibleComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Font" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Font} class represents fonts, which are used to
                     render text in a visible way.
                     A font provides the information needed to map sequences of
                     &lt;em&gt;characters&lt;/em&gt; to sequences of &lt;em&gt;glyphs&lt;/em&gt;
                     and to render sequences of glyphs on {@code Graphics} and
                     {@code Component} objects.
                    
                     &lt;h3&gt;Characters and Glyphs&lt;/h3&gt;
                    
                     A &lt;em&gt;character&lt;/em&gt; is a symbol that represents an item such as a letter,
                     a digit, or punctuation in an abstract way. For example, {@code 'g'},
                     LATIN SMALL LETTER G, is a character.
                     &lt;p&gt;
                     A &lt;em&gt;glyph&lt;/em&gt; is a shape used to render a character or a sequence of
                     characters. In simple writing systems, such as Latin, typically one glyph
                     represents one character. In general, however, characters and glyphs do not
                     have one-to-one correspondence. For example, the character '&amp;aacute;'
                     LATIN SMALL LETTER A WITH ACUTE, can be represented by
                     two glyphs: one for 'a' and one for '&amp;acute;'. On the other hand, the
                     two-character string "fi" can be represented by a single glyph, an
                     "fi" ligature. In complex writing systems, such as Arabic or the South
                     and South-East Asian writing systems, the relationship between characters
                     and glyphs can be more complicated and involve context-dependent selection
                     of glyphs as well as glyph reordering.
                    
                     A font encapsulates the collection of glyphs needed to render a selected set
                     of characters as well as the tables needed to map sequences of characters to
                     corresponding sequences of glyphs.
                    
                     &lt;h3&gt;Physical and Logical Fonts&lt;/h3&gt;
                    
                     The Java Platform distinguishes between two kinds of fonts:
                     &lt;em&gt;physical&lt;/em&gt; fonts and &lt;em&gt;logical&lt;/em&gt; fonts.
                     &lt;p&gt;
                     &lt;em&gt;Physical&lt;/em&gt; fonts are the actual font libraries containing glyph data
                     and tables to map from character sequences to glyph sequences, using a font
                     technology such as TrueType or PostScript Type 1.
                     All implementations of the Java Platform must support TrueType fonts;
                     support for other font technologies is implementation dependent.
                     Physical fonts may use names such as Helvetica, Palatino, HonMincho, or
                     any number of other font names.
                     Typically, each physical font supports only a limited set of writing
                     systems, for example, only Latin characters or only Japanese and Basic
                     Latin.
                     The set of available physical fonts varies between configurations.
                     Applications that require specific fonts can bundle them and instantiate
                     them using the {@link #createFont createFont} method.
                     &lt;p&gt;
                     &lt;em&gt;Logical&lt;/em&gt; fonts are the five font families defined by the Java
                     platform which must be supported by any Java runtime environment:
                     Serif, SansSerif, Monospaced, Dialog, and DialogInput.
                     These logical fonts are not actual font libraries. Instead, the logical
                     font names are mapped to physical fonts by the Java runtime environment.
                     The mapping is implementation and usually locale dependent, so the look
                     and the metrics provided by them vary.
                     Typically, each logical font name maps to several physical fonts in order to
                     cover a large range of characters.
                     &lt;p&gt;
                     Peered AWT components, such as {@link Label Label} and
                     {@link TextField TextField}, can only use logical fonts.
                     &lt;p&gt;
                     For a discussion of the relative advantages and disadvantages of using
                     physical or logical fonts, see the
                     &lt;a href="https://docs.oracle.com/javase/tutorial/2d/text/fonts.html#advantages-and-disadvantages"&gt;
                        Physical and Logical Fonts&lt;/a&gt;
                     in &lt;a href="https://docs.oracle.com/javase/tutorial/index.html"&gt;The Java Tutorials&lt;/a&gt;
                     document.
                    
                     &lt;h3&gt;Font Faces and Names&lt;/h3&gt;
                    
                     A {@code Font}
                     can have many faces, such as heavy, medium, oblique, gothic and
                     regular. All of these faces have similar typographic design.
                     &lt;p&gt;
                     There are three different names that you can get from a
                     {@code Font} object.  The &lt;em&gt;logical font name&lt;/em&gt; is simply the
                     name that was used to construct the font.
                     The &lt;em&gt;font face name&lt;/em&gt;, or just &lt;em&gt;font name&lt;/em&gt; for
                     short, is the name of a particular font face, like Helvetica Bold. The
                     &lt;em&gt;family name&lt;/em&gt; is the name of the font family that determines the
                     typographic design across several faces, like Helvetica.
                     &lt;p&gt;
                     The {@code Font} class represents an instance of a font face from
                     a collection of  font faces that are present in the system resources
                     of the host system.  As examples, Arial Bold and Courier Bold Italic
                     are font faces.  There can be several {@code Font} objects
                     associated with a font face, each differing in size, style, transform
                     and font features.
                     &lt;p&gt;
                     Glyphs may not always be rendered with the requested properties (e.g, font
                     and style) due to platform limitations such as the absence of suitable
                     platform fonts to implement a logical font.
                     &lt;p&gt;
                     The {@link GraphicsEnvironment#getAllFonts() getAllFonts} method
                     of the {@code GraphicsEnvironment} class returns an
                     array of all font faces available in the system. These font faces are
                     returned as {@code Font} objects with a size of 1, identity
                     transform and default font features. These
                     base fonts can then be used to derive new {@code Font} objects
                     with varying sizes, styles, transforms and font features via the
                     {@code deriveFont} methods in this class.
                    
                     &lt;h3&gt;Font and TextAttribute&lt;/h3&gt;
                    
                     &lt;p&gt;{@code Font} supports most
                     {@code TextAttribute}s.  This makes some operations, such as
                     rendering underlined text, convenient since it is not
                     necessary to explicitly construct a {@code TextLayout} object.
                     Attributes can be set on a Font by constructing or deriving it
                     using a {@code Map} of {@code TextAttribute} values.
                    
                     &lt;p&gt;The values of some {@code TextAttributes} are not
                     serializable, and therefore attempting to serialize an instance of
                     {@code Font} that has such values will not serialize them.
                     This means a Font deserialized from such a stream will not compare
                     equal to the original Font that contained the non-serializable
                     attributes.  This should very rarely pose a problem
                     since these attributes are typically used only in special
                     circumstances and are unlikely to be serialized.
                    
                     &lt;ul&gt;
                     &lt;li&gt;{@code FOREGROUND} and {@code BACKGROUND} use
                     {@code Paint} values. The subclass {@code Color} is
                     serializable, while {@code GradientPaint} and
                     {@code TexturePaint} are not.&lt;/li&gt;
                     &lt;li&gt;{@code CHAR_REPLACEMENT} uses
                     {@code GraphicAttribute} values.  The subclasses
                     {@code ShapeGraphicAttribute} and
                     {@code ImageGraphicAttribute} are not serializable.&lt;/li&gt;
                     &lt;li&gt;{@code INPUT_METHOD_HIGHLIGHT} uses
                     {@code InputMethodHighlight} values, which are
                     not serializable.  See {@link java.awt.im.InputMethodHighlight}.&lt;/li&gt;
                     &lt;/ul&gt;
                    
                     &lt;p&gt;Clients who create custom subclasses of {@code Paint} and
                     {@code GraphicAttribute} can make them serializable and
                     avoid this problem.  Clients who use input method highlights can
                     convert these to the platform-specific attributes for that
                     highlight on the current platform and set them on the Font as
                     a workaround.
                    
                     &lt;p&gt;The {@code Map}-based constructor and
                     {@code deriveFont} APIs ignore the FONT attribute, and it is
                     not retained by the Font; the static {@link #getFont} method should
                     be used if the FONT attribute might be present.  See {@link
                     java.awt.font.TextAttribute#FONT} for more information.&lt;/p&gt;
                    
                     &lt;p&gt;Several attributes will cause additional rendering overhead
                     and potentially invoke layout.  If a {@code Font} has such
                     attributes, the &lt;code&gt;{@link #hasLayoutAttributes()}&lt;/code&gt; method
                     will return true.&lt;/p&gt;
                    
                     &lt;p&gt;Note: Font rotations can cause text baselines to be rotated.  In
                     order to account for this (rare) possibility, font APIs are
                     specified to return metrics and take parameters 'in
                     baseline-relative coordinates'.  This maps the 'x' coordinate to
                     the advance along the baseline, (positive x is forward along the
                     baseline), and the 'y' coordinate to a distance along the
                     perpendicular to the baseline at 'x' (positive y is 90 degrees
                     clockwise from the baseline vector).  APIs for which this is
                     especially important are called out as having 'baseline-relative
                     coordinates.'
                    </javadoc>
            </acts>
            <acts name="GridLayout" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.LayoutManager"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code GridLayout} class is a layout manager that
                     lays out a container's components in a rectangular grid.
                     The container is divided into equal-sized rectangles,
                     and one component is placed in each rectangle.
                     For example, the following is an applet that lays out six buttons
                     into three rows and two columns:
                    
                     &lt;hr&gt;&lt;blockquote&gt;
                     &lt;pre&gt;
                     import java.awt.*;
                     import java.applet.Applet;
                     public class ButtonGrid extends Applet {
                         public void init() {
                             setLayout(new GridLayout(3,2));
                             add(new Button("1"));
                             add(new Button("2"));
                             add(new Button("3"));
                             add(new Button("4"));
                             add(new Button("5"));
                             add(new Button("6"));
                         }
                     }
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                     &lt;p&gt;
                     If the container's {@code ComponentOrientation} property is horizontal
                     and left-to-right, the above example produces the output shown in Figure 1.
                     If the container's {@code ComponentOrientation} property is horizontal
                     and right-to-left, the example produces the output shown in Figure 2.
                    
                     &lt;table style="float:center;width:600"&gt;
                     &lt;caption style="display:none"&gt;Figures&lt;/caption&gt;
                     &lt;tr style="text-align:center"&gt;
                     &lt;td&gt;&lt;img SRC="doc-files/GridLayout-1.gif"
                          alt="Shows 6 buttons in rows of 2. Row 1 shows buttons 1 then 2.
                     Row 2 shows buttons 3 then 4. Row 3 shows buttons 5 then 6."&gt;
                     &lt;/td&gt;
                    
                     &lt;td style="text-align:center"&gt;&lt;img SRC="doc-files/GridLayout-2.gif"
                                  alt="Shows 6 buttons in rows of 2. Row 1 shows buttons 2 then 1.
                     Row 2 shows buttons 4 then 3. Row 3 shows buttons 6 then 5."&gt;
                     &lt;/td&gt;
                     &lt;/tr&gt;
                    
                     &lt;tr style="text-align:center"&gt;
                     &lt;td&gt;Figure 1: Horizontal, Left-to-Right&lt;/td&gt;
                    
                     &lt;td&gt;Figure 2: Horizontal, Right-to-Left&lt;/td&gt;
                     &lt;/tr&gt;
                     &lt;/table&gt;
                     &lt;p&gt;
                     When both the number of rows and the number of columns have
                     been set to non-zero values, either by a constructor or
                     by the {@code setRows} and {@code setColumns} methods, the number of
                     columns specified is ignored.  Instead, the number of
                     columns is determined from the specified number of rows
                     and the total number of components in the layout. So, for
                     example, if three rows and two columns have been specified
                     and nine components are added to the layout, they will
                     be displayed as three rows of three columns.  Specifying
                     the number of columns affects the layout only when the
                     number of rows is set to zero.
                    
                     @author  Arthur van Hoff
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="PointerInfo" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A class that describes the pointer position.
                     It provides the {@code GraphicsDevice} where the pointer is and
                     the {@code Point} that represents the coordinates of the pointer.
                     &lt;p&gt;
                     Instances of this class should be obtained via
                     {@link MouseInfo#getPointerInfo}.
                     The {@code PointerInfo} instance is not updated dynamically as the mouse
                     moves. To get the updated location, you must call
                     {@link MouseInfo#getPointerInfo} again.
                    
                     @see MouseInfo#getPointerInfo
                     @author Roman Poborchiy
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="Type" access="PUBLIC" declaringClass="Window" kind="TYPE" typeKind="ENUM" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="MediaType" access="PUBLIC" declaringClass="PageAttributes" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.AttributeValue"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="TrayIcon" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@code TrayIcon} object represents a tray icon that can be
                     added to the {@link SystemTray system tray}. A
                     {@code TrayIcon} can have a tooltip (text), an image, a popup
                     menu, and a set of listeners associated with it.
                    
                     &lt;p&gt;A {@code TrayIcon} can generate various {@link MouseEvent
                     MouseEvents} and supports adding corresponding listeners to receive
                     notification of these events.  {@code TrayIcon} processes some
                     of the events by itself.  For example, by default, when the
                     right-mouse click is performed on the {@code TrayIcon} it
                     displays the specified popup menu.  When the mouse hovers
                     over the {@code TrayIcon} the tooltip is displayed (this behaviour is
                     platform dependent).
                    
                     &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; When the {@code MouseEvent} is
                     dispatched to its registered listeners its {@code component}
                     property will be set to {@code null}.  (See {@link
                     java.awt.event.ComponentEvent#getComponent}) The
                     {@code source} property will be set to this
                     {@code TrayIcon}. (See {@link
                     java.util.EventObject#getSource})
                    
                     &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; A well-behaved {@link TrayIcon} implementation
                     will assign different gestures to showing a popup menu and
                     selecting a tray icon.
                    
                     &lt;p&gt;A {@code TrayIcon} can generate an {@link ActionEvent
                     ActionEvent}.  On some platforms, this occurs when the user selects
                     the tray icon using either the mouse or keyboard.
                    
                     &lt;p&gt;If a SecurityManager is installed, the AWTPermission
                     {@code accessSystemTray} must be granted in order to create
                     a {@code TrayIcon}. Otherwise the constructor will throw a
                     SecurityException.
                    
                     &lt;p&gt; See the {@link SystemTray} class overview for an example on how
                     to use the {@code TrayIcon} API.
                    
                     @since 1.6
                     @see SystemTray#add
                     @see java.awt.event.ComponentEvent#getComponent
                     @see java.util.EventObject#getSource
                    
                     @author Bino George
                     @author Denis Mikhalkin
                     @author Sharon Zakhour
                     @author Anton Tarasov
                    </javadoc>
            </acts>
            <acts name="FontMetrics" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code FontMetrics} class defines a font metrics object, which
                     encapsulates information about the rendering of a particular font on a
                     particular screen.
                     &lt;p&gt;
                     &lt;b&gt;Note to subclassers&lt;/b&gt;: Since many of these methods form closed,
                     mutually recursive loops, you must take care that you implement
                     at least one of the methods in each such loop to prevent
                     infinite recursion when your subclass is used.
                     In particular, the following is the minimal suggested set of methods
                     to override in order to ensure correctness and prevent infinite
                     recursion (though other subsets are equally feasible):
                     &lt;ul&gt;
                     &lt;li&gt;{@link #getAscent()}
                     &lt;li&gt;{@link #getLeading()}
                     &lt;li&gt;{@link #getMaxAdvance()}
                     &lt;li&gt;{@link #charWidth(char)}
                     &lt;li&gt;{@link #charsWidth(char[], int, int)}
                     &lt;/ul&gt;
                     &lt;p&gt;
                     &lt;img src="doc-files/FontMetrics-1.gif" alt="The letter 'p' showing its 'reference point'"
                     style="border:15px; float:right; margin: 7px 10px;"&gt;
                     Note that the implementations of these methods are
                     inefficient, so they are usually overridden with more efficient
                     toolkit-specific implementations.
                     &lt;p&gt;
                     When an application asks to place a character at the position
                     (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;), the character is placed so that its
                     reference point (shown as the dot in the accompanying image) is
                     put at that position. The reference point specifies a horizontal
                     line called the &lt;i&gt;baseline&lt;/i&gt; of the character. In normal
                     printing, the baselines of characters should align.
                     &lt;p&gt;
                     In addition, every character in a font has an &lt;i&gt;ascent&lt;/i&gt;, a
                     &lt;i&gt;descent&lt;/i&gt;, and an &lt;i&gt;advance width&lt;/i&gt;. The ascent is the
                     amount by which the character ascends above the baseline. The
                     descent is the amount by which the character descends below the
                     baseline. The advance width indicates the position at which AWT
                     should place the next character.
                     &lt;p&gt;
                     An array of characters or a string can also have an ascent, a
                     descent, and an advance width. The ascent of the array is the
                     maximum ascent of any character in the array. The descent is the
                     maximum descent of any character in the array. The advance width
                     is the sum of the advance widths of each of the characters in the
                     character array.  The advance of a {@code String} is the
                     distance along the baseline of the {@code String}.  This
                     distance is the width that should be used for centering or
                     right-aligning the {@code String}.
                     &lt;p&gt;Note that the advance of a {@code String} is not necessarily
                     the sum of the advances of its characters measured in isolation
                     because the width of a character can vary depending on its context.
                     For example, in Arabic text, the shape of a character can change
                     in order to connect to other characters.  Also, in some scripts,
                     certain character sequences can be represented by a single shape,
                     called a &lt;em&gt;ligature&lt;/em&gt;.  Measuring characters individually does
                     not account for these transformations.
                     &lt;p&gt;Font metrics are baseline-relative, meaning that they are
                     generally independent of the rotation applied to the font (modulo
                     possible grid hinting effects).  See {@link java.awt.Font Font}.
                    
                     @author      Jim Graham
                     @see         java.awt.Font
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="SplashScreen" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The splash screen can be displayed at application startup, before the
                     Java Virtual Machine (JVM) starts. The splash screen is displayed as an
                     undecorated window containing an image. You can use GIF, JPEG, or PNG files
                     for the image. Animation is supported for the GIF format, while transparency
                     is supported both for GIF and PNG.  The window is positioned at the center
                     of the screen. The position on multi-monitor systems is not specified. It is
                     platform and implementation dependent.  The splash screen window is closed
                     automatically as soon as the first window is displayed by Swing/AWT (may be
                     also closed manually using the Java API, see below).
                     &lt;P&gt;
                     If your application is packaged in a jar file, you can use the
                     "SplashScreen-Image" option in a manifest file to show a splash screen.
                     Place the image in the jar archive and specify the path in the option.
                     The path should not have a leading slash.
                     &lt;BR&gt;
                     For example, in the {@code manifest.mf} file:
                     &lt;PRE&gt;
                     Manifest-Version: 1.0
                     Main-Class: Test
                     SplashScreen-Image: filename.gif
                     &lt;/PRE&gt;
                     &lt;P&gt;
                     If the Java implementation provides the command-line interface and you run
                     your application by using the command line or a shortcut, use the Java
                     application launcher option to show a splash screen. The Oracle reference
                     implementation allows you to specify the splash screen image location with
                     the {@code -splash:} option.
                     &lt;BR&gt;
                     For example:
                     &lt;PRE&gt;
                     java -splash:filename.gif Test
                     &lt;/PRE&gt;
                     HiDPI scaled image is also supported.
                     Unscaled image name i.e. filename.gif should be passed in
                     {@code manifest.mf}/{@code -splash:} option for all image types irrespective of
                     HiDPI and Non-HiDPI.
                     Following is the naming convention for scaled images.
                     Screen scale 1.25: filename@125pct.gif
                     Screen scale 1.50: filename@150pct.gif
                     Screen scale 2:    filename@200pct.gif and filename@2x.gif both are supported
                     Screen scale 2.50: filename@250pct.gif
                     Screen scale 3:    filename@300pct.gif and filename@3x.gif both are supported
                     The command line interface has higher precedence over the manifest
                     setting.
                     &lt;p&gt;
                     The splash screen will be displayed as faithfully as possible to present the
                     whole splash screen image given the limitations of the target platform and
                     display.
                     &lt;p&gt;
                     It is implied that the specified image is presented on the screen "as is",
                     i.e. preserving the exact color values as specified in the image file. Under
                     certain circumstances, though, the presented image may differ, e.g. when
                     applying color dithering to present a 32 bits per pixel (bpp) image on a 16
                     or 8 bpp screen. The native platform display configuration may also affect
                     the colors of the displayed image (e.g.  color profiles, etc.)
                     &lt;p&gt;
                     The {@code SplashScreen} class provides the API for controlling the splash
                     screen. This class may be used to close the splash screen, change the splash
                     screen image, get the splash screen native window position/size, and paint
                     in the splash screen. It cannot be used to create the splash screen. You
                     should use the options provided by the Java implementation for that.
                     &lt;p&gt;
                     This class cannot be instantiated. Only a single instance of this class
                     can exist, and it may be obtained by using the {@link #getSplashScreen()}
                     static method. In case the splash screen has not been created at
                     application startup via the command line or manifest file option,
                     the {@code getSplashScreen} method returns {@code null}.
                    
                     @author Oleg Semenov
                     @since 1.6
                    </javadoc>
            </acts>
            <acts name="Toolkit" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class is the abstract superclass of all actual
                     implementations of the Abstract Window Toolkit. Subclasses of
                     the {@code Toolkit} class are used to bind the various components
                     to particular native toolkit implementations.
                     &lt;p&gt;
                     Many GUI events may be delivered to user
                     asynchronously, if the opposite is not specified explicitly.
                     As well as
                     many GUI operations may be performed asynchronously.
                     This fact means that if the state of a component is set, and then
                     the state immediately queried, the returned value may not yet
                     reflect the requested change.  This behavior includes, but is not
                     limited to:
                     &lt;ul&gt;
                     &lt;li&gt;Scrolling to a specified position.
                     &lt;br&gt;For example, calling {@code ScrollPane.setScrollPosition}
                         and then {@code getScrollPosition} may return an incorrect
                         value if the original request has not yet been processed.
                    
                     &lt;li&gt;Moving the focus from one component to another.
                     &lt;br&gt;For more information, see
                     &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html#transferTiming"&gt;Timing
                     Focus Transfers&lt;/a&gt;, a section in
                     &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/"&gt;The Swing
                     Tutorial&lt;/a&gt;.
                    
                     &lt;li&gt;Making a top-level container visible.
                     &lt;br&gt;Calling {@code setVisible(true)} on a {@code Window},
                         {@code Frame} or {@code Dialog} may occur
                         asynchronously.
                    
                     &lt;li&gt;Setting the size or location of a top-level container.
                     &lt;br&gt;Calls to {@code setSize}, {@code setBounds} or
                         {@code setLocation} on a {@code Window},
                         {@code Frame} or {@code Dialog} are forwarded
                         to the underlying window management system and may be
                         ignored or modified.  See {@link java.awt.Window} for
                         more information.
                     &lt;/ul&gt;
                     &lt;p&gt;
                     Most applications should not call any of the methods in this
                     class directly. The methods defined by {@code Toolkit} are
                     the "glue" that joins the platform-independent classes in the
                     {@code java.awt} package with their counterparts in
                     {@code java.awt.peer}. Some methods defined by
                     {@code Toolkit} query the native operating system directly.
                    
                     @author      Sami Shaio
                     @author      Arthur van Hoff
                     @author      Fred Ecks
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="Menu" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.MenuContainer"/>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.MenuItem"/>
                    <superType superType="java.awt.MenuComponent"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@code Menu} object is a pull-down menu component
                     that is deployed from a menu bar.
                     &lt;p&gt;
                     A menu can optionally be a &lt;i&gt;tear-off&lt;/i&gt; menu. A tear-off menu
                     can be opened and dragged away from its parent menu bar or menu.
                     It remains on the screen after the mouse button has been released.
                     The mechanism for tearing off a menu is platform dependent, since
                     the look and feel of the tear-off menu is determined by its peer.
                     On platforms that do not support tear-off menus, the tear-off
                     property is ignored.
                     &lt;p&gt;
                     Each item in a menu must belong to the {@code MenuItem}
                     class. It can be an instance of {@code MenuItem}, a submenu
                     (an instance of {@code Menu}), or a check box (an instance of
                     {@code CheckboxMenuItem}).
                    
                     @author Sami Shaio
                     @see     java.awt.MenuItem
                     @see     java.awt.CheckboxMenuItem
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTMenuBar" access="PROTECTED" declaringClass="MenuBar" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.MenuComponent$AccessibleAWTMenuComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Scrollbar" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Adjustable"/>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Scrollbar} class embodies a scroll bar, a
                     familiar user-interface object. A scroll bar provides a
                     convenient means for allowing a user to select from a
                     range of values. The following three vertical
                     scroll bars could be used as slider controls to pick
                     the red, green, and blue components of a color:
                     &lt;p&gt;
                     &lt;img src="doc-files/Scrollbar-1.gif" alt="Image shows 3 vertical sliders, side-by-side."
                     style="float:center; margin: 7px 10px;"&gt;
                     &lt;p&gt;
                     Each scroll bar in this example could be created with
                     code similar to the following:
                    
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                     redSlider=new Scrollbar(Scrollbar.VERTICAL, 0, 1, 0, 255);
                     add(redSlider);
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                     &lt;p&gt;
                     Alternatively, a scroll bar can represent a range of values. For
                     example, if a scroll bar is used for scrolling through text, the
                     width of the "bubble" (also called the "thumb" or "scroll box")
                     can be used to represent the amount of text that is visible.
                     Here is an example of a scroll bar that represents a range:
                     &lt;p&gt;
                     &lt;img src="doc-files/Scrollbar-2.gif"
                     alt="Image shows horizontal slider with starting range of 0 and ending range of 300. The slider thumb is labeled 60."
                     style="float:center; margin: 7px 10px;"&gt;
                     &lt;p&gt;
                     The value range represented by the bubble in this example
                     is the &lt;em&gt;visible amount&lt;/em&gt;. The horizontal scroll bar
                     in this example could be created with code like the following:
                    
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                     ranger = new Scrollbar(Scrollbar.HORIZONTAL, 0, 60, 0, 300);
                     add(ranger);
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                     &lt;p&gt;
                     Note that the actual maximum value of the scroll bar is the
                     {@code maximum} minus the {@code visible amount}.
                     In the previous example, because the {@code maximum} is
                     300 and the {@code visible amount} is 60, the actual maximum
                     value is 240.  The range of the scrollbar track is 0 - 300.
                     The left side of the bubble indicates the value of the
                     scroll bar.
                     &lt;p&gt;
                     Normally, the user changes the value of the scroll bar by
                     making a gesture with the mouse. For example, the user can
                     drag the scroll bar's bubble up and down, or click in the
                     scroll bar's unit increment or block increment areas. Keyboard
                     gestures can also be mapped to the scroll bar. By convention,
                     the &lt;b&gt;Page&amp;nbsp;Up&lt;/b&gt; and &lt;b&gt;Page&amp;nbsp;Down&lt;/b&gt;
                     keys are equivalent to clicking in the scroll bar's block
                     increment and block decrement areas.
                     &lt;p&gt;
                     When the user changes the value of the scroll bar, the scroll bar
                     receives an instance of {@code AdjustmentEvent}.
                     The scroll bar processes this event, passing it along to
                     any registered listeners.
                     &lt;p&gt;
                     Any object that wishes to be notified of changes to the
                     scroll bar's value should implement
                     {@code AdjustmentListener}, an interface defined in
                     the package {@code java.awt.event}.
                     Listeners can be added and removed dynamically by calling
                     the methods {@code addAdjustmentListener} and
                     {@code removeAdjustmentListener}.
                     &lt;p&gt;
                     The {@code AdjustmentEvent} class defines five types
                     of adjustment event, listed here:
                    
                     &lt;ul&gt;
                     &lt;li&gt;{@code AdjustmentEvent.TRACK} is sent out when the
                     user drags the scroll bar's bubble.
                     &lt;li&gt;{@code AdjustmentEvent.UNIT_INCREMENT} is sent out
                     when the user clicks in the left arrow of a horizontal scroll
                     bar, or the top arrow of a vertical scroll bar, or makes the
                     equivalent gesture from the keyboard.
                     &lt;li&gt;{@code AdjustmentEvent.UNIT_DECREMENT} is sent out
                     when the user clicks in the right arrow of a horizontal scroll
                     bar, or the bottom arrow of a vertical scroll bar, or makes the
                     equivalent gesture from the keyboard.
                     &lt;li&gt;{@code AdjustmentEvent.BLOCK_INCREMENT} is sent out
                     when the user clicks in the track, to the left of the bubble
                     on a horizontal scroll bar, or above the bubble on a vertical
                     scroll bar. By convention, the &lt;b&gt;Page&amp;nbsp;Up&lt;/b&gt;
                     key is equivalent, if the user is using a keyboard that
                     defines a &lt;b&gt;Page&amp;nbsp;Up&lt;/b&gt; key.
                     &lt;li&gt;{@code AdjustmentEvent.BLOCK_DECREMENT} is sent out
                     when the user clicks in the track, to the right of the bubble
                     on a horizontal scroll bar, or below the bubble on a vertical
                     scroll bar. By convention, the &lt;b&gt;Page&amp;nbsp;Down&lt;/b&gt;
                     key is equivalent, if the user is using a keyboard that
                     defines a &lt;b&gt;Page&amp;nbsp;Down&lt;/b&gt; key.
                     &lt;/ul&gt;
                     &lt;p&gt;
                     The JDK&amp;nbsp;1.0 event system is supported for backwards
                     compatibility, but its use with newer versions of the platform is
                     discouraged. The five types of adjustment events introduced
                     with JDK&amp;nbsp;1.1 correspond to the five event types
                     that are associated with scroll bars in previous platform versions.
                     The following list gives the adjustment event type,
                     and the corresponding JDK&amp;nbsp;1.0 event type it replaces.
                    
                     &lt;ul&gt;
                     &lt;li&gt;{@code AdjustmentEvent.TRACK} replaces
                     {@code Event.SCROLL_ABSOLUTE}
                     &lt;li&gt;{@code AdjustmentEvent.UNIT_INCREMENT} replaces
                     {@code Event.SCROLL_LINE_UP}
                     &lt;li&gt;{@code AdjustmentEvent.UNIT_DECREMENT} replaces
                     {@code Event.SCROLL_LINE_DOWN}
                     &lt;li&gt;{@code AdjustmentEvent.BLOCK_INCREMENT} replaces
                     {@code Event.SCROLL_PAGE_UP}
                     &lt;li&gt;{@code AdjustmentEvent.BLOCK_DECREMENT} replaces
                     {@code Event.SCROLL_PAGE_DOWN}
                     &lt;/ul&gt;
                     &lt;p&gt;
                     &lt;b&gt;Note&lt;/b&gt;: We recommend using a {@code Scrollbar}
                     for value selection only.  If you want to implement
                     a scrollable component inside a container, we recommend you use
                     a {@link ScrollPane ScrollPane}. If you use a
                     {@code Scrollbar} for this purpose, you are likely to
                     encounter issues with painting, key handling, sizing and
                     positioning.
                    
                     @author      Sami Shaio
                     @see         java.awt.event.AdjustmentEvent
                     @see         java.awt.event.AdjustmentListener
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="GraphicsConfigTemplate" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code GraphicsConfigTemplate} class is used to obtain a valid
                     {@link GraphicsConfiguration}.  A user instantiates one of these
                     objects and then sets all non-default attributes as desired.  The
                     {@link GraphicsDevice#getBestConfiguration} method found in the
                     {@link GraphicsDevice} class is then called with this
                     {@code GraphicsConfigTemplate}.  A valid
                     {@code GraphicsConfiguration} is returned that meets or exceeds
                     what was requested in the {@code GraphicsConfigTemplate}.
                     @see GraphicsDevice
                     @see GraphicsConfiguration
                    
                     @since       1.2
                    </javadoc>
            </acts>
            <acts name="Window" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.Container"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@code Window} object is a top-level window with no borders and no
                     menubar.
                     The default layout for a window is {@code BorderLayout}.
                     &lt;p&gt;
                     A window must have either a frame, dialog, or another window defined as its
                     owner when it's constructed.
                     &lt;p&gt;
                     In a multi-screen environment, you can create a {@code Window}
                     on a different screen device by constructing the {@code Window}
                     with {@link #Window(Window, GraphicsConfiguration)}.  The
                     {@code GraphicsConfiguration} object is one of the
                     {@code GraphicsConfiguration} objects of the target screen device.
                     &lt;p&gt;
                     In a virtual device multi-screen environment in which the desktop
                     area could span multiple physical screen devices, the bounds of all
                     configurations are relative to the virtual device coordinate system.
                     The origin of the virtual-coordinate system is at the upper left-hand
                     corner of the primary physical screen.  Depending on the location of
                     the primary screen in the virtual device, negative coordinates are
                     possible, as shown in the following figure.
                     &lt;p&gt;
                     &lt;img src="doc-files/MultiScreen.gif"
                     alt="Diagram shows virtual device containing 4 physical screens. Primary physical screen shows coords (0,0), other screen shows (-80,-100)."
                     style="float:center; margin: 7px 10px;"&gt;
                     &lt;p&gt;
                     In such an environment, when calling {@code setLocation},
                     you must pass a virtual coordinate to this method.  Similarly,
                     calling {@code getLocationOnScreen} on a {@code Window} returns
                     virtual device coordinates.  Call the {@code getBounds} method
                     of a {@code GraphicsConfiguration} to find its origin in the virtual
                     coordinate system.
                     &lt;p&gt;
                     The following code sets the location of a {@code Window}
                     at (10, 10) relative to the origin of the physical screen
                     of the corresponding {@code GraphicsConfiguration}.  If the
                     bounds of the {@code GraphicsConfiguration} is not taken
                     into account, the {@code Window} location would be set
                     at (10, 10) relative to the virtual-coordinate system and would appear
                     on the primary physical screen, which might be different from the
                     physical screen of the specified {@code GraphicsConfiguration}.
                    
                     &lt;pre&gt;
                          Window w = new Window(Window owner, GraphicsConfiguration gc);
                          Rectangle bounds = gc.getBounds();
                          w.setLocation(10 + bounds.x, 10 + bounds.y);
                     &lt;/pre&gt;
                    
                     &lt;p&gt;
                     Note: the location and size of top-level windows (including
                     {@code Window}s, {@code Frame}s, and {@code Dialog}s)
                     are under the control of the desktop's window management system.
                     Calls to {@code setLocation}, {@code setSize}, and
                     {@code setBounds} are requests (not directives) which are
                     forwarded to the window management system.  Every effort will be
                     made to honor such requests.  However, in some cases the window
                     management system may ignore such requests, or modify the requested
                     geometry in order to place and size the {@code Window} in a way
                     that more closely matches the desktop settings.
                     &lt;p&gt;
                     Due to the asynchronous nature of native event handling, the results
                     returned by {@code getBounds}, {@code getLocation},
                     {@code getLocationOnScreen}, and {@code getSize} might not
                     reflect the actual geometry of the Window on screen until the last
                     request has been processed.  During the processing of subsequent
                     requests these values might change accordingly while the window
                     management system fulfills the requests.
                     &lt;p&gt;
                     An application may set the size and location of an invisible
                     {@code Window} arbitrarily, but the window management system may
                     subsequently change its size and/or location when the
                     {@code Window} is made visible. One or more {@code ComponentEvent}s
                     will be generated to indicate the new geometry.
                     &lt;p&gt;
                     Windows are capable of generating the following WindowEvents:
                     WindowOpened, WindowClosed, WindowGainedFocus, WindowLostFocus.
                    
                     @author      Sami Shaio
                     @author      Arthur van Hoff
                     @see WindowEvent
                     @see #addWindowListener
                     @see java.awt.BorderLayout
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="Stroke" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     The {@code Stroke} interface allows a
                     {@link Graphics2D} object to obtain a {@link Shape} that is the
                     decorated outline, or stylistic representation of the outline,
                     of the specified {@code Shape}.
                     Stroking a {@code Shape} is like tracing its outline with a
                     marking pen of the appropriate size and shape.
                     The area where the pen would place ink is the area enclosed by the
                     outline {@code Shape}.
                     &lt;p&gt;
                     The methods of the {@code Graphics2D} interface that use the
                     outline {@code Shape} returned by a {@code Stroke} object
                     include {@code draw} and any other methods that are
                     implemented in terms of that method, such as
                     {@code drawLine}, {@code drawRect},
                     {@code drawRoundRect}, {@code drawOval},
                     {@code drawArc}, {@code drawPolyline},
                     and {@code drawPolygon}.
                     &lt;p&gt;
                     The objects of the classes implementing {@code Stroke}
                     must be read-only because {@code Graphics2D} does not
                     clone these objects either when they are set as an attribute
                     with the {@code setStroke} method or when the
                     {@code Graphics2D} object is itself cloned.
                     If a {@code Stroke} object is modified after it is set in
                     the {@code Graphics2D} context then the behavior
                     of subsequent rendering would be undefined.
                     @see BasicStroke
                     @see Graphics2D#setStroke
                    </javadoc>
            </acts>
            <acts name="Composite" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     The {@code Composite} interface, along with
                     {@link CompositeContext}, defines the methods to compose a draw
                     primitive with the underlying graphics area.
                     After the {@code Composite} is set in the
                     {@link Graphics2D} context, it combines a shape, text, or an image
                     being rendered with the colors that have already been rendered
                     according to pre-defined rules. The classes
                     implementing this interface provide the rules and a method to create
                     the context for a particular operation.
                     {@code CompositeContext} is an environment used by the
                     compositing operation, which is created by the {@code Graphics2D}
                     prior to the start of the operation.  {@code CompositeContext}
                     contains private information and resources needed for a compositing
                     operation.  When the {@code CompositeContext} is no longer needed,
                     the {@code Graphics2D} object disposes of it in order to reclaim
                     resources allocated for the operation.
                     &lt;p&gt;
                     Instances of classes implementing {@code Composite} must be
                     immutable because the {@code Graphics2D} does not clone
                     these objects when they are set as an attribute with the
                     {@code setComposite} method or when the {@code Graphics2D}
                     object is cloned.  This is to avoid undefined rendering behavior of
                     {@code Graphics2D}, resulting from the modification of
                     the {@code Composite} object after it has been set in the
                     {@code Graphics2D} context.
                     &lt;p&gt;
                     Since this interface must expose the contents of pixels on the
                     target device or image to potentially arbitrary code, the use of
                     custom objects which implement this interface when rendering directly
                     to a screen device is governed by the {@code readDisplayPixels}
                     {@link AWTPermission}.  The permission check will occur when such
                     a custom object is passed to the {@code setComposite} method
                     of a {@code Graphics2D} retrieved from a {@link Component}.
                     @see AlphaComposite
                     @see CompositeContext
                     @see Graphics2D#setComposite
                    </javadoc>
            </acts>
            <acts name="State" access="PUBLIC" declaringClass="Taskbar" kind="TYPE" typeKind="ENUM" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Dimension" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.awt.geom.Dimension2D"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Dimension} class encapsulates the width and
                     height of a component (in integer precision) in a single object.
                     The class is
                     associated with certain properties of components. Several methods
                     defined by the {@code Component} class and the
                     {@code LayoutManager} interface return a
                     {@code Dimension} object.
                     &lt;p&gt;
                     Normally the values of {@code width}
                     and {@code height} are non-negative integers.
                     The constructors that allow you to create a dimension do
                     not prevent you from setting a negative value for these properties.
                     If the value of {@code width} or {@code height} is
                     negative, the behavior of some methods defined by other objects is
                     undefined.
                    
                     @author      Sami Shaio
                     @author      Arthur van Hoff
                     @see         java.awt.Component
                     @see         java.awt.LayoutManager
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="MenuComponent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The abstract class {@code MenuComponent} is the superclass
                     of all menu-related components. In this respect, the class
                     {@code MenuComponent} is analogous to the abstract superclass
                     {@code Component} for AWT components.
                     &lt;p&gt;
                     Menu components receive and process AWT events, just as components do,
                     through the method {@code processEvent}.
                    
                     @author      Arthur van Hoff
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTDialog" access="PROTECTED" declaringClass="Dialog" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Window$AccessibleAWTWindow"/>
                    <superType superType="java.awt.Container$AccessibleAWTContainer"/>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="FontFormatException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Thrown by method createFont in the {@code Font} class to indicate
                     that the specified font is bad.
                    
                     @author  Parry Kejriwal
                     @see     java.awt.Font
                     @since   1.3
                    </javadoc>
            </acts>
            <acts name="DestinationType" access="PUBLIC" declaringClass="JobAttributes" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.AttributeValue"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="BltBufferStrategy" access="PROTECTED" declaringClass="Component" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.image.BufferStrategy"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Graphics2D" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Graphics"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This {@code Graphics2D} class extends the
                     {@link Graphics} class to provide more sophisticated
                     control over geometry, coordinate transformations, color management,
                     and text layout.  This is the fundamental class for rendering
                     2-dimensional shapes, text and images on the  Java(tm) platform.
                    
                     &lt;h2&gt;Coordinate Spaces&lt;/h2&gt;
                     All coordinates passed to a {@code Graphics2D} object are specified
                     in a device-independent coordinate system called User Space, which is
                     used by applications.  The {@code Graphics2D} object contains
                     an {@link AffineTransform} object as part of its rendering state
                     that defines how to convert coordinates from user space to
                     device-dependent coordinates in Device Space.
                     &lt;p&gt;
                     Coordinates in device space usually refer to individual device pixels
                     and are aligned on the infinitely thin gaps between these pixels.
                     Some {@code Graphics2D} objects can be used to capture rendering
                     operations for storage into a graphics metafile for playback on a
                     concrete device of unknown physical resolution at a later time.  Since
                     the resolution might not be known when the rendering operations are
                     captured, the {@code Graphics2D Transform} is set up
                     to transform user coordinates to a virtual device space that
                     approximates the expected resolution of the target device. Further
                     transformations might need to be applied at playback time if the
                     estimate is incorrect.
                     &lt;p&gt;
                     Some of the operations performed by the rendering attribute objects
                     occur in the device space, but all {@code Graphics2D} methods take
                     user space coordinates.
                     &lt;p&gt;
                     Every {@code Graphics2D} object is associated with a target that
                     defines where rendering takes place. A
                     {@link GraphicsConfiguration} object defines the characteristics
                     of the rendering target, such as pixel format and resolution.
                     The same rendering target is used throughout the life of a
                     {@code Graphics2D} object.
                     &lt;p&gt;
                     When creating a {@code Graphics2D} object,  the
                     {@code GraphicsConfiguration}
                     specifies the &lt;a id="deftransform"&gt;default transform&lt;/a&gt; for
                     the target of the {@code Graphics2D} (a
                     {@link Component} or {@link Image}).  This default transform maps the
                     user space coordinate system to screen and printer device coordinates
                     such that the origin maps to the upper left hand corner of the
                     target region of the device with increasing X coordinates extending
                     to the right and increasing Y coordinates extending downward.
                     The scaling of the default transform is set to identity for those devices
                     that are close to 72 dpi, such as screen devices.
                     The scaling of the default transform is set to approximately 72 user
                     space coordinates per square inch for high resolution devices, such as
                     printers.  For image buffers, the default transform is the
                     {@code Identity} transform.
                    
                     &lt;h2&gt;Rendering Process&lt;/h2&gt;
                     The Rendering Process can be broken down into four phases that are
                     controlled by the {@code Graphics2D} rendering attributes.
                     The renderer can optimize many of these steps, either by caching the
                     results for future calls, by collapsing multiple virtual steps into
                     a single operation, or by recognizing various attributes as common
                     simple cases that can be eliminated by modifying other parts of the
                     operation.
                     &lt;p&gt;
                     The steps in the rendering process are:
                     &lt;ol&gt;
                     &lt;li&gt;
                     Determine what to render.
                     &lt;li&gt;
                     Constrain the rendering operation to the current {@code Clip}.
                     The {@code Clip} is specified by a {@link Shape} in user
                     space and is controlled by the program using the various clip
                     manipulation methods of {@code Graphics} and
                     {@code Graphics2D}.  This &lt;i&gt;user clip&lt;/i&gt;
                     is transformed into device space by the current
                     {@code Transform} and combined with the
                     &lt;i&gt;device clip&lt;/i&gt;, which is defined by the visibility of windows and
                     device extents.  The combination of the user clip and device clip
                     defines the &lt;i&gt;composite clip&lt;/i&gt;, which determines the final clipping
                     region.  The user clip is not modified by the rendering
                     system to reflect the resulting composite clip.
                     &lt;li&gt;
                     Determine what colors to render.
                     &lt;li&gt;
                     Apply the colors to the destination drawing surface using the current
                     {@link Composite} attribute in the {@code Graphics2D} context.
                     &lt;/ol&gt;
                     &lt;br&gt;
                     The three types of rendering operations, along with details of each
                     of their particular rendering processes are:
                     &lt;ol&gt;
                     &lt;li&gt;
                     &lt;b&gt;&lt;a id="rendershape"&gt;{@code Shape} operations&lt;/a&gt;&lt;/b&gt;
                     &lt;ol&gt;
                     &lt;li&gt;
                     If the operation is a {@code draw(Shape)} operation, then
                     the  {@link Stroke#createStrokedShape(Shape) createStrokedShape}
                     method on the current {@link Stroke} attribute in the
                     {@code Graphics2D} context is used to construct a new
                     {@code Shape} object that contains the outline of the specified
                     {@code Shape}.
                     &lt;li&gt;
                     The {@code Shape} is transformed from user space to device space
                     using the current {@code Transform}
                     in the {@code Graphics2D} context.
                     &lt;li&gt;
                     The outline of the {@code Shape} is extracted using the
                     {@link Shape#getPathIterator(AffineTransform) getPathIterator} method of
                     {@code Shape}, which returns a
                     {@link java.awt.geom.PathIterator PathIterator}
                     object that iterates along the boundary of the {@code Shape}.
                     &lt;li&gt;
                     If the {@code Graphics2D} object cannot handle the curved segments
                     that the {@code PathIterator} object returns then it can call the
                     alternate
                     {@link Shape#getPathIterator(AffineTransform, double) getPathIterator}
                     method of {@code Shape}, which flattens the {@code Shape}.
                     &lt;li&gt;
                     The current {@link Paint} in the {@code Graphics2D} context
                     is queried for a {@link PaintContext}, which specifies the
                     colors to render in device space.
                     &lt;/ol&gt;
                     &lt;li&gt;
                     &lt;b&gt;&lt;a id=rendertext&gt;Text operations&lt;/a&gt;&lt;/b&gt;
                     &lt;ol&gt;
                     &lt;li&gt;
                     The following steps are used to determine the set of glyphs required
                     to render the indicated {@code String}:
                     &lt;ol&gt;
                     &lt;li&gt;
                     If the argument is a {@code String}, then the current
                     {@code Font} in the {@code Graphics2D} context is asked to
                     convert the Unicode characters in the {@code String} into a set of
                     glyphs for presentation with whatever basic layout and shaping
                     algorithms the font implements.
                     &lt;li&gt;
                     If the argument is an
                     {@link AttributedCharacterIterator},
                     the iterator is asked to convert itself to a
                     {@link java.awt.font.TextLayout TextLayout}
                     using its embedded font attributes. The {@code TextLayout}
                     implements more sophisticated glyph layout algorithms that
                     perform Unicode bi-directional layout adjustments automatically
                     for multiple fonts of differing writing directions.
                     &lt;li&gt;
                     If the argument is a
                     {@link GlyphVector}, then the
                     {@code GlyphVector} object already contains the appropriate
                     font-specific glyph codes with explicit coordinates for the position of
                     each glyph.
                     &lt;/ol&gt;
                     &lt;li&gt;
                     The current {@code Font} is queried to obtain outlines for the
                     indicated glyphs.  These outlines are treated as shapes in user space
                     relative to the position of each glyph that was determined in step 1.
                     &lt;li&gt;
                     The character outlines are filled as indicated above
                     under &lt;a href="#rendershape"&gt;{@code Shape} operations&lt;/a&gt;.
                     &lt;li&gt;
                     The current {@code Paint} is queried for a
                     {@code PaintContext}, which specifies
                     the colors to render in device space.
                     &lt;/ol&gt;
                     &lt;li&gt;
                     &lt;b&gt;&lt;a id= renderingimage&gt;{@code Image} Operations&lt;/a&gt;&lt;/b&gt;
                     &lt;ol&gt;
                     &lt;li&gt;
                     The region of interest is defined by the bounding box of the source
                     {@code Image}.
                     This bounding box is specified in Image Space, which is the
                     {@code Image} object's local coordinate system.
                     &lt;li&gt;
                     If an {@code AffineTransform} is passed to
                     {@link #drawImage(java.awt.Image, java.awt.geom.AffineTransform, java.awt.image.ImageObserver) drawImage(Image, AffineTransform, ImageObserver)},
                     the {@code AffineTransform} is used to transform the bounding
                     box from image space to user space. If no {@code AffineTransform}
                     is supplied, the bounding box is treated as if it is already in user space.
                     &lt;li&gt;
                     The bounding box of the source {@code Image} is transformed from user
                     space into device space using the current {@code Transform}.
                     Note that the result of transforming the bounding box does not
                     necessarily result in a rectangular region in device space.
                     &lt;li&gt;
                     The {@code Image} object determines what colors to render,
                     sampled according to the source to destination
                     coordinate mapping specified by the current {@code Transform} and the
                     optional image transform.
                     &lt;/ol&gt;
                     &lt;/ol&gt;
                    
                     &lt;h2&gt;Default Rendering Attributes&lt;/h2&gt;
                     The default values for the {@code Graphics2D} rendering attributes are:
                     &lt;dl&gt;
                     &lt;dt&gt;&lt;i&gt;{@code Paint}&lt;/i&gt;
                     &lt;dd&gt;The color of the {@code Component}.
                     &lt;dt&gt;&lt;i&gt;{@code Font}&lt;/i&gt;
                     &lt;dd&gt;The {@code Font} of the {@code Component}.
                     &lt;dt&gt;&lt;i&gt;{@code Stroke}&lt;/i&gt;
                     &lt;dd&gt;A square pen with a linewidth of 1, no dashing, miter segment joins
                     and square end caps.
                     &lt;dt&gt;&lt;i&gt;{@code Transform}&lt;/i&gt;
                     &lt;dd&gt;The
                     {@link GraphicsConfiguration#getDefaultTransform() getDefaultTransform}
                     for the {@code GraphicsConfiguration} of the {@code Component}.
                     &lt;dt&gt;&lt;i&gt;{@code Composite}&lt;/i&gt;
                     &lt;dd&gt;The {@link AlphaComposite#SRC_OVER} rule.
                     &lt;dt&gt;&lt;i&gt;{@code Clip}&lt;/i&gt;
                     &lt;dd&gt;No rendering {@code Clip}, the output is clipped to the
                     {@code Component}.
                     &lt;/dl&gt;
                    
                     &lt;h2&gt;Rendering Compatibility Issues&lt;/h2&gt;
                     The JDK(tm) 1.1 rendering model is based on a pixelization model
                     that specifies that coordinates
                     are infinitely thin, lying between the pixels.  Drawing operations are
                     performed using a one-pixel wide pen that fills the
                     pixel below and to the right of the anchor point on the path.
                     The JDK 1.1 rendering model is consistent with the
                     capabilities of most of the existing class of platform
                     renderers that need  to resolve integer coordinates to a
                     discrete pen that must fall completely on a specified number of pixels.
                     &lt;p&gt;
                     The Java 2D(tm) (Java(tm) 2 platform) API supports antialiasing renderers.
                     A pen with a width of one pixel does not need to fall
                     completely on pixel N as opposed to pixel N+1.  The pen can fall
                     partially on both pixels. It is not necessary to choose a bias
                     direction for a wide pen since the blending that occurs along the
                     pen traversal edges makes the sub-pixel position of the pen
                     visible to the user.  On the other hand, when antialiasing is
                     turned off by setting the
                     {@link RenderingHints#KEY_ANTIALIASING KEY_ANTIALIASING} hint key
                     to the
                     {@link RenderingHints#VALUE_ANTIALIAS_OFF VALUE_ANTIALIAS_OFF}
                     hint value, the renderer might need
                     to apply a bias to determine which pixel to modify when the pen
                     is straddling a pixel boundary, such as when it is drawn
                     along an integer coordinate in device space.  While the capabilities
                     of an antialiasing renderer make it no longer necessary for the
                     rendering model to specify a bias for the pen, it is desirable for the
                     antialiasing and non-antialiasing renderers to perform similarly for
                     the common cases of drawing one-pixel wide horizontal and vertical
                     lines on the screen.  To ensure that turning on antialiasing by
                     setting the
                     {@link RenderingHints#KEY_ANTIALIASING KEY_ANTIALIASING} hint
                     key to
                     {@link RenderingHints#VALUE_ANTIALIAS_ON VALUE_ANTIALIAS_ON}
                     does not cause such lines to suddenly become twice as wide and half
                     as opaque, it is desirable to have the model specify a path for such
                     lines so that they completely cover a particular set of pixels to help
                     increase their crispness.
                     &lt;p&gt;
                     Java 2D API maintains compatibility with JDK 1.1 rendering
                     behavior, such that legacy operations and existing renderer
                     behavior is unchanged under Java 2D API.  Legacy
                     methods that map onto general {@code draw} and
                     {@code fill} methods are defined, which clearly indicates
                     how {@code Graphics2D} extends {@code Graphics} based
                     on settings of {@code Stroke} and {@code Transform}
                     attributes and rendering hints.  The definition
                     performs identically under default attribute settings.
                     For example, the default {@code Stroke} is a
                     {@code BasicStroke} with a width of 1 and no dashing and the
                     default Transform for screen drawing is an Identity transform.
                     &lt;p&gt;
                     The following two rules provide predictable rendering behavior whether
                     aliasing or antialiasing is being used.
                     &lt;ul&gt;
                     &lt;li&gt; Device coordinates are defined to be between device pixels which
                     avoids any inconsistent results between aliased and antialiased
                     rendering.  If coordinates were defined to be at a pixel's center, some
                     of the pixels covered by a shape, such as a rectangle, would only be
                     half covered.
                     With aliased rendering, the half covered pixels would either be
                     rendered inside the shape or outside the shape.  With anti-aliased
                     rendering, the pixels on the entire edge of the shape would be half
                     covered.  On the other hand, since coordinates are defined to be
                     between pixels, a shape like a rectangle would have no half covered
                     pixels, whether or not it is rendered using antialiasing.
                     &lt;li&gt; Lines and paths stroked using the {@code BasicStroke}
                     object may be "normalized" to provide consistent rendering of the
                     outlines when positioned at various points on the drawable and
                     whether drawn with aliased or antialiased rendering.  This
                     normalization process is controlled by the
                     {@link RenderingHints#KEY_STROKE_CONTROL KEY_STROKE_CONTROL} hint.
                     The exact normalization algorithm is not specified, but the goals
                     of this normalization are to ensure that lines are rendered with
                     consistent visual appearance regardless of how they fall on the
                     pixel grid and to promote more solid horizontal and vertical
                     lines in antialiased mode so that they resemble their non-antialiased
                     counterparts more closely.  A typical normalization step might
                     promote antialiased line endpoints to pixel centers to reduce the
                     amount of blending or adjust the subpixel positioning of
                     non-antialiased lines so that the floating point line widths
                     round to even or odd pixel counts with equal likelihood.  This
                     process can move endpoints by up to half a pixel (usually towards
                     positive infinity along both axes) to promote these consistent
                     results.
                     &lt;/ul&gt;
                     &lt;p&gt;
                     The following definitions of general legacy methods
                     perform identically to previously specified behavior under default
                     attribute settings:
                     &lt;ul&gt;
                     &lt;li&gt;
                     For {@code fill} operations, including {@code fillRect},
                     {@code fillRoundRect}, {@code fillOval},
                     {@code fillArc}, {@code fillPolygon}, and
                     {@code clearRect}, {@link #fill(Shape) fill} can now be called
                     with the desired {@code Shape}.  For example, when filling a
                     rectangle:
                     &lt;pre&gt;
                     fill(new Rectangle(x, y, w, h));
                     &lt;/pre&gt;
                     is called.
                    
                     &lt;li&gt;
                     Similarly, for draw operations, including {@code drawLine},
                     {@code drawRect}, {@code drawRoundRect},
                     {@code drawOval}, {@code drawArc}, {@code drawPolyline},
                     and {@code drawPolygon}, {@link #draw(Shape) draw} can now be
                     called with the desired {@code Shape}.  For example, when drawing a
                     rectangle:
                     &lt;pre&gt;
                     draw(new Rectangle(x, y, w, h));
                     &lt;/pre&gt;
                     is called.
                    
                     &lt;li&gt;
                     The {@code draw3DRect} and {@code fill3DRect} methods were
                     implemented in terms of the {@code drawLine} and
                     {@code fillRect} methods in the {@code Graphics} class which
                     would predicate their behavior upon the current {@code Stroke}
                     and {@code Paint} objects in a {@code Graphics2D} context.
                     This class overrides those implementations with versions that use
                     the current {@code Color} exclusively, overriding the current
                     {@code Paint} and which uses {@code fillRect} to describe
                     the exact same behavior as the preexisting methods regardless of the
                     setting of the current {@code Stroke}.
                     &lt;/ul&gt;
                     The {@code Graphics} class defines only the {@code setColor}
                     method to control the color to be painted.  Since the Java 2D API extends
                     the {@code Color} object to implement the new {@code Paint}
                     interface, the existing
                     {@code setColor} method is now a convenience method for setting the
                     current {@code Paint} attribute to a {@code Color} object.
                     {@code setColor(c)} is equivalent to {@code setPaint(c)}.
                     &lt;p&gt;
                     The {@code Graphics} class defines two methods for controlling
                     how colors are applied to the destination.
                     &lt;ol&gt;
                     &lt;li&gt;
                     The {@code setPaintMode} method is implemented as a convenience
                     method to set the default {@code Composite}, equivalent to
                     {@code setComposite(new AlphaComposite.SrcOver)}.
                     &lt;li&gt;
                     The {@code setXORMode(Color xorcolor)} method is implemented
                     as a convenience method to set a special {@code Composite} object that
                     ignores the {@code Alpha} components of source colors and sets the
                     destination color to the value:
                     &lt;pre&gt;
                     dstpixel = (PixelOf(srccolor) ^ PixelOf(xorcolor) ^ dstpixel);
                     &lt;/pre&gt;
                     &lt;/ol&gt;
                    
                     @author Jim Graham
                     @see java.awt.RenderingHints
                    </javadoc>
            </acts>
            <acts name="Graphics" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Graphics} class is the abstract base class for
                     all graphics contexts that allow an application to draw onto
                     components that are realized on various devices, as well as
                     onto off-screen images.
                     &lt;p&gt;
                     A {@code Graphics} object encapsulates state information needed
                     for the basic rendering operations that Java supports.  This
                     state information includes the following properties:
                    
                     &lt;ul&gt;
                     &lt;li&gt;The {@code Component} object on which to draw.
                     &lt;li&gt;A translation origin for rendering and clipping coordinates.
                     &lt;li&gt;The current clip.
                     &lt;li&gt;The current color.
                     &lt;li&gt;The current font.
                     &lt;li&gt;The current logical pixel operation function (XOR or Paint).
                     &lt;li&gt;The current XOR alternation color
                         (see {@link Graphics#setXORMode}).
                     &lt;/ul&gt;
                     &lt;p&gt;
                     Coordinates are infinitely thin and lie between the pixels of the
                     output device.
                     Operations that draw the outline of a figure operate by traversing
                     an infinitely thin path between pixels with a pixel-sized pen that hangs
                     down and to the right of the anchor point on the path.
                     Operations that fill a figure operate by filling the interior
                     of that infinitely thin path.
                     Operations that render horizontal text render the ascending
                     portion of character glyphs entirely above the baseline coordinate.
                     &lt;p&gt;
                     The graphics pen hangs down and to the right from the path it traverses.
                     This has the following implications:
                     &lt;ul&gt;
                     &lt;li&gt;If you draw a figure that covers a given rectangle, that
                     figure occupies one extra row of pixels on the right and bottom edges
                     as compared to filling a figure that is bounded by that same rectangle.
                     &lt;li&gt;If you draw a horizontal line along the same &lt;i&gt;y&lt;/i&gt; coordinate as
                     the baseline of a line of text, that line is drawn entirely below
                     the text, except for any descenders.
                     &lt;/ul&gt;&lt;p&gt;
                     All coordinates that appear as arguments to the methods of this
                     {@code Graphics} object are considered relative to the
                     translation origin of this {@code Graphics} object prior to
                     the invocation of the method.
                     &lt;p&gt;
                     All rendering operations modify only pixels which lie within the
                     area bounded by the current clip, which is specified by a {@link Shape}
                     in user space and is controlled by the program using the
                     {@code Graphics} object.  This &lt;i&gt;user clip&lt;/i&gt;
                     is transformed into device space and combined with the
                     &lt;i&gt;device clip&lt;/i&gt;, which is defined by the visibility of windows and
                     device extents.  The combination of the user clip and device clip
                     defines the &lt;i&gt;composite clip&lt;/i&gt;, which determines the final clipping
                     region.  The user clip cannot be modified by the rendering
                     system to reflect the resulting composite clip. The user clip can only
                     be changed through the {@code setClip} or {@code clipRect}
                     methods.
                     All drawing or writing is done in the current color,
                     using the current paint mode, and in the current font.
                    
                     @author      Sami Shaio
                     @author      Arthur van Hoff
                     @see     java.awt.Component
                     @see     java.awt.Graphics#clipRect(int, int, int, int)
                     @see     java.awt.Graphics#setColor(java.awt.Color)
                     @see     java.awt.Graphics#setPaintMode()
                     @see     java.awt.Graphics#setXORMode(java.awt.Color)
                     @see     java.awt.Graphics#setFont(java.awt.Font)
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="OrientationRequestedType" access="PUBLIC" declaringClass="PageAttributes" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.AttributeValue"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Panel" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.Container"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     {@code Panel} is the simplest container class. A panel
                     provides space in which an application can attach any other
                     component, including other panels.
                     &lt;p&gt;
                     The default layout manager for a panel is the
                     {@code FlowLayout} layout manager.
                    
                     @author      Sami Shaio
                     @see     java.awt.FlowLayout
                     @since   1.0
                    </javadoc>
            </acts>
            <acts name="TexturePaint" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Paint"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code TexturePaint} class provides a way to fill a
                     {@link Shape} with a texture that is specified as
                     a {@link BufferedImage}. The size of the {@code BufferedImage}
                     object should be small because the {@code BufferedImage} data
                     is copied by the {@code TexturePaint} object.
                     At construction time, the texture is anchored to the upper
                     left corner of a {@link Rectangle2D} that is
                     specified in user space.  Texture is computed for
                     locations in the device space by conceptually replicating the
                     specified {@code Rectangle2D} infinitely in all directions
                     in user space and mapping the {@code BufferedImage} to each
                     replicated {@code Rectangle2D}.
                     @see Paint
                     @see Graphics2D#setPaint
                     @version 1.48, 06/05/07
                    </javadoc>
            </acts>
            <acts name="LayoutManager" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     Defines the interface for classes that know how to lay out
                     {@code Container}s.
                     &lt;p&gt;
                     Swing's painting architecture assumes the children of a
                     {@code JComponent} do not overlap.  If a
                     {@code JComponent}'s {@code LayoutManager} allows
                     children to overlap, the {@code JComponent} must override
                     {@code isOptimizedDrawingEnabled} to return false.
                    
                     @see Container
                     @see javax.swing.JComponent#isOptimizedDrawingEnabled
                    
                     @author      Sami Shaio
                     @author      Arthur van Hoff
                    </javadoc>
            </acts>
            <acts name="MultipleDocumentHandlingType" access="PUBLIC" declaringClass="JobAttributes" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.AttributeValue"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Event" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     &lt;b&gt;NOTE:&lt;/b&gt; The {@code Event} class is obsolete and is
                     available only for backwards compatibility.  It has been replaced
                     by the {@code AWTEvent} class and its subclasses.
                     &lt;p&gt;
                     {@code Event} is a platform-independent class that
                     encapsulates events from the platform's Graphical User
                     Interface in the Java&amp;nbsp;1.0 event model. In Java&amp;nbsp;1.1
                     and later versions, the {@code Event} class is maintained
                     only for backwards compatibility. The information in this
                     class description is provided to assist programmers in
                     converting Java&amp;nbsp;1.0 programs to the new event model.
                     &lt;p&gt;
                     In the Java&amp;nbsp;1.0 event model, an event contains an
                     {@link Event#id} field
                     that indicates what type of event it is and which other
                     {@code Event} variables are relevant for the event.
                     &lt;p&gt;
                     For keyboard events, {@link Event#key}
                     contains a value indicating which key was activated, and
                     {@link Event#modifiers} contains the
                     modifiers for that event.  For the KEY_PRESS and KEY_RELEASE
                     event ids, the value of {@code key} is the unicode
                     character code for the key. For KEY_ACTION and
                     KEY_ACTION_RELEASE, the value of {@code key} is
                     one of the defined action-key identifiers in the
                     {@code Event} class ({@code PGUP},
                     {@code PGDN}, {@code F1}, {@code F2}, etc).
                    
                     @deprecated It is recommended that {@code AWTEvent} and its subclasses be
                                 used instead
                     @author     Sami Shaio
                     @since      1.0
                    </javadoc>
            </acts>
            <acts name="PrintQualityType" access="PUBLIC" declaringClass="PageAttributes" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.AttributeValue"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="AccessibleContainerHandler" access="PROTECTED" declaringClass="Container.AccessibleAWTContainer" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.event.ContainerListener"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="PrintGraphics" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     An abstract class which provides a print graphics context for a page.
                    
                     @author      Amy Fowler
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTButton" access="PROTECTED" declaringClass="Button" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.AccessibleAction"/>
                    <superType superType="javax.accessibility.AccessibleValue"/>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="GridBagConstraints" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code GridBagConstraints} class specifies constraints
                     for components that are laid out using the
                     {@code GridBagLayout} class.
                    
                     @author Doug Stein
                     @author Bill Spitzak (orignial NeWS &amp;amp; OLIT implementation)
                     @see java.awt.GridBagLayout
                     @since 1.0
                    </javadoc>
            </acts>
            <acts name="MediaTracker" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code MediaTracker} class is a utility class to track
                     the status of a number of media objects. Media objects could
                     include audio clips as well as images, though currently only
                     images are supported.
                     &lt;p&gt;
                     To use a media tracker, create an instance of
                     {@code MediaTracker} and call its {@code addImage}
                     method for each image to be tracked. In addition, each image can
                     be assigned a unique identifier. This identifier controls the
                     priority order in which the images are fetched. It can also be used
                     to identify unique subsets of the images that can be waited on
                     independently. Images with a lower ID are loaded in preference to
                     those with a higher ID number.
                    
                     &lt;p&gt;
                    
                     Tracking an animated image
                     might not always be useful
                     due to the multi-part nature of animated image
                     loading and painting,
                     but it is supported.
                     {@code MediaTracker} treats an animated image
                     as completely loaded
                     when the first frame is completely loaded.
                     At that point, the {@code MediaTracker}
                     signals any waiters
                     that the image is completely loaded.
                     If no {@code ImageObserver}s are observing the image
                     when the first frame has finished loading,
                     the image might flush itself
                     to conserve resources
                     (see {@link Image#flush()}).
                    
                     &lt;p&gt;
                     Here is an example of using {@code MediaTracker}:
                    
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;{@code
                     import java.applet.Applet;
                     import java.awt.Color;
                     import java.awt.Image;
                     import java.awt.Graphics;
                     import java.awt.MediaTracker;
                    
                     public class ImageBlaster extends Applet implements Runnable {
                          MediaTracker tracker;
                          Image bg;
                          Image anim[] = new Image[5];
                          int index;
                          Thread animator;
                    
                          // Get the images for the background (id == 0)
                          // and the animation frames (id == 1)
                          // and add them to the MediaTracker
                          public void init() {
                              tracker = new MediaTracker(this);
                              bg = getImage(getDocumentBase(),
                                      "images/background.gif");
                              tracker.addImage(bg, 0);
                              for (int i = 0; i &lt; 5; i++) {
                                  anim[i] = getImage(getDocumentBase(),
                                          "images/anim"+i+".gif");
                                  tracker.addImage(anim[i], 1);
                              }
                          }
                    
                          // Start the animation thread.
                          public void start() {
                              animator = new Thread(this);
                              animator.start();
                          }
                    
                          // Stop the animation thread.
                          public void stop() {
                              animator = null;
                          }
                    
                          // Run the animation thread.
                          // First wait for the background image to fully load
                          // and paint.  Then wait for all of the animation
                          // frames to finish loading. Finally, loop and
                          // increment the animation frame index.
                          public void run() {
                              try {
                                  tracker.waitForID(0);
                                  tracker.waitForID(1);
                              } catch (InterruptedException e) {
                                  return;
                              }
                              Thread me = Thread.currentThread();
                              while (animator == me) {
                                  try {
                                      Thread.sleep(100);
                                  } catch (InterruptedException e) {
                                      break;
                                  }
                                  synchronized (this) {
                                      index++;
                                      if (index &gt;= anim.length) {
                                          index = 0;
                                      }
                                  }
                                  repaint();
                              }
                          }
                    
                          // The background image fills the frame so we
                          // don't need to clear the applet on repaints.
                          // Just call the paint method.
                          public void update(Graphics g) {
                              paint(g);
                          }
                    
                          // Paint a large red rectangle if there are any errors
                          // loading the images.  Otherwise always paint the
                          // background so that it appears incrementally as it
                          // is loading.  Finally, only paint the current animation
                          // frame if all of the frames (id == 1) are done loading,
                          // so that we don't get partial animations.
                          public void paint(Graphics g) {
                              if ((tracker.statusAll(false) &amp; MediaTracker.ERRORED) != 0) {
                                  g.setColor(Color.red);
                                  g.fillRect(0, 0, size().width, size().height);
                                  return;
                              }
                              g.drawImage(bg, 0, 0, this);
                              if (tracker.statusID(1, false) == MediaTracker.COMPLETE) {
                                  g.drawImage(anim[index], 10, 10, this);
                              }
                          }
                     }
                     } &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                    
                     @author      Jim Graham
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="Choice" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.ItemSelectable"/>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Choice} class presents a pop-up menu of choices.
                     The current choice is displayed as the title of the menu.
                     &lt;p&gt;
                     The following code example produces a pop-up menu:
                    
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                     Choice ColorChooser = new Choice();
                     ColorChooser.add("Green");
                     ColorChooser.add("Red");
                     ColorChooser.add("Blue");
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                     &lt;p&gt;
                     After this choice menu has been added to a panel,
                     it appears as follows in its normal state:
                     &lt;p&gt;
                     &lt;img src="doc-files/Choice-1.gif" alt="The following text describes the graphic"
                     style="float:center; margin: 7px 10px;"&gt;
                     &lt;p&gt;
                     In the picture, {@code "Green"} is the current choice.
                     Pushing the mouse button down on the object causes a menu to
                     appear with the current choice highlighted.
                     &lt;p&gt;
                     Some native platforms do not support arbitrary resizing of
                     {@code Choice} components and the behavior of
                     {@code setSize()/getSize()} is bound by
                     such limitations.
                     Native GUI {@code Choice} components' size are often bound by such
                     attributes as font size and length of items contained within
                     the {@code Choice}.
                    
                     @author      Sami Shaio
                     @author      Arthur van Hoff
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="TextArea" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.TextComponent"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@code TextArea} object is a multi-line region
                     that displays text. It can be set to allow editing or
                     to be read-only.
                     &lt;p&gt;
                     The following image shows the appearance of a text area:
                     &lt;p&gt;
                     &lt;img src="doc-files/TextArea-1.gif" alt="A TextArea showing the word 'Hello!'"
                     style="float:center; margin: 7px 10px;"&gt;
                     &lt;p&gt;
                     This text area could be created by the following line of code:
                    
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                     new TextArea("Hello", 5, 40);
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                    
                     @author      Sami Shaio
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTContainer" access="PROTECTED" declaringClass="Container" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Label" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@code Label} object is a component for placing text in a
                     container. A label displays a single line of read-only text.
                     The text can be changed by the application, but a user cannot edit it
                     directly.
                     &lt;p&gt;
                     For example, the code&amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
                    
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                     setLayout(new FlowLayout(FlowLayout.CENTER, 10, 10));
                     add(new Label("Hi There!"));
                     add(new Label("Another Label"));
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                     &lt;p&gt;
                     produces the following labels:
                     &lt;p&gt;
                     &lt;img src="doc-files/Label-1.gif" alt="Two labels: 'Hi There!' and 'Another label'"
                     style="float:center; margin: 7px 10px;"&gt;
                    
                     @author      Sami Shaio
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="MenuContainer" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     The super class of all menu related containers.
                    
                     @author      Arthur van Hoff
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTMenuItem" access="PROTECTED" declaringClass="MenuItem" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.AccessibleAction"/>
                    <superType superType="javax.accessibility.AccessibleValue"/>
                    <superType superType="java.awt.MenuComponent$AccessibleAWTMenuComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Cursor" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A class to encapsulate the bitmap representation of the mouse cursor.
                    
                     @see Component#setCursor
                     @author      Amy Fowler
                    </javadoc>
            </acts>
            <acts name="Container" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A generic Abstract Window Toolkit(AWT) container object is a component
                     that can contain other AWT components.
                     &lt;p&gt;
                     Components added to a container are tracked in a list.  The order
                     of the list will define the components' front-to-back stacking order
                     within the container.  If no index is specified when adding a
                     component to a container, it will be added to the end of the list
                     (and hence to the bottom of the stacking order).
                     &lt;p&gt;
                     &lt;b&gt;Note&lt;/b&gt;: For details on the focus subsystem, see
                     &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html"&gt;
                     How to Use the Focus Subsystem&lt;/a&gt;,
                     a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
                     &lt;a href="../../java/awt/doc-files/FocusSpec.html"&gt;Focus Specification&lt;/a&gt;
                     for more information.
                    
                     @author      Arthur van Hoff
                     @author      Sami Shaio
                     @see       #add(java.awt.Component, int)
                     @see       #getComponent(int)
                     @see       LayoutManager
                     @since     1.0
                    </javadoc>
            </acts>
            <acts name="GraphicsDevice" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code GraphicsDevice} class describes the graphics devices
                     that might be available in a particular graphics environment.  These
                     include screen and printer devices. Note that there can be many screens
                     and many printers in an instance of {@link GraphicsEnvironment}. Each
                     graphics device has one or more {@link GraphicsConfiguration} objects
                     associated with it.  These objects specify the different configurations
                     in which the {@code GraphicsDevice} can be used.
                     &lt;p&gt;
                     In a multi-screen environment, the {@code GraphicsConfiguration}
                     objects can be used to render components on multiple screens.  The
                     following code sample demonstrates how to create a {@code JFrame}
                     object for each {@code GraphicsConfiguration} on each screen
                     device in the {@code GraphicsEnvironment}:
                     &lt;pre&gt;{@code
                       GraphicsEnvironment ge = GraphicsEnvironment.
                       getLocalGraphicsEnvironment();
                       GraphicsDevice[] gs = ge.getScreenDevices();
                       for (int j = 0; j &lt; gs.length; j++) {
                          GraphicsDevice gd = gs[j];
                          GraphicsConfiguration[] gc =
                          gd.getConfigurations();
                          for (int i=0; i &lt; gc.length; i++) {
                             JFrame f = new
                             JFrame(gs[j].getDefaultConfiguration());
                             Canvas c = new Canvas(gc[i]);
                             Rectangle gcBounds = gc[i].getBounds();
                             int xoffs = gcBounds.x;
                             int yoffs = gcBounds.y;
                             f.getContentPane().add(c);
                             f.setLocation((i*50)+xoffs, (i*60)+yoffs);
                             f.show();
                          }
                       }
                     }&lt;/pre&gt;
                     &lt;p&gt;
                     For more information on full-screen exclusive mode API, see the
                     &lt;a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/index.html"&gt;
                     Full-Screen Exclusive Mode API Tutorial&lt;/a&gt;.
                    
                     @see GraphicsEnvironment
                     @see GraphicsConfiguration
                    </javadoc>
            </acts>
            <acts name="BorderLayout" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.LayoutManager2"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A border layout lays out a container, arranging and resizing
                     its components to fit in five regions:
                     north, south, east, west, and center.
                     Each region may contain no more than one component, and
                     is identified by a corresponding constant:
                     {@code NORTH}, {@code SOUTH}, {@code EAST},
                     {@code WEST}, and {@code CENTER}.  When adding a
                     component to a container with a border layout, use one of these
                     five constants, for example:
                     &lt;pre&gt;
                        Panel p = new Panel();
                        p.setLayout(new BorderLayout());
                        p.add(new Button("Okay"), BorderLayout.SOUTH);
                     &lt;/pre&gt;
                     As a convenience, {@code BorderLayout} interprets the
                     absence of a string specification the same as the constant
                     {@code CENTER}:
                     &lt;pre&gt;
                        Panel p2 = new Panel();
                        p2.setLayout(new BorderLayout());
                        p2.add(new TextArea());  // Same as p.add(new TextArea(), BorderLayout.CENTER);
                     &lt;/pre&gt;
                     &lt;p&gt;
                     In addition, {@code BorderLayout} supports the relative
                     positioning constants, {@code PAGE_START}, {@code PAGE_END},
                     {@code LINE_START}, and {@code LINE_END}.
                     In a container whose {@code ComponentOrientation} is set to
                     {@code ComponentOrientation.LEFT_TO_RIGHT}, these constants map to
                     {@code NORTH}, {@code SOUTH}, {@code WEST}, and
                     {@code EAST}, respectively.
                     &lt;p&gt;
                     For compatibility with previous releases, {@code BorderLayout}
                     also includes the relative positioning constants {@code BEFORE_FIRST_LINE},
                     {@code AFTER_LAST_LINE}, {@code BEFORE_LINE_BEGINS} and
                     {@code AFTER_LINE_ENDS}.  These are equivalent to
                     {@code PAGE_START}, {@code PAGE_END}, {@code LINE_START}
                     and {@code LINE_END} respectively.  For
                     consistency with the relative positioning constants used by other
                     components, the latter constants are preferred.
                     &lt;p&gt;
                     Mixing both absolute and relative positioning constants can lead to
                     unpredictable results.  If
                     you use both types, the relative constants will take precedence.
                     For example, if you add components using both the {@code NORTH}
                     and {@code PAGE_START} constants in a container whose
                     orientation is {@code LEFT_TO_RIGHT}, only the
                     {@code PAGE_START} will be laid out.
                     &lt;p&gt;
                     NOTE: Currently,
                     {@code BorderLayout} does not support vertical
                     orientations.  The {@code isVertical} setting on the container's
                     {@code ComponentOrientation} is not respected.
                     &lt;p&gt;
                     The components are laid out according to their
                     preferred sizes and the constraints of the container's size.
                     The {@code NORTH} and {@code SOUTH} components may
                     be stretched horizontally; the {@code EAST} and
                     {@code WEST} components may be stretched vertically;
                     the {@code CENTER} component may stretch both horizontally
                     and vertically to fill any space left over.
                     &lt;p&gt;
                     Here is an example of five buttons in an applet laid out using
                     the {@code BorderLayout} layout manager:
                     &lt;p&gt;
                     &lt;img src="doc-files/BorderLayout-1.gif"
                     alt="Diagram of an applet demonstrating BorderLayout.
                          Each section of the BorderLayout contains a Button corresponding to its position in the layout, one of:
                          North, West, Center, East, or South."
                     style="float:center; margin: 7px 10px;"&gt;
                     &lt;p&gt;
                     The code for this applet is as follows:
                    
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                     import java.awt.*;
                     import java.applet.Applet;
                    
                     public class buttonDir extends Applet {
                       public void init() {
                         setLayout(new BorderLayout());
                         add(new Button("North"), BorderLayout.NORTH);
                         add(new Button("South"), BorderLayout.SOUTH);
                         add(new Button("East"), BorderLayout.EAST);
                         add(new Button("West"), BorderLayout.WEST);
                         add(new Button("Center"), BorderLayout.CENTER);
                       }
                     }
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                    
                     @author      Arthur van Hoff
                     @see         java.awt.Container#add(String, Component)
                     @see         java.awt.ComponentOrientation
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="Action" access="PUBLIC" declaringClass="Desktop" kind="TYPE" typeKind="ENUM" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Checkbox" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.ItemSelectable"/>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A check box is a graphical component that can be in either an
                     "on" ({@code true}) or "off" ({@code false}) state.
                     Clicking on a check box changes its state from
                     "on" to "off," or from "off" to "on."
                     &lt;p&gt;
                     The following code example creates a set of check boxes in
                     a grid layout:
                    
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                     setLayout(new GridLayout(3, 1));
                     add(new Checkbox("one", null, true));
                     add(new Checkbox("two"));
                     add(new Checkbox("three"));
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                     &lt;p&gt;
                     This image depicts the check boxes and grid layout
                     created by this code example:
                     &lt;p&gt;
                     &lt;img src="doc-files/Checkbox-1.gif" alt="The following context describes the graphic."
                     style="float:center; margin: 7px 10px;"&gt;
                     &lt;p&gt;
                     The button labeled {@code one} is in the "on" state, and the
                     other two are in the "off" state. In this example, which uses the
                     {@code GridLayout} class, the states of the three check
                     boxes are set independently.
                     &lt;p&gt;
                     Alternatively, several check boxes can be grouped together under
                     the control of a single object, using the
                     {@code CheckboxGroup} class.
                     In a check box group, at most one button can be in the "on"
                     state at any given time. Clicking on a check box to turn it on
                     forces any other check box in the same group that is on
                     into the "off" state.
                    
                     @author      Sami Shaio
                     @see         java.awt.GridLayout
                     @see         java.awt.CheckboxGroup
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="Dialog" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Window"/>
                    <superType superType="java.awt.Container"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A Dialog is a top-level window with a title and a border
                     that is typically used to take some form of input from the user.
                    
                     The size of the dialog includes any area designated for the
                     border.  The dimensions of the border area can be obtained
                     using the {@code getInsets} method, however, since
                     these dimensions are platform-dependent, a valid insets
                     value cannot be obtained until the dialog is made displayable
                     by either calling {@code pack} or {@code show}.
                     Since the border area is included in the overall size of the
                     dialog, the border effectively obscures a portion of the dialog,
                     constraining the area available for rendering and/or displaying
                     subcomponents to the rectangle which has an upper-left corner
                     location of {@code (insets.left, insets.top)}, and has a size of
                     {@code width - (insets.left + insets.right)} by
                     {@code height - (insets.top + insets.bottom)}.
                     &lt;p&gt;
                     The default layout for a dialog is {@code BorderLayout}.
                     &lt;p&gt;
                     A dialog may have its native decorations (i.e. Frame &amp;amp; Titlebar) turned off
                     with {@code setUndecorated}.  This can only be done while the dialog
                     is not {@link Component#isDisplayable() displayable}.
                     &lt;p&gt;
                     A dialog may have another window as its owner when it's constructed.  When
                     the owner window of a visible dialog is minimized, the dialog will
                     automatically be hidden from the user. When the owner window is subsequently
                     restored, the dialog is made visible to the user again.
                     &lt;p&gt;
                     In a multi-screen environment, you can create a {@code Dialog}
                     on a different screen device than its owner.  See {@link java.awt.Frame} for
                     more information.
                     &lt;p&gt;
                     A dialog can be either modeless (the default) or modal.  A modal
                     dialog is one which blocks input to some other top-level windows
                     in the application, except for any windows created with the dialog
                     as their owner. See &lt;a href="doc-files/Modality.html"&gt;AWT Modality&lt;/a&gt;
                     specification for details.
                     &lt;p&gt;
                     Dialogs are capable of generating the following
                     {@code WindowEvents}:
                     {@code WindowOpened}, {@code WindowClosing},
                     {@code WindowClosed}, {@code WindowActivated},
                     {@code WindowDeactivated}, {@code WindowGainedFocus},
                     {@code WindowLostFocus}.
                    
                     @see WindowEvent
                     @see Window#addWindowListener
                    
                     @author      Sami Shaio
                     @author      Arthur van Hoff
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="SidesType" access="PUBLIC" declaringClass="JobAttributes" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.AttributeValue"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="AWTEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.util.EventObject"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The root event class for all AWT events.
                     This class and its subclasses supersede the original
                     java.awt.Event class.
                     Subclasses of this root AWTEvent class defined outside of the
                     java.awt.event package should define event ID values greater than
                     the value defined by RESERVED_ID_MAX.
                     &lt;p&gt;
                     The event masks defined in this class are needed by Component subclasses
                     which are using Component.enableEvents() to select for event types not
                     selected by registered listeners. If a listener is registered on a
                     component, the appropriate event mask is already set internally by the
                     component.
                     &lt;p&gt;
                     The masks are also used to specify to which types of events an
                     AWTEventListener should listen. The masks are bitwise-ORed together
                     and passed to Toolkit.addAWTEventListener.
                    
                     @see Component#enableEvents
                     @see Toolkit#addAWTEventListener
                    
                     @see java.awt.event.ActionEvent
                     @see java.awt.event.AdjustmentEvent
                     @see java.awt.event.ComponentEvent
                     @see java.awt.event.ContainerEvent
                     @see java.awt.event.FocusEvent
                     @see java.awt.event.InputMethodEvent
                     @see java.awt.event.InvocationEvent
                     @see java.awt.event.ItemEvent
                     @see java.awt.event.HierarchyEvent
                     @see java.awt.event.KeyEvent
                     @see java.awt.event.MouseEvent
                     @see java.awt.event.MouseWheelEvent
                     @see java.awt.event.PaintEvent
                     @see java.awt.event.TextEvent
                     @see java.awt.event.WindowEvent
                    
                     @author Carl Quinn
                     @author Amy Fowler
                     @since 1.1
                    </javadoc>
            </acts>
            <acts name="FilterAction" access="PUBLIC" declaringClass="EventFilter" kind="TYPE" typeKind="ENUM" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="TextField" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.TextComponent"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@code TextField} object is a text component
                     that allows for the editing of a single line of text.
                     &lt;p&gt;
                     For example, the following image depicts a frame with four
                     text fields of varying widths. Two of these text fields
                     display the predefined text {@code "Hello"}.
                     &lt;p&gt;
                     &lt;img src="doc-files/TextField-1.gif" alt="The preceding text describes this image."
                     style="float:center; margin: 7px 10px;"&gt;
                     &lt;p&gt;
                     Here is the code that produces these four text fields:
                    
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                     TextField tf1, tf2, tf3, tf4;
                     // a blank text field
                     tf1 = new TextField();
                     // blank field of 20 columns
                     tf2 = new TextField("", 20);
                     // predefined text displayed
                     tf3 = new TextField("Hello!");
                     // predefined text in 30 columns
                     tf4 = new TextField("Hello", 30);
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                     &lt;p&gt;
                     Every time the user types a key in the text field, one or
                     more key events are sent to the text field.  A {@code KeyEvent}
                     may be one of three types: keyPressed, keyReleased, or keyTyped.
                     The properties of a key event indicate which of these types
                     it is, as well as additional information about the event,
                     such as what modifiers are applied to the key event and the
                     time at which the event occurred.
                     &lt;p&gt;
                     The key event is passed to every {@code KeyListener}
                     or {@code KeyAdapter} object which registered to receive such
                     events using the component's {@code addKeyListener} method.
                     ({@code KeyAdapter} objects implement the
                     {@code KeyListener} interface.)
                     &lt;p&gt;
                     It is also possible to fire an {@code ActionEvent}.
                     If action events are enabled for the text field, they may
                     be fired by pressing the {@code Return} key.
                     &lt;p&gt;
                     The {@code TextField} class's {@code processEvent}
                     method examines the action event and passes it along to
                     {@code processActionEvent}. The latter method redirects the
                     event to any {@code ActionListener} objects that have
                     registered to receive action events generated by this
                     text field.
                    
                     @author      Sami Shaio
                     @see         java.awt.event.KeyEvent
                     @see         java.awt.event.KeyAdapter
                     @see         java.awt.event.KeyListener
                     @see         java.awt.event.ActionEvent
                     @see         java.awt.Component#addKeyListener
                     @see         java.awt.TextField#processEvent
                     @see         java.awt.TextField#processActionEvent
                     @see         java.awt.TextField#addActionListener
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="FlipBufferStrategy" access="PROTECTED" declaringClass="Component" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.image.BufferStrategy"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="List" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.ItemSelectable"/>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code List} component presents the user with a
                     scrolling list of text items. The list can be set up so that
                     the user can choose either one item or multiple items.
                     &lt;p&gt;
                     For example, the code&amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
                    
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                     List lst = new List(4, false);
                     lst.add("Mercury");
                     lst.add("Venus");
                     lst.add("Earth");
                     lst.add("JavaSoft");
                     lst.add("Mars");
                     lst.add("Jupiter");
                     lst.add("Saturn");
                     lst.add("Uranus");
                     lst.add("Neptune");
                     lst.add("Pluto");
                     cnt.add(lst);
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                     &lt;p&gt;
                     where {@code cnt} is a container, produces the following
                     scrolling list:
                     &lt;p&gt;
                     &lt;img src="doc-files/List-1.gif"
                     alt="Shows a list containing: Venus, Earth, JavaSoft, and Mars. Javasoft is selected." style="float:center; margin: 7px 10px;"&gt;
                     &lt;p&gt;
                     If the List allows multiple selections, then clicking on
                     an item that is already selected deselects it. In the preceding
                     example, only one item from the scrolling list can be selected
                     at a time, since the second argument when creating the new scrolling
                     list is {@code false}. If the List does not allow multiple
                     selections, selecting an item causes any other selected item
                     to be deselected.
                     &lt;p&gt;
                     Note that the list in the example shown was created with four visible
                     rows.  Once the list has been created, the number of visible rows
                     cannot be changed.  A default {@code List} is created with
                     four rows, so that {@code lst = new List()} is equivalent to
                     {@code list = new List(4, false)}.
                     &lt;p&gt;
                     Beginning with Java&amp;nbsp;1.1, the Abstract Window Toolkit
                     sends the {@code List} object all mouse, keyboard, and focus events
                     that occur over it. (The old AWT event model is being maintained
                     only for backwards compatibility, and its use is discouraged.)
                     &lt;p&gt;
                     When an item is selected or deselected by the user, AWT sends an instance
                     of {@code ItemEvent} to the list.
                     When the user double-clicks on an item in a scrolling list,
                     AWT sends an instance of {@code ActionEvent} to the
                     list following the item event. AWT also generates an action event
                     when the user presses the return key while an item in the
                     list is selected.
                     &lt;p&gt;
                     If an application wants to perform some action based on an item
                     in this list being selected or activated by the user, it should implement
                     {@code ItemListener} or {@code ActionListener}
                     as appropriate and register the new listener to receive
                     events from this list.
                     &lt;p&gt;
                     For multiple-selection scrolling lists, it is considered a better
                     user interface to use an external gesture (such as clicking on a
                     button) to trigger the action.
                     @author      Sami Shaio
                     @see         java.awt.event.ItemEvent
                     @see         java.awt.event.ItemListener
                     @see         java.awt.event.ActionEvent
                     @see         java.awt.event.ActionListener
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="Polygon" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Shape"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Polygon} class encapsulates a description of a
                     closed, two-dimensional region within a coordinate space. This
                     region is bounded by an arbitrary number of line segments, each of
                     which is one side of the polygon. Internally, a polygon
                     comprises of a list of {@code (x,y)}
                     coordinate pairs, where each pair defines a &lt;i&gt;vertex&lt;/i&gt; of the
                     polygon, and two successive pairs are the endpoints of a
                     line that is a side of the polygon. The first and final
                     pairs of {@code (x,y)} points are joined by a line segment
                     that closes the polygon.  This {@code Polygon} is defined with
                     an even-odd winding rule.  See
                     {@link java.awt.geom.PathIterator#WIND_EVEN_ODD WIND_EVEN_ODD}
                     for a definition of the even-odd winding rule.
                     This class's hit-testing methods, which include the
                     {@code contains}, {@code intersects} and {@code inside}
                     methods, use the &lt;i&gt;insideness&lt;/i&gt; definition described in the
                     {@link Shape} class comments.
                    
                     @author      Sami Shaio
                     @see Shape
                     @author      Herb Jellinek
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="ModalExclusionType" access="PUBLIC" declaringClass="Dialog" kind="TYPE" typeKind="ENUM" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="TextComponent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code TextComponent} class is the superclass of
                     any component that allows the editing of some text.
                     &lt;p&gt;
                     A text component embodies a string of text.  The
                     {@code TextComponent} class defines a set of methods
                     that determine whether or not this text is editable. If the
                     component is editable, it defines another set of methods
                     that supports a text insertion caret.
                     &lt;p&gt;
                     In addition, the class defines methods that are used
                     to maintain a current &lt;em&gt;selection&lt;/em&gt; from the text.
                     The text selection, a substring of the component's text,
                     is the target of editing operations. It is also referred
                     to as the &lt;em&gt;selected text&lt;/em&gt;.
                    
                     @author      Sami Shaio
                     @author      Arthur van Hoff
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="GridBagLayoutInfo" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code GridBagLayoutInfo} is an utility class for
                     {@code GridBagLayout} layout manager.
                     It stores align, size and baseline parameters for every component within a container.
                    
                     @see       java.awt.GridBagLayout
                     @see       java.awt.GridBagConstraints
                     @since 1.6
                    </javadoc>
            </acts>
            <acts name="PrintJob" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An abstract class which initiates and executes a print job.
                     It provides access to a print graphics object which renders
                     to an appropriate print device.
                    
                     @see Toolkit#getPrintJob
                    
                     @author      Amy Fowler
                    </javadoc>
            </acts>
            <acts name="ModalityType" access="PUBLIC" declaringClass="Dialog" kind="TYPE" typeKind="ENUM" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="JobAttributes" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A set of attributes which control a print job.
                     &lt;p&gt;
                     Instances of this class control the number of copies, default selection,
                     destination, print dialog, file and printer names, page ranges, multiple
                     document handling (including collation), and multi-page imposition (such
                     as duplex) of every print job which uses the instance. Attribute names are
                     compliant with the Internet Printing Protocol (IPP) 1.1 where possible.
                     Attribute values are partially compliant where possible.
                     &lt;p&gt;
                     To use a method which takes an inner class type, pass a reference to
                     one of the constant fields of the inner class. Client code cannot create
                     new instances of the inner class types because none of those classes
                     has a public constructor. For example, to set the print dialog type to
                     the cross-platform, pure Java print dialog, use the following code:
                     &lt;pre&gt;
                     import java.awt.JobAttributes;
                    
                     public class PureJavaPrintDialogExample {
                         public void setPureJavaPrintDialog(JobAttributes jobAttributes) {
                             jobAttributes.setDialog(JobAttributes.DialogType.COMMON);
                         }
                     }
                     &lt;/pre&gt;
                     &lt;p&gt;
                     Every IPP attribute which supports an &lt;i&gt;attributeName&lt;/i&gt;-default value
                     has a corresponding &lt;code&gt;set&lt;i&gt;attributeName&lt;/i&gt;ToDefault&lt;/code&gt; method.
                     Default value fields are not provided.
                    
                     @author      David Mendenhall
                     @since 1.3
                    </javadoc>
            </acts>
            <acts name="KeyEventPostProcessor" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     A KeyEventPostProcessor cooperates with the current KeyboardFocusManager
                     in the final resolution of all unconsumed KeyEvents. KeyEventPostProcessors
                     registered with the current KeyboardFocusManager will receive KeyEvents
                     after the KeyEvents have been dispatched to and handled by their targets.
                     KeyEvents that would have been otherwise discarded because no Component in
                     the application currently owns the focus will also be forwarded to
                     registered KeyEventPostProcessors. This will allow applications to implement
                     features that require global KeyEvent post-handling, such as menu shortcuts.
                     &lt;p&gt;
                     Note that the KeyboardFocusManager itself implements KeyEventPostProcessor.
                     By default, the current KeyboardFocusManager will be the final
                     KeyEventPostProcessor in the chain. The current KeyboardFocusManager cannot
                     be completely deregistered as a KeyEventPostProcessor. However, if a
                     KeyEventPostProcessor reports that no further post-processing of the
                     KeyEvent should take place, the AWT will consider the event fully handled
                     and will take no additional action with regard to the event. (While it is
                     possible for client code to register the current KeyboardFocusManager as
                     a KeyEventPostProcessor one or more times, this is usually unnecessary and
                     not recommended.)
                    
                     @author David Mendenhall
                    
                     @see KeyboardFocusManager#addKeyEventPostProcessor
                     @see KeyboardFocusManager#removeKeyEventPostProcessor
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="Canvas" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@code Canvas} component represents a blank rectangular
                     area of the screen onto which the application can draw or from
                     which the application can trap input events from the user.
                     &lt;p&gt;
                     An application must subclass the {@code Canvas} class in
                     order to get useful functionality such as creating a custom
                     component. The {@code paint} method must be overridden
                     in order to perform custom graphics on the canvas.
                    
                     @author      Sami Shaio
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="Color" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Paint"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Color} class is used to encapsulate colors in the default
                     sRGB color space or colors in arbitrary color spaces identified by a
                     {@link ColorSpace}.  Every color has an implicit alpha value of 1.0 or
                     an explicit one provided in the constructor.  The alpha value
                     defines the transparency of a color and can be represented by
                     a float value in the range 0.0&amp;nbsp;-&amp;nbsp;1.0 or 0&amp;nbsp;-&amp;nbsp;255.
                     An alpha value of 1.0 or 255 means that the color is completely
                     opaque and an alpha value of 0 or 0.0 means that the color is
                     completely transparent.
                     When constructing a {@code Color} with an explicit alpha or
                     getting the color/alpha components of a {@code Color}, the color
                     components are never premultiplied by the alpha component.
                     &lt;p&gt;
                     The default color space for the Java 2D(tm) API is sRGB, a proposed
                     standard RGB color space.  For further information on sRGB,
                     see &lt;A href="http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html"&gt;
                     http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html
                     &lt;/A&gt;.
                    
                     @version     10 Feb 1997
                     @author      Sami Shaio
                     @author      Arthur van Hoff
                     @see         ColorSpace
                     @see         AlphaComposite
                    </javadoc>
            </acts>
            <acts name="ComponentOrientation" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The ComponentOrientation class encapsulates the language-sensitive
                     orientation that is to be used to order the elements of a component
                     or of text. It is used to reflect the differences in this ordering
                     between Western alphabets, Middle Eastern (such as Hebrew), and Far
                     Eastern (such as Japanese).
                     &lt;p&gt;
                     Fundamentally, this governs items (such as characters) which are laid out
                     in lines, with the lines then laid out in a block. This also applies
                     to items in a widget: for example, in a check box where the box is
                     positioned relative to the text.
                     &lt;p&gt;
                     There are four different orientations used in modern languages
                     as in the following table.&lt;br&gt;
                     &lt;pre&gt;
                     LT          RT          TL          TR
                     A B C       C B A       A D G       G D A
                     D E F       F E D       B E H       H E B
                     G H I       I H G       C F I       I F C
                     &lt;/pre&gt;&lt;br&gt;
                     (In the header, the two-letter abbreviation represents the item direction
                     in the first letter, and the line direction in the second. For example,
                     LT means "items left-to-right, lines top-to-bottom",
                     TL means "items top-to-bottom, lines left-to-right", and so on.)
                     &lt;p&gt;
                     The orientations are:
                     &lt;ul&gt;
                     &lt;li&gt;LT - Western Europe (optional for Japanese, Chinese, Korean)
                     &lt;li&gt;RT - Middle East (Arabic, Hebrew)
                     &lt;li&gt;TR - Japanese, Chinese, Korean
                     &lt;li&gt;TL - Mongolian
                     &lt;/ul&gt;
                     Components whose view and controller code depends on orientation
                     should use the {@code isLeftToRight()} and
                     {@code isHorizontal()} methods to
                     determine their behavior. They should not include switch-like
                     code that keys off of the constants, such as:
                     &lt;pre&gt;
                     if (orientation == LEFT_TO_RIGHT) {
                       ...
                     } else if (orientation == RIGHT_TO_LEFT) {
                       ...
                     } else {
                       // Oops
                     }
                     &lt;/pre&gt;
                     This is unsafe, since more constants may be added in the future and
                     since it is not guaranteed that orientation objects will be unique.
                    </javadoc>
            </acts>
            <acts name="ColorSpaceType" access="PUBLIC" declaringClass="MultipleGradientPaint" kind="TYPE" typeKind="ENUM" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Paint" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Transparency"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This {@code Paint} interface defines how color patterns
                     can be generated for {@link Graphics2D} operations.  A class
                     implementing the {@code Paint} interface is added to the
                     {@code Graphics2D} context in order to define the color
                     pattern used by the {@code draw} and {@code fill} methods.
                     &lt;p&gt;
                     Instances of classes implementing {@code Paint} must be
                     read-only because the {@code Graphics2D} does not clone
                     these objects when they are set as an attribute with the
                     {@code setPaint} method or when the {@code Graphics2D}
                     object is itself cloned.
                     @see PaintContext
                     @see Color
                     @see GradientPaint
                     @see TexturePaint
                     @see Graphics2D#setPaint
                     @version 1.36, 06/05/07
                    </javadoc>
            </acts>
            <acts name="OriginType" access="PUBLIC" declaringClass="PageAttributes" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.AttributeValue"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="MouseInfo" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     {@code MouseInfo}  provides methods for getting information about the mouse,
                     such as mouse pointer location and the number of mouse buttons.
                    
                     @author     Roman Poborchiy
                     @since 1.5
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTMenu" access="PROTECTED" declaringClass="Menu" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.MenuItem$AccessibleAWTMenuItem"/>
                    <superType superType="java.awt.MenuComponent$AccessibleAWTMenuComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="AccessibleAWTFocusHandler" access="PROTECTED" declaringClass="Component.AccessibleAWTComponent" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.event.FocusListener"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="AWTException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that an Abstract Window Toolkit exception has occurred.
                    
                     @author      Arthur van Hoff
                    </javadoc>
            </acts>
            <acts name="PopupMenu" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Menu"/>
                    <superType superType="java.awt.MenuItem"/>
                    <superType superType="java.awt.MenuComponent"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A class that implements a menu which can be dynamically popped up
                     at a specified position within a component.
                     &lt;p&gt;
                     As the inheritance hierarchy implies, a {@code PopupMenu}
                      can be used anywhere a {@code Menu} can be used.
                     However, if you use a {@code PopupMenu} like a {@code Menu}
                     (e.g., you add it to a {@code MenuBar}), then you &lt;b&gt;cannot&lt;/b&gt;
                     call {@code show} on that {@code PopupMenu}.
                    
                     @author      Amy Fowler
                    </javadoc>
            </acts>
            <acts name="BasicStroke" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Stroke"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code BasicStroke} class defines a basic set of rendering
                     attributes for the outlines of graphics primitives, which are rendered
                     with a {@link Graphics2D} object that has its Stroke attribute set to
                     this {@code BasicStroke}.
                     The rendering attributes defined by {@code BasicStroke} describe
                     the shape of the mark made by a pen drawn along the outline of a
                     {@link Shape} and the decorations applied at the ends and joins of
                     path segments of the {@code Shape}.
                     These rendering attributes include:
                     &lt;dl&gt;
                     &lt;dt&gt;&lt;i&gt;width&lt;/i&gt;
                     &lt;dd&gt;The pen width, measured perpendicularly to the pen trajectory.
                     &lt;dt&gt;&lt;i&gt;end caps&lt;/i&gt;
                     &lt;dd&gt;The decoration applied to the ends of unclosed subpaths and
                     dash segments.  Subpaths that start and end on the same point are
                     still considered unclosed if they do not have a CLOSE segment.
                     See {@link java.awt.geom.PathIterator#SEG_CLOSE SEG_CLOSE}
                     for more information on the CLOSE segment.
                     The three different decorations are: {@link #CAP_BUTT},
                     {@link #CAP_ROUND}, and {@link #CAP_SQUARE}.
                     &lt;dt&gt;&lt;i&gt;line joins&lt;/i&gt;
                     &lt;dd&gt;The decoration applied at the intersection of two path segments
                     and at the intersection of the endpoints of a subpath that is closed
                     using {@link java.awt.geom.PathIterator#SEG_CLOSE SEG_CLOSE}.
                     The three different decorations are: {@link #JOIN_BEVEL},
                     {@link #JOIN_MITER}, and {@link #JOIN_ROUND}.
                     &lt;dt&gt;&lt;i&gt;miter limit&lt;/i&gt;
                     &lt;dd&gt;The limit to trim a line join that has a JOIN_MITER decoration.
                     A line join is trimmed when the ratio of miter length to stroke
                     width is greater than the miterlimit value.  The miter length is
                     the diagonal length of the miter, which is the distance between
                     the inside corner and the outside corner of the intersection.
                     The smaller the angle formed by two line segments, the longer
                     the miter length and the sharper the angle of intersection.  The
                     default miterlimit value of 10.0f causes all angles less than
                     11 degrees to be trimmed.  Trimming miters converts
                     the decoration of the line join to bevel.
                     &lt;dt&gt;&lt;i&gt;dash attributes&lt;/i&gt;
                     &lt;dd&gt;The definition of how to make a dash pattern by alternating
                     between opaque and transparent sections.
                     &lt;/dl&gt;
                     All attributes that specify measurements and distances controlling
                     the shape of the returned outline are measured in the same
                     coordinate system as the original unstroked {@code Shape}
                     argument.  When a {@code Graphics2D} object uses a
                     {@code Stroke} object to redefine a path during the execution
                     of one of its {@code draw} methods, the geometry is supplied
                     in its original form before the {@code Graphics2D} transform
                     attribute is applied.  Therefore, attributes such as the pen width
                     are interpreted in the user space coordinate system of the
                     {@code Graphics2D} object and are subject to the scaling and
                     shearing effects of the user-space-to-device-space transform in that
                     particular {@code Graphics2D}.
                     For example, the width of a rendered shape's outline is determined
                     not only by the width attribute of this {@code BasicStroke},
                     but also by the transform attribute of the
                     {@code Graphics2D} object.  Consider this code:
                     &lt;blockquote&gt;&lt;pre&gt;{@code
                          // sets the Graphics2D object's Transform attribute
                          g2d.scale(10, 10);
                          // sets the Graphics2D object's Stroke attribute
                          g2d.setStroke(new BasicStroke(1.5f));
                     }&lt;/pre&gt;&lt;/blockquote&gt;
                     Assuming there are no other scaling transforms added to the
                     {@code Graphics2D} object, the resulting line
                     will be approximately 15 pixels wide.
                     As the example code demonstrates, a floating-point line
                     offers better precision, especially when large transforms are
                     used with a {@code Graphics2D} object.
                     When a line is diagonal, the exact width depends on how the
                     rendering pipeline chooses which pixels to fill as it traces the
                     theoretical widened outline.  The choice of which pixels to turn
                     on is affected by the antialiasing attribute because the
                     antialiasing rendering pipeline can choose to color
                     partially-covered pixels.
                     &lt;p&gt;
                     For more information on the user space coordinate system and the
                     rendering process, see the {@code Graphics2D} class comments.
                     @see Graphics2D
                     @author Jim Graham
                    </javadoc>
            </acts>
            <acts name="FlowLayout" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.LayoutManager"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A flow layout arranges components in a directional flow, much
                     like lines of text in a paragraph. The flow direction is
                     determined by the container's {@code componentOrientation}
                     property and may be one of two values:
                     &lt;ul&gt;
                     &lt;li&gt;{@code ComponentOrientation.LEFT_TO_RIGHT}
                     &lt;li&gt;{@code ComponentOrientation.RIGHT_TO_LEFT}
                     &lt;/ul&gt;
                     Flow layouts are typically used
                     to arrange buttons in a panel. It arranges buttons
                     horizontally until no more buttons fit on the same line.
                     The line alignment is determined by the {@code align}
                     property. The possible values are:
                     &lt;ul&gt;
                     &lt;li&gt;{@link #LEFT LEFT}
                     &lt;li&gt;{@link #RIGHT RIGHT}
                     &lt;li&gt;{@link #CENTER CENTER}
                     &lt;li&gt;{@link #LEADING LEADING}
                     &lt;li&gt;{@link #TRAILING TRAILING}
                     &lt;/ul&gt;
                     &lt;p&gt;
                     For example, the following picture shows an applet using the flow
                     layout manager (its default layout manager) to position three buttons:
                     &lt;p&gt;
                     &lt;img src="doc-files/FlowLayout-1.gif"
                     ALT="Graphic of Layout for Three Buttons"
                     style="float:center; margin: 7px 10px;"&gt;
                     &lt;p&gt;
                     Here is the code for this applet:
                    
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                     import java.awt.*;
                     import java.applet.Applet;
                    
                     public class myButtons extends Applet {
                         Button button1, button2, button3;
                         public void init() {
                             button1 = new Button("Ok");
                             button2 = new Button("Open");
                             button3 = new Button("Close");
                             add(button1);
                             add(button2);
                             add(button3);
                         }
                     }
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                     &lt;p&gt;
                     A flow layout lets each component assume its natural (preferred) size.
                    
                     @author      Arthur van Hoff
                     @author      Sami Shaio
                     @since       1.0
                     @see ComponentOrientation
                    </javadoc>
            </acts>
            <acts name="Insets" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An {@code Insets} object is a representation of the borders
                     of a container. It specifies the space that a container must leave
                     at each of its edges. The space can be a border, a blank space, or
                     a title.
                    
                     @author      Arthur van Hoff
                     @author      Sami Shaio
                     @see         java.awt.LayoutManager
                     @see         java.awt.Container
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="CheckboxGroup" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code CheckboxGroup} class is used to group together
                     a set of {@code Checkbox} buttons.
                     &lt;p&gt;
                     Exactly one check box button in a {@code CheckboxGroup} can
                     be in the "on" state at any given time. Pushing any
                     button sets its state to "on" and forces any other button that
                     is in the "on" state into the "off" state.
                     &lt;p&gt;
                     The following code example produces a new check box group,
                     with three check boxes:
                    
                     &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
                     setLayout(new GridLayout(3, 1));
                     CheckboxGroup cbg = new CheckboxGroup();
                     add(new Checkbox("one", cbg, true));
                     add(new Checkbox("two", cbg, false));
                     add(new Checkbox("three", cbg, false));
                     &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
                     &lt;p&gt;
                     This image depicts the check box group created by this example:
                     &lt;p&gt;
                     &lt;img src="doc-files/CheckboxGroup-1.gif"
                     alt="Shows three checkboxes, arranged vertically, labeled one, two, and three. Checkbox one is in the on state."
                     style="float:center; margin: 7px 10px;"&gt;
                    
                     @author      Sami Shaio
                     @see         java.awt.Checkbox
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="GradientPaint" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Paint"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code GradientPaint} class provides a way to fill
                     a {@link Shape} with a linear color gradient pattern.
                     If {@link Point} P1 with {@link Color} C1 and {@code Point} P2 with
                     {@code Color} C2 are specified in user space, the
                     {@code Color} on the P1, P2 connecting line is proportionally
                     changed from C1 to C2.  Any point P not on the extended P1, P2
                     connecting line has the color of the point P' that is the perpendicular
                     projection of P on the extended P1, P2 connecting line.
                     Points on the extended line outside of the P1, P2 segment can be colored
                     in one of two ways.
                     &lt;ul&gt;
                     &lt;li&gt;
                     If the gradient is cyclic then the points on the extended P1, P2
                     connecting line cycle back and forth between the colors C1 and C2.
                     &lt;li&gt;
                     If the gradient is acyclic then points on the P1 side of the segment
                     have the constant {@code Color} C1 while points on the P2 side
                     have the constant {@code Color} C2.
                     &lt;/ul&gt;
                    
                     @see Paint
                     @see Graphics2D#setPaint
                     @version 10 Feb 1997
                    </javadoc>
            </acts>
            <acts name="MenuBar" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.MenuContainer"/>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.MenuComponent"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code MenuBar} class encapsulates the platform's
                     concept of a menu bar bound to a frame. In order to associate
                     the menu bar with a {@code Frame} object, call the
                     frame's {@code setMenuBar} method.
                     &lt;p&gt;
                     &lt;a id="mbexample"&gt;&lt;/a&gt;&lt;!-- target for cross references --&gt;
                     This is what a menu bar might look like:
                     &lt;p&gt;
                     &lt;img src="doc-files/MenuBar-1.gif"
                     alt="Diagram of MenuBar containing 2 menus: Examples and Options.
                     Examples menu is expanded showing items: Basic, Simple, Check, and More Examples."
                     style="float:center; margin: 7px 10px;"&gt;
                     &lt;p&gt;
                     A menu bar handles keyboard shortcuts for menu items, passing them
                     along to its child menus.
                     (Keyboard shortcuts, which are optional, provide the user with
                     an alternative to the mouse for invoking a menu item and the
                     action that is associated with it.)
                     Each menu item can maintain an instance of {@code MenuShortcut}.
                     The {@code MenuBar} class defines several methods,
                     {@link MenuBar#shortcuts} and
                     {@link MenuBar#getShortcutMenuItem}
                     that retrieve information about the shortcuts a given
                     menu bar is managing.
                    
                     @author Sami Shaio
                     @see        java.awt.Frame
                     @see        java.awt.Frame#setMenuBar(java.awt.MenuBar)
                     @see        java.awt.Menu
                     @see        java.awt.MenuItem
                     @see        java.awt.MenuShortcut
                     @since      1.0
                    </javadoc>
            </acts>
            <acts name="LinearGradientPaint" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.MultipleGradientPaint"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code LinearGradientPaint} class provides a way to fill
                     a {@link java.awt.Shape} with a linear color gradient pattern.  The user
                     may specify two or more gradient colors, and this paint will provide an
                     interpolation between each color.  The user also specifies start and end
                     points which define where in user space the color gradient should begin
                     and end.
                     &lt;p&gt;
                     The user must provide an array of floats specifying how to distribute the
                     colors along the gradient.  These values should range from 0.0 to 1.0 and
                     act like keyframes along the gradient (they mark where the gradient should
                     be exactly a particular color).
                     &lt;p&gt;
                     In the event that the user does not set the first keyframe value equal
                     to 0 and/or the last keyframe value equal to 1, keyframes will be created
                     at these positions and the first and last colors will be replicated there.
                     So, if a user specifies the following arrays to construct a gradient:&lt;br&gt;
                     &lt;pre&gt;
                         {Color.BLUE, Color.RED}, {.3f, .7f}
                     &lt;/pre&gt;
                     this will be converted to a gradient with the following keyframes:&lt;br&gt;
                     &lt;pre&gt;
                         {Color.BLUE, Color.BLUE, Color.RED, Color.RED}, {0f, .3f, .7f, 1f}
                     &lt;/pre&gt;
                    
                     &lt;p&gt;
                     The user may also select what action the {@code LinearGradientPaint} object
                     takes when it is filling the space outside the start and end points by
                     setting {@code CycleMethod} to either {@code REFLECTION} or {@code REPEAT}.
                     The distances between any two colors in any of the reflected or repeated
                     copies of the gradient are the same as the distance between those same two
                     colors between the start and end points.
                     Note that some minor variations in distances may occur due to sampling at
                     the granularity of a pixel.
                     If no cycle method is specified, {@code NO_CYCLE} will be chosen by
                     default, which means the endpoint colors will be used to fill the
                     remaining area.
                     &lt;p&gt;
                     The colorSpace parameter allows the user to specify in which colorspace
                     the interpolation should be performed, default sRGB or linearized RGB.
                    
                     &lt;p&gt;
                     The following code demonstrates typical usage of
                     {@code LinearGradientPaint}:
                     &lt;pre&gt;
                         Point2D start = new Point2D.Float(0, 0);
                         Point2D end = new Point2D.Float(50, 50);
                         float[] dist = {0.0f, 0.2f, 1.0f};
                         Color[] colors = {Color.RED, Color.WHITE, Color.BLUE};
                         LinearGradientPaint p =
                             new LinearGradientPaint(start, end, dist, colors);
                     &lt;/pre&gt;
                     &lt;p&gt;
                     This code will create a {@code LinearGradientPaint} which interpolates
                     between red and white for the first 20% of the gradient and between white
                     and blue for the remaining 80%.
                    
                     &lt;p&gt;
                     This image demonstrates the example code above for each
                     of the three cycle methods:
                     &lt;p style="text-align:center"&gt;
                     &lt;img src = "doc-files/LinearGradientPaint.png"
                     alt="image showing the output of the example code"&gt;
                    
                     @see java.awt.Paint
                     @see java.awt.Graphics2D#setPaint
                     @author Nicholas Talian, Vincent Hardy, Jim Graham, Jerry Evans
                     @since 1.6
                    </javadoc>
            </acts>
            <acts name="PageAttributes" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A set of attributes which control the output of a printed page.
                     &lt;p&gt;
                     Instances of this class control the color state, paper size (media type),
                     orientation, logical origin, print quality, and resolution of every
                     page which uses the instance. Attribute names are compliant with the
                     Internet Printing Protocol (IPP) 1.1 where possible. Attribute values
                     are partially compliant where possible.
                     &lt;p&gt;
                     To use a method which takes an inner class type, pass a reference to
                     one of the constant fields of the inner class. Client code cannot create
                     new instances of the inner class types because none of those classes
                     has a public constructor. For example, to set the color state to
                     monochrome, use the following code:
                     &lt;pre&gt;
                     import java.awt.PageAttributes;
                    
                     public class MonochromeExample {
                         public void setMonochrome(PageAttributes pageAttributes) {
                             pageAttributes.setColor(PageAttributes.ColorType.MONOCHROME);
                         }
                     }
                     &lt;/pre&gt;
                     &lt;p&gt;
                     Every IPP attribute which supports an &lt;i&gt;attributeName&lt;/i&gt;-default value
                     has a corresponding &lt;code&gt;set&lt;i&gt;attributeName&lt;/i&gt;ToDefault&lt;/code&gt; method.
                     Default value fields are not provided.
                    
                     @author      David Mendenhall
                     @since 1.3
                    </javadoc>
            </acts>
            <acts name="RenderingHints" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.util.Map"/>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code RenderingHints} class defines and manages collections of
                     keys and associated values which allow an application to provide input
                     into the choice of algorithms used by other classes which perform
                     rendering and image manipulation services.
                     The {@link java.awt.Graphics2D} class, and classes that implement
                     {@link java.awt.image.BufferedImageOp} and
                     {@link java.awt.image.RasterOp} all provide methods to get and
                     possibly to set individual or groups of {@code RenderingHints}
                     keys and their associated values.
                     When those implementations perform any rendering or image manipulation
                     operations they should examine the values of any {@code RenderingHints}
                     that were requested by the caller and tailor the algorithms used
                     accordingly and to the best of their ability.
                     &lt;p&gt;
                     Note that since these keys and values are &lt;i&gt;hints&lt;/i&gt;, there is
                     no requirement that a given implementation supports all possible
                     choices indicated below or that it can respond to requests to
                     modify its choice of algorithm.
                     The values of the various hint keys may also interact such that
                     while all variants of a given key are supported in one situation,
                     the implementation may be more restricted when the values associated
                     with other keys are modified.
                     For example, some implementations may be able to provide several
                     types of dithering when the antialiasing hint is turned off, but
                     have little control over dithering when antialiasing is on.
                     The full set of supported keys and hints may also vary by destination
                     since runtimes may use different underlying modules to render to
                     the screen, or to {@link java.awt.image.BufferedImage} objects,
                     or while printing.
                     &lt;p&gt;
                     Implementations are free to ignore the hints completely, but should
                     try to use an implementation algorithm that is as close as possible
                     to the request.
                     If an implementation supports a given algorithm when any value is used
                     for an associated hint key, then minimally it must do so when the
                     value for that key is the exact value that specifies the algorithm.
                     &lt;p&gt;
                     The keys used to control the hints are all special values that
                     subclass the associated {@link RenderingHints.Key} class.
                     Many common hints are expressed below as static constants in this
                     class, but the list is not meant to be exhaustive.
                     Other hints may be created by other packages by defining new objects
                     which subclass the {@code Key} class and defining the associated values.
                    </javadoc>
            </acts>
            <acts name="Key" access="PUBLIC" declaringClass="RenderingHints" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="SecondaryLoop" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     A helper interface to run the nested event loop.
                     &lt;p&gt;
                     Objects that implement this interface are created with the
                     {@link EventQueue#createSecondaryLoop} method. The interface
                     provides two methods, {@link #enter} and {@link #exit},
                     which can be used to start and stop the event loop.
                     &lt;p&gt;
                     When the {@link #enter} method is called, the current
                     thread is blocked until the loop is terminated by the
                     {@link #exit} method. Also, a new event loop is started
                     on the event dispatch thread, which may or may not be
                     the current thread. The loop can be terminated on any
                     thread by calling its {@link #exit} method. After the
                     loop is terminated, the {@code SecondaryLoop} object can
                     be reused to run a new nested event loop.
                     &lt;p&gt;
                     A typical use case of applying this interface is AWT
                     and Swing modal dialogs. When a modal dialog is shown on
                     the event dispatch thread, it enters a new secondary loop.
                     Later, when the dialog is hidden or disposed, it exits
                     the loop, and the thread continues its execution.
                     &lt;p&gt;
                     The following example illustrates a simple use case of
                     secondary loops:
                    
                     &lt;pre&gt;
                       SecondaryLoop loop;
                    
                       JButton jButton = new JButton("Button");
                       jButton.addActionListener(new ActionListener() {
                           {@code @Override}
                           public void actionPerformed(ActionEvent e) {
                               Toolkit tk = Toolkit.getDefaultToolkit();
                               EventQueue eq = tk.getSystemEventQueue();
                               loop = eq.createSecondaryLoop();
                    
                               // Spawn a new thread to do the work
                               Thread worker = new WorkerThread();
                               worker.start();
                    
                               // Enter the loop to block the current event
                               // handler, but leave UI responsive
                               if (!loop.enter()) {
                                   // Report an error
                               }
                           }
                       });
                    
                       class WorkerThread extends Thread {
                           {@code @Override}
                           public void run() {
                               // Perform calculations
                               doSomethingUseful();
                    
                               // Exit the loop
                               loop.exit();
                           }
                       }
                     &lt;/pre&gt;
                    
                     @see Dialog#show
                     @see EventQueue#createSecondaryLoop
                     @see Toolkit#getSystemEventQueue
                    
                     @author Anton Tarasov, Artem Ananiev
                    
                     @since 1.7
                    </javadoc>
            </acts>
            <acts name="Taskbar" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Taskbar} class allows a Java application to interact with
                     the system task area (taskbar, Dock, etc.).
                    
                     &lt;p&gt;
                     There are a variety of interactions depending on the current platform such as
                     displaying progress of some task, appending user-specified menu to the application
                     icon context menu, etc.
                    
                     @implNote Linux support is currently limited to Unity. However to make these
                     features work on Unity, the app should be run from a .desktop file with
                     specified {@code java.desktop.appName} system property set to this .desktop
                     file name:
                     {@code Exec=java -Djava.desktop.appName=MyApp.desktop -jar /path/to/myapp.jar}
                     see &lt;a href="https://help.ubuntu.com/community/UnityLaunchersAndDesktopFiles"&gt;
                     https://help.ubuntu.com/community/UnityLaunchersAndDesktopFiles&lt;/a&gt;
                    
                     @since 9
                    </javadoc>
            </acts>
            <acts name="FlipContents" access="PUBLIC" declaringClass="BufferCapabilities" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.AttributeValue"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="KeyboardFocusManager" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.KeyEventDispatcher"/>
                    <superType superType="java.awt.KeyEventPostProcessor"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The KeyboardFocusManager is responsible for managing the active and focused
                     Windows, and the current focus owner. The focus owner is defined as the
                     Component in an application that will typically receive all KeyEvents
                     generated by the user. The focused Window is the Window that is, or
                     contains, the focus owner. Only a Frame or a Dialog can be the active
                     Window. The native windowing system may denote the active Window or its
                     children with special decorations, such as a highlighted title bar. The
                     active Window is always either the focused Window, or the first Frame or
                     Dialog that is an owner of the focused Window.
                     &lt;p&gt;
                     The KeyboardFocusManager is both a centralized location for client code to
                     query for the focus owner and initiate focus changes, and an event
                     dispatcher for all FocusEvents, WindowEvents related to focus, and
                     KeyEvents.
                     &lt;p&gt;
                     Some browsers partition applets in different code bases into separate
                     contexts, and establish walls between these contexts. In such a scenario,
                     there will be one KeyboardFocusManager per context. Other browsers place all
                     applets into the same context, implying that there will be only a single,
                     global KeyboardFocusManager for all applets. This behavior is
                     implementation-dependent. Consult your browser's documentation for more
                     information. No matter how many contexts there may be, however, there can
                     never be more than one focus owner, focused Window, or active Window, per
                     ClassLoader.
                     &lt;p&gt;
                     Please see
                     &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html"&gt;
                     How to Use the Focus Subsystem&lt;/a&gt;,
                     a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
                     &lt;a href="../../java/awt/doc-files/FocusSpec.html"&gt;Focus Specification&lt;/a&gt;
                     for more information.
                    
                     @author David Mendenhall
                    
                     @see Window
                     @see Frame
                     @see Dialog
                     @see java.awt.event.FocusEvent
                     @see java.awt.event.WindowEvent
                     @see java.awt.event.KeyEvent
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="Component" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.image.ImageObserver"/>
                    <superType superType="java.awt.MenuContainer"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A &lt;em&gt;component&lt;/em&gt; is an object having a graphical representation
                     that can be displayed on the screen and that can interact with the
                     user. Examples of components are the buttons, checkboxes, and scrollbars
                     of a typical graphical user interface. &lt;p&gt;
                     The {@code Component} class is the abstract superclass of
                     the nonmenu-related Abstract Window Toolkit components. Class
                     {@code Component} can also be extended directly to create a
                     lightweight component. A lightweight component is a component that is
                     not associated with a native window. On the contrary, a heavyweight
                     component is associated with a native window. The {@link #isLightweight()}
                     method may be used to distinguish between the two kinds of the components.
                     &lt;p&gt;
                     Lightweight and heavyweight components may be mixed in a single component
                     hierarchy. However, for correct operating of such a mixed hierarchy of
                     components, the whole hierarchy must be valid. When the hierarchy gets
                     invalidated, like after changing the bounds of components, or
                     adding/removing components to/from containers, the whole hierarchy must be
                     validated afterwards by means of the {@link Container#validate()} method
                     invoked on the top-most invalid container of the hierarchy.
                    
                     &lt;h3&gt;Serialization&lt;/h3&gt;
                     It is important to note that only AWT listeners which conform
                     to the {@code Serializable} protocol will be saved when
                     the object is stored.  If an AWT object has listeners that
                     aren't marked serializable, they will be dropped at
                     {@code writeObject} time.  Developers will need, as always,
                     to consider the implications of making an object serializable.
                     One situation to watch out for is this:
                     &lt;pre&gt;
                        import java.awt.*;
                        import java.awt.event.*;
                        import java.io.Serializable;
                    
                        class MyApp implements ActionListener, Serializable
                        {
                            BigObjectThatShouldNotBeSerializedWithAButton bigOne;
                            Button aButton = new Button();
                    
                            MyApp()
                            {
                                // Oops, now aButton has a listener with a reference
                                // to bigOne!
                                aButton.addActionListener(this);
                            }
                    
                            public void actionPerformed(ActionEvent e)
                            {
                                System.out.println("Hello There");
                            }
                        }
                     &lt;/pre&gt;
                     In this example, serializing {@code aButton} by itself
                     will cause {@code MyApp} and everything it refers to
                     to be serialized as well.  The problem is that the listener
                     is serializable by coincidence, not by design.  To separate
                     the decisions about {@code MyApp} and the
                     {@code ActionListener} being serializable one can use a
                     nested class, as in the following example:
                     &lt;pre&gt;
                        import java.awt.*;
                        import java.awt.event.*;
                        import java.io.Serializable;
                    
                        class MyApp implements java.io.Serializable
                        {
                             BigObjectThatShouldNotBeSerializedWithAButton bigOne;
                             Button aButton = new Button();
                    
                             static class MyActionListener implements ActionListener
                             {
                                 public void actionPerformed(ActionEvent e)
                                 {
                                     System.out.println("Hello There");
                                 }
                             }
                    
                             MyApp()
                             {
                                 aButton.addActionListener(new MyActionListener());
                             }
                        }
                     &lt;/pre&gt;
                     &lt;p&gt;
                     &lt;b&gt;Note&lt;/b&gt;: For more information on the paint mechanisms utilized
                     by AWT and Swing, including information on how to write the most
                     efficient painting code, see
                     &lt;a href="http://www.oracle.com/technetwork/java/painting-140037.html"&gt;Painting in AWT and Swing&lt;/a&gt;.
                     &lt;p&gt;
                     For details on the focus subsystem, see
                     &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html"&gt;
                     How to Use the Focus Subsystem&lt;/a&gt;,
                     a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
                     &lt;a href="../../java/awt/doc-files/FocusSpec.html"&gt;Focus Specification&lt;/a&gt;
                     for more information.
                    
                     @author      Arthur van Hoff
                     @author      Sami Shaio
                    </javadoc>
            </acts>
            <acts name="ItemSelectable" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     The interface for objects which contain a set of items for
                     which zero or more can be selected.
                    
                     @author Amy Fowler
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTTextField" access="PROTECTED" declaringClass="TextField" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.TextComponent$AccessibleAWTTextComponent"/>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="CardLayout" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.LayoutManager2"/>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A {@code CardLayout} object is a layout manager for a
                     container. It treats each component in the container as a card.
                     Only one card is visible at a time, and the container acts as
                     a stack of cards. The first component added to a
                     {@code CardLayout} object is the visible component when the
                     container is first displayed.
                     &lt;p&gt;
                     The ordering of cards is determined by the container's own internal
                     ordering of its component objects. {@code CardLayout}
                     defines a set of methods that allow an application to flip
                     through these cards sequentially, or to show a specified card.
                     The {@link CardLayout#addLayoutComponent}
                     method can be used to associate a string identifier with a given card
                     for fast random access.
                    
                     @author      Arthur van Hoff
                     @see         java.awt.Container
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTLabel" access="PROTECTED" declaringClass="Label" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="AWTKeyStroke" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     An {@code AWTKeyStroke} represents a key action on the
                     keyboard, or equivalent input device. {@code AWTKeyStroke}s
                     can correspond to only a press or release of a
                     particular key, just as {@code KEY_PRESSED} and
                     {@code KEY_RELEASED KeyEvent}s do;
                     alternately, they can correspond to typing a specific Java character, just
                     as {@code KEY_TYPED KeyEvent}s do.
                     In all cases, {@code AWTKeyStroke}s can specify modifiers
                     (alt, shift, control, meta, altGraph, or a combination thereof) which must be present
                     during the action for an exact match.
                     &lt;p&gt;
                     {@code AWTKeyStrokes} are immutable, and are intended
                     to be unique. Client code should never create an
                     {@code AWTKeyStroke} on its own, but should instead use
                     a variant of {@code getAWTKeyStroke}. Client use of these factory
                     methods allows the {@code AWTKeyStroke} implementation
                     to cache and share instances efficiently.
                    
                     @see #getAWTKeyStroke
                    
                     @author Arnaud Weber
                     @author David Mendenhall
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="AlphaComposite" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Composite"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code AlphaComposite} class implements basic alpha
                     compositing rules for combining source and destination colors
                     to achieve blending and transparency effects with graphics and
                     images.
                     The specific rules implemented by this class are the basic set
                     of 12 rules described in
                     T. Porter and T. Duff, "Compositing Digital Images", SIGGRAPH 84,
                     253-259.
                     The rest of this documentation assumes some familiarity with the
                     definitions and concepts outlined in that paper.
                    
                     &lt;p&gt;
                     This class extends the standard equations defined by Porter and
                     Duff to include one additional factor.
                     An instance of the {@code AlphaComposite} class can contain
                     an alpha value that is used to modify the opacity or coverage of
                     every source pixel before it is used in the blending equations.
                    
                     &lt;p&gt;
                     It is important to note that the equations defined by the Porter
                     and Duff paper are all defined to operate on color components
                     that are premultiplied by their corresponding alpha components.
                     Since the {@code ColorModel} and {@code Raster} classes
                     allow the storage of pixel data in either premultiplied or
                     non-premultiplied form, all input data must be normalized into
                     premultiplied form before applying the equations and all results
                     might need to be adjusted back to the form required by the destination
                     before the pixel values are stored.
                    
                     &lt;p&gt;
                     Also note that this class defines only the equations
                     for combining color and alpha values in a purely mathematical
                     sense. The accurate application of its equations depends
                     on the way the data is retrieved from its sources and stored
                     in its destinations.
                     See &lt;a href="#caveats"&gt;Implementation Caveats&lt;/a&gt;
                     for further information.
                    
                     &lt;p&gt;
                     The following factors are used in the description of the blending
                     equation in the Porter and Duff paper:
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;Factors&lt;/caption&gt;
                     &lt;thead&gt;
                       &lt;tr&gt;
                         &lt;th scope="col"&gt;Factor
                         &lt;th scope="col"&gt;Definition
                     &lt;/thead&gt;
                     &lt;tbody&gt;
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;A&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;the alpha component of the source pixel
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;C&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;a color component of the source pixel in premultiplied form
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;A&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;the alpha component of the destination pixel
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;C&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;a color component of the destination pixel in premultiplied form
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;the fraction of the source pixel that contributes to the output
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;the fraction of the destination pixel that contributes to the output
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;A&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;the alpha component of the result
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;C&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;a color component of the result in premultiplied form
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                     &lt;p&gt;
                     Using these factors, Porter and Duff define 12 ways of choosing
                     the blending factors &lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; to
                     produce each of 12 desirable visual effects.
                     The equations for determining &lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;
                     are given in the descriptions of the 12 static fields
                     that specify visual effects.
                     For example,
                     the description for
                     &lt;a href="#SRC_OVER"&gt;{@code SRC_OVER}&lt;/a&gt;
                     specifies that &lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; = 1 and &lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; = (1-&lt;em&gt;A&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;).
                     Once a set of equations for determining the blending factors is
                     known they can then be applied to each pixel to produce a result
                     using the following set of equations:
                    
                     &lt;pre&gt;
                          &lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;A&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;)
                          &lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;A&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;)
                          &lt;em&gt;A&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;A&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;*&lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; + &lt;em&gt;A&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;*&lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;
                          &lt;em&gt;C&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;C&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;*&lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; + &lt;em&gt;C&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;*&lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;&lt;/pre&gt;
                    
                     &lt;p&gt;
                     The following factors will be used to discuss our extensions to
                     the blending equation in the Porter and Duff paper:
                    
                     &lt;table class="striped"&gt;
                     &lt;caption style="display:none"&gt;Factors&lt;/caption&gt;
                     &lt;thead&gt;
                       &lt;tr&gt;
                         &lt;th scope="col"&gt;Factor
                         &lt;th scope="col"&gt;Definition
                     &lt;/thead&gt;
                     &lt;tbody&gt;
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;C&lt;sub&gt;sr&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;one of the raw color components of the source pixel
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;C&lt;sub&gt;dr&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;one of the raw color components of the destination pixel
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;A&lt;sub&gt;ac&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;the "extra" alpha component from the AlphaComposite instance
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;A&lt;sub&gt;sr&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;the raw alpha component of the source pixel
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;A&lt;sub&gt;dr&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;the raw alpha component of the destination pixel
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;A&lt;sub&gt;df&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;the final alpha component stored in the destination
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;&lt;em&gt;C&lt;sub&gt;df&lt;/sub&gt;&lt;/em&gt;
                         &lt;td&gt;the final raw color component stored in the destination
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     &lt;h3&gt;Preparing Inputs&lt;/h3&gt;
                    
                     &lt;p&gt;
                     The {@code AlphaComposite} class defines an additional alpha
                     value that is applied to the source alpha.
                     This value is applied as if an implicit SRC_IN rule were first
                     applied to the source pixel against a pixel with the indicated
                     alpha by multiplying both the raw source alpha and the raw
                     source colors by the alpha in the {@code AlphaComposite}.
                     This leads to the following equation for producing the alpha
                     used in the Porter and Duff blending equation:
                    
                     &lt;pre&gt;
                          &lt;em&gt;A&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;A&lt;sub&gt;sr&lt;/sub&gt;&lt;/em&gt; * &lt;em&gt;A&lt;sub&gt;ac&lt;/sub&gt;&lt;/em&gt; &lt;/pre&gt;
                    
                     All of the raw source color components need to be multiplied
                     by the alpha in the {@code AlphaComposite} instance.
                     Additionally, if the source was not in premultiplied form
                     then the color components also need to be multiplied by the
                     source alpha.
                     Thus, the equation for producing the source color components
                     for the Porter and Duff equation depends on whether the source
                     pixels are premultiplied or not:
                    
                     &lt;pre&gt;
                          &lt;em&gt;C&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;C&lt;sub&gt;sr&lt;/sub&gt;&lt;/em&gt; * &lt;em&gt;A&lt;sub&gt;sr&lt;/sub&gt;&lt;/em&gt; * &lt;em&gt;A&lt;sub&gt;ac&lt;/sub&gt;&lt;/em&gt;     (if source is not premultiplied)
                          &lt;em&gt;C&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;C&lt;sub&gt;sr&lt;/sub&gt;&lt;/em&gt; * &lt;em&gt;A&lt;sub&gt;ac&lt;/sub&gt;&lt;/em&gt;           (if source is premultiplied) &lt;/pre&gt;
                    
                     No adjustment needs to be made to the destination alpha:
                    
                     &lt;pre&gt;
                          &lt;em&gt;A&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;A&lt;sub&gt;dr&lt;/sub&gt;&lt;/em&gt; &lt;/pre&gt;
                    
                     &lt;p&gt;
                     The destination color components need to be adjusted only if
                     they are not in premultiplied form:
                    
                     &lt;pre&gt;
                          &lt;em&gt;C&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;C&lt;sub&gt;dr&lt;/sub&gt;&lt;/em&gt; * &lt;em&gt;A&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;    (if destination is not premultiplied)
                          &lt;em&gt;C&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;C&lt;sub&gt;dr&lt;/sub&gt;&lt;/em&gt;         (if destination is premultiplied) &lt;/pre&gt;
                    
                     &lt;h3&gt;Applying the Blending Equation&lt;/h3&gt;
                    
                     &lt;p&gt;
                     The adjusted &lt;em&gt;A&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;A&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;,
                     &lt;em&gt;C&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;, and &lt;em&gt;C&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; are used in the standard
                     Porter and Duff equations to calculate the blending factors
                     &lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; and then the resulting
                     premultiplied components &lt;em&gt;A&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;C&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;.
                    
                     &lt;h3&gt;Preparing Results&lt;/h3&gt;
                    
                     &lt;p&gt;
                     The results only need to be adjusted if they are to be stored
                     back into a destination buffer that holds data that is not
                     premultiplied, using the following equations:
                    
                     &lt;pre&gt;
                          &lt;em&gt;A&lt;sub&gt;df&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;A&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;
                          &lt;em&gt;C&lt;sub&gt;df&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;C&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;                 (if dest is premultiplied)
                          &lt;em&gt;C&lt;sub&gt;df&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;C&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt; / &lt;em&gt;A&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;            (if dest is not premultiplied) &lt;/pre&gt;
                    
                     Note that since the division is undefined if the resulting alpha
                     is zero, the division in that case is omitted to avoid the "divide
                     by zero" and the color components are left as
                     all zeros.
                    
                     &lt;h3&gt;Performance Considerations&lt;/h3&gt;
                    
                     &lt;p&gt;
                     For performance reasons, it is preferable that
                     {@code Raster} objects passed to the {@code compose}
                     method of a {@link CompositeContext} object created by the
                     {@code AlphaComposite} class have premultiplied data.
                     If either the source {@code Raster}
                     or the destination {@code Raster}
                     is not premultiplied, however,
                     appropriate conversions are performed before and after the compositing
                     operation.
                    
                     &lt;h3&gt;&lt;a id="caveats"&gt;Implementation Caveats&lt;/a&gt;&lt;/h3&gt;
                    
                     &lt;ul&gt;
                     &lt;li&gt;
                     Many sources, such as some of the opaque image types listed
                     in the {@code BufferedImage} class, do not store alpha values
                     for their pixels.  Such sources supply an alpha of 1.0 for
                     all of their pixels.
                    
                     &lt;li&gt;
                     Many destinations also have no place to store the alpha values
                     that result from the blending calculations performed by this class.
                     Such destinations thus implicitly discard the resulting
                     alpha values that this class produces.
                     It is recommended that such destinations should treat their stored
                     color values as non-premultiplied and divide the resulting color
                     values by the resulting alpha value before storing the color
                     values and discarding the alpha value.
                    
                     &lt;li&gt;
                     The accuracy of the results depends on the manner in which pixels
                     are stored in the destination.
                     An image format that provides at least 8 bits of storage per color
                     and alpha component is at least adequate for use as a destination
                     for a sequence of a few to a dozen compositing operations.
                     An image format with fewer than 8 bits of storage per component
                     is of limited use for just one or two compositing operations
                     before the rounding errors dominate the results.
                     An image format
                     that does not separately store
                     color components is not a
                     good candidate for any type of translucent blending.
                     For example, {@code BufferedImage.TYPE_BYTE_INDEXED}
                     should not be used as a destination for a blending operation
                     because every operation
                     can introduce large errors, due to
                     the need to choose a pixel from a limited palette to match the
                     results of the blending equations.
                    
                     &lt;li&gt;
                     Nearly all formats store pixels as discrete integers rather than
                     the floating point values used in the reference equations above.
                     The implementation can either scale the integer pixel
                     values into floating point values in the range 0.0 to 1.0 or
                     use slightly modified versions of the equations
                     that operate entirely in the integer domain and yet produce
                     analogous results to the reference equations.
                    
                     &lt;p&gt;
                     Typically the integer values are related to the floating point
                     values in such a way that the integer 0 is equated
                     to the floating point value 0.0 and the integer
                     2^&lt;em&gt;n&lt;/em&gt;-1 (where &lt;em&gt;n&lt;/em&gt; is the number of bits
                     in the representation) is equated to 1.0.
                     For 8-bit representations, this means that 0x00
                     represents 0.0 and 0xff represents
                     1.0.
                    
                     &lt;li&gt;
                     The internal implementation can approximate some of the equations
                     and it can also eliminate some steps to avoid unnecessary operations.
                     For example, consider a discrete integer image with non-premultiplied
                     alpha values that uses 8 bits per component for storage.
                     The stored values for a
                     nearly transparent darkened red might be:
                    
                     &lt;pre&gt;
                        (A, R, G, B) = (0x01, 0xb0, 0x00, 0x00)&lt;/pre&gt;
                    
                     &lt;p&gt;
                     If integer math were being used and this value were being
                     composited in
                     &lt;a href="#SRC"&gt;{@code SRC}&lt;/a&gt;
                     mode with no extra alpha, then the math would
                     indicate that the results were (in integer format):
                    
                     &lt;pre&gt;
                        (A, R, G, B) = (0x01, 0x01, 0x00, 0x00)&lt;/pre&gt;
                    
                     &lt;p&gt;
                     Note that the intermediate values, which are always in premultiplied
                     form, would only allow the integer red component to be either 0x00
                     or 0x01.  When we try to store this result back into a destination
                     that is not premultiplied, dividing out the alpha will give us
                     very few choices for the non-premultiplied red value.
                     In this case an implementation that performs the math in integer
                     space without shortcuts is likely to end up with the final pixel
                     values of:
                    
                     &lt;pre&gt;
                        (A, R, G, B) = (0x01, 0xff, 0x00, 0x00)&lt;/pre&gt;
                    
                     &lt;p&gt;
                     (Note that 0x01 divided by 0x01 gives you 1.0, which is equivalent
                     to the value 0xff in an 8-bit storage format.)
                    
                     &lt;p&gt;
                     Alternately, an implementation that uses floating point math
                     might produce more accurate results and end up returning to the
                     original pixel value with little, if any, round-off error.
                     Or, an implementation using integer math might decide that since
                     the equations boil down to a virtual NOP on the color values
                     if performed in a floating point space, it can transfer the
                     pixel untouched to the destination and avoid all the math entirely.
                    
                     &lt;p&gt;
                     These implementations all attempt to honor the
                     same equations, but use different tradeoffs of integer and
                     floating point math and reduced or full equations.
                     To account for such differences, it is probably best to
                     expect only that the premultiplied form of the results to
                     match between implementations and image formats.  In this
                     case both answers, expressed in premultiplied form would
                     equate to:
                    
                     &lt;pre&gt;
                        (A, R, G, B) = (0x01, 0x01, 0x00, 0x00)&lt;/pre&gt;
                    
                     &lt;p&gt;
                     and thus they would all match.
                    
                     &lt;li&gt;
                     Because of the technique of simplifying the equations for
                     calculation efficiency, some implementations might perform
                     differently when encountering result alpha values of 0.0
                     on a non-premultiplied destination.
                     Note that the simplification of removing the divide by alpha
                     in the case of the SRC rule is technically not valid if the
                     denominator (alpha) is 0.
                     But, since the results should only be expected to be accurate
                     when viewed in premultiplied form, a resulting alpha of 0
                     essentially renders the resulting color components irrelevant
                     and so exact behavior in this case should not be expected.
                     &lt;/ul&gt;
                     @see Composite
                     @see CompositeContext
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTCheckboxMenuItem" access="PROTECTED" declaringClass="CheckboxMenuItem" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.AccessibleAction"/>
                    <superType superType="javax.accessibility.AccessibleValue"/>
                    <superType superType="java.awt.MenuItem$AccessibleAWTMenuItem"/>
                    <superType superType="java.awt.MenuComponent$AccessibleAWTMenuComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="KeyEventDispatcher" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     A KeyEventDispatcher cooperates with the current KeyboardFocusManager in the
                     targeting and dispatching of all KeyEvents. KeyEventDispatchers registered
                     with the current KeyboardFocusManager will receive KeyEvents before they are
                     dispatched to their targets, allowing each KeyEventDispatcher to retarget
                     the event, consume it, dispatch the event itself, or make other changes.
                     &lt;p&gt;
                     Note that KeyboardFocusManager itself implements KeyEventDispatcher. By
                     default, the current KeyboardFocusManager will be the sink for all KeyEvents
                     not dispatched by the registered KeyEventDispatchers. The current
                     KeyboardFocusManager cannot be completely deregistered as a
                     KeyEventDispatcher. However, if a KeyEventDispatcher reports that it
                     dispatched the KeyEvent, regardless of whether it actually did so, the
                     KeyboardFocusManager will take no further action with regard to the
                     KeyEvent. (While it is possible for client code to register the current
                     KeyboardFocusManager as a KeyEventDispatcher one or more times, this is
                     usually unnecessary and not recommended.)
                    
                     @author David Mendenhall
                    
                     @see KeyboardFocusManager#addKeyEventDispatcher
                     @see KeyboardFocusManager#removeKeyEventDispatcher
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTCanvas" access="PROTECTED" declaringClass="Canvas" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="MenuItem" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.Accessible"/>
                    <superType superType="java.awt.MenuComponent"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     All items in a menu must belong to the class
                     {@code MenuItem}, or one of its subclasses.
                     &lt;p&gt;
                     The default {@code MenuItem} object embodies
                     a simple labeled menu item.
                     &lt;p&gt;
                     This picture of a menu bar shows five menu items:
                     &lt;IMG SRC="doc-files/MenuBar-1.gif" alt="The following text describes this graphic."
                     style="float:center; margin: 7px 10px;"&gt;
                     &lt;br style="clear:left;"&gt;
                     The first two items are simple menu items, labeled
                     {@code "Basic"} and {@code "Simple"}.
                     Following these two items is a separator, which is itself
                     a menu item, created with the label {@code "-"}.
                     Next is an instance of {@code CheckboxMenuItem}
                     labeled {@code "Check"}. The final menu item is a
                     submenu labeled &lt;code&gt;"More&amp;nbsp;Examples"&lt;/code&gt;,
                     and this submenu is an instance of {@code Menu}.
                     &lt;p&gt;
                     When a menu item is selected, AWT sends an action event to
                     the menu item. Since the event is an
                     instance of {@code ActionEvent}, the {@code processEvent}
                     method examines the event and passes it along to
                     {@code processActionEvent}. The latter method redirects the
                     event to any {@code ActionListener} objects that have
                     registered an interest in action events generated by this
                     menu item.
                     &lt;P&gt;
                     Note that the subclass {@code Menu} overrides this behavior and
                     does not send any event to the frame until one of its subitems is
                     selected.
                    
                     @author Sami Shaio
                    </javadoc>
            </acts>
            <acts name="AWTPermission" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.security.BasicPermission"/>
                    <superType superType="java.security.Permission"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class is for AWT permissions.
                     An {@code AWTPermission} contains a target name but
                     no actions list; you either have the named permission
                     or you don't.
                    
                     &lt;P&gt;
                     The target name is the name of the AWT permission (see below). The naming
                     convention follows the hierarchical property naming convention.
                     Also, an asterisk could be used to represent all AWT permissions.
                    
                     &lt;P&gt;
                     The following table lists all the possible {@code AWTPermission}
                     target names, and for each provides a description of what the
                     permission allows and a discussion of the risks of granting code
                     the permission.
                    
                     &lt;table class="striped"&gt;
                     &lt;caption&gt;AWTPermission target names, descriptions, and associated risks
                     &lt;/caption&gt;
                     &lt;thead&gt;
                       &lt;tr&gt;
                         &lt;th scope="col"&gt;Permission Target Name
                         &lt;th scope="col"&gt;What the Permission Allows
                         &lt;th scope="col"&gt;Risks of Allowing this Permission
                     &lt;/thead&gt;
                     &lt;tbody&gt;
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;accessClipboard
                         &lt;td&gt;Posting and retrieval of information to and from the AWT clipboard
                         &lt;td&gt;This would allow malfeasant code to share potentially sensitive or
                         confidential information.
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;accessEventQueue
                         &lt;td&gt;Access to the AWT event queue
                         &lt;td&gt;After retrieving the AWT event queue, malicious code may peek at and
                         even remove existing events from its event queue, as well as post bogus
                         events which may purposefully cause the application or applet to
                         misbehave in an insecure manner.
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;accessSystemTray
                         &lt;td&gt;Access to the AWT SystemTray instance
                         &lt;td&gt;This would allow malicious code to add tray icons to the system tray.
                         First, such an icon may look like the icon of some known application
                         (such as a firewall or anti-virus) and order a user to do something
                         unsafe (with help of balloon messages). Second, the system tray may be
                         glutted with tray icons so that no one could add a tray icon anymore.
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;createRobot
                         &lt;td&gt;Create java.awt.Robot objects
                         &lt;td&gt;The java.awt.Robot object allows code to generate native-level mouse
                         and keyboard events as well as read the screen. It could allow malicious
                         code to control the system, run other programs, read the display, and
                         deny mouse and keyboard access to the user.
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;fullScreenExclusive
                         &lt;td&gt;Enter full-screen exclusive mode
                         &lt;td&gt;Entering full-screen exclusive mode allows direct access to low-level
                         graphics card memory. This could be used to spoof the system, since the
                         program is in direct control of rendering. Depending on the
                         implementation, the security warning may not be shown for the windows
                         used to enter the full-screen exclusive mode (assuming that the
                         {@code fullScreenExclusive} permission has been granted to this
                         application). Note that this behavior does not mean that the
                         {@code showWindowWithoutWarningBanner} permission will be automatically
                         granted to the application which has the {@code fullScreenExclusive}
                         permission: non-full-screen windows will continue to be shown with the
                         security warning.
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;listenToAllAWTEvents
                         &lt;td&gt;Listen to all AWT events, system-wide
                         &lt;td&gt;After adding an AWT event listener, malicious code may scan all AWT
                         events dispatched in the system, allowing it to read all user input (such
                         as passwords). Each AWT event listener is called from within the context
                         of that event queue's EventDispatchThread, so if the accessEventQueue
                         permission is also enabled, malicious code could modify the contents of
                         AWT event queues system-wide, causing the application or applet to
                         misbehave in an insecure manner.
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;readDisplayPixels
                         &lt;td&gt;Readback of pixels from the display screen
                         &lt;td&gt;Interfaces such as the java.awt.Composite interface or the
                         java.awt.Robot class allow arbitrary code to examine pixels on the
                         display enable malicious code to snoop on the activities of the user.
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;replaceKeyboardFocusManager
                         &lt;td&gt;Sets the {@code KeyboardFocusManager} for a particular thread.
                         &lt;td&gt;When {@code SecurityManager} is installed, the invoking thread must
                         be granted this permission in order to replace the current
                         {@code KeyboardFocusManager}. If permission is not granted, a
                         {@code SecurityException} will be thrown.
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;setAppletStub
                         &lt;td&gt;Setting the stub which implements Applet container services
                         &lt;td&gt;Malicious code could set an applet's stub and result in unexpected
                         behavior or denial of service to an applet.
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;setWindowAlwaysOnTop
                         &lt;td&gt;Setting always-on-top property of the window:
                         {@link Window#setAlwaysOnTop}
                         &lt;td&gt;The malicious window might make itself look and behave like a real
                         full desktop, so that information entered by the unsuspecting user is
                         captured and subsequently misused
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;showWindowWithoutWarningBanner
                         &lt;td&gt;Display of a window without also displaying a banner warning that the
                         window was created by an applet
                         &lt;td&gt;Without this warning, an applet may pop up windows without the user
                         knowing that they belong to an applet. Since users may make
                         security-sensitive decisions based on whether or not the window belongs
                         to an applet (entering a username and password into a dialog box, for
                         example), disabling this warning banner may allow applets to trick the
                         user into entering such information.
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;toolkitModality
                         &lt;td&gt;Creating {@link Dialog.ModalityType#TOOLKIT_MODAL TOOLKIT_MODAL}
                         dialogs and setting the
                         {@link Dialog.ModalExclusionType#TOOLKIT_EXCLUDE TOOLKIT_EXCLUDE} window
                         property.
                         &lt;td&gt;When a toolkit-modal dialog is shown from an applet, it blocks all
                         other applets in the browser. When launching applications from Java Web
                         Start, its windows (such as the security dialog) may also be blocked by
                         toolkit-modal dialogs, shown from these applications.
                       &lt;tr&gt;
                         &lt;th scope="row"&gt;watchMousePointer
                         &lt;td&gt;Getting the information about the mouse pointer position at any time
                         &lt;td&gt;Constantly watching the mouse pointer, an applet can make guesses
                         about what the user is doing, i.e. moving the mouse to the lower left
                         corner of the screen most likely means that the user is about to launch
                         an application. If a virtual keypad is used so that keyboard is emulated
                         using the mouse, an applet may guess what is being typed.
                     &lt;/tbody&gt;
                     &lt;/table&gt;
                    
                     @see java.security.BasicPermission
                     @see java.security.Permission
                     @see java.security.Permissions
                     @see java.security.PermissionCollection
                     @see java.lang.SecurityManager
                    
                     @author Marianne Mueller
                     @author Roland Schemers
                    </javadoc>
            </acts>
            <acts name="LayoutManager2" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.LayoutManager"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Defines an interface for classes that know how to layout Containers
                     based on a layout constraints object.
                    
                     This interface extends the LayoutManager interface to deal with layouts
                     explicitly in terms of constraint objects that specify how and where
                     components should be added to the layout.
                     &lt;p&gt;
                     This minimal extension to LayoutManager is intended for tool
                     providers who wish to the creation of constraint-based layouts.
                     It does not yet provide full, general support for custom
                     constraint-based layout managers.
                    
                     @see LayoutManager
                     @see Container
                    
                     @author      Jonni Kanerva
                    </javadoc>
            </acts>
            <acts name="Point" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.io.Serializable"/>
                    <superType superType="java.awt.geom.Point2D"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     A point representing a location in {@code (x,y)} coordinate space,
                     specified in integer precision.
                    
                     @author      Sami Shaio
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="RadialGradientPaint" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.MultipleGradientPaint"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code RadialGradientPaint} class provides a way to fill a shape with
                     a circular radial color gradient pattern. The user may specify 2 or more
                     gradient colors, and this paint will provide an interpolation between
                     each color.
                     &lt;p&gt;
                     The user must specify the circle controlling the gradient pattern,
                     which is described by a center point and a radius.  The user can also
                     specify a separate focus point within that circle, which controls the
                     location of the first color of the gradient.  By default the focus is
                     set to be the center of the circle.
                     &lt;p&gt;
                     This paint will map the first color of the gradient to the focus point,
                     and the last color to the perimeter of the circle, interpolating
                     smoothly for any in-between colors specified by the user.  Any line drawn
                     from the focus point to the circumference will thus span all the gradient
                     colors.
                     &lt;p&gt;
                     Specifying a focus point outside of the radius of the circle will cause
                     the rings of the gradient pattern to be centered on the point just inside
                     the edge of the circle in the direction of the focus point.
                     The rendering will internally use this modified location as if it were
                     the specified focus point.
                     &lt;p&gt;
                     The user must provide an array of floats specifying how to distribute the
                     colors along the gradient.  These values should range from 0.0 to 1.0 and
                     act like keyframes along the gradient (they mark where the gradient should
                     be exactly a particular color).
                     &lt;p&gt;
                     In the event that the user does not set the first keyframe value equal
                     to 0 and/or the last keyframe value equal to 1, keyframes will be created
                     at these positions and the first and last colors will be replicated there.
                     So, if a user specifies the following arrays to construct a gradient:&lt;br&gt;
                     &lt;pre&gt;
                         {Color.BLUE, Color.RED}, {.3f, .7f}
                     &lt;/pre&gt;
                     this will be converted to a gradient with the following keyframes:&lt;br&gt;
                     &lt;pre&gt;
                         {Color.BLUE, Color.BLUE, Color.RED, Color.RED}, {0f, .3f, .7f, 1f}
                     &lt;/pre&gt;
                    
                     &lt;p&gt;
                     The user may also select what action the {@code RadialGradientPaint} object
                     takes when it is filling the space outside the circle's radius by
                     setting {@code CycleMethod} to either {@code REFLECTION} or {@code REPEAT}.
                     The gradient color proportions are equal for any particular line drawn
                     from the focus point. The following figure shows that the distance AB
                     is equal to the distance BC, and the distance AD is equal to the distance DE.
                     &lt;p style="text-align:center"&gt;
                     &lt;img src = "doc-files/RadialGradientPaint-3.png" alt="image showing the
                     distance AB=BC, and AD=DE"&gt;
                     &lt;p&gt;
                     If the gradient and graphics rendering transforms are uniformly scaled and
                     the user sets the focus so that it coincides with the center of the circle,
                     the gradient color proportions are equal for any line drawn from the center.
                     The following figure shows the distances AB, BC, AD, and DE. They are all equal.
                     &lt;p style="text-align:center"&gt;
                     &lt;img src = "doc-files/RadialGradientPaint-4.png" alt="image showing the
                     distance of AB, BC, AD, and DE are all equal"&gt;
                     &lt;p&gt;
                     Note that some minor variations in distances may occur due to sampling at
                     the granularity of a pixel.
                     If no cycle method is specified, {@code NO_CYCLE} will be chosen by
                     default, which means the last keyframe color will be used to fill the
                     remaining area.
                     &lt;p&gt;
                     The colorSpace parameter allows the user to specify in which colorspace
                     the interpolation should be performed, default sRGB or linearized RGB.
                    
                     &lt;p&gt;
                     The following code demonstrates typical usage of
                     {@code RadialGradientPaint}, where the center and focus points are
                     the same:
                     &lt;pre&gt;
                         Point2D center = new Point2D.Float(50, 50);
                         float radius = 25;
                         float[] dist = {0.0f, 0.2f, 1.0f};
                         Color[] colors = {Color.RED, Color.WHITE, Color.BLUE};
                         RadialGradientPaint p =
                             new RadialGradientPaint(center, radius, dist, colors);
                     &lt;/pre&gt;
                    
                     &lt;p&gt;
                     This image demonstrates the example code above, with default
                     (centered) focus for each of the three cycle methods:
                     &lt;p style="text-align:center"&gt;
                     &lt;img src = "doc-files/RadialGradientPaint-1.png" alt="image showing the
                     output of the sameple code"&gt;
                     &lt;p&gt;
                     It is also possible to specify a non-centered focus point, as
                     in the following code:
                     &lt;pre&gt;
                         Point2D center = new Point2D.Float(50, 50);
                         float radius = 25;
                         Point2D focus = new Point2D.Float(40, 40);
                         float[] dist = {0.0f, 0.2f, 1.0f};
                         Color[] colors = {Color.RED, Color.WHITE, Color.BLUE};
                         RadialGradientPaint p =
                             new RadialGradientPaint(center, radius, focus,
                                                     dist, colors,
                                                     CycleMethod.NO_CYCLE);
                     &lt;/pre&gt;
                    
                     &lt;p&gt;
                     This image demonstrates the previous example code, with non-centered
                     focus for each of the three cycle methods:
                     &lt;p style="text-align:center"&gt;
                     &lt;img src = "doc-files/RadialGradientPaint-2.png" alt="image showing the
                     output of the sample code"&gt;
                    
                     @see java.awt.Paint
                     @see java.awt.Graphics2D#setPaint
                     @author Nicholas Talian, Vincent Hardy, Jim Graham, Jerry Evans
                     @since 1.6
                    </javadoc>
            </acts>
            <acts name="ColorType" access="PUBLIC" declaringClass="PageAttributes" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.AttributeValue"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="IllegalComponentStateException" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.IllegalStateException"/>
                    <superType superType="java.lang.RuntimeException"/>
                    <superType superType="java.lang.Exception"/>
                    <superType superType="java.lang.Throwable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Signals that an AWT component is not in an appropriate state for
                     the requested operation.
                    
                     @author      Jonni Kanerva
                    </javadoc>
            </acts>
            <acts name="DisplayMode" access="PUBLIC" kind="TYPE" typeKind="CLASS_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code DisplayMode} class encapsulates the bit depth, height,
                     width, and refresh rate of a {@code GraphicsDevice}. The ability to
                     change graphics device's display mode is platform- and
                     configuration-dependent and may not always be available
                     (see {@link GraphicsDevice#isDisplayChangeSupported}).
                     &lt;p&gt;
                     For more information on full-screen exclusive mode API, see the
                     &lt;a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/index.html"&gt;
                     Full-Screen Exclusive Mode API Tutorial&lt;/a&gt;.
                    
                     @see GraphicsDevice
                     @see GraphicsDevice#isDisplayChangeSupported
                     @see GraphicsDevice#getDisplayModes
                     @see GraphicsDevice#setDisplayMode
                     @author Michael Martak
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="AccessibleAWTPopupMenu" access="PROTECTED" declaringClass="PopupMenu" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Menu$AccessibleAWTMenu"/>
                    <superType superType="java.awt.MenuItem$AccessibleAWTMenuItem"/>
                    <superType superType="java.awt.MenuComponent$AccessibleAWTMenuComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="Desktop" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code Desktop} class allows interact with various desktop capabilities.
                    
                     &lt;p&gt; Supported operations include:
                     &lt;ul&gt;
                       &lt;li&gt;launching the user-default browser to show a specified
                           URI;&lt;/li&gt;
                       &lt;li&gt;launching the user-default mail client with an optional
                           {@code mailto} URI;&lt;/li&gt;
                       &lt;li&gt;launching a registered application to open, edit or print a
                           specified file.&lt;/li&gt;
                     &lt;/ul&gt;
                    
                     &lt;p&gt; This class provides methods corresponding to these
                     operations. The methods look for the associated application
                     registered on the current platform, and launch it to handle a URI
                     or file. If there is no associated application or the associated
                     application fails to be launched, an exception is thrown.
                    
                     Please see {@link Desktop.Action} for the full list of supported operations
                     and capabilities.
                    
                     &lt;p&gt; An application is registered to a URI or file type.
                     The mechanism of registering, accessing, and
                     launching the associated application is platform-dependent.
                    
                     &lt;p&gt; Each operation is an action type represented by the {@link
                     Desktop.Action} class.
                    
                     &lt;p&gt; Note: when some action is invoked and the associated
                     application is executed, it will be executed on the same system as
                     the one on which the Java application was launched.
                    
                     @see Action
                    
                     @since 1.6
                     @author Armin Chen
                     @author George Zhang
                    </javadoc>
            </acts>
            <acts name="BufferCapabilities" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Cloneable"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     Capabilities and properties of buffers.
                    
                     @see java.awt.image.BufferStrategy#getCapabilities()
                     @see GraphicsConfiguration#getBufferCapabilities
                     @author Michael Martak
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="CompositeContext" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt">
                <superTypes/>
                <javadoc xml:space="preserve">
                     The {@code CompositeContext} interface defines the encapsulated
                     and optimized environment for a compositing operation.
                     {@code CompositeContext} objects maintain state for
                     compositing operations.  In a multi-threaded environment, several
                     contexts can exist simultaneously for a single {@link Composite}
                     object.
                     @see Composite
                    </javadoc>
            </acts>
            <acts name="WindowTranslucency" access="PUBLIC" declaringClass="GraphicsDevice" kind="TYPE" typeKind="ENUM" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="CycleMethod" access="PUBLIC" declaringClass="MultipleGradientPaint" kind="TYPE" typeKind="ENUM" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Enum"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="AccessibleAWTChoice" access="PROTECTED" declaringClass="Choice" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="javax.accessibility.AccessibleAction"/>
                    <superType superType="java.awt.Component$AccessibleAWTComponent"/>
                    <superType superType="javax.accessibility.AccessibleContext"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
            </acts>
            <acts name="DefaultKeyboardFocusManager" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.KeyboardFocusManager"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The default KeyboardFocusManager for AWT applications. Focus traversal is
                     done in response to a Component's focus traversal keys, and using a
                     Container's FocusTraversalPolicy.
                     &lt;p&gt;
                     Please see
                     &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html"&gt;
                     How to Use the Focus Subsystem&lt;/a&gt;,
                     a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
                     &lt;a href="../../java/awt/doc-files/FocusSpec.html"&gt;Focus Specification&lt;/a&gt;
                     for more information.
                    
                     @author David Mendenhall
                    
                     @see FocusTraversalPolicy
                     @see Component#setFocusTraversalKeys
                     @see Component#getFocusTraversalKeys
                     @since 1.4
                    </javadoc>
            </acts>
            <acts name="FileDialog" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.awt.Dialog"/>
                    <superType superType="java.awt.Window"/>
                    <superType superType="java.awt.Container"/>
                    <superType superType="java.awt.Component"/>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     The {@code FileDialog} class displays a dialog window
                     from which the user can select a file.
                     &lt;p&gt;
                     Since it is a modal dialog, when the application calls
                     its {@code show} method to display the dialog,
                     it blocks the rest of the application until the user has
                     chosen a file.
                    
                     @see Window#show
                    
                     @author      Sami Shaio
                     @author      Arthur van Hoff
                     @since       1.0
                    </javadoc>
            </acts>
            <acts name="Robot" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt">
                <superTypes>
                    <superType superType="java.lang.Object"/>
                </superTypes>
                <javadoc xml:space="preserve">
                     This class is used to generate native system input events
                     for the purposes of test automation, self-running demos, and
                     other applications where control of the mouse and keyboard
                     is needed. The primary purpose of Robot is to facilitate
                     automated testing of Java platform implementations.
                     &lt;p&gt;
                     Using the class to generate input events differs from posting
                     events to the AWT event queue or AWT components in that the
                     events are generated in the platform's native input
                     queue. For example, {@code Robot.mouseMove} will actually move
                     the mouse cursor instead of just generating mouse move events.
                     &lt;p&gt;
                     Note that some platforms require special privileges or extensions
                     to access low-level input control. If the current platform configuration
                     does not allow input control, an {@code AWTException} will be thrown
                     when trying to construct Robot objects. For example, X-Window systems
                     will throw the exception if the XTEST 2.2 standard extension is not supported
                     (or not enabled) by the X server.
                     &lt;p&gt;
                     Applications that use Robot for purposes other than self-testing should
                     handle these error conditions gracefully.
                    
                     @author      Robi Khan
                     @since       1.3
                    </javadoc>
            </acts>
            <package name="image">
                <package name="renderable"/>
            </package>
            <package name="print"/>
            <package name="desktop"/>
            <package name="color"/>
            <package name="im">
                <package name="spi"/>
            </package>
            <package name="peer"/>
            <package name="dnd">
                <package name="peer"/>
            </package>
            <package name="event">
                <acts name="ComponentListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving component events.
                         The class that is interested in processing a component event
                         either implements this interface (and all the methods it
                         contains) or extends the abstract {@code ComponentAdapter} class
                         (overriding only the methods of interest).
                         The listener object created from that class is then registered with a
                         component using the component's {@code addComponentListener}
                         method. When the component's size, location, or visibility
                         changes, the relevant method in the listener object is invoked,
                         and the {@code ComponentEvent} is passed to it.
                         &lt;P&gt;
                         Component events are provided for notification purposes ONLY;
                         The AWT will automatically handle component moves and resizes
                         internally so that GUI layout works properly regardless of
                         whether a program registers a {@code ComponentListener} or not.
                        
                         @see ComponentAdapter
                         @see ComponentEvent
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/componentlistener.html"&gt;Tutorial: Writing a Component Listener&lt;/a&gt;
                        
                         @author Carl Quinn
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="FocusAdapter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.FocusListener"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An abstract adapter class for receiving keyboard focus events.
                         The methods in this class are empty. This class exists as
                         convenience for creating listener objects.
                         &lt;P&gt;
                         Extend this class to create a {@code FocusEvent} listener
                         and override the methods for the events of interest. (If you implement the
                         {@code FocusListener} interface, you have to define all of
                         the methods in it. This abstract class defines null methods for them
                         all, so you can only have to define methods for events you care about.)
                         &lt;P&gt;
                         Create a listener object using the extended class and then register it with
                         a component using the component's {@code addFocusListener}
                         method. When the component gains or loses the keyboard focus,
                         the relevant method in the listener object is invoked,
                         and the {@code FocusEvent} is passed to it.
                        
                         @see FocusEvent
                         @see FocusListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/focuslistener.html"&gt;Tutorial: Writing a Focus Listener&lt;/a&gt;
                        
                         @author Carl Quinn
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="ItemEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A semantic event which indicates that an item was selected or deselected.
                         This high-level event is generated by an ItemSelectable object (such as a
                         List) when an item is selected or deselected by the user.
                         The event is passed to every {@code ItemListener} object which
                         registered to receive such events using the component's
                         {@code addItemListener} method.
                         &lt;P&gt;
                         The object that implements the {@code ItemListener} interface gets
                         this {@code ItemEvent} when the event occurs. The listener is
                         spared the details of processing individual mouse movements and mouse
                         clicks, and can instead process a "meaningful" (semantic) event like
                         "item selected" or "item deselected".
                         &lt;p&gt;
                         An unspecified behavior will be caused if the {@code id} parameter
                         of any particular {@code ItemEvent} instance is not
                         in the range from {@code ITEM_FIRST} to {@code ITEM_LAST}.
                         &lt;p&gt;
                         The {@code stateChange} of any {@code ItemEvent} instance takes one of the following
                         values:
                                             &lt;ul&gt;
                                             &lt;li&gt; {@code ItemEvent.SELECTED}
                                             &lt;li&gt; {@code ItemEvent.DESELECTED}
                                             &lt;/ul&gt;
                         Assigning the value different from listed above will cause an unspecified behavior.
                        
                         @author Carl Quinn
                        
                         @see java.awt.ItemSelectable
                         @see ItemListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/itemlistener.html"&gt;Tutorial: Writing an Item Listener&lt;/a&gt;
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="WindowStateListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving window state events.
                         &lt;p&gt;
                         The class that is interested in processing a window state event
                         either implements this interface (and all the methods it contains)
                         or extends the abstract {@code WindowAdapter} class
                         (overriding only the methods of interest).
                         &lt;p&gt;
                         The listener object created from that class is then registered with
                         a window using the {@code Window}'s
                         {@code addWindowStateListener} method.  When the window's
                         state changes by virtue of being iconified, maximized etc., the
                         {@code windowStateChanged} method in the listener object is
                         invoked, and the {@code WindowEvent} is passed to it.
                        
                         @see java.awt.event.WindowAdapter
                         @see java.awt.event.WindowEvent
                        
                         @since 1.4
                        </javadoc>
                </acts>
                <acts name="AWTEventListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving notification of events
                         dispatched to objects that are instances of Component or
                         MenuComponent or their subclasses.  Unlike the other EventListeners
                         in this package, AWTEventListeners passively observe events
                         being dispatched in the AWT, system-wide.  Most applications
                         should never use this class; applications which might use
                         AWTEventListeners include event recorders for automated testing,
                         and facilities such as the Java Accessibility package.
                         &lt;p&gt;
                         The class that is interested in monitoring AWT events
                         implements this interface, and the object created with that
                         class is registered with the Toolkit, using the Toolkit's
                         {@code addAWTEventListener} method.  When an event is
                         dispatched anywhere in the AWT, that object's
                         {@code eventDispatched} method is invoked.
                        
                         @see java.awt.AWTEvent
                         @see java.awt.Toolkit#addAWTEventListener
                         @see java.awt.Toolkit#removeAWTEventListener
                        
                         @author Fred Ecks
                         @since 1.2
                        </javadoc>
                </acts>
                <acts name="ActionEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A semantic event which indicates that a component-defined action occurred.
                         This high-level event is generated by a component (such as a
                         {@code Button}) when
                         the component-specific action occurs (such as being pressed).
                         The event is passed to every {@code ActionListener} object
                         that registered to receive such events using the component's
                         {@code addActionListener} method.
                         &lt;p&gt;
                         &lt;b&gt;Note:&lt;/b&gt; To invoke an {@code ActionEvent} on a
                         {@code Button} using the keyboard, use the Space bar.
                         &lt;P&gt;
                         The object that implements the {@code ActionListener} interface
                         gets this {@code ActionEvent} when the event occurs. The listener
                         is therefore spared the details of processing individual mouse movements
                         and mouse clicks, and can instead process a "meaningful" (semantic)
                         event like "button pressed".
                         &lt;p&gt;
                         An unspecified behavior will be caused if the {@code id} parameter
                         of any particular {@code ActionEvent} instance is not
                         in the range from {@code ACTION_FIRST} to {@code ACTION_LAST}.
                        
                         @see ActionListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/actionlistener.html"&gt;Tutorial: How to Write an Action Listener&lt;/a&gt;
                        
                         @author Carl Quinn
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="KeyAdapter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.KeyListener"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An abstract adapter class for receiving keyboard events.
                         The methods in this class are empty. This class exists as
                         convenience for creating listener objects.
                         &lt;P&gt;
                         Extend this class to create a {@code KeyEvent} listener
                         and override the methods for the events of interest. (If you implement the
                         {@code KeyListener} interface, you have to define all of
                         the methods in it. This abstract class defines null methods for them
                         all, so you can only have to define methods for events you care about.)
                         &lt;P&gt;
                         Create a listener object using the extended class and then register it with
                         a component using the component's {@code addKeyListener}
                         method. When a key is pressed, released, or typed,
                         the relevant method in the listener object is invoked,
                         and the {@code KeyEvent} is passed to it.
                        
                         @author Carl Quinn
                        
                         @see KeyEvent
                         @see KeyListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/keylistener.html"&gt;Tutorial: Writing a Key Listener&lt;/a&gt;
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="WindowAdapter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.WindowListener"/>
                        <superType superType="java.awt.event.WindowStateListener"/>
                        <superType superType="java.awt.event.WindowFocusListener"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An abstract adapter class for receiving window events.
                         The methods in this class are empty. This class exists as
                         convenience for creating listener objects.
                         &lt;P&gt;
                         Extend this class to create a {@code WindowEvent} listener
                         and override the methods for the events of interest. (If you implement the
                         {@code WindowListener} interface, you have to define all of
                         the methods in it. This abstract class defines null methods for them
                         all, so you can only have to define methods for events you care about.)
                         &lt;P&gt;
                         Create a listener object using the extended class and then register it with
                         a Window using the window's {@code addWindowListener}
                         method. When the window's status changes by virtue of being opened,
                         closed, activated or deactivated, iconified or deiconified,
                         the relevant method in the listener
                         object is invoked, and the {@code WindowEvent} is passed to it.
                        
                         @see WindowEvent
                         @see WindowListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/windowlistener.html"&gt;Tutorial: Writing a Window Listener&lt;/a&gt;
                        
                         @author Carl Quinn
                         @author Amy Fowler
                         @author David Mendenhall
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="MouseWheelListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving mouse wheel events on a component.
                         (For clicks and other mouse events, use the {@code MouseListener}.
                         For mouse movement and drags, use the {@code MouseMotionListener}.)
                         &lt;P&gt;
                         The class that is interested in processing a mouse wheel event
                         implements this interface (and all the methods it contains).
                         &lt;P&gt;
                         The listener object created from that class is then registered with a
                         component using the component's {@code addMouseWheelListener}
                         method. A mouse wheel event is generated when the mouse wheel is rotated.
                         When a mouse wheel event occurs, that object's {@code mouseWheelMoved}
                         method is invoked.
                         &lt;p&gt;
                         For information on how mouse wheel events are dispatched, see
                         the class description for {@link MouseWheelEvent}.
                        
                         @author Brent Christian
                         @see MouseWheelEvent
                         @since 1.4
                        </javadoc>
                </acts>
                <acts name="MouseMotionListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving mouse motion events on a component.
                         (For clicks and other mouse events, use the {@code MouseListener}.)
                         &lt;P&gt;
                         The class that is interested in processing a mouse motion event
                         either implements this interface (and all the methods it
                         contains) or extends the abstract {@code MouseMotionAdapter} class
                         (overriding only the methods of interest).
                         &lt;P&gt;
                         The listener object created from that class is then registered with a
                         component using the component's {@code addMouseMotionListener}
                         method. A mouse motion event is generated when the mouse is moved
                         or dragged. (Many such events will be generated). When a mouse motion event
                         occurs, the relevant method in the listener object is invoked, and
                         the {@code MouseEvent} is passed to it.
                        
                         @author Amy Fowler
                        
                         @see MouseMotionAdapter
                         @see MouseEvent
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/mousemotionlistener.html"&gt;Tutorial: Writing a Mouse Motion Listener&lt;/a&gt;
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="FocusEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.ComponentEvent"/>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A low-level event which indicates that a Component has gained or lost the
                         input focus. This low-level event is generated by a Component (such as a
                         TextField). The event is passed to every {@code FocusListener} or
                         {@code FocusAdapter} object which registered to receive such events
                         using the Component's {@code addFocusListener} method.
                         ({@code FocusAdapter} objects implement the {@code FocusListener}
                         interface.) Each such listener object gets this {@code FocusEvent} when
                         the event occurs.
                         &lt;p&gt;
                         There are two levels of focus events: permanent and temporary. Permanent
                         focus change events occur when focus is directly moved from one Component to
                         another, such as through a call to requestFocus() or as the user uses the
                         TAB key to traverse Components. Temporary focus change events occur when
                         focus is temporarily lost for a Component as the indirect result of another
                         operation, such as Window deactivation or a Scrollbar drag. In this case,
                         the original focus state will automatically be restored once that operation
                         is finished, or, for the case of Window deactivation, when the Window is
                         reactivated. Both permanent and temporary focus events are delivered using
                         the FOCUS_GAINED and FOCUS_LOST event ids; the level may be distinguished in
                         the event using the isTemporary() method.
                         &lt;p&gt;
                         Every {@code FocusEvent} records its cause - the reason why this event was
                         generated. The cause is assigned during the focus event creation and may be
                         retrieved by calling {@link #getCause}.
                         &lt;p&gt;
                         An unspecified behavior will be caused if the {@code id} parameter
                         of any particular {@code FocusEvent} instance is not
                         in the range from {@code FOCUS_FIRST} to {@code FOCUS_LAST}.
                        
                         @see FocusAdapter
                         @see FocusListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/focuslistener.html"&gt;Tutorial: Writing a Focus Listener&lt;/a&gt;
                        
                         @author Carl Quinn
                         @author Amy Fowler
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="HierarchyBoundsAdapter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.HierarchyBoundsListener"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An abstract adapter class for receiving ancestor moved and resized events.
                         The methods in this class are empty. This class exists as a
                         convenience for creating listener objects.
                         &lt;p&gt;
                         Extend this class and override the method for the event of interest. (If
                         you implement the {@code HierarchyBoundsListener} interface, you have
                         to define both methods in it. This abstract class defines null methods for
                         them both, so you only have to define the method for the event you care
                         about.)
                         &lt;p&gt;
                         Create a listener object using your class and then register it with a
                         Component using the Component's {@code addHierarchyBoundsListener}
                         method. When the hierarchy to which the Component belongs changes by
                         resize or movement of an ancestor, the relevant method in the listener
                         object is invoked, and the {@code HierarchyEvent} is passed to it.
                        
                         @author      David Mendenhall
                         @see         HierarchyBoundsListener
                         @see         HierarchyEvent
                         @since       1.3
                        </javadoc>
                </acts>
                <acts name="HierarchyListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving hierarchy changed events.
                         The class that is interested in processing a hierarchy changed event
                         should implement this interface.
                         The listener object created from that class is then registered with a
                         Component using the Component's {@code addHierarchyListener}
                         method. When the hierarchy to which the Component belongs changes, the
                         {@code hierarchyChanged} method in the listener object is invoked,
                         and the {@code HierarchyEvent} is passed to it.
                         &lt;p&gt;
                         Hierarchy events are provided for notification purposes ONLY;
                         The AWT will automatically handle changes to the hierarchy internally so
                         that GUI layout, displayability, and visibility work properly regardless
                         of whether a program registers a {@code HierarchyListener} or not.
                        
                         @author      David Mendenhall
                         @see         HierarchyEvent
                         @since       1.3
                        </javadoc>
                </acts>
                <acts name="KeyEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.InputEvent"/>
                        <superType superType="java.awt.event.ComponentEvent"/>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An event which indicates that a keystroke occurred in a component.
                         &lt;p&gt;
                         This low-level event is generated by a component object (such as a text
                         field) when a key is pressed, released, or typed.
                         The event is passed to every {@code KeyListener}
                         or {@code KeyAdapter} object which registered to receive such
                         events using the component's {@code addKeyListener} method.
                         ({@code KeyAdapter} objects implement the
                         {@code KeyListener} interface.)  Each such listener object
                         gets this {@code KeyEvent} when the event occurs.
                         &lt;p&gt;
                         &lt;em&gt;"Key typed" events&lt;/em&gt; are higher-level and generally do not depend on
                         the platform or keyboard layout.  They are generated when a Unicode character
                         is entered, and are the preferred way to find out about character input.
                         In the simplest case, a key typed event is produced by a single key press
                         (e.g., 'a').  Often, however, characters are produced by series of key
                         presses (e.g., 'shift' + 'a'), and the mapping from key pressed events to
                         key typed events may be many-to-one or many-to-many.  Key releases are not
                         usually necessary to generate a key typed event, but there are some cases
                         where the key typed event is not generated until a key is released (e.g.,
                         entering ASCII sequences via the Alt-Numpad method in Windows).
                         No key typed events are generated for keys that don't generate Unicode
                         characters (e.g., action keys, modifier keys, etc.).
                         &lt;p&gt;
                         The getKeyChar method always returns a valid Unicode character or
                         CHAR_UNDEFINED.  Character input is reported by KEY_TYPED events:
                         KEY_PRESSED and KEY_RELEASED events are not necessarily associated
                         with character input.  Therefore, the result of the getKeyChar method
                         is guaranteed to be meaningful only for KEY_TYPED events.
                         &lt;p&gt;
                         For key pressed and key released events, the getKeyCode method returns
                         the event's keyCode.  For key typed events, the getKeyCode method
                         always returns {@code VK_UNDEFINED}. The {@code getExtendedKeyCode} method
                         may also be used with many international keyboard layouts.
                        
                         &lt;p&gt;
                         &lt;em&gt;"Key pressed" and "key released" events&lt;/em&gt; are lower-level and depend
                         on the platform and keyboard layout. They are generated whenever a key is
                         pressed or released, and are the only way to find out about keys that don't
                         generate character input (e.g., action keys, modifier keys, etc.). The key
                         being pressed or released is indicated by the {@code getKeyCode} and {@code getExtendedKeyCode}
                         methods, which return a virtual key code.
                        
                         &lt;p&gt;
                         &lt;em&gt;Virtual key codes&lt;/em&gt; are used to report which keyboard key has
                         been pressed, rather than a character generated by the combination
                         of one or more keystrokes (such as "A", which comes from shift and "a").
                        
                         &lt;p&gt;
                         For example, pressing the Shift key will cause a KEY_PRESSED event
                         with a VK_SHIFT keyCode, while pressing the 'a' key will result in
                         a VK_A keyCode.  After the 'a' key is released, a KEY_RELEASED event
                         will be fired with VK_A. Separately, a KEY_TYPED event with a keyChar
                         value of 'A' is generated.
                        
                         &lt;p&gt;
                         Pressing and releasing a key on the keyboard results in the generating
                         the following key events (in order):
                         &lt;PRE&gt;
                            {@code KEY_PRESSED}
                            {@code KEY_TYPED} (is only generated if a valid Unicode character could be generated.)
                            {@code KEY_RELEASED}
                         &lt;/PRE&gt;
                        
                         But in some cases (e.g. auto-repeat or input method is activated) the order
                         could be different (and platform dependent).
                        
                         &lt;p&gt;
                         Notes:
                         &lt;ul&gt;
                         &lt;li&gt;Key combinations which do not result in Unicode characters, such as action
                         keys like F1 and the HELP key, do not generate KEY_TYPED events.
                         &lt;li&gt;Not all keyboards or systems are capable of generating all
                         virtual key codes.  No attempt is made in Java to generate these keys
                         artificially.
                         &lt;li&gt;Virtual key codes do not identify a physical key: they depend on the
                         platform and keyboard layout. For example, the key that generates VK_Q
                         when using a U.S. keyboard layout will generate VK_A when using a French
                         keyboard layout.
                         &lt;li&gt;The key that generates {@code VK_Q} when using a U.S. keyboard layout also
                         generates a unique code for Russian or Hebrew layout. There is no a
                         {@code VK_} constant for these and many other codes in various layouts. These codes
                         may be obtained by using {@code getExtendedKeyCode} and are used whenever
                         a {@code VK_} constant is used.
                         &lt;li&gt;Not all characters have a keycode associated with them.  For example,
                         there is no keycode for the question mark because there is no keyboard
                         for which it appears on the primary layer.
                         &lt;li&gt;In order to support the platform-independent handling of action keys,
                         the Java platform uses a few additional virtual key constants for functions
                         that would otherwise have to be recognized by interpreting virtual key codes
                         and modifiers. For example, for Japanese Windows keyboards, VK_ALL_CANDIDATES
                         is returned instead of VK_CONVERT with the ALT modifier.
                         &lt;li&gt;As specified in &lt;a href="../doc-files/FocusSpec.html"&gt;Focus Specification&lt;/a&gt;
                         key events are dispatched to the focus owner by default.
                         &lt;/ul&gt;
                        
                         &lt;p&gt;
                         WARNING: Aside from those keys that are defined by the Java language
                         (VK_ENTER, VK_BACK_SPACE, and VK_TAB), do not rely on the values of the VK_
                         constants.  The platform steward reserves the right to change these values as needed
                         to accommodate a wider range of keyboards in the future.
                         &lt;p&gt;
                         An unspecified behavior will be caused if the {@code id} parameter
                         of any particular {@code KeyEvent} instance is not
                         in the range from {@code KEY_FIRST} to {@code KEY_LAST}.
                        
                         @author Carl Quinn
                         @author Amy Fowler
                         @author Norbert Lindenberg
                        
                         @see KeyAdapter
                         @see KeyListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/keylistener.html"&gt;Tutorial: Writing a Key Listener&lt;/a&gt;
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="MouseListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving "interesting" mouse events
                         (press, release, click, enter, and exit) on a component.
                         (To track mouse moves and mouse drags, use the
                         {@code MouseMotionListener}.)
                         &lt;P&gt;
                         The class that is interested in processing a mouse event
                         either implements this interface (and all the methods it
                         contains) or extends the abstract {@code MouseAdapter} class
                         (overriding only the methods of interest).
                         &lt;P&gt;
                         The listener object created from that class is then registered with a
                         component using the component's {@code addMouseListener}
                         method. A mouse event is generated when the mouse is pressed, released
                         clicked (pressed and released). A mouse event is also generated when
                         the mouse cursor enters or leaves a component. When a mouse event
                         occurs, the relevant method in the listener object is invoked, and
                         the {@code MouseEvent} is passed to it.
                        
                         @author Carl Quinn
                        
                         @see MouseAdapter
                         @see MouseEvent
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/mouselistener.html"&gt;Tutorial: Writing a Mouse Listener&lt;/a&gt;
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="InputMethodListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving input method events. A text editing
                         component has to install an input method event listener in order to work
                         with input methods.
                        
                         &lt;p&gt;
                         The text editing component also has to provide an instance of InputMethodRequests.
                        
                         @author JavaSoft Asia/Pacific
                         @see InputMethodEvent
                         @see java.awt.im.InputMethodRequests
                         @since 1.2
                        </javadoc>
                </acts>
                <acts name="InputEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.ComponentEvent"/>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The root event class for all component-level input events.
                        
                         Input events are delivered to listeners before they are
                         processed normally by the source where they originated.
                         This allows listeners and component subclasses to "consume"
                         the event so that the source will not process them in their
                         default manner.  For example, consuming mousePressed events
                         on a Button component will prevent the Button from being
                         activated.
                        
                         @author Carl Quinn
                        
                         @see KeyEvent
                         @see KeyAdapter
                         @see MouseEvent
                         @see MouseAdapter
                         @see MouseMotionAdapter
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="ComponentAdapter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.ComponentListener"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An abstract adapter class for receiving component events.
                         The methods in this class are empty. This class exists as
                         convenience for creating listener objects.
                         &lt;P&gt;
                         Extend this class to create a {@code ComponentEvent} listener
                         and override the methods for the events of interest. (If you implement the
                         {@code ComponentListener} interface, you have to define all of
                         the methods in it. This abstract class defines null methods for them
                         all, so you can only have to define methods for events you care about.)
                         &lt;P&gt;
                         Create a listener object using your class and then register it with a
                         component using the component's {@code addComponentListener}
                         method. When the component's size, location, or visibility
                         changes, the relevant method in the listener object is invoked,
                         and the {@code ComponentEvent} is passed to it.
                        
                         @see ComponentEvent
                         @see ComponentListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/componentlistener.html"&gt;Tutorial: Writing a Component Listener&lt;/a&gt;
                        
                         @author Carl Quinn
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="WindowFocusListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving {@code WindowEvents}, including
                         {@code WINDOW_GAINED_FOCUS} and {@code WINDOW_LOST_FOCUS} events.
                         The class that is interested in processing a {@code WindowEvent}
                         either implements this interface (and
                         all the methods it contains) or extends the abstract
                         {@code WindowAdapter} class (overriding only the methods of interest).
                         The listener object created from that class is then registered with a
                         {@code Window}
                         using the {@code Window}'s {@code addWindowFocusListener} method.
                         When the {@code Window}'s
                         status changes by virtue of it being opened, closed, activated, deactivated,
                         iconified, or deiconified, or by focus being transferred into or out of the
                         {@code Window}, the relevant method in the listener object is invoked,
                         and the {@code WindowEvent} is passed to it.
                        
                         @author David Mendenhall
                        
                         @see WindowAdapter
                         @see WindowEvent
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/windowlistener.html"&gt;Tutorial: Writing a Window Listener&lt;/a&gt;
                        
                         @since 1.4
                        </javadoc>
                </acts>
                <acts name="ContainerEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.ComponentEvent"/>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A low-level event which indicates that a container's contents
                         changed because a component was added or removed.
                         &lt;P&gt;
                         Container events are provided for notification purposes ONLY;
                         The AWT will automatically handle changes to the containers
                         contents internally so that the program works properly regardless of
                         whether the program is receiving these events or not.
                         &lt;P&gt;
                         This low-level event is generated by a container object (such as a
                         Panel) when a component is added to it or removed from it.
                         The event is passed to every {@code ContainerListener}
                         or {@code ContainerAdapter} object which registered to receive such
                         events using the component's {@code addContainerListener} method.
                         ({@code ContainerAdapter} objects implement the
                         {@code ContainerListener} interface.) Each such listener object
                         gets this {@code ContainerEvent} when the event occurs.
                         &lt;p&gt;
                         An unspecified behavior will be caused if the {@code id} parameter
                         of any particular {@code ContainerEvent} instance is not
                         in the range from {@code CONTAINER_FIRST} to {@code CONTAINER_LAST}.
                        
                         @see ContainerAdapter
                         @see ContainerListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/containerlistener.html"&gt;Tutorial: Writing a Container Listener&lt;/a&gt;
                        
                         @author Tim Prinzing
                         @author Amy Fowler
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="TextEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A semantic event which indicates that an object's text changed.
                         This high-level event is generated by an object (such as a TextComponent)
                         when its text changes. The event is passed to
                         every {@code TextListener} object which registered to receive such
                         events using the component's {@code addTextListener} method.
                         &lt;P&gt;
                         The object that implements the {@code TextListener} interface gets
                         this {@code TextEvent} when the event occurs. The listener is
                         spared the details of processing individual mouse movements and key strokes
                         Instead, it can process a "meaningful" (semantic) event like "text changed".
                         &lt;p&gt;
                         An unspecified behavior will be caused if the {@code id} parameter
                         of any particular {@code TextEvent} instance is not
                         in the range from {@code TEXT_FIRST} to {@code TEXT_LAST}.
                        
                         @author Georges Saab
                        
                         @see java.awt.TextComponent
                         @see TextListener
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="WindowListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving window events.
                         The class that is interested in processing a window event
                         either implements this interface (and all the methods it
                         contains) or extends the abstract {@code WindowAdapter} class
                         (overriding only the methods of interest).
                         The listener object created from that class is then registered with a
                         Window using the window's {@code addWindowListener}
                         method. When the window's status changes by virtue of being opened,
                         closed, activated or deactivated, iconified or deiconified,
                         the relevant method in the listener object is invoked, and the
                         {@code WindowEvent} is passed to it.
                        
                         @author Carl Quinn
                        
                         @see WindowAdapter
                         @see WindowEvent
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/windowlistener.html"&gt;Tutorial: How to Write Window Listeners&lt;/a&gt;
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="HierarchyBoundsListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving ancestor moved and resized events.
                         The class that is interested in processing these events either implements
                         this interface (and all the methods it contains) or extends the abstract
                         {@code HierarchyBoundsAdapter} class (overriding only the method of
                         interest).
                         The listener object created from that class is then registered with a
                         Component using the Component's {@code addHierarchyBoundsListener}
                         method. When the hierarchy to which the Component belongs changes by
                         the resizing or movement of an ancestor, the relevant method in the listener
                         object is invoked, and the {@code HierarchyEvent} is passed to it.
                         &lt;p&gt;
                         Hierarchy events are provided for notification purposes ONLY;
                         The AWT will automatically handle changes to the hierarchy internally so
                         that GUI layout works properly regardless of whether a
                         program registers an {@code HierarchyBoundsListener} or not.
                        
                         @author      David Mendenhall
                         @see         HierarchyBoundsAdapter
                         @see         HierarchyEvent
                         @since       1.3
                        </javadoc>
                </acts>
                <acts name="MouseEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.InputEvent"/>
                        <superType superType="java.awt.event.ComponentEvent"/>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An event which indicates that a mouse action occurred in a component.
                         A mouse action is considered to occur in a particular component if and only
                         if the mouse cursor is over the unobscured part of the component's bounds
                         when the action happens.
                         For lightweight components, such as Swing's components, mouse events
                         are only dispatched to the component if the mouse event type has been
                         enabled on the component. A mouse event type is enabled by adding the
                         appropriate mouse-based {@code EventListener} to the component
                         ({@link MouseListener} or {@link MouseMotionListener}), or by invoking
                         {@link Component#enableEvents(long)} with the appropriate mask parameter
                         ({@code AWTEvent.MOUSE_EVENT_MASK} or {@code AWTEvent.MOUSE_MOTION_EVENT_MASK}).
                         If the mouse event type has not been enabled on the component, the
                         corresponding mouse events are dispatched to the first ancestor that
                         has enabled the mouse event type.
                        &lt;p&gt;
                         For example, if a {@code MouseListener} has been added to a component, or
                         {@code enableEvents(AWTEvent.MOUSE_EVENT_MASK)} has been invoked, then all
                         the events defined by {@code MouseListener} are dispatched to the component.
                         On the other hand, if a {@code MouseMotionListener} has not been added and
                         {@code enableEvents} has not been invoked with
                         {@code AWTEvent.MOUSE_MOTION_EVENT_MASK}, then mouse motion events are not
                         dispatched to the component. Instead the mouse motion events are
                         dispatched to the first ancestors that has enabled mouse motion
                         events.
                         &lt;P&gt;
                         This low-level event is generated by a component object for:
                         &lt;ul&gt;
                         &lt;li&gt;Mouse Events
                             &lt;ul&gt;
                             &lt;li&gt;a mouse button is pressed
                             &lt;li&gt;a mouse button is released
                             &lt;li&gt;a mouse button is clicked (pressed and released)
                             &lt;li&gt;the mouse cursor enters the unobscured part of component's geometry
                             &lt;li&gt;the mouse cursor exits the unobscured part of component's geometry
                             &lt;/ul&gt;
                         &lt;li&gt; Mouse Motion Events
                             &lt;ul&gt;
                             &lt;li&gt;the mouse is moved
                             &lt;li&gt;the mouse is dragged
                             &lt;/ul&gt;
                         &lt;/ul&gt;
                         &lt;P&gt;
                         A {@code MouseEvent} object is passed to every
                         {@code MouseListener}
                         or {@code MouseAdapter} object which is registered to receive
                         the "interesting" mouse events using the component's
                         {@code addMouseListener} method.
                         ({@code MouseAdapter} objects implement the
                         {@code MouseListener} interface.) Each such listener object
                         gets a {@code MouseEvent} containing the mouse event.
                         &lt;P&gt;
                         A {@code MouseEvent} object is also passed to every
                         {@code MouseMotionListener} or
                         {@code MouseMotionAdapter} object which is registered to receive
                         mouse motion events using the component's
                         {@code addMouseMotionListener}
                         method. ({@code MouseMotionAdapter} objects implement the
                         {@code MouseMotionListener} interface.) Each such listener object
                         gets a {@code MouseEvent} containing the mouse motion event.
                         &lt;P&gt;
                         When a mouse button is clicked, events are generated and sent to the
                         registered {@code MouseListener}s.
                         The state of modal keys can be retrieved using {@link InputEvent#getModifiers}
                         and {@link InputEvent#getModifiersEx}.
                         The button mask returned by {@link InputEvent#getModifiers} reflects
                         only the button that changed state, not the current state of all buttons.
                         (Note: Due to overlap in the values of ALT_MASK/BUTTON2_MASK and
                         META_MASK/BUTTON3_MASK, this is not always true for mouse events involving
                         modifier keys).
                         To get the state of all buttons and modifier keys, use
                         {@link InputEvent#getModifiersEx}.
                         The button which has changed state is returned by {@link MouseEvent#getButton}
                         &lt;P&gt;
                         For example, if the first mouse button is pressed, events are sent in the
                         following order:
                         &lt;pre&gt;&lt;b&gt;
                            id              modifiers    button&lt;/b&gt;{@code
                            MOUSE_PRESSED:  BUTTON1_MASK BUTTON1
                            MOUSE_RELEASED: BUTTON1_MASK BUTTON1
                            MOUSE_CLICKED:  BUTTON1_MASK BUTTON1
                         }&lt;/pre&gt;
                         When multiple mouse buttons are pressed, each press, release, and click
                         results in a separate event.
                         &lt;P&gt;
                         For example, if the user presses &lt;b&gt;button 1&lt;/b&gt; followed by
                         &lt;b&gt;button 2&lt;/b&gt;, and then releases them in the same order,
                         the following sequence of events is generated:
                         &lt;pre&gt;&lt;b&gt;
                            id              modifiers    button&lt;/b&gt;{@code
                            MOUSE_PRESSED:  BUTTON1_MASK BUTTON1
                            MOUSE_PRESSED:  BUTTON2_MASK BUTTON2
                            MOUSE_RELEASED: BUTTON1_MASK BUTTON1
                            MOUSE_CLICKED:  BUTTON1_MASK BUTTON1
                            MOUSE_RELEASED: BUTTON2_MASK BUTTON2
                            MOUSE_CLICKED:  BUTTON2_MASK BUTTON2
                         }&lt;/pre&gt;
                         If &lt;b&gt;button 2&lt;/b&gt; is released first, the
                         {@code MOUSE_RELEASED}/{@code MOUSE_CLICKED} pair
                         for {@code BUTTON2_MASK} arrives first,
                         followed by the pair for {@code BUTTON1_MASK}.
                         &lt;p&gt;
                         Some extra mouse buttons are added to extend the standard set of buttons
                         represented by the following constants:{@code BUTTON1}, {@code BUTTON2}, and {@code BUTTON3}.
                         Extra buttons have no assigned {@code BUTTONx}
                         constants as well as their button masks have no assigned {@code BUTTONx_DOWN_MASK}
                         constants. Nevertheless, ordinal numbers starting from 4 may be
                         used as button numbers (button ids). Values obtained by the
                         {@link InputEvent#getMaskForButton(int) getMaskForButton(button)} method may be used
                         as button masks.
                         &lt;p&gt;
                         {@code MOUSE_DRAGGED} events are delivered to the {@code Component}
                         in which the mouse button was pressed until the mouse button is released
                         (regardless of whether the mouse position is within the bounds of the
                         {@code Component}).  Due to platform-dependent Drag&amp;amp;Drop implementations,
                         {@code MOUSE_DRAGGED} events may not be delivered during a native
                         Drag&amp;amp;Drop operation.
                        
                         In a multi-screen environment mouse drag events are delivered to the
                         {@code Component} even if the mouse position is outside the bounds of the
                         {@code GraphicsConfiguration} associated with that
                         {@code Component}. However, the reported position for mouse drag events
                         in this case may differ from the actual mouse position:
                         &lt;ul&gt;
                         &lt;li&gt;In a multi-screen environment without a virtual device:
                         &lt;br&gt;
                         The reported coordinates for mouse drag events are clipped to fit within the
                         bounds of the {@code GraphicsConfiguration} associated with
                         the {@code Component}.
                         &lt;li&gt;In a multi-screen environment with a virtual device:
                         &lt;br&gt;
                         The reported coordinates for mouse drag events are clipped to fit within the
                         bounds of the virtual device associated with the {@code Component}.
                         &lt;/ul&gt;
                         &lt;p&gt;
                         An unspecified behavior will be caused if the {@code id} parameter
                         of any particular {@code MouseEvent} instance is not
                         in the range from {@code MOUSE_FIRST} to {@code MOUSE_LAST}-1
                         ({@code MOUSE_WHEEL} is not acceptable).
                        
                         @author Carl Quinn
                        
                         @see MouseAdapter
                         @see MouseListener
                         @see MouseMotionAdapter
                         @see MouseMotionListener
                         @see MouseWheelListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/mouselistener.html"&gt;Tutorial: Writing a Mouse Listener&lt;/a&gt;
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/mousemotionlistener.html"&gt;Tutorial: Writing a Mouse Motion Listener&lt;/a&gt;
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="PaintEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.ComponentEvent"/>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The component-level paint event.
                         This event is a special type which is used to ensure that
                         paint/update method calls are serialized along with the other
                         events delivered from the event queue.  This event is not
                         designed to be used with the Event Listener model; programs
                         should continue to override paint/update methods in order
                         render themselves properly.
                         &lt;p&gt;
                         An unspecified behavior will be caused if the {@code id} parameter
                         of any particular {@code PaintEvent} instance is not
                         in the range from {@code PAINT_FIRST} to {@code PAINT_LAST}.
                        
                         @author Amy Fowler
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="AdjustmentEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The adjustment event emitted by Adjustable objects like
                         {@link java.awt.Scrollbar} and {@link java.awt.ScrollPane}.
                         When the user changes the value of the scrolling component,
                         it receives an instance of {@code AdjustmentEvent}.
                         &lt;p&gt;
                         An unspecified behavior will be caused if the {@code id} parameter
                         of any particular {@code AdjustmentEvent} instance is not
                         in the range from {@code ADJUSTMENT_FIRST} to {@code ADJUSTMENT_LAST}.
                         &lt;p&gt;
                         The {@code type} of any {@code AdjustmentEvent} instance takes one of the following
                         values:
                                             &lt;ul&gt;
                                             &lt;li&gt; {@code UNIT_INCREMENT}
                                             &lt;li&gt; {@code UNIT_DECREMENT}
                                             &lt;li&gt; {@code BLOCK_INCREMENT}
                                             &lt;li&gt; {@code BLOCK_DECREMENT}
                                             &lt;li&gt; {@code TRACK}
                                             &lt;/ul&gt;
                         Assigning the value different from listed above will cause an unspecified behavior.
                         @see java.awt.Adjustable
                         @see AdjustmentListener
                        
                         @author Amy Fowler
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="MouseAdapter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.MouseListener"/>
                        <superType superType="java.awt.event.MouseWheelListener"/>
                        <superType superType="java.awt.event.MouseMotionListener"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An abstract adapter class for receiving mouse events.
                         The methods in this class are empty. This class exists as
                         convenience for creating listener objects.
                         &lt;P&gt;
                         Mouse events let you track when a mouse is pressed, released, clicked,
                         moved, dragged, when it enters a component, when it exits and
                         when a mouse wheel is moved.
                         &lt;P&gt;
                         Extend this class to create a {@code MouseEvent}
                         (including drag and motion events) or/and {@code MouseWheelEvent}
                         listener and override the methods for the events of interest. (If you implement the
                         {@code MouseListener},
                         {@code MouseMotionListener}
                         interface, you have to define all of
                         the methods in it. This abstract class defines null methods for them
                         all, so you can only have to define methods for events you care about.)
                         &lt;P&gt;
                         Create a listener object using the extended class and then register it with
                         a component using the component's {@code addMouseListener}
                         {@code addMouseMotionListener}, {@code addMouseWheelListener}
                         methods.
                         The relevant method in the listener object is invoked  and the {@code MouseEvent}
                         or {@code MouseWheelEvent}  is passed to it in following cases:
                         &lt;ul&gt;
                         &lt;li&gt;when a mouse button is pressed, released, or clicked (pressed and  released)
                         &lt;li&gt;when the mouse cursor enters or exits the component
                         &lt;li&gt;when the mouse wheel rotated, or mouse moved or dragged
                         &lt;/ul&gt;
                        
                         @author Carl Quinn
                         @author Andrei Dmitriev
                        
                         @see MouseEvent
                         @see MouseWheelEvent
                         @see MouseListener
                         @see MouseMotionListener
                         @see MouseWheelListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/mouselistener.html"&gt;Tutorial: Writing a Mouse Listener&lt;/a&gt;
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="TextListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving text events.
                        
                         The class that is interested in processing a text event
                         implements this interface. The object created with that
                         class is then registered with a component using the
                         component's {@code addTextListener} method. When the
                         component's text changes, the listener object's
                         {@code textValueChanged} method is invoked.
                        
                         @author Georges Saab
                        
                         @see TextEvent
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="InputMethodEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         Input method events contain information about text that is being
                         composed using an input method. Whenever the text changes, the
                         input method sends an event. If the text component that's currently
                         using the input method is an active client, the event is dispatched
                         to that component. Otherwise, it is dispatched to a separate
                         composition window.
                        
                         &lt;p&gt;
                         The text included with the input method event consists of two parts:
                         committed text and composed text. Either part may be empty. The two
                         parts together replace any uncommitted composed text sent in previous events,
                         or the currently selected committed text.
                         Committed text should be integrated into the text component's persistent
                         data, it will not be sent again. Composed text may be sent repeatedly,
                         with changes to reflect the user's editing operations. Committed text
                         always precedes composed text.
                        
                         @author JavaSoft Asia/Pacific
                         @since 1.2
                        </javadoc>
                </acts>
                <acts name="AWTEventListenerProxy" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.AWTEventListener"/>
                        <superType superType="java.util.EventListenerProxy"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A class which extends the {@code EventListenerProxy}
                         specifically for adding an {@code AWTEventListener}
                         for a specific event mask.
                         Instances of this class can be added as {@code AWTEventListener}s
                         to a {@code Toolkit} object.
                         &lt;p&gt;
                         The {@code getAWTEventListeners} method of {@code Toolkit}
                         can return a mixture of {@code AWTEventListener}
                         and {@code AWTEventListenerProxy} objects.
                        
                         @see java.awt.Toolkit
                         @see java.util.EventListenerProxy
                         @since 1.4
                        </javadoc>
                </acts>
                <acts name="InvocationEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.ActiveEvent"/>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An event which executes the {@code run()} method on a {@code Runnable
                         } when dispatched by the AWT event dispatcher thread. This class can
                         be used as a reference implementation of {@code ActiveEvent} rather
                         than declaring a new class and defining {@code dispatch()}.&lt;p&gt;
                        
                         Instances of this class are placed on the {@code EventQueue} by calls
                         to {@code invokeLater} and {@code invokeAndWait}. Client code
                         can use this fact to write replacement functions for {@code invokeLater
                         } and {@code invokeAndWait} without writing special-case code
                         in any {@code AWTEventListener} objects.
                         &lt;p&gt;
                         An unspecified behavior will be caused if the {@code id} parameter
                         of any particular {@code InvocationEvent} instance is not
                         in the range from {@code INVOCATION_FIRST} to {@code INVOCATION_LAST}.
                        
                         @author      Fred Ecks
                         @author      David Mendenhall
                        
                         @see         java.awt.ActiveEvent
                         @see         java.awt.EventQueue#invokeLater
                         @see         java.awt.EventQueue#invokeAndWait
                         @see         AWTEventListener
                        
                         @since       1.2
                        </javadoc>
                </acts>
                <acts name="MouseMotionAdapter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.MouseMotionListener"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An abstract adapter class for receiving mouse motion events.
                         The methods in this class are empty. This class exists as
                         convenience for creating listener objects.
                         &lt;P&gt;
                         Mouse motion events occur when a mouse is moved or dragged.
                         (Many such events will be generated in a normal program.
                         To track clicks and other mouse events, use the MouseAdapter.)
                         &lt;P&gt;
                         Extend this class to create a {@code MouseEvent} listener
                         and override the methods for the events of interest. (If you implement the
                         {@code MouseMotionListener} interface, you have to define all of
                         the methods in it. This abstract class defines null methods for them
                         all, so you can only have to define methods for events you care about.)
                         &lt;P&gt;
                         Create a listener object using the extended class and then register it with
                         a component using the component's {@code addMouseMotionListener}
                         method. When the mouse is moved or dragged, the relevant method in the
                         listener object is invoked and the {@code MouseEvent} is passed to it.
                        
                         @author Amy Fowler
                        
                         @see MouseEvent
                         @see MouseMotionListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/mousemotionlistener.html"&gt;Tutorial: Writing a Mouse Motion Listener&lt;/a&gt;
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="ActionListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving action events.
                         The class that is interested in processing an action event
                         implements this interface, and the object created with that
                         class is registered with a component, using the component's
                         {@code addActionListener} method. When the action event
                         occurs, that object's {@code actionPerformed} method is
                         invoked.
                        
                         @see ActionEvent
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/actionlistener.html"&gt;How to Write an Action Listener&lt;/a&gt;
                        
                         @author Carl Quinn
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="MouseWheelEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.MouseEvent"/>
                        <superType superType="java.awt.event.InputEvent"/>
                        <superType superType="java.awt.event.ComponentEvent"/>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An event which indicates that the mouse wheel was rotated in a component.
                         &lt;P&gt;
                         A wheel mouse is a mouse which has a wheel in place of the middle button.
                         This wheel can be rotated towards or away from the user.  Mouse wheels are
                         most often used for scrolling, though other uses are possible.
                         &lt;P&gt;
                         A MouseWheelEvent object is passed to every {@code MouseWheelListener}
                         object which registered to receive the "interesting" mouse events using the
                         component's {@code addMouseWheelListener} method.  Each such listener
                         object gets a {@code MouseEvent} containing the mouse event.
                         &lt;P&gt;
                         Due to the mouse wheel's special relationship to scrolling Components,
                         MouseWheelEvents are delivered somewhat differently than other MouseEvents.
                         This is because while other MouseEvents usually affect a change on
                         the Component directly under the mouse
                         cursor (for instance, when clicking a button), MouseWheelEvents often have
                         an effect away from the mouse cursor (moving the wheel while
                         over a Component inside a ScrollPane should scroll one of the
                         Scrollbars on the ScrollPane).
                         &lt;P&gt;
                         MouseWheelEvents start delivery from the Component underneath the
                         mouse cursor.  If MouseWheelEvents are not enabled on the
                         Component, the event is delivered to the first ancestor
                         Container with MouseWheelEvents enabled.  This will usually be
                         a ScrollPane with wheel scrolling enabled.  The source
                         Component and x,y coordinates will be relative to the event's
                         final destination (the ScrollPane).  This allows a complex
                         GUI to be installed without modification into a ScrollPane, and
                         for all MouseWheelEvents to be delivered to the ScrollPane for
                         scrolling.
                         &lt;P&gt;
                         Some AWT Components are implemented using native widgets which
                         display their own scrollbars and handle their own scrolling.
                         The particular Components for which this is true will vary from
                         platform to platform.  When the mouse wheel is
                         moved over one of these Components, the event is delivered straight to
                         the native widget, and not propagated to ancestors.
                         &lt;P&gt;
                         Platforms offer customization of the amount of scrolling that
                         should take place when the mouse wheel is moved.  The two most
                         common settings are to scroll a certain number of "units"
                         (commonly lines of text in a text-based component) or an entire "block"
                         (similar to page-up/page-down).  The MouseWheelEvent offers
                         methods for conforming to the underlying platform settings.  These
                         platform settings can be changed at any time by the user.  MouseWheelEvents
                         reflect the most recent settings.
                         &lt;P&gt;
                         The {@code MouseWheelEvent} class includes methods for
                         getting the number of "clicks" by which the mouse wheel is rotated.
                         The {@link #getWheelRotation} method returns the integer number
                         of "clicks" corresponding to the number of notches by which the wheel was
                         rotated. In addition to this method, the {@code MouseWheelEvent}
                         class provides the {@link #getPreciseWheelRotation} method which returns
                         a double number of "clicks" in case a partial rotation occurred.
                         The {@link #getPreciseWheelRotation} method is useful if a mouse supports
                         a high-resolution wheel, such as a freely rotating wheel with no
                         notches. Applications can benefit by using this method to process
                         mouse wheel events more precisely, and thus, making visual perception
                         smoother.
                        
                         @author Brent Christian
                         @see MouseWheelListener
                         @see java.awt.ScrollPane
                         @see java.awt.ScrollPane#setWheelScrollingEnabled(boolean)
                         @see javax.swing.JScrollPane
                         @see javax.swing.JScrollPane#setWheelScrollingEnabled(boolean)
                         @since 1.4
                        </javadoc>
                </acts>
                <acts name="HierarchyEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An event which indicates a change to the {@code Component}
                         hierarchy to which {@code Component} belongs.
                         &lt;ul&gt;
                         &lt;li&gt;Hierarchy Change Events (HierarchyListener)
                             &lt;ul&gt;
                             &lt;li&gt; addition of an ancestor
                             &lt;li&gt; removal of an ancestor
                             &lt;li&gt; hierarchy made displayable
                             &lt;li&gt; hierarchy made undisplayable
                             &lt;li&gt; hierarchy shown on the screen (both visible and displayable)
                             &lt;li&gt; hierarchy hidden on the screen (either invisible or undisplayable)
                             &lt;/ul&gt;
                         &lt;li&gt;Ancestor Reshape Events (HierarchyBoundsListener)
                             &lt;ul&gt;
                             &lt;li&gt; an ancestor was resized
                             &lt;li&gt; an ancestor was moved
                             &lt;/ul&gt;
                         &lt;/ul&gt;
                         &lt;p&gt;
                         Hierarchy events are provided for notification purposes ONLY.
                         The AWT will automatically handle changes to the hierarchy internally so
                         that GUI layout and displayability works properly regardless of whether a
                         program is receiving these events or not.
                         &lt;p&gt;
                         This event is generated by a Container object (such as a Panel) when the
                         Container is added, removed, moved, or resized, and passed down the
                         hierarchy. It is also generated by a Component object when that object's
                         {@code addNotify}, {@code removeNotify}, {@code show}, or
                         {@code hide} method is called. The {@code ANCESTOR_MOVED} and
                         {@code ANCESTOR_RESIZED}
                         events are dispatched to every {@code HierarchyBoundsListener} or
                         {@code HierarchyBoundsAdapter} object which registered to receive
                         such events using the Component's {@code addHierarchyBoundsListener}
                         method. ({@code HierarchyBoundsAdapter} objects implement the
                         {@code HierarchyBoundsListener} interface.) The {@code HIERARCHY_CHANGED} events are
                         dispatched to every {@code HierarchyListener} object which registered
                         to receive such events using the Component's {@code addHierarchyListener}
                         method. Each such listener object gets this {@code HierarchyEvent}
                         when the event occurs.
                         &lt;p&gt;
                         An unspecified behavior will be caused if the {@code id} parameter
                         of any particular {@code HierarchyEvent} instance is not
                         in the range from {@code HIERARCHY_FIRST} to {@code HIERARCHY_LAST}.
                         &lt;br&gt;
                         The {@code changeFlags} parameter of any {@code HierarchyEvent} instance takes one of the following
                         values:
                         &lt;ul&gt;
                         &lt;li&gt; {@code HierarchyEvent.PARENT_CHANGED}
                         &lt;li&gt; {@code HierarchyEvent.DISPLAYABILITY_CHANGED}
                         &lt;li&gt; {@code HierarchyEvent.SHOWING_CHANGED}
                         &lt;/ul&gt;
                         Assigning the value different from listed above will cause unspecified behavior.
                        
                         @author      David Mendenhall
                         @see         HierarchyListener
                         @see         HierarchyBoundsAdapter
                         @see         HierarchyBoundsListener
                         @since       1.3
                        </javadoc>
                </acts>
                <acts name="WindowEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.ComponentEvent"/>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A low-level event that indicates that a window has changed its status. This
                         low-level event is generated by a Window object when it is opened, closed,
                         activated, deactivated, iconified, or deiconified, or when focus is
                         transferred into or out of the Window.
                         &lt;P&gt;
                         The event is passed to every {@code WindowListener}
                         or {@code WindowAdapter} object which registered to receive such
                         events using the window's {@code addWindowListener} method.
                         ({@code WindowAdapter} objects implement the
                         {@code WindowListener} interface.) Each such listener object
                         gets this {@code WindowEvent} when the event occurs.
                         &lt;p&gt;
                         An unspecified behavior will be caused if the {@code id} parameter
                         of any particular {@code WindowEvent} instance is not
                         in the range from {@code WINDOW_FIRST} to {@code WINDOW_LAST}.
                        
                         @author Carl Quinn
                         @author Amy Fowler
                        
                         @see WindowAdapter
                         @see WindowListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/windowlistener.html"&gt;Tutorial: Writing a Window Listener&lt;/a&gt;
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="AdjustmentListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving adjustment events.
                        
                         @author Amy Fowler
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="ContainerListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving container events.
                         The class that is interested in processing a container event
                         either implements this interface (and all the methods it
                         contains) or extends the abstract {@code ContainerAdapter} class
                         (overriding only the methods of interest).
                         The listener object created from that class is then registered with a
                         component using the component's {@code addContainerListener}
                         method. When the container's contents change because a component
                         has been added or removed, the relevant method in the listener object
                         is invoked, and the {@code ContainerEvent} is passed to it.
                         &lt;P&gt;
                         Container events are provided for notification purposes ONLY;
                         The AWT will automatically handle add and remove operations
                         internally so the program works properly regardless of
                         whether the program registers a {@code ContainerListener} or not.
                        
                         @see ContainerAdapter
                         @see ContainerEvent
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/containerlistener.html"&gt;Tutorial: Writing a Container Listener&lt;/a&gt;
                        
                         @author Tim Prinzing
                         @author Amy Fowler
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="ItemListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving item events.
                         The class that is interested in processing an item event
                         implements this interface. The object created with that
                         class is then registered with a component using the
                         component's {@code addItemListener} method. When an
                         item-selection event occurs, the listener object's
                         {@code itemStateChanged} method is invoked.
                        
                         @author Amy Fowler
                        
                         @see java.awt.ItemSelectable
                         @see ItemEvent
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/itemlistener.html"&gt;Tutorial: Writing an Item Listener&lt;/a&gt;
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="KeyListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving keyboard events (keystrokes).
                         The class that is interested in processing a keyboard event
                         either implements this interface (and all the methods it
                         contains) or extends the abstract {@code KeyAdapter} class
                         (overriding only the methods of interest).
                         &lt;P&gt;
                         The listener object created from that class is then registered with a
                         component using the component's {@code addKeyListener}
                         method. A keyboard event is generated when a key is pressed, released,
                         or typed. The relevant method in the listener
                         object is then invoked, and the {@code KeyEvent} is passed to it.
                        
                         @author Carl Quinn
                        
                         @see KeyAdapter
                         @see KeyEvent
                         @see &lt;a href="https://docs.oracle.com/javase/tutorial/uiswing/events/keylistener.html"&gt;Tutorial: Writing a Key Listener&lt;/a&gt;
                        
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="ComponentEvent" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.AWTEvent"/>
                        <superType superType="java.util.EventObject"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         A low-level event which indicates that a component moved, changed
                         size, or changed visibility (also, the root class for the other
                         component-level events).
                         &lt;P&gt;
                         Component events are provided for notification purposes ONLY;
                         The AWT will automatically handle component moves and resizes
                         internally so that GUI layout works properly regardless of
                         whether a program is receiving these events or not.
                         &lt;P&gt;
                         In addition to serving as the base class for other component-related
                         events (InputEvent, FocusEvent, WindowEvent, ContainerEvent),
                         this class defines the events that indicate changes in
                         a component's size, position, or visibility.
                         &lt;P&gt;
                         This low-level event is generated by a component object (such as a
                         List) when the component is moved, resized, rendered invisible, or made
                         visible again. The event is passed to every {@code ComponentListener}
                         or {@code ComponentAdapter} object which registered to receive such
                         events using the component's {@code addComponentListener} method.
                         ({@code ComponentAdapter} objects implement the
                         {@code ComponentListener} interface.) Each such listener object
                         gets this {@code ComponentEvent} when the event occurs.
                         &lt;p&gt;
                         An unspecified behavior will be caused if the {@code id} parameter
                         of any particular {@code ComponentEvent} instance is not
                         in the range from {@code COMPONENT_FIRST} to {@code COMPONENT_LAST}.
                        
                         @see ComponentAdapter
                         @see ComponentListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/componentlistener.html"&gt;Tutorial: Writing a Component Listener&lt;/a&gt;
                        
                         @author Carl Quinn
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="ContainerAdapter" access="PUBLIC" kind="TYPE" typeKind="CLASS_NON_FINAL" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.awt.event.ContainerListener"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         An abstract adapter class for receiving container events.
                         The methods in this class are empty. This class exists as
                         convenience for creating listener objects.
                         &lt;P&gt;
                         Extend this class to create a {@code ContainerEvent} listener
                         and override the methods for the events of interest. (If you implement the
                         {@code ContainerListener} interface, you have to define all of
                         the methods in it. This abstract class defines null methods for them
                         all, so you can only have to define methods for events you care about.)
                         &lt;P&gt;
                         Create a listener object using the extended class and then register it with
                         a component using the component's {@code addContainerListener}
                         method. When the container's contents change because a component has
                         been added or removed, the relevant method in the listener object is invoked,
                         and the {@code ContainerEvent} is passed to it.
                        
                         @see ContainerEvent
                         @see ContainerListener
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/containerlistener.html"&gt;Tutorial: Writing a Container Listener&lt;/a&gt;
                        
                         @author Amy Fowler
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="FocusListener" access="PUBLIC" kind="TYPE" typeKind="INTERFACE" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.util.EventListener"/>
                    </superTypes>
                    <javadoc xml:space="preserve">
                         The listener interface for receiving keyboard focus events on
                         a component.
                         The class that is interested in processing a focus event
                         either implements this interface (and all the methods it
                         contains) or extends the abstract {@code FocusAdapter} class
                         (overriding only the methods of interest).
                         The listener object created from that class is then registered with a
                         component using the component's {@code addFocusListener}
                         method. When the component gains or loses the keyboard focus,
                         the relevant method in the listener object
                         is invoked, and the {@code FocusEvent} is passed to it.
                        
                         @see FocusAdapter
                         @see FocusEvent
                         @see &lt;a href="http://docs.oracle.com/javase/tutorial/uiswing/events/focuslistener.html"&gt;Tutorial: Writing a Focus Listener&lt;/a&gt;
                        
                         @author Carl Quinn
                         @since 1.1
                        </javadoc>
                </acts>
                <acts name="Cause" access="PUBLIC" declaringClass="FocusEvent" kind="TYPE" typeKind="ENUM" packageName="java.awt.event">
                    <superTypes>
                        <superType superType="java.lang.Enum"/>
                        <superType superType="java.lang.Object"/>
                    </superTypes>
                </acts>
            </package>
            <package name="geom"/>
            <package name="datatransfer"/>
            <package name="font"/>
        </package>
    </package>
</packages>
